// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Agent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __display_name,
            __default_language_code,
            __supported_language_codes,
            __time_zone,
            __description,
            __avatar_uri,
            __enable_logging,
            __match_mode,
            __classification_threshold,
            __api_version,
            __tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Agent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "defaultLanguageCode" => Ok(__FieldTag::__default_language_code),
                            "default_language_code" => Ok(__FieldTag::__default_language_code),
                            "supportedLanguageCodes" => Ok(__FieldTag::__supported_language_codes),
                            "supported_language_codes" => Ok(__FieldTag::__supported_language_codes),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "description" => Ok(__FieldTag::__description),
                            "avatarUri" => Ok(__FieldTag::__avatar_uri),
                            "avatar_uri" => Ok(__FieldTag::__avatar_uri),
                            "enableLogging" => Ok(__FieldTag::__enable_logging),
                            "enable_logging" => Ok(__FieldTag::__enable_logging),
                            "matchMode" => Ok(__FieldTag::__match_mode),
                            "match_mode" => Ok(__FieldTag::__match_mode),
                            "classificationThreshold" => Ok(__FieldTag::__classification_threshold),
                            "classification_threshold" => Ok(__FieldTag::__classification_threshold),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "tier" => Ok(__FieldTag::__tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Agent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Agent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__default_language_code => {
                            if !fields.insert(__FieldTag::__default_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for default_language_code"));
                            }
                            result.default_language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__supported_language_codes => {
                            if !fields.insert(__FieldTag::__supported_language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for supported_language_codes"));
                            }
                            result.supported_language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time_zone"));
                            }
                            result.time_zone = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__avatar_uri => {
                            if !fields.insert(__FieldTag::__avatar_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for avatar_uri"));
                            }
                            result.avatar_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_logging => {
                            if !fields.insert(__FieldTag::__enable_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_logging"));
                            }
                            result.enable_logging = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_mode => {
                            if !fields.insert(__FieldTag::__match_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_mode"));
                            }
                            result.match_mode = map.next_value::<std::option::Option<crate::model::agent::MatchMode>>()?.unwrap_or_default();
                        },
                        __FieldTag::__classification_threshold => {
                            if !fields.insert(__FieldTag::__classification_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for classification_threshold"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.classification_threshold = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for api_version"));
                            }
                            result.api_version = map.next_value::<std::option::Option<crate::model::agent::ApiVersion>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tier"));
                            }
                            result.tier = map.next_value::<std::option::Option<crate::model::agent::Tier>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent"));
                            }
                            result.agent = map.next_value::<std::option::Option<crate::model::Agent>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SearchAgentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAgentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SearchAgentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAgentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SearchAgentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAgentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agents" => Ok(__FieldTag::__agents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SearchAgentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAgentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agents => {
                            if !fields.insert(__FieldTag::__agents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agents"));
                            }
                            result.agents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Agent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TrainAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TrainAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExportAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExportAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_uri"));
                            }
                            result.agent_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExportAgentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_uri,
            __agent_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAgentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExportAgentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAgentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_uri"));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ExportAgentResponse.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_content"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ExportAgentResponse.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent_uri,
            __agent_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_uri"));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ImportAgentRequest.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::import_agent_request::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_content"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ImportAgentRequest.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::import_agent_request::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RestoreAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent_uri,
            __agent_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RestoreAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_uri"));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.RestoreAgentRequest.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_content"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.RestoreAgentRequest.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetValidationResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetValidationResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetValidationResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetValidationResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AgentCoachingInstruction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __display_details,
            __condition,
            __agent_action,
            __system_action,
            __duplicate_check_result,
            __triggering_event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentCoachingInstruction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "displayDetails" => Ok(__FieldTag::__display_details),
                            "display_details" => Ok(__FieldTag::__display_details),
                            "condition" => Ok(__FieldTag::__condition),
                            "agentAction" => Ok(__FieldTag::__agent_action),
                            "agent_action" => Ok(__FieldTag::__agent_action),
                            "systemAction" => Ok(__FieldTag::__system_action),
                            "system_action" => Ok(__FieldTag::__system_action),
                            "duplicateCheckResult" => Ok(__FieldTag::__duplicate_check_result),
                            "duplicate_check_result" => Ok(__FieldTag::__duplicate_check_result),
                            "triggeringEvent" => Ok(__FieldTag::__triggering_event),
                            "triggering_event" => Ok(__FieldTag::__triggering_event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AgentCoachingInstruction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentCoachingInstruction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_details => {
                            if !fields.insert(__FieldTag::__display_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_details"));
                            }
                            result.display_details = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for condition"));
                            }
                            result.condition = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_action => {
                            if !fields.insert(__FieldTag::__agent_action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_action"));
                            }
                            result.agent_action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__system_action => {
                            if !fields.insert(__FieldTag::__system_action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for system_action"));
                            }
                            result.system_action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__duplicate_check_result => {
                            if !fields.insert(__FieldTag::__duplicate_check_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for duplicate_check_result"));
                            }
                            result.duplicate_check_result = map.next_value::<std::option::Option<crate::model::agent_coaching_instruction::DuplicateCheckResult>>()?
                                ;
                        },
                        __FieldTag::__triggering_event => {
                            if !fields.insert(__FieldTag::__triggering_event) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for triggering_event"));
                            }
                            result.triggering_event = map.next_value::<std::option::Option<crate::model::agent_coaching_instruction::TriggerEvent>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_instruction::DuplicateCheckResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __duplicate_suggestions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DuplicateCheckResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "duplicateSuggestions" => Ok(__FieldTag::__duplicate_suggestions),
                            "duplicate_suggestions" => Ok(__FieldTag::__duplicate_suggestions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_instruction::DuplicateCheckResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DuplicateCheckResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__duplicate_suggestions => {
                            if !fields.insert(__FieldTag::__duplicate_suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for duplicate_suggestions"));
                            }
                            result.duplicate_suggestions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::agent_coaching_instruction::duplicate_check_result::DuplicateSuggestion>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_instruction::duplicate_check_result::DuplicateSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_record,
            __suggestion_index,
            __similarity_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DuplicateSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "suggestionIndex" => Ok(__FieldTag::__suggestion_index),
                            "suggestion_index" => Ok(__FieldTag::__suggestion_index),
                            "similarityScore" => Ok(__FieldTag::__similarity_score),
                            "similarity_score" => Ok(__FieldTag::__similarity_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_instruction::duplicate_check_result::DuplicateSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DuplicateSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_index => {
                            if !fields.insert(__FieldTag::__suggestion_index) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_index"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.suggestion_index = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__similarity_score => {
                            if !fields.insert(__FieldTag::__similarity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for similarity_score"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.similarity_score = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AnswerRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __answer_feedback,
            __agent_assistant_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "answerFeedback" => Ok(__FieldTag::__answer_feedback),
                            "answer_feedback" => Ok(__FieldTag::__answer_feedback),
                            "agentAssistantRecord" => Ok(__FieldTag::__agent_assistant_record),
                            "agent_assistant_record" => Ok(__FieldTag::__agent_assistant_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AnswerRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_feedback => {
                            if !fields.insert(__FieldTag::__answer_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_feedback"));
                            }
                            result.answer_feedback = map.next_value::<std::option::Option<crate::model::AnswerFeedback>>()?
                                ;
                        },
                        __FieldTag::__agent_assistant_record => {
                            if !fields.insert(__FieldTag::__agent_assistant_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_assistant_record"));
                            }
                            if result.record.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `record`, a oneof with full ID .google.cloud.dialogflow.v2.AnswerRecord.agent_assistant_record, latest field was agentAssistantRecord",
                                ));
                            }
                            result.record = std::option::Option::Some(
                                crate::model::answer_record::Record::AgentAssistantRecord(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AgentAssistantRecord>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAnswerRecordsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnswerRecordsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAnswerRecordsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnswerRecordsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListAnswerRecordsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_records,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnswerRecordsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecords" => Ok(__FieldTag::__answer_records),
                            "answer_records" => Ok(__FieldTag::__answer_records),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListAnswerRecordsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnswerRecordsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_records => {
                            if !fields.insert(__FieldTag::__answer_records) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_records"));
                            }
                            result.answer_records = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AnswerRecord>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateAnswerRecordRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_record,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAnswerRecordRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateAnswerRecordRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAnswerRecordRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<crate::model::AnswerRecord>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AnswerFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __correctness_level,
            __agent_assistant_detail_feedback,
            __clicked,
            __click_time,
            __displayed,
            __display_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "correctnessLevel" => Ok(__FieldTag::__correctness_level),
                            "correctness_level" => Ok(__FieldTag::__correctness_level),
                            "agentAssistantDetailFeedback" => Ok(__FieldTag::__agent_assistant_detail_feedback),
                            "agent_assistant_detail_feedback" => Ok(__FieldTag::__agent_assistant_detail_feedback),
                            "clicked" => Ok(__FieldTag::__clicked),
                            "clickTime" => Ok(__FieldTag::__click_time),
                            "click_time" => Ok(__FieldTag::__click_time),
                            "displayed" => Ok(__FieldTag::__displayed),
                            "displayTime" => Ok(__FieldTag::__display_time),
                            "display_time" => Ok(__FieldTag::__display_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AnswerFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__correctness_level => {
                            if !fields.insert(__FieldTag::__correctness_level) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for correctness_level"));
                            }
                            result.correctness_level = map.next_value::<std::option::Option<crate::model::answer_feedback::CorrectnessLevel>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_assistant_detail_feedback => {
                            if !fields.insert(__FieldTag::__agent_assistant_detail_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_assistant_detail_feedback"));
                            }
                            if result.detail_feedback.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `detail_feedback`, a oneof with full ID .google.cloud.dialogflow.v2.AnswerFeedback.agent_assistant_detail_feedback, latest field was agentAssistantDetailFeedback",
                                ));
                            }
                            result.detail_feedback = std::option::Option::Some(
                                crate::model::answer_feedback::DetailFeedback::AgentAssistantDetailFeedback(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AgentAssistantFeedback>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__clicked => {
                            if !fields.insert(__FieldTag::__clicked) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for clicked"));
                            }
                            result.clicked = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__click_time => {
                            if !fields.insert(__FieldTag::__click_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for click_time"));
                            }
                            result.click_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__displayed => {
                            if !fields.insert(__FieldTag::__displayed) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for displayed"));
                            }
                            result.displayed = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_time => {
                            if !fields.insert(__FieldTag::__display_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_time"));
                            }
                            result.display_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AgentAssistantFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_relevance,
            __document_correctness,
            __document_efficiency,
            __summarization_feedback,
            __knowledge_search_feedback,
            __knowledge_assist_feedback,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentAssistantFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRelevance" => Ok(__FieldTag::__answer_relevance),
                            "answer_relevance" => Ok(__FieldTag::__answer_relevance),
                            "documentCorrectness" => Ok(__FieldTag::__document_correctness),
                            "document_correctness" => Ok(__FieldTag::__document_correctness),
                            "documentEfficiency" => Ok(__FieldTag::__document_efficiency),
                            "document_efficiency" => Ok(__FieldTag::__document_efficiency),
                            "summarizationFeedback" => Ok(__FieldTag::__summarization_feedback),
                            "summarization_feedback" => Ok(__FieldTag::__summarization_feedback),
                            "knowledgeSearchFeedback" => Ok(__FieldTag::__knowledge_search_feedback),
                            "knowledge_search_feedback" => Ok(__FieldTag::__knowledge_search_feedback),
                            "knowledgeAssistFeedback" => Ok(__FieldTag::__knowledge_assist_feedback),
                            "knowledge_assist_feedback" => Ok(__FieldTag::__knowledge_assist_feedback),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AgentAssistantFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentAssistantFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_relevance => {
                            if !fields.insert(__FieldTag::__answer_relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_relevance"));
                            }
                            result.answer_relevance = map.next_value::<std::option::Option<crate::model::agent_assistant_feedback::AnswerRelevance>>()?.unwrap_or_default();
                        },
                        __FieldTag::__document_correctness => {
                            if !fields.insert(__FieldTag::__document_correctness) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for document_correctness"));
                            }
                            result.document_correctness = map.next_value::<std::option::Option<crate::model::agent_assistant_feedback::DocumentCorrectness>>()?.unwrap_or_default();
                        },
                        __FieldTag::__document_efficiency => {
                            if !fields.insert(__FieldTag::__document_efficiency) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for document_efficiency"));
                            }
                            result.document_efficiency = map.next_value::<std::option::Option<crate::model::agent_assistant_feedback::DocumentEfficiency>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summarization_feedback => {
                            if !fields.insert(__FieldTag::__summarization_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_feedback"));
                            }
                            result.summarization_feedback = map.next_value::<std::option::Option<crate::model::agent_assistant_feedback::SummarizationFeedback>>()?
                                ;
                        },
                        __FieldTag::__knowledge_search_feedback => {
                            if !fields.insert(__FieldTag::__knowledge_search_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_search_feedback"));
                            }
                            result.knowledge_search_feedback = map.next_value::<std::option::Option<crate::model::agent_assistant_feedback::KnowledgeSearchFeedback>>()?
                                ;
                        },
                        __FieldTag::__knowledge_assist_feedback => {
                            if !fields.insert(__FieldTag::__knowledge_assist_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_assist_feedback"));
                            }
                            result.knowledge_assist_feedback = map.next_value::<std::option::Option<crate::model::agent_assistant_feedback::KnowledgeAssistFeedback>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_assistant_feedback::SummarizationFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __submit_time,
            __summary_text,
            __text_sections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            "summaryText" => Ok(__FieldTag::__summary_text),
                            "summary_text" => Ok(__FieldTag::__summary_text),
                            "textSections" => Ok(__FieldTag::__text_sections),
                            "text_sections" => Ok(__FieldTag::__text_sections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_assistant_feedback::SummarizationFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start_time"));
                            }
                            result.start_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for submit_time"));
                            }
                            result.submit_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__summary_text => {
                            if !fields.insert(__FieldTag::__summary_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary_text"));
                            }
                            result.summary_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__text_sections => {
                            if !fields.insert(__FieldTag::__text_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_sections"));
                            }
                            result.text_sections = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_assistant_feedback::KnowledgeSearchFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_copied,
            __clicked_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeSearchFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerCopied" => Ok(__FieldTag::__answer_copied),
                            "answer_copied" => Ok(__FieldTag::__answer_copied),
                            "clickedUris" => Ok(__FieldTag::__clicked_uris),
                            "clicked_uris" => Ok(__FieldTag::__clicked_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_assistant_feedback::KnowledgeSearchFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeSearchFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_copied => {
                            if !fields.insert(__FieldTag::__answer_copied) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_copied"));
                            }
                            result.answer_copied = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__clicked_uris => {
                            if !fields.insert(__FieldTag::__clicked_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for clicked_uris"));
                            }
                            result.clicked_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_assistant_feedback::KnowledgeAssistFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_copied,
            __clicked_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeAssistFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerCopied" => Ok(__FieldTag::__answer_copied),
                            "answer_copied" => Ok(__FieldTag::__answer_copied),
                            "clickedUris" => Ok(__FieldTag::__clicked_uris),
                            "clicked_uris" => Ok(__FieldTag::__clicked_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_assistant_feedback::KnowledgeAssistFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeAssistFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_copied => {
                            if !fields.insert(__FieldTag::__answer_copied) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_copied"));
                            }
                            result.answer_copied = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__clicked_uris => {
                            if !fields.insert(__FieldTag::__clicked_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for clicked_uris"));
                            }
                            result.clicked_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AgentAssistantRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __article_suggestion_answer,
            __faq_answer,
            __dialogflow_assist_answer,
            __generator_suggestion,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentAssistantRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "articleSuggestionAnswer" => Ok(__FieldTag::__article_suggestion_answer),
                            "article_suggestion_answer" => Ok(__FieldTag::__article_suggestion_answer),
                            "faqAnswer" => Ok(__FieldTag::__faq_answer),
                            "faq_answer" => Ok(__FieldTag::__faq_answer),
                            "dialogflowAssistAnswer" => Ok(__FieldTag::__dialogflow_assist_answer),
                            "dialogflow_assist_answer" => Ok(__FieldTag::__dialogflow_assist_answer),
                            "generatorSuggestion" => Ok(__FieldTag::__generator_suggestion),
                            "generator_suggestion" => Ok(__FieldTag::__generator_suggestion),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AgentAssistantRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentAssistantRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__article_suggestion_answer => {
                            if !fields.insert(__FieldTag::__article_suggestion_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for article_suggestion_answer"));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.article_suggestion_answer, latest field was articleSuggestionAnswer",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::ArticleSuggestionAnswer(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ArticleAnswer>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__faq_answer => {
                            if !fields.insert(__FieldTag::__faq_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for faq_answer"));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.faq_answer, latest field was faqAnswer",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::FaqAnswer(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FaqAnswer>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__dialogflow_assist_answer => {
                            if !fields.insert(__FieldTag::__dialogflow_assist_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dialogflow_assist_answer"));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.dialogflow_assist_answer, latest field was dialogflowAssistAnswer",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::DialogflowAssistAnswer(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DialogflowAssistAnswer>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__generator_suggestion => {
                            if !fields.insert(__FieldTag::__generator_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_suggestion"));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.generator_suggestion, latest field was generatorSuggestion",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::GeneratorSuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GeneratorSuggestion>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SpeechContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrases,
            __boost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phrases" => Ok(__FieldTag::__phrases),
                            "boost" => Ok(__FieldTag::__boost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SpeechContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrases => {
                            if !fields.insert(__FieldTag::__phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phrases"));
                            }
                            result.phrases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__boost => {
                            if !fields.insert(__FieldTag::__boost) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for boost"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boost = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SpeechWordInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __word,
            __start_offset,
            __end_offset,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechWordInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "word" => Ok(__FieldTag::__word),
                            "startOffset" => Ok(__FieldTag::__start_offset),
                            "start_offset" => Ok(__FieldTag::__start_offset),
                            "endOffset" => Ok(__FieldTag::__end_offset),
                            "end_offset" => Ok(__FieldTag::__end_offset),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SpeechWordInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechWordInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__word => {
                            if !fields.insert(__FieldTag::__word) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for word"));
                            }
                            result.word = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__start_offset => {
                            if !fields.insert(__FieldTag::__start_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start_offset"));
                            }
                            result.start_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__end_offset => {
                            if !fields.insert(__FieldTag::__end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_offset"));
                            }
                            result.end_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InputAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __language_code,
            __enable_word_info,
            __phrase_hints,
            __speech_contexts,
            __model,
            __model_variant,
            __single_utterance,
            __disable_no_speech_recognized_event,
            __enable_automatic_punctuation,
            __phrase_sets,
            __opt_out_conformer_model_migration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "enableWordInfo" => Ok(__FieldTag::__enable_word_info),
                            "enable_word_info" => Ok(__FieldTag::__enable_word_info),
                            "phraseHints" => Ok(__FieldTag::__phrase_hints),
                            "phrase_hints" => Ok(__FieldTag::__phrase_hints),
                            "speechContexts" => Ok(__FieldTag::__speech_contexts),
                            "speech_contexts" => Ok(__FieldTag::__speech_contexts),
                            "model" => Ok(__FieldTag::__model),
                            "modelVariant" => Ok(__FieldTag::__model_variant),
                            "model_variant" => Ok(__FieldTag::__model_variant),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "disableNoSpeechRecognizedEvent" => Ok(__FieldTag::__disable_no_speech_recognized_event),
                            "disable_no_speech_recognized_event" => Ok(__FieldTag::__disable_no_speech_recognized_event),
                            "enableAutomaticPunctuation" => Ok(__FieldTag::__enable_automatic_punctuation),
                            "enable_automatic_punctuation" => Ok(__FieldTag::__enable_automatic_punctuation),
                            "phraseSets" => Ok(__FieldTag::__phrase_sets),
                            "phrase_sets" => Ok(__FieldTag::__phrase_sets),
                            "optOutConformerModelMigration" => Ok(__FieldTag::__opt_out_conformer_model_migration),
                            "opt_out_conformer_model_migration" => Ok(__FieldTag::__opt_out_conformer_model_migration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InputAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_encoding"));
                            }
                            result.audio_encoding = map.next_value::<std::option::Option<crate::model::AudioEncoding>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sample_rate_hertz"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_word_info => {
                            if !fields.insert(__FieldTag::__enable_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_word_info"));
                            }
                            result.enable_word_info = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__phrase_hints => {
                            if !fields.insert(__FieldTag::__phrase_hints) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phrase_hints"));
                            }
                            result.phrase_hints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__speech_contexts => {
                            if !fields.insert(__FieldTag::__speech_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_contexts"));
                            }
                            result.speech_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SpeechContext>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for model"));
                            }
                            result.model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__model_variant => {
                            if !fields.insert(__FieldTag::__model_variant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for model_variant"));
                            }
                            result.model_variant = map.next_value::<std::option::Option<crate::model::SpeechModelVariant>>()?.unwrap_or_default();
                        },
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for single_utterance"));
                            }
                            result.single_utterance = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__disable_no_speech_recognized_event => {
                            if !fields.insert(__FieldTag::__disable_no_speech_recognized_event) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for disable_no_speech_recognized_event"));
                            }
                            result.disable_no_speech_recognized_event = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_automatic_punctuation => {
                            if !fields.insert(__FieldTag::__enable_automatic_punctuation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_automatic_punctuation"));
                            }
                            result.enable_automatic_punctuation = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__phrase_sets => {
                            if !fields.insert(__FieldTag::__phrase_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phrase_sets"));
                            }
                            result.phrase_sets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__opt_out_conformer_model_migration => {
                            if !fields.insert(__FieldTag::__opt_out_conformer_model_migration) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for opt_out_conformer_model_migration"));
                            }
                            result.opt_out_conformer_model_migration = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations",feature = "environments",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VoiceSelectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ssml_gender,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceSelectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VoiceSelectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceSelectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ssml_gender"));
                            }
                            result.ssml_gender = map.next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations",feature = "environments",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesizeSpeechConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speaking_rate,
            __pitch,
            __volume_gain_db,
            __effects_profile_id,
            __voice,
            __pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            "pitch" => Ok(__FieldTag::__pitch),
                            "volumeGainDb" => Ok(__FieldTag::__volume_gain_db),
                            "volume_gain_db" => Ok(__FieldTag::__volume_gain_db),
                            "effectsProfileId" => Ok(__FieldTag::__effects_profile_id),
                            "effects_profile_id" => Ok(__FieldTag::__effects_profile_id),
                            "voice" => Ok(__FieldTag::__voice),
                            "pronunciations" => Ok(__FieldTag::__pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesizeSpeechConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speaking_rate"));
                            }
                            struct __With( std::option::Option<f64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__pitch => {
                            if !fields.insert(__FieldTag::__pitch) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pitch"));
                            }
                            struct __With( std::option::Option<f64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pitch = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__volume_gain_db => {
                            if !fields.insert(__FieldTag::__volume_gain_db) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for volume_gain_db"));
                            }
                            struct __With( std::option::Option<f64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_gain_db = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__effects_profile_id => {
                            if !fields.insert(__FieldTag::__effects_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effects_profile_id"));
                            }
                            result.effects_profile_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for voice"));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        },
                        __FieldTag::__pronunciations => {
                            if !fields.insert(__FieldTag::__pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pronunciations"));
                            }
                            result.pronunciations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CustomPronunciationParams>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations",feature = "environments",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CustomPronunciationParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase,
            __phonetic_encoding,
            __pronunciation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomPronunciationParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phrase" => Ok(__FieldTag::__phrase),
                            "phoneticEncoding" => Ok(__FieldTag::__phonetic_encoding),
                            "phonetic_encoding" => Ok(__FieldTag::__phonetic_encoding),
                            "pronunciation" => Ok(__FieldTag::__pronunciation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CustomPronunciationParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomPronunciationParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase => {
                            if !fields.insert(__FieldTag::__phrase) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phrase"));
                            }
                            result.phrase = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__phonetic_encoding => {
                            if !fields.insert(__FieldTag::__phonetic_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phonetic_encoding"));
                            }
                            result.phonetic_encoding = map.next_value::<std::option::Option<crate::model::custom_pronunciation_params::PhoneticEncoding>>()?.unwrap_or_default();
                        },
                        __FieldTag::__pronunciation => {
                            if !fields.insert(__FieldTag::__pronunciation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pronunciation"));
                            }
                            result.pronunciation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OutputAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __synthesize_speech_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "synthesizeSpeechConfig" => Ok(__FieldTag::__synthesize_speech_config),
                            "synthesize_speech_config" => Ok(__FieldTag::__synthesize_speech_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OutputAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_encoding"));
                            }
                            result.audio_encoding = map.next_value::<std::option::Option<crate::model::OutputAudioEncoding>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sample_rate_hertz"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__synthesize_speech_config => {
                            if !fields.insert(__FieldTag::__synthesize_speech_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for synthesize_speech_config"));
                            }
                            result.synthesize_speech_config = map.next_value::<std::option::Option<crate::model::SynthesizeSpeechConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TelephonyDtmfEvents {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dtmf_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TelephonyDtmfEvents")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dtmfEvents" => Ok(__FieldTag::__dtmf_events),
                            "dtmf_events" => Ok(__FieldTag::__dtmf_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TelephonyDtmfEvents;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TelephonyDtmfEvents")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dtmf_events => {
                            if !fields.insert(__FieldTag::__dtmf_events) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dtmf_events"));
                            }
                            result.dtmf_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TelephonyDtmf>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SpeechToTextConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speech_model_variant,
            __model,
            __phrase_sets,
            __audio_encoding,
            __sample_rate_hertz,
            __language_code,
            __enable_word_info,
            __use_timeout_based_endpointing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechToTextConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speechModelVariant" => Ok(__FieldTag::__speech_model_variant),
                            "speech_model_variant" => Ok(__FieldTag::__speech_model_variant),
                            "model" => Ok(__FieldTag::__model),
                            "phraseSets" => Ok(__FieldTag::__phrase_sets),
                            "phrase_sets" => Ok(__FieldTag::__phrase_sets),
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "enableWordInfo" => Ok(__FieldTag::__enable_word_info),
                            "enable_word_info" => Ok(__FieldTag::__enable_word_info),
                            "useTimeoutBasedEndpointing" => Ok(__FieldTag::__use_timeout_based_endpointing),
                            "use_timeout_based_endpointing" => Ok(__FieldTag::__use_timeout_based_endpointing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SpeechToTextConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechToTextConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speech_model_variant => {
                            if !fields.insert(__FieldTag::__speech_model_variant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_model_variant"));
                            }
                            result.speech_model_variant = map.next_value::<std::option::Option<crate::model::SpeechModelVariant>>()?.unwrap_or_default();
                        },
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for model"));
                            }
                            result.model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__phrase_sets => {
                            if !fields.insert(__FieldTag::__phrase_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phrase_sets"));
                            }
                            result.phrase_sets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_encoding"));
                            }
                            result.audio_encoding = map.next_value::<std::option::Option<crate::model::AudioEncoding>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sample_rate_hertz"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_word_info => {
                            if !fields.insert(__FieldTag::__enable_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_word_info"));
                            }
                            result.enable_word_info = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__use_timeout_based_endpointing => {
                            if !fields.insert(__FieldTag::__use_timeout_based_endpointing) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for use_timeout_based_endpointing"));
                            }
                            result.use_timeout_based_endpointing = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "contexts",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Context {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __lifespan_count,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Context")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "lifespanCount" => Ok(__FieldTag::__lifespan_count),
                            "lifespan_count" => Ok(__FieldTag::__lifespan_count),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Context;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Context")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__lifespan_count => {
                            if !fields.insert(__FieldTag::__lifespan_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for lifespan_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lifespan_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parameters"));
                            }
                            result.parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListContextsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContextsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListContextsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContextsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListContextsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contexts,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContextsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contexts" => Ok(__FieldTag::__contexts),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListContextsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContextsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for contexts"));
                            }
                            result.contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "context" => Ok(__FieldTag::__context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context"));
                            }
                            result.context = map.next_value::<std::option::Option<crate::model::Context>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __context,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "context" => Ok(__FieldTag::__context),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context"));
                            }
                            result.context = map.next_value::<std::option::Option<crate::model::Context>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteAllContextsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAllContextsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteAllContextsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAllContextsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Conversation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __lifecycle_state,
            __conversation_profile,
            __phone_number,
            __start_time,
            __end_time,
            __conversation_stage,
            __telephony_connection_info,
            __ingested_context_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Conversation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "lifecycleState" => Ok(__FieldTag::__lifecycle_state),
                            "lifecycle_state" => Ok(__FieldTag::__lifecycle_state),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "phoneNumber" => Ok(__FieldTag::__phone_number),
                            "phone_number" => Ok(__FieldTag::__phone_number),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "conversationStage" => Ok(__FieldTag::__conversation_stage),
                            "conversation_stage" => Ok(__FieldTag::__conversation_stage),
                            "telephonyConnectionInfo" => Ok(__FieldTag::__telephony_connection_info),
                            "telephony_connection_info" => Ok(__FieldTag::__telephony_connection_info),
                            "ingestedContextReferences" => Ok(__FieldTag::__ingested_context_references),
                            "ingested_context_references" => Ok(__FieldTag::__ingested_context_references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Conversation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Conversation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__lifecycle_state => {
                            if !fields.insert(__FieldTag::__lifecycle_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for lifecycle_state"));
                            }
                            result.lifecycle_state = map.next_value::<std::option::Option<crate::model::conversation::LifecycleState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__phone_number => {
                            if !fields.insert(__FieldTag::__phone_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phone_number"));
                            }
                            result.phone_number = map.next_value::<std::option::Option<crate::model::ConversationPhoneNumber>>()?
                                ;
                        },
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start_time"));
                            }
                            result.start_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_time"));
                            }
                            result.end_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__conversation_stage => {
                            if !fields.insert(__FieldTag::__conversation_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_stage"));
                            }
                            result.conversation_stage = map.next_value::<std::option::Option<crate::model::conversation::ConversationStage>>()?.unwrap_or_default();
                        },
                        __FieldTag::__telephony_connection_info => {
                            if !fields.insert(__FieldTag::__telephony_connection_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for telephony_connection_info"));
                            }
                            result.telephony_connection_info = map.next_value::<std::option::Option<crate::model::conversation::TelephonyConnectionInfo>>()?
                                ;
                        },
                        __FieldTag::__ingested_context_references => {
                            if !fields.insert(__FieldTag::__ingested_context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ingested_context_references"));
                            }
                            result.ingested_context_references = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::conversation::ContextReference>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::conversation::TelephonyConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dialed_number,
            __sdp,
            __sip_headers,
            __extra_mime_contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TelephonyConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dialedNumber" => Ok(__FieldTag::__dialed_number),
                            "dialed_number" => Ok(__FieldTag::__dialed_number),
                            "sdp" => Ok(__FieldTag::__sdp),
                            "sipHeaders" => Ok(__FieldTag::__sip_headers),
                            "sip_headers" => Ok(__FieldTag::__sip_headers),
                            "extraMimeContents" => Ok(__FieldTag::__extra_mime_contents),
                            "extra_mime_contents" => Ok(__FieldTag::__extra_mime_contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::conversation::TelephonyConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TelephonyConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dialed_number => {
                            if !fields.insert(__FieldTag::__dialed_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dialed_number"));
                            }
                            result.dialed_number = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sdp => {
                            if !fields.insert(__FieldTag::__sdp) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sdp"));
                            }
                            result.sdp = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sip_headers => {
                            if !fields.insert(__FieldTag::__sip_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sip_headers"));
                            }
                            result.sip_headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::telephony_connection_info::SipHeader>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__extra_mime_contents => {
                            if !fields.insert(__FieldTag::__extra_mime_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for extra_mime_contents"));
                            }
                            result.extra_mime_contents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::telephony_connection_info::MimeContent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::conversation::telephony_connection_info::SipHeader {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SipHeader")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::conversation::telephony_connection_info::SipHeader;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SipHeader")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for value"));
                            }
                            result.value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::conversation::telephony_connection_info::MimeContent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mime_type,
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MimeContent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::conversation::telephony_connection_info::MimeContent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MimeContent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for mime_type"));
                            }
                            result.mime_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::conversation::ContextReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __context_contents,
            __update_mode,
            __language_code,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContextReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contextContents" => Ok(__FieldTag::__context_contents),
                            "context_contents" => Ok(__FieldTag::__context_contents),
                            "updateMode" => Ok(__FieldTag::__update_mode),
                            "update_mode" => Ok(__FieldTag::__update_mode),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::conversation::ContextReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContextReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__context_contents => {
                            if !fields.insert(__FieldTag::__context_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_contents"));
                            }
                            result.context_contents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::context_reference::ContextContent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mode => {
                            if !fields.insert(__FieldTag::__update_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mode"));
                            }
                            result.update_mode = map.next_value::<std::option::Option<crate::model::conversation::context_reference::UpdateMode>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::conversation::context_reference::ContextContent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __content_format,
            __ingestion_time,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContextContent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "contentFormat" => Ok(__FieldTag::__content_format),
                            "content_format" => Ok(__FieldTag::__content_format),
                            "ingestionTime" => Ok(__FieldTag::__ingestion_time),
                            "ingestion_time" => Ok(__FieldTag::__ingestion_time),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::conversation::context_reference::ContextContent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContextContent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content"));
                            }
                            result.content = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content_format => {
                            if !fields.insert(__FieldTag::__content_format) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_format"));
                            }
                            result.content_format = map.next_value::<std::option::Option<crate::model::conversation::context_reference::context_content::ContentFormat>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ingestion_time => {
                            if !fields.insert(__FieldTag::__ingestion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ingestion_time"));
                            }
                            result.ingestion_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation,
            __conversation_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "conversationId" => Ok(__FieldTag::__conversation_id),
                            "conversation_id" => Ok(__FieldTag::__conversation_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<crate::model::Conversation>>()?
                                ;
                        },
                        __FieldTag::__conversation_id => {
                            if !fields.insert(__FieldTag::__conversation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_id"));
                            }
                            result.conversation_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversations" => Ok(__FieldTag::__conversations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversations => {
                            if !fields.insert(__FieldTag::__conversations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversations"));
                            }
                            result.conversations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Conversation>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CompleteConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CompleteConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListMessagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListMessagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListMessagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __messages,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messages" => Ok(__FieldTag::__messages),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListMessagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for messages"));
                            }
                            result.messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Message>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationPhoneNumber {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __country_code,
            __phone_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationPhoneNumber")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "countryCode" => Ok(__FieldTag::__country_code),
                            "country_code" => Ok(__FieldTag::__country_code),
                            "phoneNumber" => Ok(__FieldTag::__phone_number),
                            "phone_number" => Ok(__FieldTag::__phone_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationPhoneNumber;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationPhoneNumber")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__country_code => {
                            if !fields.insert(__FieldTag::__country_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for country_code"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.country_code = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__phone_number => {
                            if !fields.insert(__FieldTag::__phone_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for phone_number"));
                            }
                            result.phone_number = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IngestContextReferencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __context_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestContextReferencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "contextReferences" => Ok(__FieldTag::__context_references),
                            "context_references" => Ok(__FieldTag::__context_references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IngestContextReferencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestContextReferencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_references => {
                            if !fields.insert(__FieldTag::__context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_references"));
                            }
                            result.context_references = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::conversation::ContextReference>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IngestContextReferencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ingested_context_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestContextReferencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ingestedContextReferences" => Ok(__FieldTag::__ingested_context_references),
                            "ingested_context_references" => Ok(__FieldTag::__ingested_context_references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IngestContextReferencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestContextReferencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ingested_context_references => {
                            if !fields.insert(__FieldTag::__ingested_context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ingested_context_references"));
                            }
                            result.ingested_context_references = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::conversation::ContextReference>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestConversationSummaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __latest_message,
            __context_size,
            __assist_query_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestConversationSummaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestConversationSummaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestConversationSummaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for assist_query_params"));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestConversationSummaryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestConversationSummaryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summary" => Ok(__FieldTag::__summary),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestConversationSummaryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestConversationSummaryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary"));
                            }
                            result.summary = map.next_value::<std::option::Option<crate::model::suggest_conversation_summary_response::Summary>>()?
                                ;
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::suggest_conversation_summary_response::Summary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __text_sections,
            __answer_record,
            __baseline_model_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Summary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "textSections" => Ok(__FieldTag::__text_sections),
                            "text_sections" => Ok(__FieldTag::__text_sections),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "baselineModelVersion" => Ok(__FieldTag::__baseline_model_version),
                            "baseline_model_version" => Ok(__FieldTag::__baseline_model_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::suggest_conversation_summary_response::Summary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Summary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__text_sections => {
                            if !fields.insert(__FieldTag::__text_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_sections"));
                            }
                            result.text_sections = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__baseline_model_version => {
                            if !fields.insert(__FieldTag::__baseline_model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for baseline_model_version"));
                            }
                            result.baseline_model_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateStatelessSummaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stateless_conversation,
            __conversation_profile,
            __latest_message,
            __max_context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSummaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "statelessConversation" => Ok(__FieldTag::__stateless_conversation),
                            "stateless_conversation" => Ok(__FieldTag::__stateless_conversation),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "maxContextSize" => Ok(__FieldTag::__max_context_size),
                            "max_context_size" => Ok(__FieldTag::__max_context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateStatelessSummaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSummaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stateless_conversation => {
                            if !fields.insert(__FieldTag::__stateless_conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stateless_conversation"));
                            }
                            result.stateless_conversation = map.next_value::<std::option::Option<crate::model::generate_stateless_summary_request::MinimalConversation>>()?
                                ;
                        },
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<crate::model::ConversationProfile>>()?
                                ;
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__max_context_size => {
                            if !fields.insert(__FieldTag::__max_context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generate_stateless_summary_request::MinimalConversation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __messages,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MinimalConversation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messages" => Ok(__FieldTag::__messages),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generate_stateless_summary_request::MinimalConversation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MinimalConversation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for messages"));
                            }
                            result.messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Message>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateStatelessSummaryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSummaryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summary" => Ok(__FieldTag::__summary),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateStatelessSummaryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSummaryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary"));
                            }
                            result.summary = map.next_value::<std::option::Option<crate::model::generate_stateless_summary_response::Summary>>()?
                                ;
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generate_stateless_summary_response::Summary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __text_sections,
            __baseline_model_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Summary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "textSections" => Ok(__FieldTag::__text_sections),
                            "text_sections" => Ok(__FieldTag::__text_sections),
                            "baselineModelVersion" => Ok(__FieldTag::__baseline_model_version),
                            "baseline_model_version" => Ok(__FieldTag::__baseline_model_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generate_stateless_summary_response::Summary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Summary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__text_sections => {
                            if !fields.insert(__FieldTag::__text_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_sections"));
                            }
                            result.text_sections = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__baseline_model_version => {
                            if !fields.insert(__FieldTag::__baseline_model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for baseline_model_version"));
                            }
                            result.baseline_model_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateStatelessSuggestionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __generator,
            __generator_name,
            __context_references,
            __conversation_context,
            __trigger_events,
            __security_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSuggestionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "generator" => Ok(__FieldTag::__generator),
                            "generatorName" => Ok(__FieldTag::__generator_name),
                            "generator_name" => Ok(__FieldTag::__generator_name),
                            "contextReferences" => Ok(__FieldTag::__context_references),
                            "context_references" => Ok(__FieldTag::__context_references),
                            "conversationContext" => Ok(__FieldTag::__conversation_context),
                            "conversation_context" => Ok(__FieldTag::__conversation_context),
                            "triggerEvents" => Ok(__FieldTag::__trigger_events),
                            "trigger_events" => Ok(__FieldTag::__trigger_events),
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateStatelessSuggestionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSuggestionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator"));
                            }
                            if result.generator_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `generator_resource`, a oneof with full ID .google.cloud.dialogflow.v2.GenerateStatelessSuggestionRequest.generator, latest field was generator",
                                ));
                            }
                            result.generator_resource = std::option::Option::Some(
                                crate::model::generate_stateless_suggestion_request::GeneratorResource::Generator(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Generator>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__generator_name => {
                            if !fields.insert(__FieldTag::__generator_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_name"));
                            }
                            if result.generator_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `generator_resource`, a oneof with full ID .google.cloud.dialogflow.v2.GenerateStatelessSuggestionRequest.generator_name, latest field was generatorName",
                                ));
                            }
                            result.generator_resource = std::option::Option::Some(
                                crate::model::generate_stateless_suggestion_request::GeneratorResource::GeneratorName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__context_references => {
                            if !fields.insert(__FieldTag::__context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_references"));
                            }
                            result.context_references = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::conversation::ContextReference>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_context => {
                            if !fields.insert(__FieldTag::__conversation_context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_context"));
                            }
                            result.conversation_context = map.next_value::<std::option::Option<crate::model::ConversationContext>>()?
                                ;
                        },
                        __FieldTag::__trigger_events => {
                            if !fields.insert(__FieldTag::__trigger_events) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for trigger_events"));
                            }
                            result.trigger_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TriggerEvent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for security_settings"));
                            }
                            result.security_settings = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateStatelessSuggestionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_suggestion,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSuggestionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorSuggestion" => Ok(__FieldTag::__generator_suggestion),
                            "generator_suggestion" => Ok(__FieldTag::__generator_suggestion),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateStatelessSuggestionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSuggestionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_suggestion => {
                            if !fields.insert(__FieldTag::__generator_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_suggestion"));
                            }
                            result.generator_suggestion = map.next_value::<std::option::Option<crate::model::GeneratorSuggestion>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SearchKnowledgeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __query,
            __conversation_profile,
            __session_id,
            __conversation,
            __latest_message,
            __query_source,
            __end_user_metadata,
            __search_config,
            __exact_search,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchKnowledgeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "query" => Ok(__FieldTag::__query),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "querySource" => Ok(__FieldTag::__query_source),
                            "query_source" => Ok(__FieldTag::__query_source),
                            "endUserMetadata" => Ok(__FieldTag::__end_user_metadata),
                            "end_user_metadata" => Ok(__FieldTag::__end_user_metadata),
                            "searchConfig" => Ok(__FieldTag::__search_config),
                            "search_config" => Ok(__FieldTag::__search_config),
                            "exactSearch" => Ok(__FieldTag::__exact_search),
                            "exact_search" => Ok(__FieldTag::__exact_search),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SearchKnowledgeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchKnowledgeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query"));
                            }
                            result.query = map.next_value::<std::option::Option<crate::model::TextInput>>()?
                                ;
                        },
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_id"));
                            }
                            result.session_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__query_source => {
                            if !fields.insert(__FieldTag::__query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_source"));
                            }
                            result.query_source = map.next_value::<std::option::Option<crate::model::search_knowledge_request::QuerySource>>()?.unwrap_or_default();
                        },
                        __FieldTag::__end_user_metadata => {
                            if !fields.insert(__FieldTag::__end_user_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_user_metadata"));
                            }
                            result.end_user_metadata = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__search_config => {
                            if !fields.insert(__FieldTag::__search_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for search_config"));
                            }
                            result.search_config = map.next_value::<std::option::Option<crate::model::search_knowledge_request::SearchConfig>>()?
                                ;
                        },
                        __FieldTag::__exact_search => {
                            if !fields.insert(__FieldTag::__exact_search) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for exact_search"));
                            }
                            result.exact_search = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::SearchConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __boost_specs,
            __filter_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boostSpecs" => Ok(__FieldTag::__boost_specs),
                            "boost_specs" => Ok(__FieldTag::__boost_specs),
                            "filterSpecs" => Ok(__FieldTag::__filter_specs),
                            "filter_specs" => Ok(__FieldTag::__filter_specs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::SearchConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__boost_specs => {
                            if !fields.insert(__FieldTag::__boost_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for boost_specs"));
                            }
                            result.boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::BoostSpecs>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter_specs => {
                            if !fields.insert(__FieldTag::__filter_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_specs"));
                            }
                            result.filter_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::FilterSpecs>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::search_config::BoostSpecs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_stores,
            __spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoostSpecs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataStores" => Ok(__FieldTag::__data_stores),
                            "data_stores" => Ok(__FieldTag::__data_stores),
                            "spec" => Ok(__FieldTag::__spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::search_config::BoostSpecs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoostSpecs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_stores => {
                            if !fields.insert(__FieldTag::__data_stores) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for data_stores"));
                            }
                            result.data_stores = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for spec"));
                            }
                            result.spec = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::BoostSpec>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::search_config::boost_specs::BoostSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __condition_boost_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoostSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conditionBoostSpecs" => Ok(__FieldTag::__condition_boost_specs),
                            "condition_boost_specs" => Ok(__FieldTag::__condition_boost_specs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::search_config::boost_specs::BoostSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoostSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__condition_boost_specs => {
                            if !fields.insert(__FieldTag::__condition_boost_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for condition_boost_specs"));
                            }
                            result.condition_boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __condition,
            __boost,
            __boost_control_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConditionBoostSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "condition" => Ok(__FieldTag::__condition),
                            "boost" => Ok(__FieldTag::__boost),
                            "boostControlSpec" => Ok(__FieldTag::__boost_control_spec),
                            "boost_control_spec" => Ok(__FieldTag::__boost_control_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConditionBoostSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for condition"));
                            }
                            result.condition = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__boost => {
                            if !fields.insert(__FieldTag::__boost) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for boost"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boost = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__boost_control_spec => {
                            if !fields.insert(__FieldTag::__boost_control_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for boost_control_spec"));
                            }
                            result.boost_control_spec = map.next_value::<std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_name,
            __attribute_type,
            __interpolation_type,
            __control_points,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoostControlSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldName" => Ok(__FieldTag::__field_name),
                            "field_name" => Ok(__FieldTag::__field_name),
                            "attributeType" => Ok(__FieldTag::__attribute_type),
                            "attribute_type" => Ok(__FieldTag::__attribute_type),
                            "interpolationType" => Ok(__FieldTag::__interpolation_type),
                            "interpolation_type" => Ok(__FieldTag::__interpolation_type),
                            "controlPoints" => Ok(__FieldTag::__control_points),
                            "control_points" => Ok(__FieldTag::__control_points),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoostControlSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_name => {
                            if !fields.insert(__FieldTag::__field_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for field_name"));
                            }
                            result.field_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__attribute_type => {
                            if !fields.insert(__FieldTag::__attribute_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attribute_type"));
                            }
                            result.attribute_type = map.next_value::<std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::AttributeType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__interpolation_type => {
                            if !fields.insert(__FieldTag::__interpolation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for interpolation_type"));
                            }
                            result.interpolation_type = map.next_value::<std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__control_points => {
                            if !fields.insert(__FieldTag::__control_points) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for control_points"));
                            }
                            result.control_points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute_value,
            __boost_amount,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ControlPoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributeValue" => Ok(__FieldTag::__attribute_value),
                            "attribute_value" => Ok(__FieldTag::__attribute_value),
                            "boostAmount" => Ok(__FieldTag::__boost_amount),
                            "boost_amount" => Ok(__FieldTag::__boost_amount),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ControlPoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute_value => {
                            if !fields.insert(__FieldTag::__attribute_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for attribute_value"));
                            }
                            result.attribute_value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__boost_amount => {
                            if !fields.insert(__FieldTag::__boost_amount) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for boost_amount"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boost_amount = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_request::search_config::FilterSpecs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_stores,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterSpecs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataStores" => Ok(__FieldTag::__data_stores),
                            "data_stores" => Ok(__FieldTag::__data_stores),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_request::search_config::FilterSpecs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterSpecs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_stores => {
                            if !fields.insert(__FieldTag::__data_stores) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for data_stores"));
                            }
                            result.data_stores = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SearchKnowledgeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answers,
            __rewritten_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchKnowledgeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answers" => Ok(__FieldTag::__answers),
                            "rewrittenQuery" => Ok(__FieldTag::__rewritten_query),
                            "rewritten_query" => Ok(__FieldTag::__rewritten_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SearchKnowledgeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchKnowledgeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answers => {
                            if !fields.insert(__FieldTag::__answers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answers"));
                            }
                            result.answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SearchKnowledgeAnswer>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__rewritten_query => {
                            if !fields.insert(__FieldTag::__rewritten_query) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rewritten_query"));
                            }
                            result.rewritten_query = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SearchKnowledgeAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer,
            __answer_type,
            __answer_sources,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchKnowledgeAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answer" => Ok(__FieldTag::__answer),
                            "answerType" => Ok(__FieldTag::__answer_type),
                            "answer_type" => Ok(__FieldTag::__answer_type),
                            "answerSources" => Ok(__FieldTag::__answer_sources),
                            "answer_sources" => Ok(__FieldTag::__answer_sources),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SearchKnowledgeAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchKnowledgeAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer"));
                            }
                            result.answer = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_type => {
                            if !fields.insert(__FieldTag::__answer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_type"));
                            }
                            result.answer_type = map.next_value::<std::option::Option<crate::model::search_knowledge_answer::AnswerType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_sources => {
                            if !fields.insert(__FieldTag::__answer_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_sources"));
                            }
                            result.answer_sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_answer::AnswerSource>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::search_knowledge_answer::AnswerSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __uri,
            __snippet,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "uri" => Ok(__FieldTag::__uri),
                            "snippet" => Ok(__FieldTag::__snippet),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::search_knowledge_answer::AnswerSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__snippet => {
                            if !fields.insert(__FieldTag::__snippet) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for snippet"));
                            }
                            result.snippet = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateSuggestionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __latest_message,
            __trigger_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateSuggestionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "triggerEvents" => Ok(__FieldTag::__trigger_events),
                            "trigger_events" => Ok(__FieldTag::__trigger_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateSuggestionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateSuggestionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__trigger_events => {
                            if !fields.insert(__FieldTag::__trigger_events) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for trigger_events"));
                            }
                            result.trigger_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TriggerEvent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gcs_source"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.InputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsSources>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __input_config,
            __conversation_info,
            __conversation_count,
            __satisfies_pzi,
            __satisfies_pzs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "conversationInfo" => Ok(__FieldTag::__conversation_info),
                            "conversation_info" => Ok(__FieldTag::__conversation_info),
                            "conversationCount" => Ok(__FieldTag::__conversation_count),
                            "conversation_count" => Ok(__FieldTag::__conversation_count),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_config"));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::InputConfig>>()?
                                ;
                        },
                        __FieldTag::__conversation_info => {
                            if !fields.insert(__FieldTag::__conversation_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_info"));
                            }
                            result.conversation_info = map.next_value::<std::option::Option<crate::model::ConversationInfo>>()?
                                ;
                        },
                        __FieldTag::__conversation_count => {
                            if !fields.insert(__FieldTag::__conversation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_count"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.conversation_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzi"));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzs"));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_dataset"));
                            }
                            result.conversation_dataset = map.next_value::<std::option::Option<crate::model::ConversationDataset>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConversationDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConversationDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationDatasetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationDatasetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationDatasetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationDatasetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationDatasetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_datasets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationDatasetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDatasets" => Ok(__FieldTag::__conversation_datasets),
                            "conversation_datasets" => Ok(__FieldTag::__conversation_datasets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationDatasetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationDatasetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_datasets => {
                            if !fields.insert(__FieldTag::__conversation_datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_datasets"));
                            }
                            result.conversation_datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ConversationDataset>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConversationDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConversationDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportConversationDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __input_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportConversationDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportConversationDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportConversationDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_config"));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::InputConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportConversationDataOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_dataset,
            __partial_failures,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportConversationDataOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            "partialFailures" => Ok(__FieldTag::__partial_failures),
                            "partial_failures" => Ok(__FieldTag::__partial_failures),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportConversationDataOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportConversationDataOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_dataset"));
                            }
                            result.conversation_dataset = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__partial_failures => {
                            if !fields.insert(__FieldTag::__partial_failures) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for partial_failures"));
                            }
                            result.partial_failures = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportConversationDataOperationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_dataset,
            __import_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportConversationDataOperationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            "importCount" => Ok(__FieldTag::__import_count),
                            "import_count" => Ok(__FieldTag::__import_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportConversationDataOperationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportConversationDataOperationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_dataset"));
                            }
                            result.conversation_dataset = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__import_count => {
                            if !fields.insert(__FieldTag::__import_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for import_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.import_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationDatasetOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationDatasetOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationDatasetOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationDatasetOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_dataset"));
                            }
                            result.conversation_dataset = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConversationDatasetOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationDatasetOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConversationDatasetOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationDatasetOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all ( feature = "agents",feature = "answer-records",feature = "contexts",feature = "conversation-datasets",feature = "conversation-models",feature = "conversation-profiles",feature = "conversations",feature = "documents",feature = "encryption-spec-service",feature = "entity-types",feature = "environments",feature = "fulfillments",feature = "generator-evaluations",feature = "generators",feature = "intents",feature = "knowledge-bases",feature = "participants",feature = "session-entity-types",feature = "sessions",feature = "sip-trunks",feature = "tools",feature = "versions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __type,
            __error_status,
            __new_message_payload,
            __new_recognition_result_payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "type" => Ok(__FieldTag::__type),
                            "errorStatus" => Ok(__FieldTag::__error_status),
                            "error_status" => Ok(__FieldTag::__error_status),
                            "newMessagePayload" => Ok(__FieldTag::__new_message_payload),
                            "new_message_payload" => Ok(__FieldTag::__new_message_payload),
                            "newRecognitionResultPayload" => Ok(__FieldTag::__new_recognition_result_payload),
                            "new_recognition_result_payload" => Ok(__FieldTag::__new_recognition_result_payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::conversation_event::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__error_status => {
                            if !fields.insert(__FieldTag::__error_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_status"));
                            }
                            result.error_status = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::__new_message_payload => {
                            if !fields.insert(__FieldTag::__new_message_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_message_payload"));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationEvent.new_message_payload, latest field was newMessagePayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::conversation_event::Payload::NewMessagePayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Message>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__new_recognition_result_payload => {
                            if !fields.insert(__FieldTag::__new_recognition_result_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_recognition_result_payload"));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationEvent.new_recognition_result_payload, latest field was newRecognitionResultPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::conversation_event::Payload::NewRecognitionResultPayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamingRecognitionResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationModel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __datasets,
            __state,
            __language_code,
            __article_suggestion_model_metadata,
            __smart_reply_model_metadata,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationModel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "datasets" => Ok(__FieldTag::__datasets),
                            "state" => Ok(__FieldTag::__state),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "articleSuggestionModelMetadata" => Ok(__FieldTag::__article_suggestion_model_metadata),
                            "article_suggestion_model_metadata" => Ok(__FieldTag::__article_suggestion_model_metadata),
                            "smartReplyModelMetadata" => Ok(__FieldTag::__smart_reply_model_metadata),
                            "smart_reply_model_metadata" => Ok(__FieldTag::__smart_reply_model_metadata),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationModel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationModel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for datasets"));
                            }
                            result.datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InputDataset>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::conversation_model::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__article_suggestion_model_metadata => {
                            if !fields.insert(__FieldTag::__article_suggestion_model_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for article_suggestion_model_metadata"));
                            }
                            if result.model_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_metadata`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationModel.article_suggestion_model_metadata, latest field was articleSuggestionModelMetadata",
                                ));
                            }
                            result.model_metadata = std::option::Option::Some(
                                crate::model::conversation_model::ModelMetadata::ArticleSuggestionModelMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ArticleSuggestionModelMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__smart_reply_model_metadata => {
                            if !fields.insert(__FieldTag::__smart_reply_model_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_reply_model_metadata"));
                            }
                            if result.model_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_metadata`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationModel.smart_reply_model_metadata, latest field was smartReplyModelMetadata",
                                ));
                            }
                            result.model_metadata = std::option::Option::Some(
                                crate::model::conversation_model::ModelMetadata::SmartReplyModelMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SmartReplyModelMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzs"));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzi"));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationModelEvaluation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __evaluation_config,
            __create_time,
            __smart_reply_metrics,
            __raw_human_eval_template_csv,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationModelEvaluation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "evaluationConfig" => Ok(__FieldTag::__evaluation_config),
                            "evaluation_config" => Ok(__FieldTag::__evaluation_config),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "smartReplyMetrics" => Ok(__FieldTag::__smart_reply_metrics),
                            "smart_reply_metrics" => Ok(__FieldTag::__smart_reply_metrics),
                            "rawHumanEvalTemplateCsv" => Ok(__FieldTag::__raw_human_eval_template_csv),
                            "raw_human_eval_template_csv" => Ok(__FieldTag::__raw_human_eval_template_csv),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationModelEvaluation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationModelEvaluation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__evaluation_config => {
                            if !fields.insert(__FieldTag::__evaluation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for evaluation_config"));
                            }
                            result.evaluation_config = map.next_value::<std::option::Option<crate::model::EvaluationConfig>>()?
                                ;
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__smart_reply_metrics => {
                            if !fields.insert(__FieldTag::__smart_reply_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_reply_metrics"));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationModelEvaluation.smart_reply_metrics, latest field was smartReplyMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::conversation_model_evaluation::Metrics::SmartReplyMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SmartReplyMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__raw_human_eval_template_csv => {
                            if !fields.insert(__FieldTag::__raw_human_eval_template_csv) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for raw_human_eval_template_csv"));
                            }
                            result.raw_human_eval_template_csv = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EvaluationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datasets,
            __smart_reply_config,
            __smart_compose_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasets" => Ok(__FieldTag::__datasets),
                            "smartReplyConfig" => Ok(__FieldTag::__smart_reply_config),
                            "smart_reply_config" => Ok(__FieldTag::__smart_reply_config),
                            "smartComposeConfig" => Ok(__FieldTag::__smart_compose_config),
                            "smart_compose_config" => Ok(__FieldTag::__smart_compose_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EvaluationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for datasets"));
                            }
                            result.datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InputDataset>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__smart_reply_config => {
                            if !fields.insert(__FieldTag::__smart_reply_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_reply_config"));
                            }
                            if result.model_specific_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_specific_config`, a oneof with full ID .google.cloud.dialogflow.v2.EvaluationConfig.smart_reply_config, latest field was smartReplyConfig",
                                ));
                            }
                            result.model_specific_config = std::option::Option::Some(
                                crate::model::evaluation_config::ModelSpecificConfig::SmartReplyConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::evaluation_config::SmartReplyConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__smart_compose_config => {
                            if !fields.insert(__FieldTag::__smart_compose_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_compose_config"));
                            }
                            if result.model_specific_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_specific_config`, a oneof with full ID .google.cloud.dialogflow.v2.EvaluationConfig.smart_compose_config, latest field was smartComposeConfig",
                                ));
                            }
                            result.model_specific_config = std::option::Option::Some(
                                crate::model::evaluation_config::ModelSpecificConfig::SmartComposeConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::evaluation_config::SmartComposeConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::evaluation_config::SmartReplyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowlist_document,
            __max_result_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowlistDocument" => Ok(__FieldTag::__allowlist_document),
                            "allowlist_document" => Ok(__FieldTag::__allowlist_document),
                            "maxResultCount" => Ok(__FieldTag::__max_result_count),
                            "max_result_count" => Ok(__FieldTag::__max_result_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::evaluation_config::SmartReplyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowlist_document => {
                            if !fields.insert(__FieldTag::__allowlist_document) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowlist_document"));
                            }
                            result.allowlist_document = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__max_result_count => {
                            if !fields.insert(__FieldTag::__max_result_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_result_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_result_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::evaluation_config::SmartComposeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowlist_document,
            __max_result_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartComposeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowlistDocument" => Ok(__FieldTag::__allowlist_document),
                            "allowlist_document" => Ok(__FieldTag::__allowlist_document),
                            "maxResultCount" => Ok(__FieldTag::__max_result_count),
                            "max_result_count" => Ok(__FieldTag::__max_result_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::evaluation_config::SmartComposeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartComposeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowlist_document => {
                            if !fields.insert(__FieldTag::__allowlist_document) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowlist_document"));
                            }
                            result.allowlist_document = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__max_result_count => {
                            if !fields.insert(__FieldTag::__max_result_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_result_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_result_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InputDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InputDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dataset"));
                            }
                            result.dataset = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ArticleSuggestionModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __training_model_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArticleSuggestionModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trainingModelType" => Ok(__FieldTag::__training_model_type),
                            "training_model_type" => Ok(__FieldTag::__training_model_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ArticleSuggestionModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArticleSuggestionModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__training_model_type => {
                            if !fields.insert(__FieldTag::__training_model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for training_model_type"));
                            }
                            result.training_model_type = map.next_value::<std::option::Option<crate::model::conversation_model::ModelType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SmartReplyModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __training_model_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trainingModelType" => Ok(__FieldTag::__training_model_type),
                            "training_model_type" => Ok(__FieldTag::__training_model_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SmartReplyModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__training_model_type => {
                            if !fields.insert(__FieldTag::__training_model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for training_model_type"));
                            }
                            result.training_model_type = map.next_value::<std::option::Option<crate::model::conversation_model::ModelType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SmartReplyMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowlist_coverage,
            __top_n_metrics,
            __conversation_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowlistCoverage" => Ok(__FieldTag::__allowlist_coverage),
                            "allowlist_coverage" => Ok(__FieldTag::__allowlist_coverage),
                            "topNMetrics" => Ok(__FieldTag::__top_n_metrics),
                            "top_n_metrics" => Ok(__FieldTag::__top_n_metrics),
                            "conversationCount" => Ok(__FieldTag::__conversation_count),
                            "conversation_count" => Ok(__FieldTag::__conversation_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SmartReplyMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowlist_coverage => {
                            if !fields.insert(__FieldTag::__allowlist_coverage) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowlist_coverage"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.allowlist_coverage = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__top_n_metrics => {
                            if !fields.insert(__FieldTag::__top_n_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for top_n_metrics"));
                            }
                            result.top_n_metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::smart_reply_metrics::TopNMetrics>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_count => {
                            if !fields.insert(__FieldTag::__conversation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_count"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.conversation_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::smart_reply_metrics::TopNMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __n,
            __recall,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TopNMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "n" => Ok(__FieldTag::__n),
                            "recall" => Ok(__FieldTag::__recall),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::smart_reply_metrics::TopNMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TopNMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__n => {
                            if !fields.insert(__FieldTag::__n) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for n"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.n = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__recall => {
                            if !fields.insert(__FieldTag::__recall) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for recall"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.recall = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model"));
                            }
                            result.conversation_model = map.next_value::<std::option::Option<crate::model::ConversationModel>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModels" => Ok(__FieldTag::__conversation_models),
                            "conversation_models" => Ok(__FieldTag::__conversation_models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_models => {
                            if !fields.insert(__FieldTag::__conversation_models) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_models"));
                            }
                            result.conversation_models = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ConversationModel>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeployConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeployConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UndeployConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UndeployConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConversationModelEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationModelEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConversationModelEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationModelEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationModelEvaluationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationModelEvaluationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationModelEvaluationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelEvaluationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationModelEvaluationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model_evaluations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationModelEvaluationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModelEvaluations" => Ok(__FieldTag::__conversation_model_evaluations),
                            "conversation_model_evaluations" => Ok(__FieldTag::__conversation_model_evaluations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationModelEvaluationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelEvaluationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model_evaluations => {
                            if !fields.insert(__FieldTag::__conversation_model_evaluations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model_evaluations"));
                            }
                            result.conversation_model_evaluations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ConversationModelEvaluation>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationModelEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_model_evaluation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationModelEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationModelEvaluation" => Ok(__FieldTag::__conversation_model_evaluation),
                            "conversation_model_evaluation" => Ok(__FieldTag::__conversation_model_evaluation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationModelEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_model_evaluation => {
                            if !fields.insert(__FieldTag::__conversation_model_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model_evaluation"));
                            }
                            result.conversation_model_evaluation = map.next_value::<std::option::Option<crate::model::ConversationModelEvaluation>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __state,
            __create_time,
            __done_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model"));
                            }
                            result.conversation_model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::create_conversation_model_operation_metadata::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done_time"));
                            }
                            result.done_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeployConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __create_time,
            __done_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeployConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model"));
                            }
                            result.conversation_model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done_time"));
                            }
                            result.done_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UndeployConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __create_time,
            __done_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UndeployConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model"));
                            }
                            result.conversation_model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done_time"));
                            }
                            result.done_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __create_time,
            __done_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model"));
                            }
                            result.conversation_model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done_time"));
                            }
                            result.done_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationModelEvaluationOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model_evaluation,
            __conversation_model,
            __state,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationModelEvaluationOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModelEvaluation" => Ok(__FieldTag::__conversation_model_evaluation),
                            "conversation_model_evaluation" => Ok(__FieldTag::__conversation_model_evaluation),
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationModelEvaluationOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelEvaluationOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model_evaluation => {
                            if !fields.insert(__FieldTag::__conversation_model_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model_evaluation"));
                            }
                            result.conversation_model_evaluation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model"));
                            }
                            result.conversation_model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::create_conversation_model_evaluation_operation_metadata::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __update_time,
            __automated_agent_config,
            __human_agent_assistant_config,
            __human_agent_handoff_config,
            __notification_config,
            __logging_config,
            __new_message_event_notification_config,
            __new_recognition_result_notification_config,
            __stt_config,
            __language_code,
            __time_zone,
            __security_settings,
            __tts_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "automatedAgentConfig" => Ok(__FieldTag::__automated_agent_config),
                            "automated_agent_config" => Ok(__FieldTag::__automated_agent_config),
                            "humanAgentAssistantConfig" => Ok(__FieldTag::__human_agent_assistant_config),
                            "human_agent_assistant_config" => Ok(__FieldTag::__human_agent_assistant_config),
                            "humanAgentHandoffConfig" => Ok(__FieldTag::__human_agent_handoff_config),
                            "human_agent_handoff_config" => Ok(__FieldTag::__human_agent_handoff_config),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "newMessageEventNotificationConfig" => Ok(__FieldTag::__new_message_event_notification_config),
                            "new_message_event_notification_config" => Ok(__FieldTag::__new_message_event_notification_config),
                            "newRecognitionResultNotificationConfig" => Ok(__FieldTag::__new_recognition_result_notification_config),
                            "new_recognition_result_notification_config" => Ok(__FieldTag::__new_recognition_result_notification_config),
                            "sttConfig" => Ok(__FieldTag::__stt_config),
                            "stt_config" => Ok(__FieldTag::__stt_config),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            "ttsConfig" => Ok(__FieldTag::__tts_config),
                            "tts_config" => Ok(__FieldTag::__tts_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__automated_agent_config => {
                            if !fields.insert(__FieldTag::__automated_agent_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for automated_agent_config"));
                            }
                            result.automated_agent_config = map.next_value::<std::option::Option<crate::model::AutomatedAgentConfig>>()?
                                ;
                        },
                        __FieldTag::__human_agent_assistant_config => {
                            if !fields.insert(__FieldTag::__human_agent_assistant_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for human_agent_assistant_config"));
                            }
                            result.human_agent_assistant_config = map.next_value::<std::option::Option<crate::model::HumanAgentAssistantConfig>>()?
                                ;
                        },
                        __FieldTag::__human_agent_handoff_config => {
                            if !fields.insert(__FieldTag::__human_agent_handoff_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for human_agent_handoff_config"));
                            }
                            result.human_agent_handoff_config = map.next_value::<std::option::Option<crate::model::HumanAgentHandoffConfig>>()?
                                ;
                        },
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for notification_config"));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        },
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for logging_config"));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::LoggingConfig>>()?
                                ;
                        },
                        __FieldTag::__new_message_event_notification_config => {
                            if !fields.insert(__FieldTag::__new_message_event_notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_message_event_notification_config"));
                            }
                            result.new_message_event_notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        },
                        __FieldTag::__new_recognition_result_notification_config => {
                            if !fields.insert(__FieldTag::__new_recognition_result_notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_recognition_result_notification_config"));
                            }
                            result.new_recognition_result_notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        },
                        __FieldTag::__stt_config => {
                            if !fields.insert(__FieldTag::__stt_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stt_config"));
                            }
                            result.stt_config = map.next_value::<std::option::Option<crate::model::SpeechToTextConfig>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time_zone"));
                            }
                            result.time_zone = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for security_settings"));
                            }
                            result.security_settings = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tts_config => {
                            if !fields.insert(__FieldTag::__tts_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tts_config"));
                            }
                            result.tts_config = map.next_value::<std::option::Option<crate::model::SynthesizeSpeechConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConversationProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profiles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfiles" => Ok(__FieldTag::__conversation_profiles),
                            "conversation_profiles" => Ok(__FieldTag::__conversation_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConversationProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profiles => {
                            if !fields.insert(__FieldTag::__conversation_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profiles"));
                            }
                            result.conversation_profiles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ConversationProfile>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<crate::model::ConversationProfile>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<crate::model::ConversationProfile>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutomatedAgentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __session_ttl,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomatedAgentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "sessionTtl" => Ok(__FieldTag::__session_ttl),
                            "session_ttl" => Ok(__FieldTag::__session_ttl),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutomatedAgentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomatedAgentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent"));
                            }
                            result.agent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__session_ttl => {
                            if !fields.insert(__FieldTag::__session_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_ttl"));
                            }
                            result.session_ttl = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HumanAgentAssistantConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notification_config,
            __human_agent_suggestion_config,
            __end_user_suggestion_config,
            __message_analysis_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentAssistantConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "humanAgentSuggestionConfig" => Ok(__FieldTag::__human_agent_suggestion_config),
                            "human_agent_suggestion_config" => Ok(__FieldTag::__human_agent_suggestion_config),
                            "endUserSuggestionConfig" => Ok(__FieldTag::__end_user_suggestion_config),
                            "end_user_suggestion_config" => Ok(__FieldTag::__end_user_suggestion_config),
                            "messageAnalysisConfig" => Ok(__FieldTag::__message_analysis_config),
                            "message_analysis_config" => Ok(__FieldTag::__message_analysis_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HumanAgentAssistantConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentAssistantConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for notification_config"));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        },
                        __FieldTag::__human_agent_suggestion_config => {
                            if !fields.insert(__FieldTag::__human_agent_suggestion_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for human_agent_suggestion_config"));
                            }
                            result.human_agent_suggestion_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionConfig>>()?
                                ;
                        },
                        __FieldTag::__end_user_suggestion_config => {
                            if !fields.insert(__FieldTag::__end_user_suggestion_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_user_suggestion_config"));
                            }
                            result.end_user_suggestion_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionConfig>>()?
                                ;
                        },
                        __FieldTag::__message_analysis_config => {
                            if !fields.insert(__FieldTag::__message_analysis_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_analysis_config"));
                            }
                            result.message_analysis_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::MessageAnalysisConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::SuggestionTriggerSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __no_smalltalk,
            __only_end_user,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionTriggerSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "noSmalltalk" => Ok(__FieldTag::__no_smalltalk),
                            "no_smalltalk" => Ok(__FieldTag::__no_smalltalk),
                            "onlyEndUser" => Ok(__FieldTag::__only_end_user),
                            "only_end_user" => Ok(__FieldTag::__only_end_user),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::SuggestionTriggerSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionTriggerSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__no_smalltalk => {
                            if !fields.insert(__FieldTag::__no_smalltalk) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for no_smalltalk"));
                            }
                            result.no_smalltalk = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__only_end_user => {
                            if !fields.insert(__FieldTag::__only_end_user) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for only_end_user"));
                            }
                            result.only_end_user = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::SuggestionFeatureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __suggestion_feature,
            __enable_event_based_suggestion,
            __disable_agent_query_logging,
            __enable_query_suggestion_when_no_answer,
            __enable_conversation_augmented_query,
            __enable_query_suggestion_only,
            __enable_response_debug_info,
            __rai_settings,
            __suggestion_trigger_settings,
            __query_config,
            __conversation_model_config,
            __conversation_process_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionFeatureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "suggestionFeature" => Ok(__FieldTag::__suggestion_feature),
                            "suggestion_feature" => Ok(__FieldTag::__suggestion_feature),
                            "enableEventBasedSuggestion" => Ok(__FieldTag::__enable_event_based_suggestion),
                            "enable_event_based_suggestion" => Ok(__FieldTag::__enable_event_based_suggestion),
                            "disableAgentQueryLogging" => Ok(__FieldTag::__disable_agent_query_logging),
                            "disable_agent_query_logging" => Ok(__FieldTag::__disable_agent_query_logging),
                            "enableQuerySuggestionWhenNoAnswer" => Ok(__FieldTag::__enable_query_suggestion_when_no_answer),
                            "enable_query_suggestion_when_no_answer" => Ok(__FieldTag::__enable_query_suggestion_when_no_answer),
                            "enableConversationAugmentedQuery" => Ok(__FieldTag::__enable_conversation_augmented_query),
                            "enable_conversation_augmented_query" => Ok(__FieldTag::__enable_conversation_augmented_query),
                            "enableQuerySuggestionOnly" => Ok(__FieldTag::__enable_query_suggestion_only),
                            "enable_query_suggestion_only" => Ok(__FieldTag::__enable_query_suggestion_only),
                            "enableResponseDebugInfo" => Ok(__FieldTag::__enable_response_debug_info),
                            "enable_response_debug_info" => Ok(__FieldTag::__enable_response_debug_info),
                            "raiSettings" => Ok(__FieldTag::__rai_settings),
                            "rai_settings" => Ok(__FieldTag::__rai_settings),
                            "suggestionTriggerSettings" => Ok(__FieldTag::__suggestion_trigger_settings),
                            "suggestion_trigger_settings" => Ok(__FieldTag::__suggestion_trigger_settings),
                            "queryConfig" => Ok(__FieldTag::__query_config),
                            "query_config" => Ok(__FieldTag::__query_config),
                            "conversationModelConfig" => Ok(__FieldTag::__conversation_model_config),
                            "conversation_model_config" => Ok(__FieldTag::__conversation_model_config),
                            "conversationProcessConfig" => Ok(__FieldTag::__conversation_process_config),
                            "conversation_process_config" => Ok(__FieldTag::__conversation_process_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::SuggestionFeatureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionFeatureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__suggestion_feature => {
                            if !fields.insert(__FieldTag::__suggestion_feature) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_feature"));
                            }
                            result.suggestion_feature = map.next_value::<std::option::Option<crate::model::SuggestionFeature>>()?
                                ;
                        },
                        __FieldTag::__enable_event_based_suggestion => {
                            if !fields.insert(__FieldTag::__enable_event_based_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_event_based_suggestion"));
                            }
                            result.enable_event_based_suggestion = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__disable_agent_query_logging => {
                            if !fields.insert(__FieldTag::__disable_agent_query_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for disable_agent_query_logging"));
                            }
                            result.disable_agent_query_logging = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_query_suggestion_when_no_answer => {
                            if !fields.insert(__FieldTag::__enable_query_suggestion_when_no_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_query_suggestion_when_no_answer"));
                            }
                            result.enable_query_suggestion_when_no_answer = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_conversation_augmented_query => {
                            if !fields.insert(__FieldTag::__enable_conversation_augmented_query) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_conversation_augmented_query"));
                            }
                            result.enable_conversation_augmented_query = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_query_suggestion_only => {
                            if !fields.insert(__FieldTag::__enable_query_suggestion_only) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_query_suggestion_only"));
                            }
                            result.enable_query_suggestion_only = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_response_debug_info => {
                            if !fields.insert(__FieldTag::__enable_response_debug_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_response_debug_info"));
                            }
                            result.enable_response_debug_info = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__rai_settings => {
                            if !fields.insert(__FieldTag::__rai_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rai_settings"));
                            }
                            result.rai_settings = map.next_value::<std::option::Option<crate::model::RaiSettings>>()?
                                ;
                        },
                        __FieldTag::__suggestion_trigger_settings => {
                            if !fields.insert(__FieldTag::__suggestion_trigger_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_trigger_settings"));
                            }
                            result.suggestion_trigger_settings = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionTriggerSettings>>()?
                                ;
                        },
                        __FieldTag::__query_config => {
                            if !fields.insert(__FieldTag::__query_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_config"));
                            }
                            result.query_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionQueryConfig>>()?
                                ;
                        },
                        __FieldTag::__conversation_model_config => {
                            if !fields.insert(__FieldTag::__conversation_model_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_model_config"));
                            }
                            result.conversation_model_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::ConversationModelConfig>>()?
                                ;
                        },
                        __FieldTag::__conversation_process_config => {
                            if !fields.insert(__FieldTag::__conversation_process_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_process_config"));
                            }
                            result.conversation_process_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::ConversationProcessConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::SuggestionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feature_configs,
            __group_suggestion_responses,
            __generators,
            __disable_high_latency_features_sync_delivery,
            __skip_empty_event_based_suggestion,
            __use_unredacted_conversation_data,
            __enable_async_tool_call,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "featureConfigs" => Ok(__FieldTag::__feature_configs),
                            "feature_configs" => Ok(__FieldTag::__feature_configs),
                            "groupSuggestionResponses" => Ok(__FieldTag::__group_suggestion_responses),
                            "group_suggestion_responses" => Ok(__FieldTag::__group_suggestion_responses),
                            "generators" => Ok(__FieldTag::__generators),
                            "disableHighLatencyFeaturesSyncDelivery" => Ok(__FieldTag::__disable_high_latency_features_sync_delivery),
                            "disable_high_latency_features_sync_delivery" => Ok(__FieldTag::__disable_high_latency_features_sync_delivery),
                            "skipEmptyEventBasedSuggestion" => Ok(__FieldTag::__skip_empty_event_based_suggestion),
                            "skip_empty_event_based_suggestion" => Ok(__FieldTag::__skip_empty_event_based_suggestion),
                            "useUnredactedConversationData" => Ok(__FieldTag::__use_unredacted_conversation_data),
                            "use_unredacted_conversation_data" => Ok(__FieldTag::__use_unredacted_conversation_data),
                            "enableAsyncToolCall" => Ok(__FieldTag::__enable_async_tool_call),
                            "enable_async_tool_call" => Ok(__FieldTag::__enable_async_tool_call),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::SuggestionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feature_configs => {
                            if !fields.insert(__FieldTag::__feature_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for feature_configs"));
                            }
                            result.feature_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__group_suggestion_responses => {
                            if !fields.insert(__FieldTag::__group_suggestion_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for group_suggestion_responses"));
                            }
                            result.group_suggestion_responses = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generators => {
                            if !fields.insert(__FieldTag::__generators) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generators"));
                            }
                            result.generators = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__disable_high_latency_features_sync_delivery => {
                            if !fields.insert(__FieldTag::__disable_high_latency_features_sync_delivery) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for disable_high_latency_features_sync_delivery"));
                            }
                            result.disable_high_latency_features_sync_delivery = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__skip_empty_event_based_suggestion => {
                            if !fields.insert(__FieldTag::__skip_empty_event_based_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for skip_empty_event_based_suggestion"));
                            }
                            result.skip_empty_event_based_suggestion = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__use_unredacted_conversation_data => {
                            if !fields.insert(__FieldTag::__use_unredacted_conversation_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for use_unredacted_conversation_data"));
                            }
                            result.use_unredacted_conversation_data = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_async_tool_call => {
                            if !fields.insert(__FieldTag::__enable_async_tool_call) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_async_tool_call"));
                            }
                            result.enable_async_tool_call = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::SuggestionQueryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_base_query_source,
            __document_query_source,
            __dialogflow_query_source,
            __max_results,
            __confidence_threshold,
            __context_filter_settings,
            __sections,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionQueryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeBaseQuerySource" => Ok(__FieldTag::__knowledge_base_query_source),
                            "knowledge_base_query_source" => Ok(__FieldTag::__knowledge_base_query_source),
                            "documentQuerySource" => Ok(__FieldTag::__document_query_source),
                            "document_query_source" => Ok(__FieldTag::__document_query_source),
                            "dialogflowQuerySource" => Ok(__FieldTag::__dialogflow_query_source),
                            "dialogflow_query_source" => Ok(__FieldTag::__dialogflow_query_source),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "confidenceThreshold" => Ok(__FieldTag::__confidence_threshold),
                            "confidence_threshold" => Ok(__FieldTag::__confidence_threshold),
                            "contextFilterSettings" => Ok(__FieldTag::__context_filter_settings),
                            "context_filter_settings" => Ok(__FieldTag::__context_filter_settings),
                            "sections" => Ok(__FieldTag::__sections),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::SuggestionQueryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionQueryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_base_query_source => {
                            if !fields.insert(__FieldTag::__knowledge_base_query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_base_query_source"));
                            }
                            if result.query_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_source`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.knowledge_base_query_source, latest field was knowledgeBaseQuerySource",
                                ));
                            }
                            result.query_source = std::option::Option::Some(
                                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::KnowledgeBaseQuerySource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__document_query_source => {
                            if !fields.insert(__FieldTag::__document_query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for document_query_source"));
                            }
                            if result.query_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_source`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.document_query_source, latest field was documentQuerySource",
                                ));
                            }
                            result.query_source = std::option::Option::Some(
                                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DocumentQuerySource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__dialogflow_query_source => {
                            if !fields.insert(__FieldTag::__dialogflow_query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dialogflow_query_source"));
                            }
                            if result.query_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_source`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.dialogflow_query_source, latest field was dialogflowQuerySource",
                                ));
                            }
                            result.query_source = std::option::Option::Some(
                                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DialogflowQuerySource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_results"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__confidence_threshold => {
                            if !fields.insert(__FieldTag::__confidence_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence_threshold"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_threshold = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__context_filter_settings => {
                            if !fields.insert(__FieldTag::__context_filter_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_filter_settings"));
                            }
                            result.context_filter_settings = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings>>()?
                                ;
                        },
                        __FieldTag::__sections => {
                            if !fields.insert(__FieldTag::__sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sections"));
                            }
                            result.sections = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::Sections>>()?
                                ;
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_bases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeBaseQuerySource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeBases" => Ok(__FieldTag::__knowledge_bases),
                            "knowledge_bases" => Ok(__FieldTag::__knowledge_bases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeBaseQuerySource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_bases => {
                            if !fields.insert(__FieldTag::__knowledge_bases) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_bases"));
                            }
                            result.knowledge_bases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentQuerySource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documents" => Ok(__FieldTag::__documents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentQuerySource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for documents"));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __human_agent_side_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DialogflowQuerySource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "humanAgentSideConfig" => Ok(__FieldTag::__human_agent_side_config),
                            "human_agent_side_config" => Ok(__FieldTag::__human_agent_side_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DialogflowQuerySource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent"));
                            }
                            result.agent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__human_agent_side_config => {
                            if !fields.insert(__FieldTag::__human_agent_side_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for human_agent_side_config"));
                            }
                            result.human_agent_side_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentSideConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentSideConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent"));
                            }
                            result.agent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __drop_handoff_messages,
            __drop_virtual_agent_messages,
            __drop_ivr_messages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContextFilterSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dropHandoffMessages" => Ok(__FieldTag::__drop_handoff_messages),
                            "drop_handoff_messages" => Ok(__FieldTag::__drop_handoff_messages),
                            "dropVirtualAgentMessages" => Ok(__FieldTag::__drop_virtual_agent_messages),
                            "drop_virtual_agent_messages" => Ok(__FieldTag::__drop_virtual_agent_messages),
                            "dropIvrMessages" => Ok(__FieldTag::__drop_ivr_messages),
                            "drop_ivr_messages" => Ok(__FieldTag::__drop_ivr_messages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContextFilterSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__drop_handoff_messages => {
                            if !fields.insert(__FieldTag::__drop_handoff_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for drop_handoff_messages"));
                            }
                            result.drop_handoff_messages = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__drop_virtual_agent_messages => {
                            if !fields.insert(__FieldTag::__drop_virtual_agent_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for drop_virtual_agent_messages"));
                            }
                            result.drop_virtual_agent_messages = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__drop_ivr_messages => {
                            if !fields.insert(__FieldTag::__drop_ivr_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for drop_ivr_messages"));
                            }
                            result.drop_ivr_messages = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::suggestion_query_config::Sections {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __section_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sections")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sectionTypes" => Ok(__FieldTag::__section_types),
                            "section_types" => Ok(__FieldTag::__section_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::suggestion_query_config::Sections;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sections")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__section_types => {
                            if !fields.insert(__FieldTag::__section_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section_types"));
                            }
                            result.section_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::human_agent_assistant_config::suggestion_query_config::sections::SectionType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::ConversationModelConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __baseline_model_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationModelConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "baselineModelVersion" => Ok(__FieldTag::__baseline_model_version),
                            "baseline_model_version" => Ok(__FieldTag::__baseline_model_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::ConversationModelConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationModelConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for model"));
                            }
                            result.model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__baseline_model_version => {
                            if !fields.insert(__FieldTag::__baseline_model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for baseline_model_version"));
                            }
                            result.baseline_model_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::ConversationProcessConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recent_sentences_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationProcessConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recentSentencesCount" => Ok(__FieldTag::__recent_sentences_count),
                            "recent_sentences_count" => Ok(__FieldTag::__recent_sentences_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::ConversationProcessConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationProcessConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recent_sentences_count => {
                            if !fields.insert(__FieldTag::__recent_sentences_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for recent_sentences_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.recent_sentences_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_assistant_config::MessageAnalysisConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_entity_extraction,
            __enable_sentiment_analysis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageAnalysisConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableEntityExtraction" => Ok(__FieldTag::__enable_entity_extraction),
                            "enable_entity_extraction" => Ok(__FieldTag::__enable_entity_extraction),
                            "enableSentimentAnalysis" => Ok(__FieldTag::__enable_sentiment_analysis),
                            "enable_sentiment_analysis" => Ok(__FieldTag::__enable_sentiment_analysis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_assistant_config::MessageAnalysisConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageAnalysisConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_entity_extraction => {
                            if !fields.insert(__FieldTag::__enable_entity_extraction) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_entity_extraction"));
                            }
                            result.enable_entity_extraction = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_sentiment_analysis => {
                            if !fields.insert(__FieldTag::__enable_sentiment_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_sentiment_analysis"));
                            }
                            result.enable_sentiment_analysis = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HumanAgentHandoffConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __live_person_config,
            __salesforce_live_agent_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentHandoffConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "livePersonConfig" => Ok(__FieldTag::__live_person_config),
                            "live_person_config" => Ok(__FieldTag::__live_person_config),
                            "salesforceLiveAgentConfig" => Ok(__FieldTag::__salesforce_live_agent_config),
                            "salesforce_live_agent_config" => Ok(__FieldTag::__salesforce_live_agent_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HumanAgentHandoffConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentHandoffConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__live_person_config => {
                            if !fields.insert(__FieldTag::__live_person_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for live_person_config"));
                            }
                            if result.agent_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent_service`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentHandoffConfig.live_person_config, latest field was livePersonConfig",
                                ));
                            }
                            result.agent_service = std::option::Option::Some(
                                crate::model::human_agent_handoff_config::AgentService::LivePersonConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_handoff_config::LivePersonConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__salesforce_live_agent_config => {
                            if !fields.insert(__FieldTag::__salesforce_live_agent_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for salesforce_live_agent_config"));
                            }
                            if result.agent_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent_service`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentHandoffConfig.salesforce_live_agent_config, latest field was salesforceLiveAgentConfig",
                                ));
                            }
                            result.agent_service = std::option::Option::Some(
                                crate::model::human_agent_handoff_config::AgentService::SalesforceLiveAgentConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_handoff_config::LivePersonConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LivePersonConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountNumber" => Ok(__FieldTag::__account_number),
                            "account_number" => Ok(__FieldTag::__account_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_handoff_config::LivePersonConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LivePersonConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_number => {
                            if !fields.insert(__FieldTag::__account_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for account_number"));
                            }
                            result.account_number = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::human_agent_handoff_config::SalesforceLiveAgentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __organization_id,
            __deployment_id,
            __button_id,
            __endpoint_domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceLiveAgentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "organizationId" => Ok(__FieldTag::__organization_id),
                            "organization_id" => Ok(__FieldTag::__organization_id),
                            "deploymentId" => Ok(__FieldTag::__deployment_id),
                            "deployment_id" => Ok(__FieldTag::__deployment_id),
                            "buttonId" => Ok(__FieldTag::__button_id),
                            "button_id" => Ok(__FieldTag::__button_id),
                            "endpointDomain" => Ok(__FieldTag::__endpoint_domain),
                            "endpoint_domain" => Ok(__FieldTag::__endpoint_domain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::human_agent_handoff_config::SalesforceLiveAgentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceLiveAgentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__organization_id => {
                            if !fields.insert(__FieldTag::__organization_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for organization_id"));
                            }
                            result.organization_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__deployment_id => {
                            if !fields.insert(__FieldTag::__deployment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for deployment_id"));
                            }
                            result.deployment_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__button_id => {
                            if !fields.insert(__FieldTag::__button_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for button_id"));
                            }
                            result.button_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__endpoint_domain => {
                            if !fields.insert(__FieldTag::__endpoint_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for endpoint_domain"));
                            }
                            result.endpoint_domain = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            __message_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            "messageFormat" => Ok(__FieldTag::__message_format),
                            "message_format" => Ok(__FieldTag::__message_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for topic"));
                            }
                            result.topic = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_format => {
                            if !fields.insert(__FieldTag::__message_format) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_format"));
                            }
                            result.message_format = map.next_value::<std::option::Option<crate::model::notification_config::MessageFormat>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_stackdriver_logging,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableStackdriverLogging" => Ok(__FieldTag::__enable_stackdriver_logging),
                            "enable_stackdriver_logging" => Ok(__FieldTag::__enable_stackdriver_logging),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_stackdriver_logging => {
                            if !fields.insert(__FieldTag::__enable_stackdriver_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_stackdriver_logging"));
                            }
                            result.enable_stackdriver_logging = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestionFeature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionFeature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestionFeature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionFeature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetSuggestionFeatureConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetSuggestionFeatureConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureConfig" => Ok(__FieldTag::__suggestion_feature_config),
                            "suggestion_feature_config" => Ok(__FieldTag::__suggestion_feature_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetSuggestionFeatureConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetSuggestionFeatureConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant_role"));
                            }
                            result.participant_role = map.next_value::<std::option::Option<crate::model::participant::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_feature_config => {
                            if !fields.insert(__FieldTag::__suggestion_feature_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_feature_config"));
                            }
                            result.suggestion_feature_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ClearSuggestionFeatureConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClearSuggestionFeatureConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureType" => Ok(__FieldTag::__suggestion_feature_type),
                            "suggestion_feature_type" => Ok(__FieldTag::__suggestion_feature_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ClearSuggestionFeatureConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClearSuggestionFeatureConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant_role"));
                            }
                            result.participant_role = map.next_value::<std::option::Option<crate::model::participant::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_feature_type => {
                            if !fields.insert(__FieldTag::__suggestion_feature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_feature_type"));
                            }
                            result.suggestion_feature_type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetSuggestionFeatureConfigOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_type,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetSuggestionFeatureConfigOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureType" => Ok(__FieldTag::__suggestion_feature_type),
                            "suggestion_feature_type" => Ok(__FieldTag::__suggestion_feature_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetSuggestionFeatureConfigOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetSuggestionFeatureConfigOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant_role"));
                            }
                            result.participant_role = map.next_value::<std::option::Option<crate::model::participant::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_feature_type => {
                            if !fields.insert(__FieldTag::__suggestion_feature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_feature_type"));
                            }
                            result.suggestion_feature_type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ClearSuggestionFeatureConfigOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_type,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClearSuggestionFeatureConfigOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureType" => Ok(__FieldTag::__suggestion_feature_type),
                            "suggestion_feature_type" => Ok(__FieldTag::__suggestion_feature_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ClearSuggestionFeatureConfigOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClearSuggestionFeatureConfigOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_profile"));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant_role"));
                            }
                            result.participant_role = map.next_value::<std::option::Option<crate::model::participant::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_feature_type => {
                            if !fields.insert(__FieldTag::__suggestion_feature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_feature_type"));
                            }
                            result.suggestion_feature_type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Document {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __mime_type,
            __knowledge_types,
            __content_uri,
            __raw_content,
            __enable_auto_reload,
            __latest_reload_status,
            __metadata,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Document")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "knowledgeTypes" => Ok(__FieldTag::__knowledge_types),
                            "knowledge_types" => Ok(__FieldTag::__knowledge_types),
                            "contentUri" => Ok(__FieldTag::__content_uri),
                            "content_uri" => Ok(__FieldTag::__content_uri),
                            "rawContent" => Ok(__FieldTag::__raw_content),
                            "raw_content" => Ok(__FieldTag::__raw_content),
                            "enableAutoReload" => Ok(__FieldTag::__enable_auto_reload),
                            "enable_auto_reload" => Ok(__FieldTag::__enable_auto_reload),
                            "latestReloadStatus" => Ok(__FieldTag::__latest_reload_status),
                            "latest_reload_status" => Ok(__FieldTag::__latest_reload_status),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Document;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Document")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for mime_type"));
                            }
                            result.mime_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__knowledge_types => {
                            if !fields.insert(__FieldTag::__knowledge_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_types"));
                            }
                            result.knowledge_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::KnowledgeType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content_uri => {
                            if !fields.insert(__FieldTag::__content_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_uri"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.Document.content_uri, latest field was contentUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document::Source::ContentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__raw_content => {
                            if !fields.insert(__FieldTag::__raw_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for raw_content"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.Document.raw_content, latest field was rawContent",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document::Source::RawContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__enable_auto_reload => {
                            if !fields.insert(__FieldTag::__enable_auto_reload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_auto_reload"));
                            }
                            result.enable_auto_reload = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_reload_status => {
                            if !fields.insert(__FieldTag::__latest_reload_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_reload_status"));
                            }
                            result.latest_reload_status = map.next_value::<std::option::Option<crate::model::document::ReloadStatus>>()?
                                ;
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::document::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::document::ReloadStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReloadStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "time" => Ok(__FieldTag::__time),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::document::ReloadStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReloadStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time => {
                            if !fields.insert(__FieldTag::__time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time"));
                            }
                            result.time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status"));
                            }
                            result.status = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documents" => Ok(__FieldTag::__documents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for documents"));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Document>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "document" => Ok(__FieldTag::__document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for document"));
                            }
                            result.document = map.next_value::<std::option::Option<crate::model::Document>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __gcs_source,
            __document_template,
            __import_gcs_custom_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "documentTemplate" => Ok(__FieldTag::__document_template),
                            "document_template" => Ok(__FieldTag::__document_template),
                            "importGcsCustomMetadata" => Ok(__FieldTag::__import_gcs_custom_metadata),
                            "import_gcs_custom_metadata" => Ok(__FieldTag::__import_gcs_custom_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gcs_source"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.ImportDocumentsRequest.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_documents_request::Source::GcsSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsSources>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__document_template => {
                            if !fields.insert(__FieldTag::__document_template) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for document_template"));
                            }
                            result.document_template = map.next_value::<std::option::Option<crate::model::ImportDocumentTemplate>>()?
                                ;
                        },
                        __FieldTag::__import_gcs_custom_metadata => {
                            if !fields.insert(__FieldTag::__import_gcs_custom_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for import_gcs_custom_metadata"));
                            }
                            result.import_gcs_custom_metadata = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportDocumentTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mime_type,
            __knowledge_types,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "knowledgeTypes" => Ok(__FieldTag::__knowledge_types),
                            "knowledge_types" => Ok(__FieldTag::__knowledge_types),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportDocumentTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for mime_type"));
                            }
                            result.mime_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__knowledge_types => {
                            if !fields.insert(__FieldTag::__knowledge_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_types"));
                            }
                            result.knowledge_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::KnowledgeType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ImportDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ImportDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for warnings"));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for document"));
                            }
                            result.document = map.next_value::<std::option::Option<crate::model::Document>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReloadDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __content_uri,
            __import_gcs_custom_metadata,
            __smart_messaging_partial_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReloadDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "contentUri" => Ok(__FieldTag::__content_uri),
                            "content_uri" => Ok(__FieldTag::__content_uri),
                            "importGcsCustomMetadata" => Ok(__FieldTag::__import_gcs_custom_metadata),
                            "import_gcs_custom_metadata" => Ok(__FieldTag::__import_gcs_custom_metadata),
                            "smartMessagingPartialUpdate" => Ok(__FieldTag::__smart_messaging_partial_update),
                            "smart_messaging_partial_update" => Ok(__FieldTag::__smart_messaging_partial_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReloadDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReloadDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content_uri => {
                            if !fields.insert(__FieldTag::__content_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_uri"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.ReloadDocumentRequest.content_uri, latest field was contentUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::reload_document_request::Source::ContentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__import_gcs_custom_metadata => {
                            if !fields.insert(__FieldTag::__import_gcs_custom_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for import_gcs_custom_metadata"));
                            }
                            result.import_gcs_custom_metadata = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__smart_messaging_partial_update => {
                            if !fields.insert(__FieldTag::__smart_messaging_partial_update) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_messaging_partial_update"));
                            }
                            result.smart_messaging_partial_update = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExportDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __gcs_destination,
            __export_full_content,
            __smart_messaging_partial_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "exportFullContent" => Ok(__FieldTag::__export_full_content),
                            "export_full_content" => Ok(__FieldTag::__export_full_content),
                            "smartMessagingPartialUpdate" => Ok(__FieldTag::__smart_messaging_partial_update),
                            "smart_messaging_partial_update" => Ok(__FieldTag::__smart_messaging_partial_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExportDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gcs_destination"));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.v2.ExportDocumentRequest.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_document_request::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__export_full_content => {
                            if !fields.insert(__FieldTag::__export_full_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for export_full_content"));
                            }
                            result.export_full_content = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__smart_messaging_partial_update => {
                            if !fields.insert(__FieldTag::__smart_messaging_partial_update) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_messaging_partial_update"));
                            }
                            result.smart_messaging_partial_update = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExportOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __exported_gcs_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exportedGcsDestination" => Ok(__FieldTag::__exported_gcs_destination),
                            "exported_gcs_destination" => Ok(__FieldTag::__exported_gcs_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExportOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__exported_gcs_destination => {
                            if !fields.insert(__FieldTag::__exported_gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for exported_gcs_destination"));
                            }
                            result.exported_gcs_destination = map.next_value::<std::option::Option<crate::model::GcsDestination>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::KnowledgeOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __knowledge_base,
            __export_operation_metadata,
            __done_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "knowledgeBase" => Ok(__FieldTag::__knowledge_base),
                            "knowledge_base" => Ok(__FieldTag::__knowledge_base),
                            "exportOperationMetadata" => Ok(__FieldTag::__export_operation_metadata),
                            "export_operation_metadata" => Ok(__FieldTag::__export_operation_metadata),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::KnowledgeOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::knowledge_operation_metadata::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__knowledge_base => {
                            if !fields.insert(__FieldTag::__knowledge_base) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_base"));
                            }
                            result.knowledge_base = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__export_operation_metadata => {
                            if !fields.insert(__FieldTag::__export_operation_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for export_operation_metadata"));
                            }
                            if result.operation_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation_metadata`, a oneof with full ID .google.cloud.dialogflow.v2.KnowledgeOperationMetadata.export_operation_metadata, latest field was exportOperationMetadata",
                                ));
                            }
                            result.operation_metadata = std::option::Option::Some(
                                crate::model::knowledge_operation_metadata::OperationMetadata::ExportOperationMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ExportOperationMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done_time"));
                            }
                            result.done_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetEncryptionSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEncryptionSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetEncryptionSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEncryptionSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EncryptionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EncryptionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for kms_key"));
                            }
                            result.kms_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InitializeEncryptionSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionSpec" => Ok(__FieldTag::__encryption_spec),
                            "encryption_spec" => Ok(__FieldTag::__encryption_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InitializeEncryptionSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_spec => {
                            if !fields.insert(__FieldTag::__encryption_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for encryption_spec"));
                            }
                            result.encryption_spec = map.next_value::<std::option::Option<crate::model::EncryptionSpec>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InitializeEncryptionSpecResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InitializeEncryptionSpecResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InitializeEncryptionSpecMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InitializeEncryptionSpecMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request"));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::InitializeEncryptionSpecRequest>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "entity-types",feature = "participants",feature = "session-entity-types",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __kind,
            __auto_expansion_mode,
            __entities,
            __enable_fuzzy_extraction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "autoExpansionMode" => Ok(__FieldTag::__auto_expansion_mode),
                            "auto_expansion_mode" => Ok(__FieldTag::__auto_expansion_mode),
                            "entities" => Ok(__FieldTag::__entities),
                            "enableFuzzyExtraction" => Ok(__FieldTag::__enable_fuzzy_extraction),
                            "enable_fuzzy_extraction" => Ok(__FieldTag::__enable_fuzzy_extraction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EntityType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for kind"));
                            }
                            result.kind = map.next_value::<std::option::Option<crate::model::entity_type::Kind>>()?.unwrap_or_default();
                        },
                        __FieldTag::__auto_expansion_mode => {
                            if !fields.insert(__FieldTag::__auto_expansion_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for auto_expansion_mode"));
                            }
                            result.auto_expansion_mode = map.next_value::<std::option::Option<crate::model::entity_type::AutoExpansionMode>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entities"));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::entity_type::Entity>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_fuzzy_extraction => {
                            if !fields.insert(__FieldTag::__enable_fuzzy_extraction) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_fuzzy_extraction"));
                            }
                            result.enable_fuzzy_extraction = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "entity-types",feature = "participants",feature = "session-entity-types",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::entity_type::Entity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __synonyms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "synonyms" => Ok(__FieldTag::__synonyms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::entity_type::Entity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for value"));
                            }
                            result.value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__synonyms => {
                            if !fields.insert(__FieldTag::__synonyms) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for synonyms"));
                            }
                            result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_types"));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type"));
                            }
                            result.entity_type = map.next_value::<std::option::Option<crate::model::EntityType>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_type,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type"));
                            }
                            result.entity_type = map.next_value::<std::option::Option<crate::model::EntityType>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchUpdateEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type_batch_uri,
            __entity_type_batch_inline,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityTypeBatchUri" => Ok(__FieldTag::__entity_type_batch_uri),
                            "entity_type_batch_uri" => Ok(__FieldTag::__entity_type_batch_uri),
                            "entityTypeBatchInline" => Ok(__FieldTag::__entity_type_batch_inline),
                            "entity_type_batch_inline" => Ok(__FieldTag::__entity_type_batch_inline),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchUpdateEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_type_batch_uri => {
                            if !fields.insert(__FieldTag::__entity_type_batch_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type_batch_uri"));
                            }
                            if result.entity_type_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_type_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateEntityTypesRequest.entity_type_batch_uri, latest field was entityTypeBatchUri",
                                ));
                            }
                            result.entity_type_batch = std::option::Option::Some(
                                crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__entity_type_batch_inline => {
                            if !fields.insert(__FieldTag::__entity_type_batch_inline) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type_batch_inline"));
                            }
                            if result.entity_type_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_type_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateEntityTypesRequest.entity_type_batch_inline, latest field was entityTypeBatchInline",
                                ));
                            }
                            result.entity_type_batch = std::option::Option::Some(
                                crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchInline(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::EntityTypeBatch>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchUpdateEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchUpdateEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_types"));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchDeleteEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityTypeNames" => Ok(__FieldTag::__entity_type_names),
                            "entity_type_names" => Ok(__FieldTag::__entity_type_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchDeleteEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_type_names => {
                            if !fields.insert(__FieldTag::__entity_type_names) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type_names"));
                            }
                            result.entity_type_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchCreateEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entities,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entities" => Ok(__FieldTag::__entities),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchCreateEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entities"));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::entity_type::Entity>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchUpdateEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entities,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entities" => Ok(__FieldTag::__entities),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchUpdateEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entities"));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::entity_type::Entity>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchDeleteEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_values,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityValues" => Ok(__FieldTag::__entity_values),
                            "entity_values" => Ok(__FieldTag::__entity_values),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchDeleteEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_values => {
                            if !fields.insert(__FieldTag::__entity_values) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_values"));
                            }
                            result.entity_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EntityTypeBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityTypeBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EntityTypeBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityTypeBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_types"));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Environment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __agent_version,
            __state,
            __update_time,
            __text_to_speech_settings,
            __fulfillment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Environment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "agentVersion" => Ok(__FieldTag::__agent_version),
                            "agent_version" => Ok(__FieldTag::__agent_version),
                            "state" => Ok(__FieldTag::__state),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "textToSpeechSettings" => Ok(__FieldTag::__text_to_speech_settings),
                            "text_to_speech_settings" => Ok(__FieldTag::__text_to_speech_settings),
                            "fulfillment" => Ok(__FieldTag::__fulfillment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Environment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Environment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_version => {
                            if !fields.insert(__FieldTag::__agent_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_version"));
                            }
                            result.agent_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::environment::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__text_to_speech_settings => {
                            if !fields.insert(__FieldTag::__text_to_speech_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_to_speech_settings"));
                            }
                            result.text_to_speech_settings = map.next_value::<std::option::Option<crate::model::TextToSpeechSettings>>()?
                                ;
                        },
                        __FieldTag::__fulfillment => {
                            if !fields.insert(__FieldTag::__fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fulfillment"));
                            }
                            result.fulfillment = map.next_value::<std::option::Option<crate::model::Fulfillment>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TextToSpeechSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_text_to_speech,
            __output_audio_encoding,
            __sample_rate_hertz,
            __synthesize_speech_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextToSpeechSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableTextToSpeech" => Ok(__FieldTag::__enable_text_to_speech),
                            "enable_text_to_speech" => Ok(__FieldTag::__enable_text_to_speech),
                            "outputAudioEncoding" => Ok(__FieldTag::__output_audio_encoding),
                            "output_audio_encoding" => Ok(__FieldTag::__output_audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "synthesizeSpeechConfigs" => Ok(__FieldTag::__synthesize_speech_configs),
                            "synthesize_speech_configs" => Ok(__FieldTag::__synthesize_speech_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TextToSpeechSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextToSpeechSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_text_to_speech => {
                            if !fields.insert(__FieldTag::__enable_text_to_speech) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_text_to_speech"));
                            }
                            result.enable_text_to_speech = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__output_audio_encoding => {
                            if !fields.insert(__FieldTag::__output_audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_encoding"));
                            }
                            result.output_audio_encoding = map.next_value::<std::option::Option<crate::model::OutputAudioEncoding>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sample_rate_hertz"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__synthesize_speech_configs => {
                            if !fields.insert(__FieldTag::__synthesize_speech_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for synthesize_speech_configs"));
                            }
                            result.synthesize_speech_configs = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::SynthesizeSpeechConfig>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListEnvironmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListEnvironmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListEnvironmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environments" => Ok(__FieldTag::__environments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListEnvironmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environments => {
                            if !fields.insert(__FieldTag::__environments) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for environments"));
                            }
                            result.environments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Environment>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __environment,
            __environment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "environment" => Ok(__FieldTag::__environment),
                            "environmentId" => Ok(__FieldTag::__environment_id),
                            "environment_id" => Ok(__FieldTag::__environment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for environment"));
                            }
                            result.environment = map.next_value::<std::option::Option<crate::model::Environment>>()?
                                ;
                        },
                        __FieldTag::__environment_id => {
                            if !fields.insert(__FieldTag::__environment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for environment_id"));
                            }
                            result.environment_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __update_mask,
            __allow_load_to_draft_and_discard_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowLoadToDraftAndDiscardChanges" => Ok(__FieldTag::__allow_load_to_draft_and_discard_changes),
                            "allow_load_to_draft_and_discard_changes" => Ok(__FieldTag::__allow_load_to_draft_and_discard_changes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for environment"));
                            }
                            result.environment = map.next_value::<std::option::Option<crate::model::Environment>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__allow_load_to_draft_and_discard_changes => {
                            if !fields.insert(__FieldTag::__allow_load_to_draft_and_discard_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allow_load_to_draft_and_discard_changes"));
                            }
                            result.allow_load_to_draft_and_discard_changes = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetEnvironmentHistoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentHistoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetEnvironmentHistoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentHistoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EnvironmentHistory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvironmentHistory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entries" => Ok(__FieldTag::__entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EnvironmentHistory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvironmentHistory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entries"));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::environment_history::Entry>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::environment_history::Entry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_version,
            __description,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentVersion" => Ok(__FieldTag::__agent_version),
                            "agent_version" => Ok(__FieldTag::__agent_version),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::environment_history::Entry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_version => {
                            if !fields.insert(__FieldTag::__agent_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_version"));
                            }
                            result.agent_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "environments",feature = "fulfillments", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Fulfillment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __generic_web_service,
            __enabled,
            __features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fulfillment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "genericWebService" => Ok(__FieldTag::__generic_web_service),
                            "generic_web_service" => Ok(__FieldTag::__generic_web_service),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "features" => Ok(__FieldTag::__features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Fulfillment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fulfillment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generic_web_service => {
                            if !fields.insert(__FieldTag::__generic_web_service) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generic_web_service"));
                            }
                            if result.fulfillment.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `fulfillment`, a oneof with full ID .google.cloud.dialogflow.v2.Fulfillment.generic_web_service, latest field was genericWebService",
                                ));
                            }
                            result.fulfillment = std::option::Option::Some(
                                crate::model::fulfillment::Fulfillment::GenericWebService(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::fulfillment::GenericWebService>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enabled"));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for features"));
                            }
                            result.features = map.next_value::<std::option::Option<std::vec::Vec<crate::model::fulfillment::Feature>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "environments",feature = "fulfillments", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::fulfillment::GenericWebService {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __username,
            __password,
            __request_headers,
            __is_cloud_function,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenericWebService")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "requestHeaders" => Ok(__FieldTag::__request_headers),
                            "request_headers" => Ok(__FieldTag::__request_headers),
                            "isCloudFunction" => Ok(__FieldTag::__is_cloud_function),
                            "is_cloud_function" => Ok(__FieldTag::__is_cloud_function),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::fulfillment::GenericWebService;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenericWebService")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for username"));
                            }
                            result.username = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for password"));
                            }
                            result.password = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__request_headers => {
                            if !fields.insert(__FieldTag::__request_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_headers"));
                            }
                            result.request_headers = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_cloud_function => {
                            if !fields.insert(__FieldTag::__is_cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_cloud_function"));
                            }
                            result.is_cloud_function = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "environments",feature = "fulfillments", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::fulfillment::Feature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Feature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::fulfillment::Feature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Feature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::fulfillment::feature::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "fulfillments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetFulfillmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFulfillmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetFulfillmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFulfillmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "fulfillments" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateFulfillmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fulfillment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFulfillmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fulfillment" => Ok(__FieldTag::__fulfillment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateFulfillmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFulfillmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fulfillment => {
                            if !fields.insert(__FieldTag::__fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fulfillment"));
                            }
                            result.fulfillment = map.next_value::<std::option::Option<crate::model::Fulfillment>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-datasets",feature = "documents", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsSources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uris" => Ok(__FieldTag::__uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsSources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uris => {
                            if !fields.insert(__FieldTag::__uris) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uris"));
                            }
                            result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __generator,
            __generator_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "generator" => Ok(__FieldTag::__generator),
                            "generatorId" => Ok(__FieldTag::__generator_id),
                            "generator_id" => Ok(__FieldTag::__generator_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator"));
                            }
                            result.generator = map.next_value::<std::option::Option<crate::model::Generator>>()?
                                ;
                        },
                        __FieldTag::__generator_id => {
                            if !fields.insert(__FieldTag::__generator_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_id"));
                            }
                            result.generator_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListGeneratorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListGeneratorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListGeneratorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generators,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generators" => Ok(__FieldTag::__generators),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListGeneratorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generators => {
                            if !fields.insert(__FieldTag::__generators) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generators"));
                            }
                            result.generators = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Generator>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generator" => Ok(__FieldTag::__generator),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator"));
                            }
                            result.generator = map.next_value::<std::option::Option<crate::model::Generator>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __text,
            __language_code,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "text" => Ok(__FieldTag::__text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for role"));
                            }
                            result.role = map.next_value::<std::option::Option<crate::model::message_entry::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConversationContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageEntries" => Ok(__FieldTag::__message_entries),
                            "message_entries" => Ok(__FieldTag::__message_entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConversationContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_entries => {
                            if !fields.insert(__FieldTag::__message_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_entries"));
                            }
                            result.message_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageEntry>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SummarizationSectionList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summarization_sections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationSectionList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarizationSections" => Ok(__FieldTag::__summarization_sections),
                            "summarization_sections" => Ok(__FieldTag::__summarization_sections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SummarizationSectionList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationSectionList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summarization_sections => {
                            if !fields.insert(__FieldTag::__summarization_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_sections"));
                            }
                            result.summarization_sections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SummarizationSection>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FewShotExample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_context,
            __extra_info,
            __summarization_section_list,
            __output,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FewShotExample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationContext" => Ok(__FieldTag::__conversation_context),
                            "conversation_context" => Ok(__FieldTag::__conversation_context),
                            "extraInfo" => Ok(__FieldTag::__extra_info),
                            "extra_info" => Ok(__FieldTag::__extra_info),
                            "summarizationSectionList" => Ok(__FieldTag::__summarization_section_list),
                            "summarization_section_list" => Ok(__FieldTag::__summarization_section_list),
                            "output" => Ok(__FieldTag::__output),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FewShotExample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FewShotExample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_context => {
                            if !fields.insert(__FieldTag::__conversation_context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_context"));
                            }
                            result.conversation_context = map.next_value::<std::option::Option<crate::model::ConversationContext>>()?
                                ;
                        },
                        __FieldTag::__extra_info => {
                            if !fields.insert(__FieldTag::__extra_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for extra_info"));
                            }
                            result.extra_info = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summarization_section_list => {
                            if !fields.insert(__FieldTag::__summarization_section_list) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_section_list"));
                            }
                            if result.instruction_list.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `instruction_list`, a oneof with full ID .google.cloud.dialogflow.v2.FewShotExample.summarization_section_list, latest field was summarizationSectionList",
                                ));
                            }
                            result.instruction_list = std::option::Option::Some(
                                crate::model::few_shot_example::InstructionList::SummarizationSectionList(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SummarizationSectionList>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__output => {
                            if !fields.insert(__FieldTag::__output) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output"));
                            }
                            result.output = map.next_value::<std::option::Option<crate::model::GeneratorSuggestion>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InferenceParameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_output_tokens,
            __temperature,
            __top_k,
            __top_p,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InferenceParameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxOutputTokens" => Ok(__FieldTag::__max_output_tokens),
                            "max_output_tokens" => Ok(__FieldTag::__max_output_tokens),
                            "temperature" => Ok(__FieldTag::__temperature),
                            "topK" => Ok(__FieldTag::__top_k),
                            "top_k" => Ok(__FieldTag::__top_k),
                            "topP" => Ok(__FieldTag::__top_p),
                            "top_p" => Ok(__FieldTag::__top_p),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InferenceParameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InferenceParameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_output_tokens => {
                            if !fields.insert(__FieldTag::__max_output_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_output_tokens"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_output_tokens = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__temperature => {
                            if !fields.insert(__FieldTag::__temperature) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for temperature"));
                            }
                            struct __With( std::option::Option<f64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.temperature = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__top_k => {
                            if !fields.insert(__FieldTag::__top_k) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for top_k"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.top_k = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__top_p => {
                            if !fields.insert(__FieldTag::__top_p) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for top_p"));
                            }
                            struct __With( std::option::Option<f64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.top_p = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AgentCoachingContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __overarching_guidance,
            __instructions,
            __version,
            __output_language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentCoachingContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "overarchingGuidance" => Ok(__FieldTag::__overarching_guidance),
                            "overarching_guidance" => Ok(__FieldTag::__overarching_guidance),
                            "instructions" => Ok(__FieldTag::__instructions),
                            "version" => Ok(__FieldTag::__version),
                            "outputLanguageCode" => Ok(__FieldTag::__output_language_code),
                            "output_language_code" => Ok(__FieldTag::__output_language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AgentCoachingContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentCoachingContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__overarching_guidance => {
                            if !fields.insert(__FieldTag::__overarching_guidance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for overarching_guidance"));
                            }
                            result.overarching_guidance = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__instructions => {
                            if !fields.insert(__FieldTag::__instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instructions"));
                            }
                            result.instructions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AgentCoachingInstruction>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version"));
                            }
                            result.version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__output_language_code => {
                            if !fields.insert(__FieldTag::__output_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_language_code"));
                            }
                            result.output_language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SummarizationSection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __definition,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationSection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "definition" => Ok(__FieldTag::__definition),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SummarizationSection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationSection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for key"));
                            }
                            result.key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__definition => {
                            if !fields.insert(__FieldTag::__definition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for definition"));
                            }
                            result.definition = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::summarization_section::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SummarizationContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summarization_sections,
            __few_shot_examples,
            __version,
            __output_language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarizationSections" => Ok(__FieldTag::__summarization_sections),
                            "summarization_sections" => Ok(__FieldTag::__summarization_sections),
                            "fewShotExamples" => Ok(__FieldTag::__few_shot_examples),
                            "few_shot_examples" => Ok(__FieldTag::__few_shot_examples),
                            "version" => Ok(__FieldTag::__version),
                            "outputLanguageCode" => Ok(__FieldTag::__output_language_code),
                            "output_language_code" => Ok(__FieldTag::__output_language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SummarizationContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summarization_sections => {
                            if !fields.insert(__FieldTag::__summarization_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_sections"));
                            }
                            result.summarization_sections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SummarizationSection>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__few_shot_examples => {
                            if !fields.insert(__FieldTag::__few_shot_examples) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for few_shot_examples"));
                            }
                            result.few_shot_examples = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FewShotExample>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version"));
                            }
                            result.version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__output_language_code => {
                            if !fields.insert(__FieldTag::__output_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_language_code"));
                            }
                            result.output_language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FreeFormContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FreeFormContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FreeFormContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FreeFormContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Generator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __free_form_context,
            __agent_coaching_context,
            __summarization_context,
            __inference_parameter,
            __trigger_event,
            __published_model,
            __create_time,
            __update_time,
            __tools,
            __suggestion_deduping_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Generator")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "freeFormContext" => Ok(__FieldTag::__free_form_context),
                            "free_form_context" => Ok(__FieldTag::__free_form_context),
                            "agentCoachingContext" => Ok(__FieldTag::__agent_coaching_context),
                            "agent_coaching_context" => Ok(__FieldTag::__agent_coaching_context),
                            "summarizationContext" => Ok(__FieldTag::__summarization_context),
                            "summarization_context" => Ok(__FieldTag::__summarization_context),
                            "inferenceParameter" => Ok(__FieldTag::__inference_parameter),
                            "inference_parameter" => Ok(__FieldTag::__inference_parameter),
                            "triggerEvent" => Ok(__FieldTag::__trigger_event),
                            "trigger_event" => Ok(__FieldTag::__trigger_event),
                            "publishedModel" => Ok(__FieldTag::__published_model),
                            "published_model" => Ok(__FieldTag::__published_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "tools" => Ok(__FieldTag::__tools),
                            "suggestionDedupingConfig" => Ok(__FieldTag::__suggestion_deduping_config),
                            "suggestion_deduping_config" => Ok(__FieldTag::__suggestion_deduping_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Generator;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Generator")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__free_form_context => {
                            if !fields.insert(__FieldTag::__free_form_context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for free_form_context"));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.free_form_context, latest field was freeFormContext",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::generator::Context::FreeFormContext(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FreeFormContext>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__agent_coaching_context => {
                            if !fields.insert(__FieldTag::__agent_coaching_context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_coaching_context"));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.agent_coaching_context, latest field was agentCoachingContext",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::generator::Context::AgentCoachingContext(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AgentCoachingContext>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__summarization_context => {
                            if !fields.insert(__FieldTag::__summarization_context) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_context"));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.summarization_context, latest field was summarizationContext",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::generator::Context::SummarizationContext(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SummarizationContext>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__inference_parameter => {
                            if !fields.insert(__FieldTag::__inference_parameter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inference_parameter"));
                            }
                            result.inference_parameter = map.next_value::<std::option::Option<crate::model::InferenceParameter>>()?
                                ;
                        },
                        __FieldTag::__trigger_event => {
                            if !fields.insert(__FieldTag::__trigger_event) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for trigger_event"));
                            }
                            result.trigger_event = map.next_value::<std::option::Option<crate::model::TriggerEvent>>()?.unwrap_or_default();
                        },
                        __FieldTag::__published_model => {
                            if !fields.insert(__FieldTag::__published_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for published_model"));
                            }
                            if result.foundation_model.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `foundation_model`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.published_model, latest field was publishedModel",
                                ));
                            }
                            result.foundation_model = std::option::Option::Some(
                                crate::model::generator::FoundationModel::PublishedModel(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__tools => {
                            if !fields.insert(__FieldTag::__tools) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tools"));
                            }
                            result.tools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_deduping_config => {
                            if !fields.insert(__FieldTag::__suggestion_deduping_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_deduping_config"));
                            }
                            result.suggestion_deduping_config = map.next_value::<std::option::Option<crate::model::SuggestionDedupingConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FreeFormSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FreeFormSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "response" => Ok(__FieldTag::__response),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FreeFormSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FreeFormSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response => {
                            if !fields.insert(__FieldTag::__response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response"));
                            }
                            result.response = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SummarySuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary_sections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarySuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarySections" => Ok(__FieldTag::__summary_sections),
                            "summary_sections" => Ok(__FieldTag::__summary_sections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SummarySuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarySuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary_sections => {
                            if !fields.insert(__FieldTag::__summary_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary_sections"));
                            }
                            result.summary_sections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summary_suggestion::SummarySection>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summary_suggestion::SummarySection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __section,
            __summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarySection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "section" => Ok(__FieldTag::__section),
                            "summary" => Ok(__FieldTag::__summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summary_suggestion::SummarySection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarySection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__section => {
                            if !fields.insert(__FieldTag::__section) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section"));
                            }
                            result.section = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary"));
                            }
                            result.summary = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AgentCoachingSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __applicable_instructions,
            __agent_action_suggestions,
            __sample_responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentCoachingSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "applicableInstructions" => Ok(__FieldTag::__applicable_instructions),
                            "applicable_instructions" => Ok(__FieldTag::__applicable_instructions),
                            "agentActionSuggestions" => Ok(__FieldTag::__agent_action_suggestions),
                            "agent_action_suggestions" => Ok(__FieldTag::__agent_action_suggestions),
                            "sampleResponses" => Ok(__FieldTag::__sample_responses),
                            "sample_responses" => Ok(__FieldTag::__sample_responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AgentCoachingSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentCoachingSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__applicable_instructions => {
                            if !fields.insert(__FieldTag::__applicable_instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for applicable_instructions"));
                            }
                            result.applicable_instructions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AgentCoachingInstruction>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_action_suggestions => {
                            if !fields.insert(__FieldTag::__agent_action_suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_action_suggestions"));
                            }
                            result.agent_action_suggestions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::agent_coaching_suggestion::AgentActionSuggestion>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sample_responses => {
                            if !fields.insert(__FieldTag::__sample_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sample_responses"));
                            }
                            result.sample_responses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::agent_coaching_suggestion::SampleResponse>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_suggestion::Sources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instruction_indexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instructionIndexes" => Ok(__FieldTag::__instruction_indexes),
                            "instruction_indexes" => Ok(__FieldTag::__instruction_indexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_suggestion::Sources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instruction_indexes => {
                            if !fields.insert(__FieldTag::__instruction_indexes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instruction_indexes"));
                            }
                            struct __With( std::option::Option<std::vec::Vec<i32>> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<std::vec::Vec<wkt::internal::I32>> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.instruction_indexes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_suggestion::DuplicateCheckResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __duplicate_suggestions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DuplicateCheckResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "duplicateSuggestions" => Ok(__FieldTag::__duplicate_suggestions),
                            "duplicate_suggestions" => Ok(__FieldTag::__duplicate_suggestions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_suggestion::DuplicateCheckResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DuplicateCheckResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__duplicate_suggestions => {
                            if !fields.insert(__FieldTag::__duplicate_suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for duplicate_suggestions"));
                            }
                            result.duplicate_suggestions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::agent_coaching_suggestion::duplicate_check_result::DuplicateSuggestion>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_suggestion::duplicate_check_result::DuplicateSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_record,
            __sources,
            __suggestion_index,
            __similarity_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DuplicateSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "sources" => Ok(__FieldTag::__sources),
                            "suggestionIndex" => Ok(__FieldTag::__suggestion_index),
                            "suggestion_index" => Ok(__FieldTag::__suggestion_index),
                            "similarityScore" => Ok(__FieldTag::__similarity_score),
                            "similarity_score" => Ok(__FieldTag::__similarity_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_suggestion::duplicate_check_result::DuplicateSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DuplicateSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sources"));
                            }
                            result.sources = map.next_value::<std::option::Option<crate::model::agent_coaching_suggestion::Sources>>()?
                                ;
                        },
                        __FieldTag::__suggestion_index => {
                            if !fields.insert(__FieldTag::__suggestion_index) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_index"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.suggestion_index = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__similarity_score => {
                            if !fields.insert(__FieldTag::__similarity_score) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for similarity_score"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.similarity_score = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_suggestion::AgentActionSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_action,
            __sources,
            __duplicate_check_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentActionSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentAction" => Ok(__FieldTag::__agent_action),
                            "agent_action" => Ok(__FieldTag::__agent_action),
                            "sources" => Ok(__FieldTag::__sources),
                            "duplicateCheckResult" => Ok(__FieldTag::__duplicate_check_result),
                            "duplicate_check_result" => Ok(__FieldTag::__duplicate_check_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_suggestion::AgentActionSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentActionSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_action => {
                            if !fields.insert(__FieldTag::__agent_action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_action"));
                            }
                            result.agent_action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sources"));
                            }
                            result.sources = map.next_value::<std::option::Option<crate::model::agent_coaching_suggestion::Sources>>()?
                                ;
                        },
                        __FieldTag::__duplicate_check_result => {
                            if !fields.insert(__FieldTag::__duplicate_check_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for duplicate_check_result"));
                            }
                            result.duplicate_check_result = map.next_value::<std::option::Option<crate::model::agent_coaching_suggestion::DuplicateCheckResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::agent_coaching_suggestion::SampleResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_text,
            __sources,
            __duplicate_check_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SampleResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseText" => Ok(__FieldTag::__response_text),
                            "response_text" => Ok(__FieldTag::__response_text),
                            "sources" => Ok(__FieldTag::__sources),
                            "duplicateCheckResult" => Ok(__FieldTag::__duplicate_check_result),
                            "duplicate_check_result" => Ok(__FieldTag::__duplicate_check_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::agent_coaching_suggestion::SampleResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SampleResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_text => {
                            if !fields.insert(__FieldTag::__response_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response_text"));
                            }
                            result.response_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sources"));
                            }
                            result.sources = map.next_value::<std::option::Option<crate::model::agent_coaching_suggestion::Sources>>()?
                                ;
                        },
                        __FieldTag::__duplicate_check_result => {
                            if !fields.insert(__FieldTag::__duplicate_check_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for duplicate_check_result"));
                            }
                            result.duplicate_check_result = map.next_value::<std::option::Option<crate::model::agent_coaching_suggestion::DuplicateCheckResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GeneratorSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __free_form_suggestion,
            __summary_suggestion,
            __agent_coaching_suggestion,
            __tool_call_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeneratorSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "freeFormSuggestion" => Ok(__FieldTag::__free_form_suggestion),
                            "free_form_suggestion" => Ok(__FieldTag::__free_form_suggestion),
                            "summarySuggestion" => Ok(__FieldTag::__summary_suggestion),
                            "summary_suggestion" => Ok(__FieldTag::__summary_suggestion),
                            "agentCoachingSuggestion" => Ok(__FieldTag::__agent_coaching_suggestion),
                            "agent_coaching_suggestion" => Ok(__FieldTag::__agent_coaching_suggestion),
                            "toolCallInfo" => Ok(__FieldTag::__tool_call_info),
                            "tool_call_info" => Ok(__FieldTag::__tool_call_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GeneratorSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeneratorSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__free_form_suggestion => {
                            if !fields.insert(__FieldTag::__free_form_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for free_form_suggestion"));
                            }
                            if result.suggestion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorSuggestion.free_form_suggestion, latest field was freeFormSuggestion",
                                ));
                            }
                            result.suggestion = std::option::Option::Some(
                                crate::model::generator_suggestion::Suggestion::FreeFormSuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FreeFormSuggestion>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__summary_suggestion => {
                            if !fields.insert(__FieldTag::__summary_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary_suggestion"));
                            }
                            if result.suggestion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorSuggestion.summary_suggestion, latest field was summarySuggestion",
                                ));
                            }
                            result.suggestion = std::option::Option::Some(
                                crate::model::generator_suggestion::Suggestion::SummarySuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SummarySuggestion>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__agent_coaching_suggestion => {
                            if !fields.insert(__FieldTag::__agent_coaching_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_coaching_suggestion"));
                            }
                            if result.suggestion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorSuggestion.agent_coaching_suggestion, latest field was agentCoachingSuggestion",
                                ));
                            }
                            result.suggestion = std::option::Option::Some(
                                crate::model::generator_suggestion::Suggestion::AgentCoachingSuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AgentCoachingSuggestion>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__tool_call_info => {
                            if !fields.insert(__FieldTag::__tool_call_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_call_info"));
                            }
                            result.tool_call_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::generator_suggestion::ToolCallInfo>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generator_suggestion::ToolCallInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tool_call,
            __tool_call_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ToolCallInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "toolCall" => Ok(__FieldTag::__tool_call),
                            "tool_call" => Ok(__FieldTag::__tool_call),
                            "toolCallResult" => Ok(__FieldTag::__tool_call_result),
                            "tool_call_result" => Ok(__FieldTag::__tool_call_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generator_suggestion::ToolCallInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ToolCallInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tool_call => {
                            if !fields.insert(__FieldTag::__tool_call) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_call"));
                            }
                            result.tool_call = map.next_value::<std::option::Option<crate::model::ToolCall>>()?
                                ;
                        },
                        __FieldTag::__tool_call_result => {
                            if !fields.insert(__FieldTag::__tool_call_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_call_result"));
                            }
                            result.tool_call_result = map.next_value::<std::option::Option<crate::model::ToolCallResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "generator-evaluations",feature = "generators", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestionDedupingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_deduping,
            __similarity_threshold,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionDedupingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableDeduping" => Ok(__FieldTag::__enable_deduping),
                            "enable_deduping" => Ok(__FieldTag::__enable_deduping),
                            "similarityThreshold" => Ok(__FieldTag::__similarity_threshold),
                            "similarity_threshold" => Ok(__FieldTag::__similarity_threshold),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestionDedupingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionDedupingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_deduping => {
                            if !fields.insert(__FieldTag::__enable_deduping) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_deduping"));
                            }
                            result.enable_deduping = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__similarity_threshold => {
                            if !fields.insert(__FieldTag::__similarity_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for similarity_threshold"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.similarity_threshold = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RaiSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rai_category_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "raiCategoryConfigs" => Ok(__FieldTag::__rai_category_configs),
                            "rai_category_configs" => Ok(__FieldTag::__rai_category_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RaiSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rai_category_configs => {
                            if !fields.insert(__FieldTag::__rai_category_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rai_category_configs"));
                            }
                            result.rai_category_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::rai_settings::RaiCategoryConfig>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::rai_settings::RaiCategoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __category,
            __sensitivity_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RaiCategoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "category" => Ok(__FieldTag::__category),
                            "sensitivityLevel" => Ok(__FieldTag::__sensitivity_level),
                            "sensitivity_level" => Ok(__FieldTag::__sensitivity_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::rai_settings::RaiCategoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RaiCategoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for category"));
                            }
                            result.category = map.next_value::<std::option::Option<crate::model::rai_settings::rai_category_config::RaiCategory>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sensitivity_level => {
                            if !fields.insert(__FieldTag::__sensitivity_level) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sensitivity_level"));
                            }
                            result.sensitivity_level = map.next_value::<std::option::Option<crate::model::rai_settings::rai_category_config::SensitivityLevel>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateGeneratorEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __generator_evaluation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGeneratorEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "generatorEvaluation" => Ok(__FieldTag::__generator_evaluation),
                            "generator_evaluation" => Ok(__FieldTag::__generator_evaluation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateGeneratorEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGeneratorEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generator_evaluation => {
                            if !fields.insert(__FieldTag::__generator_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_evaluation"));
                            }
                            result.generator_evaluation = map.next_value::<std::option::Option<crate::model::GeneratorEvaluation>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetGeneratorEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGeneratorEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetGeneratorEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGeneratorEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListGeneratorEvaluationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorEvaluationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListGeneratorEvaluationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorEvaluationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListGeneratorEvaluationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_evaluations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorEvaluationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorEvaluations" => Ok(__FieldTag::__generator_evaluations),
                            "generator_evaluations" => Ok(__FieldTag::__generator_evaluations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListGeneratorEvaluationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorEvaluationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_evaluations => {
                            if !fields.insert(__FieldTag::__generator_evaluations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_evaluations"));
                            }
                            result.generator_evaluations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GeneratorEvaluation>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteGeneratorEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGeneratorEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteGeneratorEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGeneratorEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GeneratorEvaluation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __generator_evaluation_config,
            __create_time,
            __complete_time,
            __initial_generator,
            __summarization_metrics,
            __evaluation_status,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeneratorEvaluation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "generatorEvaluationConfig" => Ok(__FieldTag::__generator_evaluation_config),
                            "generator_evaluation_config" => Ok(__FieldTag::__generator_evaluation_config),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            "initialGenerator" => Ok(__FieldTag::__initial_generator),
                            "initial_generator" => Ok(__FieldTag::__initial_generator),
                            "summarizationMetrics" => Ok(__FieldTag::__summarization_metrics),
                            "summarization_metrics" => Ok(__FieldTag::__summarization_metrics),
                            "evaluationStatus" => Ok(__FieldTag::__evaluation_status),
                            "evaluation_status" => Ok(__FieldTag::__evaluation_status),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GeneratorEvaluation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeneratorEvaluation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generator_evaluation_config => {
                            if !fields.insert(__FieldTag::__generator_evaluation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_evaluation_config"));
                            }
                            result.generator_evaluation_config = map.next_value::<std::option::Option<crate::model::GeneratorEvaluationConfig>>()?
                                ;
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for complete_time"));
                            }
                            result.complete_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__initial_generator => {
                            if !fields.insert(__FieldTag::__initial_generator) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for initial_generator"));
                            }
                            result.initial_generator = map.next_value::<std::option::Option<crate::model::Generator>>()?
                                ;
                        },
                        __FieldTag::__summarization_metrics => {
                            if !fields.insert(__FieldTag::__summarization_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_metrics"));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorEvaluation.summarization_metrics, latest field was summarizationMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::generator_evaluation::Metrics::SummarizationMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SummarizationEvaluationMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__evaluation_status => {
                            if !fields.insert(__FieldTag::__evaluation_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for evaluation_status"));
                            }
                            result.evaluation_status = map.next_value::<std::option::Option<crate::model::EvaluationStatus>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzs"));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzi"));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SummarizationEvaluationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summarization_evaluation_results,
            __summarization_evaluation_merged_results_uri,
            __overall_metrics,
            __overall_section_tokens,
            __conversation_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationEvaluationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarizationEvaluationResults" => Ok(__FieldTag::__summarization_evaluation_results),
                            "summarization_evaluation_results" => Ok(__FieldTag::__summarization_evaluation_results),
                            "summarizationEvaluationMergedResultsUri" => Ok(__FieldTag::__summarization_evaluation_merged_results_uri),
                            "summarization_evaluation_merged_results_uri" => Ok(__FieldTag::__summarization_evaluation_merged_results_uri),
                            "overallMetrics" => Ok(__FieldTag::__overall_metrics),
                            "overall_metrics" => Ok(__FieldTag::__overall_metrics),
                            "overallSectionTokens" => Ok(__FieldTag::__overall_section_tokens),
                            "overall_section_tokens" => Ok(__FieldTag::__overall_section_tokens),
                            "conversationDetails" => Ok(__FieldTag::__conversation_details),
                            "conversation_details" => Ok(__FieldTag::__conversation_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SummarizationEvaluationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationEvaluationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summarization_evaluation_results => {
                            if !fields.insert(__FieldTag::__summarization_evaluation_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_evaluation_results"));
                            }
                            result.summarization_evaluation_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::SummarizationEvaluationResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summarization_evaluation_merged_results_uri => {
                            if !fields.insert(__FieldTag::__summarization_evaluation_merged_results_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_evaluation_merged_results_uri"));
                            }
                            result.summarization_evaluation_merged_results_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__overall_metrics => {
                            if !fields.insert(__FieldTag::__overall_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for overall_metrics"));
                            }
                            result.overall_metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::OverallScoresByMetric>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__overall_section_tokens => {
                            if !fields.insert(__FieldTag::__overall_section_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for overall_section_tokens"));
                            }
                            result.overall_section_tokens = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::SectionToken>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__conversation_details => {
                            if !fields.insert(__FieldTag::__conversation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation_details"));
                            }
                            result.conversation_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::ConversationDetail>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::AccuracyDecomposition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __point,
            __accuracy_reasoning,
            __is_accurate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccuracyDecomposition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "point" => Ok(__FieldTag::__point),
                            "accuracyReasoning" => Ok(__FieldTag::__accuracy_reasoning),
                            "accuracy_reasoning" => Ok(__FieldTag::__accuracy_reasoning),
                            "isAccurate" => Ok(__FieldTag::__is_accurate),
                            "is_accurate" => Ok(__FieldTag::__is_accurate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::AccuracyDecomposition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccuracyDecomposition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__point => {
                            if !fields.insert(__FieldTag::__point) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for point"));
                            }
                            result.point = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__accuracy_reasoning => {
                            if !fields.insert(__FieldTag::__accuracy_reasoning) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for accuracy_reasoning"));
                            }
                            result.accuracy_reasoning = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_accurate => {
                            if !fields.insert(__FieldTag::__is_accurate) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_accurate"));
                            }
                            result.is_accurate = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::AdherenceDecomposition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __point,
            __adherence_reasoning,
            __is_adherent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdherenceDecomposition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "point" => Ok(__FieldTag::__point),
                            "adherenceReasoning" => Ok(__FieldTag::__adherence_reasoning),
                            "adherence_reasoning" => Ok(__FieldTag::__adherence_reasoning),
                            "isAdherent" => Ok(__FieldTag::__is_adherent),
                            "is_adherent" => Ok(__FieldTag::__is_adherent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::AdherenceDecomposition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdherenceDecomposition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__point => {
                            if !fields.insert(__FieldTag::__point) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for point"));
                            }
                            result.point = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__adherence_reasoning => {
                            if !fields.insert(__FieldTag::__adherence_reasoning) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for adherence_reasoning"));
                            }
                            result.adherence_reasoning = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_adherent => {
                            if !fields.insert(__FieldTag::__is_adherent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_adherent"));
                            }
                            result.is_adherent = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::AdherenceRubric {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __question,
            __reasoning,
            __is_addressed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdherenceRubric")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "question" => Ok(__FieldTag::__question),
                            "reasoning" => Ok(__FieldTag::__reasoning),
                            "isAddressed" => Ok(__FieldTag::__is_addressed),
                            "is_addressed" => Ok(__FieldTag::__is_addressed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::AdherenceRubric;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdherenceRubric")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__question => {
                            if !fields.insert(__FieldTag::__question) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for question"));
                            }
                            result.question = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__reasoning => {
                            if !fields.insert(__FieldTag::__reasoning) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reasoning"));
                            }
                            result.reasoning = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_addressed => {
                            if !fields.insert(__FieldTag::__is_addressed) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_addressed"));
                            }
                            result.is_addressed = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::CompletenessRubric {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __question,
            __is_addressed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompletenessRubric")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "question" => Ok(__FieldTag::__question),
                            "isAddressed" => Ok(__FieldTag::__is_addressed),
                            "is_addressed" => Ok(__FieldTag::__is_addressed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::CompletenessRubric;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompletenessRubric")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__question => {
                            if !fields.insert(__FieldTag::__question) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for question"));
                            }
                            result.question = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_addressed => {
                            if !fields.insert(__FieldTag::__is_addressed) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_addressed"));
                            }
                            result.is_addressed = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::Decomposition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accuracy_decomposition,
            __adherence_decomposition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Decomposition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accuracyDecomposition" => Ok(__FieldTag::__accuracy_decomposition),
                            "accuracy_decomposition" => Ok(__FieldTag::__accuracy_decomposition),
                            "adherenceDecomposition" => Ok(__FieldTag::__adherence_decomposition),
                            "adherence_decomposition" => Ok(__FieldTag::__adherence_decomposition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::Decomposition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Decomposition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accuracy_decomposition => {
                            if !fields.insert(__FieldTag::__accuracy_decomposition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for accuracy_decomposition"));
                            }
                            if result.decomposition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decomposition`, a oneof with full ID .google.cloud.dialogflow.v2.SummarizationEvaluationMetrics.Decomposition.accuracy_decomposition, latest field was accuracyDecomposition",
                                ));
                            }
                            result.decomposition = std::option::Option::Some(
                                crate::model::summarization_evaluation_metrics::decomposition::Decomposition::AccuracyDecomposition(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::summarization_evaluation_metrics::AccuracyDecomposition>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__adherence_decomposition => {
                            if !fields.insert(__FieldTag::__adherence_decomposition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for adherence_decomposition"));
                            }
                            if result.decomposition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decomposition`, a oneof with full ID .google.cloud.dialogflow.v2.SummarizationEvaluationMetrics.Decomposition.adherence_decomposition, latest field was adherenceDecomposition",
                                ));
                            }
                            result.decomposition = std::option::Option::Some(
                                crate::model::summarization_evaluation_metrics::decomposition::Decomposition::AdherenceDecomposition(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::summarization_evaluation_metrics::AdherenceDecomposition>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::EvaluationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accuracy_decomposition,
            __adherence_rubric,
            __completeness_rubric,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accuracyDecomposition" => Ok(__FieldTag::__accuracy_decomposition),
                            "accuracy_decomposition" => Ok(__FieldTag::__accuracy_decomposition),
                            "adherenceRubric" => Ok(__FieldTag::__adherence_rubric),
                            "adherence_rubric" => Ok(__FieldTag::__adherence_rubric),
                            "completenessRubric" => Ok(__FieldTag::__completeness_rubric),
                            "completeness_rubric" => Ok(__FieldTag::__completeness_rubric),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::EvaluationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accuracy_decomposition => {
                            if !fields.insert(__FieldTag::__accuracy_decomposition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for accuracy_decomposition"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.SummarizationEvaluationMetrics.EvaluationResult.accuracy_decomposition, latest field was accuracyDecomposition",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::summarization_evaluation_metrics::evaluation_result::Result::AccuracyDecomposition(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::summarization_evaluation_metrics::AccuracyDecomposition>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__adherence_rubric => {
                            if !fields.insert(__FieldTag::__adherence_rubric) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for adherence_rubric"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.SummarizationEvaluationMetrics.EvaluationResult.adherence_rubric, latest field was adherenceRubric",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::summarization_evaluation_metrics::evaluation_result::Result::AdherenceRubric(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::summarization_evaluation_metrics::AdherenceRubric>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__completeness_rubric => {
                            if !fields.insert(__FieldTag::__completeness_rubric) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for completeness_rubric"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.SummarizationEvaluationMetrics.EvaluationResult.completeness_rubric, latest field was completenessRubric",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::summarization_evaluation_metrics::evaluation_result::Result::CompletenessRubric(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::summarization_evaluation_metrics::CompletenessRubric>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::SummarizationEvaluationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_id,
            __metric,
            __section,
            __score,
            __section_summary,
            __decompositions,
            __evaluation_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationEvaluationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "metric" => Ok(__FieldTag::__metric),
                            "section" => Ok(__FieldTag::__section),
                            "score" => Ok(__FieldTag::__score),
                            "sectionSummary" => Ok(__FieldTag::__section_summary),
                            "section_summary" => Ok(__FieldTag::__section_summary),
                            "decompositions" => Ok(__FieldTag::__decompositions),
                            "evaluationResults" => Ok(__FieldTag::__evaluation_results),
                            "evaluation_results" => Ok(__FieldTag::__evaluation_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::SummarizationEvaluationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationEvaluationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_id"));
                            }
                            result.session_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metric"));
                            }
                            result.metric = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__section => {
                            if !fields.insert(__FieldTag::__section) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section"));
                            }
                            result.section = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for score"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__section_summary => {
                            if !fields.insert(__FieldTag::__section_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section_summary"));
                            }
                            result.section_summary = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__decompositions => {
                            if !fields.insert(__FieldTag::__decompositions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for decompositions"));
                            }
                            result.decompositions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::Decomposition>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__evaluation_results => {
                            if !fields.insert(__FieldTag::__evaluation_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for evaluation_results"));
                            }
                            result.evaluation_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::EvaluationResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::OverallScoresByMetric {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OverallScoresByMetric")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metric" => Ok(__FieldTag::__metric),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::OverallScoresByMetric;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OverallScoresByMetric")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metric"));
                            }
                            result.metric = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::SectionToken {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __section,
            __token_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SectionToken")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "section" => Ok(__FieldTag::__section),
                            "tokenCount" => Ok(__FieldTag::__token_count),
                            "token_count" => Ok(__FieldTag::__token_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::SectionToken;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SectionToken")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__section => {
                            if !fields.insert(__FieldTag::__section) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section"));
                            }
                            result.section = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__token_count => {
                            if !fields.insert(__FieldTag::__token_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for token_count"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.token_count = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::ConversationDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_entries,
            __summary_sections,
            __metric_details,
            __section_tokens,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageEntries" => Ok(__FieldTag::__message_entries),
                            "message_entries" => Ok(__FieldTag::__message_entries),
                            "summarySections" => Ok(__FieldTag::__summary_sections),
                            "summary_sections" => Ok(__FieldTag::__summary_sections),
                            "metricDetails" => Ok(__FieldTag::__metric_details),
                            "metric_details" => Ok(__FieldTag::__metric_details),
                            "sectionTokens" => Ok(__FieldTag::__section_tokens),
                            "section_tokens" => Ok(__FieldTag::__section_tokens),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::ConversationDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_entries => {
                            if !fields.insert(__FieldTag::__message_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_entries"));
                            }
                            result.message_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageEntry>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summary_sections => {
                            if !fields.insert(__FieldTag::__summary_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary_sections"));
                            }
                            result.summary_sections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summary_suggestion::SummarySection>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metric_details => {
                            if !fields.insert(__FieldTag::__metric_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metric_details"));
                            }
                            result.metric_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::conversation_detail::MetricDetail>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__section_tokens => {
                            if !fields.insert(__FieldTag::__section_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section_tokens"));
                            }
                            result.section_tokens = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::SectionToken>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::conversation_detail::MetricDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric,
            __score,
            __section_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetricDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metric" => Ok(__FieldTag::__metric),
                            "score" => Ok(__FieldTag::__score),
                            "sectionDetails" => Ok(__FieldTag::__section_details),
                            "section_details" => Ok(__FieldTag::__section_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::conversation_detail::MetricDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetricDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metric"));
                            }
                            result.metric = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for score"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__section_details => {
                            if !fields.insert(__FieldTag::__section_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section_details"));
                            }
                            result.section_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::conversation_detail::metric_detail::SectionDetail>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::summarization_evaluation_metrics::conversation_detail::metric_detail::SectionDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __section,
            __score,
            __section_summary,
            __evaluation_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SectionDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "section" => Ok(__FieldTag::__section),
                            "score" => Ok(__FieldTag::__score),
                            "sectionSummary" => Ok(__FieldTag::__section_summary),
                            "section_summary" => Ok(__FieldTag::__section_summary),
                            "evaluationResults" => Ok(__FieldTag::__evaluation_results),
                            "evaluation_results" => Ok(__FieldTag::__evaluation_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::summarization_evaluation_metrics::conversation_detail::metric_detail::SectionDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SectionDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__section => {
                            if !fields.insert(__FieldTag::__section) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section"));
                            }
                            result.section = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for score"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__section_summary => {
                            if !fields.insert(__FieldTag::__section_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for section_summary"));
                            }
                            result.section_summary = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__evaluation_results => {
                            if !fields.insert(__FieldTag::__evaluation_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for evaluation_results"));
                            }
                            result.evaluation_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::summarization_evaluation_metrics::EvaluationResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GeneratorEvaluationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_data_config,
            __output_gcs_bucket_path,
            __summarization_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeneratorEvaluationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputDataConfig" => Ok(__FieldTag::__input_data_config),
                            "input_data_config" => Ok(__FieldTag::__input_data_config),
                            "outputGcsBucketPath" => Ok(__FieldTag::__output_gcs_bucket_path),
                            "output_gcs_bucket_path" => Ok(__FieldTag::__output_gcs_bucket_path),
                            "summarizationConfig" => Ok(__FieldTag::__summarization_config),
                            "summarization_config" => Ok(__FieldTag::__summarization_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GeneratorEvaluationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeneratorEvaluationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_data_config => {
                            if !fields.insert(__FieldTag::__input_data_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_data_config"));
                            }
                            result.input_data_config = map.next_value::<std::option::Option<crate::model::generator_evaluation_config::InputDataConfig>>()?
                                ;
                        },
                        __FieldTag::__output_gcs_bucket_path => {
                            if !fields.insert(__FieldTag::__output_gcs_bucket_path) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_gcs_bucket_path"));
                            }
                            result.output_gcs_bucket_path = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summarization_config => {
                            if !fields.insert(__FieldTag::__summarization_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summarization_config"));
                            }
                            if result.evaluation_feature_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `evaluation_feature_config`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorEvaluationConfig.summarization_config, latest field was summarizationConfig",
                                ));
                            }
                            result.evaluation_feature_config = std::option::Option::Some(
                                crate::model::generator_evaluation_config::EvaluationFeatureConfig::SummarizationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::generator_evaluation_config::SummarizationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generator_evaluation_config::AgentAssistInputDataConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentAssistInputDataConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generator_evaluation_config::AgentAssistInputDataConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentAssistInputDataConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start_time"));
                            }
                            result.start_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_time"));
                            }
                            result.end_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generator_evaluation_config::DatasetInputDataConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetInputDataConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generator_evaluation_config::DatasetInputDataConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetInputDataConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dataset"));
                            }
                            result.dataset = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generator_evaluation_config::InputDataConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_data_source_type,
            __start_time,
            __end_time,
            __sample_size,
            __is_summary_generation_allowed,
            __summary_generation_option,
            __agent_assist_input_data_config,
            __dataset_input_data_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputDataConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputDataSourceType" => Ok(__FieldTag::__input_data_source_type),
                            "input_data_source_type" => Ok(__FieldTag::__input_data_source_type),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "sampleSize" => Ok(__FieldTag::__sample_size),
                            "sample_size" => Ok(__FieldTag::__sample_size),
                            "isSummaryGenerationAllowed" => Ok(__FieldTag::__is_summary_generation_allowed),
                            "is_summary_generation_allowed" => Ok(__FieldTag::__is_summary_generation_allowed),
                            "summaryGenerationOption" => Ok(__FieldTag::__summary_generation_option),
                            "summary_generation_option" => Ok(__FieldTag::__summary_generation_option),
                            "agentAssistInputDataConfig" => Ok(__FieldTag::__agent_assist_input_data_config),
                            "agent_assist_input_data_config" => Ok(__FieldTag::__agent_assist_input_data_config),
                            "datasetInputDataConfig" => Ok(__FieldTag::__dataset_input_data_config),
                            "dataset_input_data_config" => Ok(__FieldTag::__dataset_input_data_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generator_evaluation_config::InputDataConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputDataConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_data_source_type => {
                            if !fields.insert(__FieldTag::__input_data_source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_data_source_type"));
                            }
                            result.input_data_source_type = map.next_value::<std::option::Option<crate::model::generator_evaluation_config::InputDataSourceType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for start_time"));
                            }
                            result.start_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_time"));
                            }
                            result.end_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__sample_size => {
                            if !fields.insert(__FieldTag::__sample_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sample_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__is_summary_generation_allowed => {
                            if !fields.insert(__FieldTag::__is_summary_generation_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_summary_generation_allowed"));
                            }
                            result.is_summary_generation_allowed = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__summary_generation_option => {
                            if !fields.insert(__FieldTag::__summary_generation_option) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for summary_generation_option"));
                            }
                            result.summary_generation_option = map.next_value::<std::option::Option<crate::model::generator_evaluation_config::input_data_config::SummaryGenerationOption>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_assist_input_data_config => {
                            if !fields.insert(__FieldTag::__agent_assist_input_data_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_assist_input_data_config"));
                            }
                            if result.source_specific_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_specific_config`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorEvaluationConfig.InputDataConfig.agent_assist_input_data_config, latest field was agentAssistInputDataConfig",
                                ));
                            }
                            result.source_specific_config = std::option::Option::Some(
                                crate::model::generator_evaluation_config::input_data_config::SourceSpecificConfig::AgentAssistInputDataConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::generator_evaluation_config::AgentAssistInputDataConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__dataset_input_data_config => {
                            if !fields.insert(__FieldTag::__dataset_input_data_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dataset_input_data_config"));
                            }
                            if result.source_specific_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_specific_config`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorEvaluationConfig.InputDataConfig.dataset_input_data_config, latest field was datasetInputDataConfig",
                                ));
                            }
                            result.source_specific_config = std::option::Option::Some(
                                crate::model::generator_evaluation_config::input_data_config::SourceSpecificConfig::DatasetInputDataConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::generator_evaluation_config::DatasetInputDataConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generator_evaluation_config::SummarizationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_accuracy_evaluation,
            __accuracy_evaluation_version,
            __enable_completeness_evaluation,
            __completeness_evaluation_version,
            __evaluator_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableAccuracyEvaluation" => Ok(__FieldTag::__enable_accuracy_evaluation),
                            "enable_accuracy_evaluation" => Ok(__FieldTag::__enable_accuracy_evaluation),
                            "accuracyEvaluationVersion" => Ok(__FieldTag::__accuracy_evaluation_version),
                            "accuracy_evaluation_version" => Ok(__FieldTag::__accuracy_evaluation_version),
                            "enableCompletenessEvaluation" => Ok(__FieldTag::__enable_completeness_evaluation),
                            "enable_completeness_evaluation" => Ok(__FieldTag::__enable_completeness_evaluation),
                            "completenessEvaluationVersion" => Ok(__FieldTag::__completeness_evaluation_version),
                            "completeness_evaluation_version" => Ok(__FieldTag::__completeness_evaluation_version),
                            "evaluatorVersion" => Ok(__FieldTag::__evaluator_version),
                            "evaluator_version" => Ok(__FieldTag::__evaluator_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generator_evaluation_config::SummarizationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_accuracy_evaluation => {
                            if !fields.insert(__FieldTag::__enable_accuracy_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_accuracy_evaluation"));
                            }
                            result.enable_accuracy_evaluation = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__accuracy_evaluation_version => {
                            if !fields.insert(__FieldTag::__accuracy_evaluation_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for accuracy_evaluation_version"));
                            }
                            result.accuracy_evaluation_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_completeness_evaluation => {
                            if !fields.insert(__FieldTag::__enable_completeness_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_completeness_evaluation"));
                            }
                            result.enable_completeness_evaluation = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__completeness_evaluation_version => {
                            if !fields.insert(__FieldTag::__completeness_evaluation_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for completeness_evaluation_version"));
                            }
                            result.completeness_evaluation_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__evaluator_version => {
                            if !fields.insert(__FieldTag::__evaluator_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for evaluator_version"));
                            }
                            result.evaluator_version = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EvaluationStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __done,
            __pipeline_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "done" => Ok(__FieldTag::__done),
                            "pipelineStatus" => Ok(__FieldTag::__pipeline_status),
                            "pipeline_status" => Ok(__FieldTag::__pipeline_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EvaluationStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done"));
                            }
                            result.done = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__pipeline_status => {
                            if !fields.insert(__FieldTag::__pipeline_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for pipeline_status"));
                            }
                            result.pipeline_status = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all ( feature = "agents",feature = "answer-records",feature = "contexts",feature = "conversation-datasets",feature = "conversation-models",feature = "conversation-profiles",feature = "conversations",feature = "documents",feature = "encryption-spec-service",feature = "entity-types",feature = "environments",feature = "fulfillments",feature = "generator-evaluations",feature = "generators",feature = "intents",feature = "knowledge-bases",feature = "participants",feature = "session-entity-types",feature = "sessions",feature = "sip-trunks",feature = "tools",feature = "versions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HumanAgentAssistantEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __participant,
            __suggestion_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentAssistantEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "participant" => Ok(__FieldTag::__participant),
                            "suggestionResults" => Ok(__FieldTag::__suggestion_results),
                            "suggestion_results" => Ok(__FieldTag::__suggestion_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HumanAgentAssistantEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentAssistantEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for conversation"));
                            }
                            result.conversation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant"));
                            }
                            result.participant = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__suggestion_results => {
                            if !fields.insert(__FieldTag::__suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_results"));
                            }
                            result.suggestion_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SuggestionResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Intent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __webhook_state,
            __priority,
            __is_fallback,
            __ml_disabled,
            __live_agent_handoff,
            __end_interaction,
            __input_context_names,
            __events,
            __training_phrases,
            __action,
            __output_contexts,
            __reset_contexts,
            __parameters,
            __messages,
            __default_response_platforms,
            __root_followup_intent_name,
            __parent_followup_intent_name,
            __followup_intent_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Intent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "webhookState" => Ok(__FieldTag::__webhook_state),
                            "webhook_state" => Ok(__FieldTag::__webhook_state),
                            "priority" => Ok(__FieldTag::__priority),
                            "isFallback" => Ok(__FieldTag::__is_fallback),
                            "is_fallback" => Ok(__FieldTag::__is_fallback),
                            "mlDisabled" => Ok(__FieldTag::__ml_disabled),
                            "ml_disabled" => Ok(__FieldTag::__ml_disabled),
                            "liveAgentHandoff" => Ok(__FieldTag::__live_agent_handoff),
                            "live_agent_handoff" => Ok(__FieldTag::__live_agent_handoff),
                            "endInteraction" => Ok(__FieldTag::__end_interaction),
                            "end_interaction" => Ok(__FieldTag::__end_interaction),
                            "inputContextNames" => Ok(__FieldTag::__input_context_names),
                            "input_context_names" => Ok(__FieldTag::__input_context_names),
                            "events" => Ok(__FieldTag::__events),
                            "trainingPhrases" => Ok(__FieldTag::__training_phrases),
                            "training_phrases" => Ok(__FieldTag::__training_phrases),
                            "action" => Ok(__FieldTag::__action),
                            "outputContexts" => Ok(__FieldTag::__output_contexts),
                            "output_contexts" => Ok(__FieldTag::__output_contexts),
                            "resetContexts" => Ok(__FieldTag::__reset_contexts),
                            "reset_contexts" => Ok(__FieldTag::__reset_contexts),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "messages" => Ok(__FieldTag::__messages),
                            "defaultResponsePlatforms" => Ok(__FieldTag::__default_response_platforms),
                            "default_response_platforms" => Ok(__FieldTag::__default_response_platforms),
                            "rootFollowupIntentName" => Ok(__FieldTag::__root_followup_intent_name),
                            "root_followup_intent_name" => Ok(__FieldTag::__root_followup_intent_name),
                            "parentFollowupIntentName" => Ok(__FieldTag::__parent_followup_intent_name),
                            "parent_followup_intent_name" => Ok(__FieldTag::__parent_followup_intent_name),
                            "followupIntentInfo" => Ok(__FieldTag::__followup_intent_info),
                            "followup_intent_info" => Ok(__FieldTag::__followup_intent_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Intent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Intent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__webhook_state => {
                            if !fields.insert(__FieldTag::__webhook_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for webhook_state"));
                            }
                            result.webhook_state = map.next_value::<std::option::Option<crate::model::intent::WebhookState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for priority"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__is_fallback => {
                            if !fields.insert(__FieldTag::__is_fallback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_fallback"));
                            }
                            result.is_fallback = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ml_disabled => {
                            if !fields.insert(__FieldTag::__ml_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ml_disabled"));
                            }
                            result.ml_disabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__live_agent_handoff => {
                            if !fields.insert(__FieldTag::__live_agent_handoff) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for live_agent_handoff"));
                            }
                            result.live_agent_handoff = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__end_interaction => {
                            if !fields.insert(__FieldTag::__end_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_interaction"));
                            }
                            result.end_interaction = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__input_context_names => {
                            if !fields.insert(__FieldTag::__input_context_names) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_context_names"));
                            }
                            result.input_context_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for events"));
                            }
                            result.events = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__training_phrases => {
                            if !fields.insert(__FieldTag::__training_phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for training_phrases"));
                            }
                            result.training_phrases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::TrainingPhrase>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__output_contexts => {
                            if !fields.insert(__FieldTag::__output_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_contexts"));
                            }
                            result.output_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__reset_contexts => {
                            if !fields.insert(__FieldTag::__reset_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reset_contexts"));
                            }
                            result.reset_contexts = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parameters"));
                            }
                            result.parameters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::Parameter>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for messages"));
                            }
                            result.messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::Message>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__default_response_platforms => {
                            if !fields.insert(__FieldTag::__default_response_platforms) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for default_response_platforms"));
                            }
                            result.default_response_platforms = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::Platform>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__root_followup_intent_name => {
                            if !fields.insert(__FieldTag::__root_followup_intent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for root_followup_intent_name"));
                            }
                            result.root_followup_intent_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parent_followup_intent_name => {
                            if !fields.insert(__FieldTag::__parent_followup_intent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent_followup_intent_name"));
                            }
                            result.parent_followup_intent_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__followup_intent_info => {
                            if !fields.insert(__FieldTag::__followup_intent_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for followup_intent_info"));
                            }
                            result.followup_intent_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::FollowupIntentInfo>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::TrainingPhrase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __parts,
            __times_added_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainingPhrase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "parts" => Ok(__FieldTag::__parts),
                            "timesAddedCount" => Ok(__FieldTag::__times_added_count),
                            "times_added_count" => Ok(__FieldTag::__times_added_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::TrainingPhrase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainingPhrase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::intent::training_phrase::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parts => {
                            if !fields.insert(__FieldTag::__parts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parts"));
                            }
                            result.parts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::training_phrase::Part>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__times_added_count => {
                            if !fields.insert(__FieldTag::__times_added_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for times_added_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.times_added_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::training_phrase::Part {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __entity_type,
            __alias,
            __user_defined,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Part")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "alias" => Ok(__FieldTag::__alias),
                            "userDefined" => Ok(__FieldTag::__user_defined),
                            "user_defined" => Ok(__FieldTag::__user_defined),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::training_phrase::Part;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Part")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type"));
                            }
                            result.entity_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__alias => {
                            if !fields.insert(__FieldTag::__alias) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for alias"));
                            }
                            result.alias = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__user_defined => {
                            if !fields.insert(__FieldTag::__user_defined) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for user_defined"));
                            }
                            result.user_defined = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::Parameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __value,
            __default_value,
            __entity_type_display_name,
            __mandatory,
            __prompts,
            __is_list,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Parameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "value" => Ok(__FieldTag::__value),
                            "defaultValue" => Ok(__FieldTag::__default_value),
                            "default_value" => Ok(__FieldTag::__default_value),
                            "entityTypeDisplayName" => Ok(__FieldTag::__entity_type_display_name),
                            "entity_type_display_name" => Ok(__FieldTag::__entity_type_display_name),
                            "mandatory" => Ok(__FieldTag::__mandatory),
                            "prompts" => Ok(__FieldTag::__prompts),
                            "isList" => Ok(__FieldTag::__is_list),
                            "is_list" => Ok(__FieldTag::__is_list),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::Parameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Parameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for value"));
                            }
                            result.value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__default_value => {
                            if !fields.insert(__FieldTag::__default_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for default_value"));
                            }
                            result.default_value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_type_display_name => {
                            if !fields.insert(__FieldTag::__entity_type_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type_display_name"));
                            }
                            result.entity_type_display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__mandatory => {
                            if !fields.insert(__FieldTag::__mandatory) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for mandatory"));
                            }
                            result.mandatory = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__prompts => {
                            if !fields.insert(__FieldTag::__prompts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for prompts"));
                            }
                            result.prompts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_list => {
                            if !fields.insert(__FieldTag::__is_list) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_list"));
                            }
                            result.is_list = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::Message {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __image,
            __quick_replies,
            __card,
            __payload,
            __simple_responses,
            __basic_card,
            __suggestions,
            __link_out_suggestion,
            __list_select,
            __carousel_select,
            __browse_carousel_card,
            __table_card,
            __media_content,
            __platform,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Message")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "image" => Ok(__FieldTag::__image),
                            "quickReplies" => Ok(__FieldTag::__quick_replies),
                            "quick_replies" => Ok(__FieldTag::__quick_replies),
                            "card" => Ok(__FieldTag::__card),
                            "payload" => Ok(__FieldTag::__payload),
                            "simpleResponses" => Ok(__FieldTag::__simple_responses),
                            "simple_responses" => Ok(__FieldTag::__simple_responses),
                            "basicCard" => Ok(__FieldTag::__basic_card),
                            "basic_card" => Ok(__FieldTag::__basic_card),
                            "suggestions" => Ok(__FieldTag::__suggestions),
                            "linkOutSuggestion" => Ok(__FieldTag::__link_out_suggestion),
                            "link_out_suggestion" => Ok(__FieldTag::__link_out_suggestion),
                            "listSelect" => Ok(__FieldTag::__list_select),
                            "list_select" => Ok(__FieldTag::__list_select),
                            "carouselSelect" => Ok(__FieldTag::__carousel_select),
                            "carousel_select" => Ok(__FieldTag::__carousel_select),
                            "browseCarouselCard" => Ok(__FieldTag::__browse_carousel_card),
                            "browse_carousel_card" => Ok(__FieldTag::__browse_carousel_card),
                            "tableCard" => Ok(__FieldTag::__table_card),
                            "table_card" => Ok(__FieldTag::__table_card),
                            "mediaContent" => Ok(__FieldTag::__media_content),
                            "media_content" => Ok(__FieldTag::__media_content),
                            "platform" => Ok(__FieldTag::__platform),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::Message;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Message")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.text, latest field was text",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::Text(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Text>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.image, latest field was image",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::Image(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Image>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__quick_replies => {
                            if !fields.insert(__FieldTag::__quick_replies) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for quick_replies"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.quick_replies, latest field was quickReplies",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::QuickReplies(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::QuickReplies>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__card => {
                            if !fields.insert(__FieldTag::__card) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for card"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.card, latest field was card",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::Card(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Card>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for payload"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.payload, latest field was payload",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::Payload(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Struct>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__simple_responses => {
                            if !fields.insert(__FieldTag::__simple_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for simple_responses"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.simple_responses, latest field was simpleResponses",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::SimpleResponses(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::SimpleResponses>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__basic_card => {
                            if !fields.insert(__FieldTag::__basic_card) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for basic_card"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.basic_card, latest field was basicCard",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::BasicCard(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::BasicCard>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__suggestions => {
                            if !fields.insert(__FieldTag::__suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestions"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.suggestions, latest field was suggestions",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::Suggestions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Suggestions>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__link_out_suggestion => {
                            if !fields.insert(__FieldTag::__link_out_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for link_out_suggestion"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.link_out_suggestion, latest field was linkOutSuggestion",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::LinkOutSuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::LinkOutSuggestion>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__list_select => {
                            if !fields.insert(__FieldTag::__list_select) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for list_select"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.list_select, latest field was listSelect",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::ListSelect(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::ListSelect>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__carousel_select => {
                            if !fields.insert(__FieldTag::__carousel_select) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for carousel_select"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.carousel_select, latest field was carouselSelect",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::CarouselSelect(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::CarouselSelect>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__browse_carousel_card => {
                            if !fields.insert(__FieldTag::__browse_carousel_card) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for browse_carousel_card"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.browse_carousel_card, latest field was browseCarouselCard",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::BrowseCarouselCard(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::BrowseCarouselCard>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__table_card => {
                            if !fields.insert(__FieldTag::__table_card) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for table_card"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.table_card, latest field was tableCard",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::TableCard(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::TableCard>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__media_content => {
                            if !fields.insert(__FieldTag::__media_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for media_content"));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.media_content, latest field was mediaContent",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::intent::message::Message::MediaContent(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::MediaContent>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for platform"));
                            }
                            result.platform = map.next_value::<std::option::Option<crate::model::intent::message::Platform>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::Text {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Text")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::Text;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Text")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::Image {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_uri,
            __accessibility_text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Image")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            "accessibilityText" => Ok(__FieldTag::__accessibility_text),
                            "accessibility_text" => Ok(__FieldTag::__accessibility_text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::Image;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Image")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image_uri"));
                            }
                            result.image_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__accessibility_text => {
                            if !fields.insert(__FieldTag::__accessibility_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for accessibility_text"));
                            }
                            result.accessibility_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::QuickReplies {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __quick_replies,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuickReplies")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "quickReplies" => Ok(__FieldTag::__quick_replies),
                            "quick_replies" => Ok(__FieldTag::__quick_replies),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::QuickReplies;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuickReplies")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__quick_replies => {
                            if !fields.insert(__FieldTag::__quick_replies) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for quick_replies"));
                            }
                            result.quick_replies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::Card {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __subtitle,
            __image_uri,
            __buttons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Card")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "subtitle" => Ok(__FieldTag::__subtitle),
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            "buttons" => Ok(__FieldTag::__buttons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::Card;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Card")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__subtitle => {
                            if !fields.insert(__FieldTag::__subtitle) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subtitle"));
                            }
                            result.subtitle = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image_uri"));
                            }
                            result.image_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__buttons => {
                            if !fields.insert(__FieldTag::__buttons) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for buttons"));
                            }
                            result.buttons = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::card::Button>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::card::Button {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __postback,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Button")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "postback" => Ok(__FieldTag::__postback),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::card::Button;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Button")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__postback => {
                            if !fields.insert(__FieldTag::__postback) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for postback"));
                            }
                            result.postback = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::SimpleResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text_to_speech,
            __ssml,
            __display_text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SimpleResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "textToSpeech" => Ok(__FieldTag::__text_to_speech),
                            "text_to_speech" => Ok(__FieldTag::__text_to_speech),
                            "ssml" => Ok(__FieldTag::__ssml),
                            "displayText" => Ok(__FieldTag::__display_text),
                            "display_text" => Ok(__FieldTag::__display_text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::SimpleResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SimpleResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text_to_speech => {
                            if !fields.insert(__FieldTag::__text_to_speech) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_to_speech"));
                            }
                            result.text_to_speech = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ssml => {
                            if !fields.insert(__FieldTag::__ssml) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ssml"));
                            }
                            result.ssml = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_text => {
                            if !fields.insert(__FieldTag::__display_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_text"));
                            }
                            result.display_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::SimpleResponses {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __simple_responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SimpleResponses")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "simpleResponses" => Ok(__FieldTag::__simple_responses),
                            "simple_responses" => Ok(__FieldTag::__simple_responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::SimpleResponses;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SimpleResponses")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__simple_responses => {
                            if !fields.insert(__FieldTag::__simple_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for simple_responses"));
                            }
                            result.simple_responses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::SimpleResponse>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::BasicCard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __subtitle,
            __formatted_text,
            __image,
            __buttons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BasicCard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "subtitle" => Ok(__FieldTag::__subtitle),
                            "formattedText" => Ok(__FieldTag::__formatted_text),
                            "formatted_text" => Ok(__FieldTag::__formatted_text),
                            "image" => Ok(__FieldTag::__image),
                            "buttons" => Ok(__FieldTag::__buttons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::BasicCard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BasicCard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__subtitle => {
                            if !fields.insert(__FieldTag::__subtitle) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subtitle"));
                            }
                            result.subtitle = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__formatted_text => {
                            if !fields.insert(__FieldTag::__formatted_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for formatted_text"));
                            }
                            result.formatted_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image"));
                            }
                            result.image = map.next_value::<std::option::Option<crate::model::intent::message::Image>>()?
                                ;
                        },
                        __FieldTag::__buttons => {
                            if !fields.insert(__FieldTag::__buttons) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for buttons"));
                            }
                            result.buttons = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::basic_card::Button>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::basic_card::Button {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __open_uri_action,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Button")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "openUriAction" => Ok(__FieldTag::__open_uri_action),
                            "open_uri_action" => Ok(__FieldTag::__open_uri_action),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::basic_card::Button;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Button")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__open_uri_action => {
                            if !fields.insert(__FieldTag::__open_uri_action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for open_uri_action"));
                            }
                            result.open_uri_action = map.next_value::<std::option::Option<crate::model::intent::message::basic_card::button::OpenUriAction>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::basic_card::button::OpenUriAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpenUriAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::basic_card::button::OpenUriAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpenUriAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::Suggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Suggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::Suggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Suggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::Suggestions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __suggestions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Suggestions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "suggestions" => Ok(__FieldTag::__suggestions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::Suggestions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Suggestions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__suggestions => {
                            if !fields.insert(__FieldTag::__suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestions"));
                            }
                            result.suggestions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::Suggestion>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::LinkOutSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_name,
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkOutSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationName" => Ok(__FieldTag::__destination_name),
                            "destination_name" => Ok(__FieldTag::__destination_name),
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::LinkOutSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkOutSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_name => {
                            if !fields.insert(__FieldTag::__destination_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_name"));
                            }
                            result.destination_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::ListSelect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __items,
            __subtitle,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSelect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "items" => Ok(__FieldTag::__items),
                            "subtitle" => Ok(__FieldTag::__subtitle),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::ListSelect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSelect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for items"));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::list_select::Item>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__subtitle => {
                            if !fields.insert(__FieldTag::__subtitle) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subtitle"));
                            }
                            result.subtitle = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::list_select::Item {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info,
            __title,
            __description,
            __image,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Item")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "info" => Ok(__FieldTag::__info),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "image" => Ok(__FieldTag::__image),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::list_select::Item;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Item")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info => {
                            if !fields.insert(__FieldTag::__info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for info"));
                            }
                            result.info = map.next_value::<std::option::Option<crate::model::intent::message::SelectItemInfo>>()?
                                ;
                        },
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image"));
                            }
                            result.image = map.next_value::<std::option::Option<crate::model::intent::message::Image>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::CarouselSelect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CarouselSelect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::CarouselSelect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CarouselSelect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for items"));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::carousel_select::Item>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::carousel_select::Item {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __info,
            __title,
            __description,
            __image,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Item")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "info" => Ok(__FieldTag::__info),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "image" => Ok(__FieldTag::__image),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::carousel_select::Item;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Item")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__info => {
                            if !fields.insert(__FieldTag::__info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for info"));
                            }
                            result.info = map.next_value::<std::option::Option<crate::model::intent::message::SelectItemInfo>>()?
                                ;
                        },
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image"));
                            }
                            result.image = map.next_value::<std::option::Option<crate::model::intent::message::Image>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::SelectItemInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __synonyms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SelectItemInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "synonyms" => Ok(__FieldTag::__synonyms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::SelectItemInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SelectItemInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for key"));
                            }
                            result.key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__synonyms => {
                            if !fields.insert(__FieldTag::__synonyms) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for synonyms"));
                            }
                            result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::MediaContent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __media_type,
            __media_objects,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MediaContent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mediaType" => Ok(__FieldTag::__media_type),
                            "media_type" => Ok(__FieldTag::__media_type),
                            "mediaObjects" => Ok(__FieldTag::__media_objects),
                            "media_objects" => Ok(__FieldTag::__media_objects),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::MediaContent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MediaContent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__media_type => {
                            if !fields.insert(__FieldTag::__media_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for media_type"));
                            }
                            result.media_type = map.next_value::<std::option::Option<crate::model::intent::message::media_content::ResponseMediaType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__media_objects => {
                            if !fields.insert(__FieldTag::__media_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for media_objects"));
                            }
                            result.media_objects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::media_content::ResponseMediaObject>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::media_content::ResponseMediaObject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __large_image,
            __icon,
            __content_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponseMediaObject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "largeImage" => Ok(__FieldTag::__large_image),
                            "large_image" => Ok(__FieldTag::__large_image),
                            "icon" => Ok(__FieldTag::__icon),
                            "contentUrl" => Ok(__FieldTag::__content_url),
                            "content_url" => Ok(__FieldTag::__content_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::media_content::ResponseMediaObject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponseMediaObject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__large_image => {
                            if !fields.insert(__FieldTag::__large_image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for large_image"));
                            }
                            if result.image.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `image`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.MediaContent.ResponseMediaObject.large_image, latest field was largeImage",
                                ));
                            }
                            result.image = std::option::Option::Some(
                                crate::model::intent::message::media_content::response_media_object::Image::LargeImage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Image>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__icon => {
                            if !fields.insert(__FieldTag::__icon) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for icon"));
                            }
                            if result.image.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `image`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.MediaContent.ResponseMediaObject.icon, latest field was icon",
                                ));
                            }
                            result.image = std::option::Option::Some(
                                crate::model::intent::message::media_content::response_media_object::Image::Icon(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Image>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__content_url => {
                            if !fields.insert(__FieldTag::__content_url) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_url"));
                            }
                            result.content_url = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::BrowseCarouselCard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __items,
            __image_display_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BrowseCarouselCard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "items" => Ok(__FieldTag::__items),
                            "imageDisplayOptions" => Ok(__FieldTag::__image_display_options),
                            "image_display_options" => Ok(__FieldTag::__image_display_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::BrowseCarouselCard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BrowseCarouselCard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for items"));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image_display_options => {
                            if !fields.insert(__FieldTag::__image_display_options) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image_display_options"));
                            }
                            result.image_display_options = map.next_value::<std::option::Option<crate::model::intent::message::browse_carousel_card::ImageDisplayOptions>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::browse_carousel_card::BrowseCarouselCardItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __open_uri_action,
            __title,
            __description,
            __image,
            __footer,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BrowseCarouselCardItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "openUriAction" => Ok(__FieldTag::__open_uri_action),
                            "open_uri_action" => Ok(__FieldTag::__open_uri_action),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "image" => Ok(__FieldTag::__image),
                            "footer" => Ok(__FieldTag::__footer),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::browse_carousel_card::BrowseCarouselCardItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BrowseCarouselCardItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__open_uri_action => {
                            if !fields.insert(__FieldTag::__open_uri_action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for open_uri_action"));
                            }
                            result.open_uri_action = map.next_value::<std::option::Option<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction>>()?
                                ;
                        },
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image"));
                            }
                            result.image = map.next_value::<std::option::Option<crate::model::intent::message::Image>>()?
                                ;
                        },
                        __FieldTag::__footer => {
                            if !fields.insert(__FieldTag::__footer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for footer"));
                            }
                            result.footer = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __url_type_hint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpenUrlAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "urlTypeHint" => Ok(__FieldTag::__url_type_hint),
                            "url_type_hint" => Ok(__FieldTag::__url_type_hint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpenUrlAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for url"));
                            }
                            result.url = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__url_type_hint => {
                            if !fields.insert(__FieldTag::__url_type_hint) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for url_type_hint"));
                            }
                            result.url_type_hint = map.next_value::<std::option::Option<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::open_url_action::UrlTypeHint>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::TableCard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __subtitle,
            __image,
            __column_properties,
            __rows,
            __buttons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableCard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "subtitle" => Ok(__FieldTag::__subtitle),
                            "image" => Ok(__FieldTag::__image),
                            "columnProperties" => Ok(__FieldTag::__column_properties),
                            "column_properties" => Ok(__FieldTag::__column_properties),
                            "rows" => Ok(__FieldTag::__rows),
                            "buttons" => Ok(__FieldTag::__buttons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::TableCard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableCard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__subtitle => {
                            if !fields.insert(__FieldTag::__subtitle) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subtitle"));
                            }
                            result.subtitle = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for image"));
                            }
                            result.image = map.next_value::<std::option::Option<crate::model::intent::message::Image>>()?
                                ;
                        },
                        __FieldTag::__column_properties => {
                            if !fields.insert(__FieldTag::__column_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for column_properties"));
                            }
                            result.column_properties = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::ColumnProperties>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rows"));
                            }
                            result.rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::TableCardRow>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__buttons => {
                            if !fields.insert(__FieldTag::__buttons) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for buttons"));
                            }
                            result.buttons = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::basic_card::Button>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::ColumnProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __header,
            __horizontal_alignment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "header" => Ok(__FieldTag::__header),
                            "horizontalAlignment" => Ok(__FieldTag::__horizontal_alignment),
                            "horizontal_alignment" => Ok(__FieldTag::__horizontal_alignment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::ColumnProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__header => {
                            if !fields.insert(__FieldTag::__header) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for header"));
                            }
                            result.header = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__horizontal_alignment => {
                            if !fields.insert(__FieldTag::__horizontal_alignment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for horizontal_alignment"));
                            }
                            result.horizontal_alignment = map.next_value::<std::option::Option<crate::model::intent::message::column_properties::HorizontalAlignment>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::TableCardRow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cells,
            __divider_after,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableCardRow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cells" => Ok(__FieldTag::__cells),
                            "dividerAfter" => Ok(__FieldTag::__divider_after),
                            "divider_after" => Ok(__FieldTag::__divider_after),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::TableCardRow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableCardRow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cells => {
                            if !fields.insert(__FieldTag::__cells) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cells"));
                            }
                            result.cells = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::TableCardCell>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__divider_after => {
                            if !fields.insert(__FieldTag::__divider_after) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for divider_after"));
                            }
                            result.divider_after = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::message::TableCardCell {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableCardCell")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::message::TableCardCell;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableCardCell")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "intents",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::intent::FollowupIntentInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __followup_intent_name,
            __parent_followup_intent_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FollowupIntentInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "followupIntentName" => Ok(__FieldTag::__followup_intent_name),
                            "followup_intent_name" => Ok(__FieldTag::__followup_intent_name),
                            "parentFollowupIntentName" => Ok(__FieldTag::__parent_followup_intent_name),
                            "parent_followup_intent_name" => Ok(__FieldTag::__parent_followup_intent_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::intent::FollowupIntentInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FollowupIntentInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__followup_intent_name => {
                            if !fields.insert(__FieldTag::__followup_intent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for followup_intent_name"));
                            }
                            result.followup_intent_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parent_followup_intent_name => {
                            if !fields.insert(__FieldTag::__parent_followup_intent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent_followup_intent_name"));
                            }
                            result.parent_followup_intent_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __intent_view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_view"));
                            }
                            result.intent_view = map.next_value::<std::option::Option<crate::model::IntentView>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intents"));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_view"));
                            }
                            result.intent_view = map.next_value::<std::option::Option<crate::model::IntentView>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intent,
            __language_code,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intent" => Ok(__FieldTag::__intent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent"));
                            }
                            result.intent = map.next_value::<std::option::Option<crate::model::Intent>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_view"));
                            }
                            result.intent_view = map.next_value::<std::option::Option<crate::model::IntentView>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intent,
            __language_code,
            __update_mask,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intent" => Ok(__FieldTag::__intent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent"));
                            }
                            result.intent = map.next_value::<std::option::Option<crate::model::Intent>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_view"));
                            }
                            result.intent_view = map.next_value::<std::option::Option<crate::model::IntentView>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchUpdateIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intent_batch_uri,
            __intent_batch_inline,
            __language_code,
            __update_mask,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intentBatchUri" => Ok(__FieldTag::__intent_batch_uri),
                            "intent_batch_uri" => Ok(__FieldTag::__intent_batch_uri),
                            "intentBatchInline" => Ok(__FieldTag::__intent_batch_inline),
                            "intent_batch_inline" => Ok(__FieldTag::__intent_batch_inline),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchUpdateIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent_batch_uri => {
                            if !fields.insert(__FieldTag::__intent_batch_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_batch_uri"));
                            }
                            if result.intent_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intent_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateIntentsRequest.intent_batch_uri, latest field was intentBatchUri",
                                ));
                            }
                            result.intent_batch = std::option::Option::Some(
                                crate::model::batch_update_intents_request::IntentBatch::IntentBatchUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__intent_batch_inline => {
                            if !fields.insert(__FieldTag::__intent_batch_inline) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_batch_inline"));
                            }
                            if result.intent_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intent_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateIntentsRequest.intent_batch_inline, latest field was intentBatchInline",
                                ));
                            }
                            result.intent_batch = std::option::Option::Some(
                                crate::model::batch_update_intents_request::IntentBatch::IntentBatchInline(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::IntentBatch>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_view"));
                            }
                            result.intent_view = map.next_value::<std::option::Option<crate::model::IntentView>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchUpdateIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchUpdateIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intents"));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchDeleteIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intents" => Ok(__FieldTag::__intents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchDeleteIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intents"));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IntentBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IntentBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intents"));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::KnowledgeBase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeBase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::KnowledgeBase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeBase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListKnowledgeBasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKnowledgeBasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListKnowledgeBasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKnowledgeBasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListKnowledgeBasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_bases,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKnowledgeBasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeBases" => Ok(__FieldTag::__knowledge_bases),
                            "knowledge_bases" => Ok(__FieldTag::__knowledge_bases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListKnowledgeBasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKnowledgeBasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_bases => {
                            if !fields.insert(__FieldTag::__knowledge_bases) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_bases"));
                            }
                            result.knowledge_bases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::KnowledgeBase>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __knowledge_base,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "knowledgeBase" => Ok(__FieldTag::__knowledge_base),
                            "knowledge_base" => Ok(__FieldTag::__knowledge_base),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__knowledge_base => {
                            if !fields.insert(__FieldTag::__knowledge_base) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_base"));
                            }
                            result.knowledge_base = map.next_value::<std::option::Option<crate::model::KnowledgeBase>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for force"));
                            }
                            result.force = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_base,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeBase" => Ok(__FieldTag::__knowledge_base),
                            "knowledge_base" => Ok(__FieldTag::__knowledge_base),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_base => {
                            if !fields.insert(__FieldTag::__knowledge_base) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_base"));
                            }
                            result.knowledge_base = map.next_value::<std::option::Option<crate::model::KnowledgeBase>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generator-evaluations" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GeneratorEvaluationOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_evaluation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeneratorEvaluationOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorEvaluation" => Ok(__FieldTag::__generator_evaluation),
                            "generator_evaluation" => Ok(__FieldTag::__generator_evaluation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GeneratorEvaluationOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeneratorEvaluationOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_evaluation => {
                            if !fields.insert(__FieldTag::__generator_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_evaluation"));
                            }
                            result.generator_evaluation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversation-profiles",feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Participant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __role,
            __sip_recording_media_label,
            __obfuscated_external_user_id,
            __documents_metadata_filters,
            __agent_desktop_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Participant")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "role" => Ok(__FieldTag::__role),
                            "sipRecordingMediaLabel" => Ok(__FieldTag::__sip_recording_media_label),
                            "sip_recording_media_label" => Ok(__FieldTag::__sip_recording_media_label),
                            "obfuscatedExternalUserId" => Ok(__FieldTag::__obfuscated_external_user_id),
                            "obfuscated_external_user_id" => Ok(__FieldTag::__obfuscated_external_user_id),
                            "documentsMetadataFilters" => Ok(__FieldTag::__documents_metadata_filters),
                            "documents_metadata_filters" => Ok(__FieldTag::__documents_metadata_filters),
                            "agentDesktopSource" => Ok(__FieldTag::__agent_desktop_source),
                            "agent_desktop_source" => Ok(__FieldTag::__agent_desktop_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Participant;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Participant")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for role"));
                            }
                            result.role = map.next_value::<std::option::Option<crate::model::participant::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sip_recording_media_label => {
                            if !fields.insert(__FieldTag::__sip_recording_media_label) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sip_recording_media_label"));
                            }
                            result.sip_recording_media_label = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__obfuscated_external_user_id => {
                            if !fields.insert(__FieldTag::__obfuscated_external_user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for obfuscated_external_user_id"));
                            }
                            result.obfuscated_external_user_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__documents_metadata_filters => {
                            if !fields.insert(__FieldTag::__documents_metadata_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for documents_metadata_filters"));
                            }
                            result.documents_metadata_filters = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__agent_desktop_source => {
                            if !fields.insert(__FieldTag::__agent_desktop_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for agent_desktop_source"));
                            }
                            result.agent_desktop_source = map.next_value::<std::option::Option<crate::model::participant::AgentDesktopSource>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[cfg(any ( feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Message {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __content,
            __language_code,
            __participant,
            __participant_role,
            __create_time,
            __send_time,
            __message_annotation,
            __sentiment_analysis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Message")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "content" => Ok(__FieldTag::__content),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "participant" => Ok(__FieldTag::__participant),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "sendTime" => Ok(__FieldTag::__send_time),
                            "send_time" => Ok(__FieldTag::__send_time),
                            "messageAnnotation" => Ok(__FieldTag::__message_annotation),
                            "message_annotation" => Ok(__FieldTag::__message_annotation),
                            "sentimentAnalysis" => Ok(__FieldTag::__sentiment_analysis),
                            "sentiment_analysis" => Ok(__FieldTag::__sentiment_analysis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Message;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Message")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content"));
                            }
                            result.content = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant"));
                            }
                            result.participant = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant_role"));
                            }
                            result.participant_role = map.next_value::<std::option::Option<crate::model::participant::Role>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__send_time => {
                            if !fields.insert(__FieldTag::__send_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for send_time"));
                            }
                            result.send_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__message_annotation => {
                            if !fields.insert(__FieldTag::__message_annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_annotation"));
                            }
                            result.message_annotation = map.next_value::<std::option::Option<crate::model::MessageAnnotation>>()?
                                ;
                        },
                        __FieldTag::__sentiment_analysis => {
                            if !fields.insert(__FieldTag::__sentiment_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sentiment_analysis"));
                            }
                            result.sentiment_analysis = map.next_value::<std::option::Option<crate::model::SentimentAnalysisResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateParticipantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __participant,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateParticipantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "participant" => Ok(__FieldTag::__participant),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateParticipantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateParticipantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant"));
                            }
                            result.participant = map.next_value::<std::option::Option<crate::model::Participant>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetParticipantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetParticipantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetParticipantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetParticipantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListParticipantsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListParticipantsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListParticipantsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListParticipantsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListParticipantsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participants,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListParticipantsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participants" => Ok(__FieldTag::__participants),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListParticipantsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListParticipantsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participants => {
                            if !fields.insert(__FieldTag::__participants) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participants"));
                            }
                            result.participants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Participant>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateParticipantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participant,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateParticipantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participant" => Ok(__FieldTag::__participant),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateParticipantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateParticipantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant"));
                            }
                            result.participant = map.next_value::<std::option::Option<crate::model::Participant>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AnalyzeContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participant,
            __text_input,
            __audio_input,
            __event_input,
            __suggestion_input,
            __reply_audio_config,
            __query_params,
            __assist_query_params,
            __cx_parameters,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participant" => Ok(__FieldTag::__participant),
                            "textInput" => Ok(__FieldTag::__text_input),
                            "text_input" => Ok(__FieldTag::__text_input),
                            "audioInput" => Ok(__FieldTag::__audio_input),
                            "audio_input" => Ok(__FieldTag::__audio_input),
                            "eventInput" => Ok(__FieldTag::__event_input),
                            "event_input" => Ok(__FieldTag::__event_input),
                            "suggestionInput" => Ok(__FieldTag::__suggestion_input),
                            "suggestion_input" => Ok(__FieldTag::__suggestion_input),
                            "replyAudioConfig" => Ok(__FieldTag::__reply_audio_config),
                            "reply_audio_config" => Ok(__FieldTag::__reply_audio_config),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            "cxParameters" => Ok(__FieldTag::__cx_parameters),
                            "cx_parameters" => Ok(__FieldTag::__cx_parameters),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AnalyzeContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant"));
                            }
                            result.participant = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__text_input => {
                            if !fields.insert(__FieldTag::__text_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_input"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.text_input, latest field was textInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::TextInput(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TextInput>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__audio_input => {
                            if !fields.insert(__FieldTag::__audio_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_input"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.audio_input, latest field was audioInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::AudioInput(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AudioInput>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__event_input => {
                            if !fields.insert(__FieldTag::__event_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for event_input"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.event_input, latest field was eventInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::EventInput(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::EventInput>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__suggestion_input => {
                            if !fields.insert(__FieldTag::__suggestion_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggestion_input"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.suggestion_input, latest field was suggestionInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::SuggestionInput(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestionInput>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__reply_audio_config => {
                            if !fields.insert(__FieldTag::__reply_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply_audio_config"));
                            }
                            result.reply_audio_config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_params"));
                            }
                            result.query_params = map.next_value::<std::option::Option<crate::model::QueryParameters>>()?
                                ;
                        },
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for assist_query_params"));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        },
                        __FieldTag::__cx_parameters => {
                            if !fields.insert(__FieldTag::__cx_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cx_parameters"));
                            }
                            result.cx_parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_id"));
                            }
                            result.request_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DtmfParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accepts_dtmf_input,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DtmfParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceptsDtmfInput" => Ok(__FieldTag::__accepts_dtmf_input),
                            "accepts_dtmf_input" => Ok(__FieldTag::__accepts_dtmf_input),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DtmfParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DtmfParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accepts_dtmf_input => {
                            if !fields.insert(__FieldTag::__accepts_dtmf_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for accepts_dtmf_input"));
                            }
                            result.accepts_dtmf_input = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AnalyzeContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reply_text,
            __reply_audio,
            __automated_agent_reply,
            __message,
            __human_agent_suggestion_results,
            __end_user_suggestion_results,
            __dtmf_parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replyText" => Ok(__FieldTag::__reply_text),
                            "reply_text" => Ok(__FieldTag::__reply_text),
                            "replyAudio" => Ok(__FieldTag::__reply_audio),
                            "reply_audio" => Ok(__FieldTag::__reply_audio),
                            "automatedAgentReply" => Ok(__FieldTag::__automated_agent_reply),
                            "automated_agent_reply" => Ok(__FieldTag::__automated_agent_reply),
                            "message" => Ok(__FieldTag::__message),
                            "humanAgentSuggestionResults" => Ok(__FieldTag::__human_agent_suggestion_results),
                            "human_agent_suggestion_results" => Ok(__FieldTag::__human_agent_suggestion_results),
                            "endUserSuggestionResults" => Ok(__FieldTag::__end_user_suggestion_results),
                            "end_user_suggestion_results" => Ok(__FieldTag::__end_user_suggestion_results),
                            "dtmfParameters" => Ok(__FieldTag::__dtmf_parameters),
                            "dtmf_parameters" => Ok(__FieldTag::__dtmf_parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AnalyzeContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reply_text => {
                            if !fields.insert(__FieldTag::__reply_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply_text"));
                            }
                            result.reply_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__reply_audio => {
                            if !fields.insert(__FieldTag::__reply_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply_audio"));
                            }
                            result.reply_audio = map.next_value::<std::option::Option<crate::model::OutputAudio>>()?
                                ;
                        },
                        __FieldTag::__automated_agent_reply => {
                            if !fields.insert(__FieldTag::__automated_agent_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for automated_agent_reply"));
                            }
                            result.automated_agent_reply = map.next_value::<std::option::Option<crate::model::AutomatedAgentReply>>()?
                                ;
                        },
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message"));
                            }
                            result.message = map.next_value::<std::option::Option<crate::model::Message>>()?
                                ;
                        },
                        __FieldTag::__human_agent_suggestion_results => {
                            if !fields.insert(__FieldTag::__human_agent_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for human_agent_suggestion_results"));
                            }
                            result.human_agent_suggestion_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SuggestionResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__end_user_suggestion_results => {
                            if !fields.insert(__FieldTag::__end_user_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_user_suggestion_results"));
                            }
                            result.end_user_suggestion_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SuggestionResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dtmf_parameters => {
                            if !fields.insert(__FieldTag::__dtmf_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dtmf_parameters"));
                            }
                            result.dtmf_parameters = map.next_value::<std::option::Option<crate::model::DtmfParameters>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingAnalyzeContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participant,
            __audio_config,
            __text_config,
            __reply_audio_config,
            __input_audio,
            __input_text,
            __input_dtmf,
            __query_params,
            __assist_query_params,
            __cx_parameters,
            __enable_extended_streaming,
            __enable_partial_automated_agent_reply,
            __enable_debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingAnalyzeContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participant" => Ok(__FieldTag::__participant),
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "textConfig" => Ok(__FieldTag::__text_config),
                            "text_config" => Ok(__FieldTag::__text_config),
                            "replyAudioConfig" => Ok(__FieldTag::__reply_audio_config),
                            "reply_audio_config" => Ok(__FieldTag::__reply_audio_config),
                            "inputAudio" => Ok(__FieldTag::__input_audio),
                            "input_audio" => Ok(__FieldTag::__input_audio),
                            "inputText" => Ok(__FieldTag::__input_text),
                            "input_text" => Ok(__FieldTag::__input_text),
                            "inputDtmf" => Ok(__FieldTag::__input_dtmf),
                            "input_dtmf" => Ok(__FieldTag::__input_dtmf),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            "cxParameters" => Ok(__FieldTag::__cx_parameters),
                            "cx_parameters" => Ok(__FieldTag::__cx_parameters),
                            "enableExtendedStreaming" => Ok(__FieldTag::__enable_extended_streaming),
                            "enable_extended_streaming" => Ok(__FieldTag::__enable_extended_streaming),
                            "enablePartialAutomatedAgentReply" => Ok(__FieldTag::__enable_partial_automated_agent_reply),
                            "enable_partial_automated_agent_reply" => Ok(__FieldTag::__enable_partial_automated_agent_reply),
                            "enableDebuggingInfo" => Ok(__FieldTag::__enable_debugging_info),
                            "enable_debugging_info" => Ok(__FieldTag::__enable_debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingAnalyzeContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingAnalyzeContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for participant"));
                            }
                            result.participant = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_config"));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.audio_config, latest field was audioConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Config::AudioConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InputAudioConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__text_config => {
                            if !fields.insert(__FieldTag::__text_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_config"));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.text_config, latest field was textConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Config::TextConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InputTextConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__reply_audio_config => {
                            if !fields.insert(__FieldTag::__reply_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply_audio_config"));
                            }
                            result.reply_audio_config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__input_audio => {
                            if !fields.insert(__FieldTag::__input_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_audio, latest field was inputAudio",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Input::InputAudio(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__input_text => {
                            if !fields.insert(__FieldTag::__input_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_text"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_text, latest field was inputText",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Input::InputText(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__input_dtmf => {
                            if !fields.insert(__FieldTag::__input_dtmf) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_dtmf"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_dtmf, latest field was inputDtmf",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Input::InputDtmf(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TelephonyDtmfEvents>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_params"));
                            }
                            result.query_params = map.next_value::<std::option::Option<crate::model::QueryParameters>>()?
                                ;
                        },
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for assist_query_params"));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        },
                        __FieldTag::__cx_parameters => {
                            if !fields.insert(__FieldTag::__cx_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cx_parameters"));
                            }
                            result.cx_parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__enable_extended_streaming => {
                            if !fields.insert(__FieldTag::__enable_extended_streaming) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_extended_streaming"));
                            }
                            result.enable_extended_streaming = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_partial_automated_agent_reply => {
                            if !fields.insert(__FieldTag::__enable_partial_automated_agent_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_partial_automated_agent_reply"));
                            }
                            result.enable_partial_automated_agent_reply = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_debugging_info => {
                            if !fields.insert(__FieldTag::__enable_debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_debugging_info"));
                            }
                            result.enable_debugging_info = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingAnalyzeContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognition_result,
            __reply_text,
            __reply_audio,
            __automated_agent_reply,
            __message,
            __human_agent_suggestion_results,
            __end_user_suggestion_results,
            __dtmf_parameters,
            __debugging_info,
            __speech_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingAnalyzeContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognitionResult" => Ok(__FieldTag::__recognition_result),
                            "recognition_result" => Ok(__FieldTag::__recognition_result),
                            "replyText" => Ok(__FieldTag::__reply_text),
                            "reply_text" => Ok(__FieldTag::__reply_text),
                            "replyAudio" => Ok(__FieldTag::__reply_audio),
                            "reply_audio" => Ok(__FieldTag::__reply_audio),
                            "automatedAgentReply" => Ok(__FieldTag::__automated_agent_reply),
                            "automated_agent_reply" => Ok(__FieldTag::__automated_agent_reply),
                            "message" => Ok(__FieldTag::__message),
                            "humanAgentSuggestionResults" => Ok(__FieldTag::__human_agent_suggestion_results),
                            "human_agent_suggestion_results" => Ok(__FieldTag::__human_agent_suggestion_results),
                            "endUserSuggestionResults" => Ok(__FieldTag::__end_user_suggestion_results),
                            "end_user_suggestion_results" => Ok(__FieldTag::__end_user_suggestion_results),
                            "dtmfParameters" => Ok(__FieldTag::__dtmf_parameters),
                            "dtmf_parameters" => Ok(__FieldTag::__dtmf_parameters),
                            "debuggingInfo" => Ok(__FieldTag::__debugging_info),
                            "debugging_info" => Ok(__FieldTag::__debugging_info),
                            "speechModel" => Ok(__FieldTag::__speech_model),
                            "speech_model" => Ok(__FieldTag::__speech_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingAnalyzeContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingAnalyzeContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognition_result => {
                            if !fields.insert(__FieldTag::__recognition_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for recognition_result"));
                            }
                            result.recognition_result = map.next_value::<std::option::Option<crate::model::StreamingRecognitionResult>>()?
                                ;
                        },
                        __FieldTag::__reply_text => {
                            if !fields.insert(__FieldTag::__reply_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply_text"));
                            }
                            result.reply_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__reply_audio => {
                            if !fields.insert(__FieldTag::__reply_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply_audio"));
                            }
                            result.reply_audio = map.next_value::<std::option::Option<crate::model::OutputAudio>>()?
                                ;
                        },
                        __FieldTag::__automated_agent_reply => {
                            if !fields.insert(__FieldTag::__automated_agent_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for automated_agent_reply"));
                            }
                            result.automated_agent_reply = map.next_value::<std::option::Option<crate::model::AutomatedAgentReply>>()?
                                ;
                        },
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message"));
                            }
                            result.message = map.next_value::<std::option::Option<crate::model::Message>>()?
                                ;
                        },
                        __FieldTag::__human_agent_suggestion_results => {
                            if !fields.insert(__FieldTag::__human_agent_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for human_agent_suggestion_results"));
                            }
                            result.human_agent_suggestion_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SuggestionResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__end_user_suggestion_results => {
                            if !fields.insert(__FieldTag::__end_user_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_user_suggestion_results"));
                            }
                            result.end_user_suggestion_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SuggestionResult>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dtmf_parameters => {
                            if !fields.insert(__FieldTag::__dtmf_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dtmf_parameters"));
                            }
                            result.dtmf_parameters = map.next_value::<std::option::Option<crate::model::DtmfParameters>>()?
                                ;
                        },
                        __FieldTag::__debugging_info => {
                            if !fields.insert(__FieldTag::__debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for debugging_info"));
                            }
                            result.debugging_info = map.next_value::<std::option::Option<crate::model::CloudConversationDebuggingInfo>>()?
                                ;
                        },
                        __FieldTag::__speech_model => {
                            if !fields.insert(__FieldTag::__speech_model) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_model"));
                            }
                            result.speech_model = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestArticlesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __latest_message,
            __context_size,
            __assist_query_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestArticlesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestArticlesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestArticlesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for assist_query_params"));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestArticlesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __article_answers,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestArticlesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "articleAnswers" => Ok(__FieldTag::__article_answers),
                            "article_answers" => Ok(__FieldTag::__article_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestArticlesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestArticlesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__article_answers => {
                            if !fields.insert(__FieldTag::__article_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for article_answers"));
                            }
                            result.article_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ArticleAnswer>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestFaqAnswersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __latest_message,
            __context_size,
            __assist_query_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestFaqAnswersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestFaqAnswersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestFaqAnswersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for assist_query_params"));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestFaqAnswersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __faq_answers,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestFaqAnswersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "faqAnswers" => Ok(__FieldTag::__faq_answers),
                            "faq_answers" => Ok(__FieldTag::__faq_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestFaqAnswersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestFaqAnswersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__faq_answers => {
                            if !fields.insert(__FieldTag::__faq_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for faq_answers"));
                            }
                            result.faq_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FaqAnswer>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GenerateSuggestionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_suggestion_answers,
            __latest_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateSuggestionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorSuggestionAnswers" => Ok(__FieldTag::__generator_suggestion_answers),
                            "generator_suggestion_answers" => Ok(__FieldTag::__generator_suggestion_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GenerateSuggestionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateSuggestionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_suggestion_answers => {
                            if !fields.insert(__FieldTag::__generator_suggestion_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_suggestion_answers"));
                            }
                            result.generator_suggestion_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::generate_suggestions_response::GeneratorSuggestionAnswer>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::generate_suggestions_response::GeneratorSuggestionAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_suggestion,
            __source_generator,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeneratorSuggestionAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorSuggestion" => Ok(__FieldTag::__generator_suggestion),
                            "generator_suggestion" => Ok(__FieldTag::__generator_suggestion),
                            "sourceGenerator" => Ok(__FieldTag::__source_generator),
                            "source_generator" => Ok(__FieldTag::__source_generator),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::generate_suggestions_response::GeneratorSuggestionAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeneratorSuggestionAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_suggestion => {
                            if !fields.insert(__FieldTag::__generator_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generator_suggestion"));
                            }
                            result.generator_suggestion = map.next_value::<std::option::Option<crate::model::GeneratorSuggestion>>()?
                                ;
                        },
                        __FieldTag::__source_generator => {
                            if !fields.insert(__FieldTag::__source_generator) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_generator"));
                            }
                            result.source_generator = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestSmartRepliesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __current_text_input,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestSmartRepliesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "currentTextInput" => Ok(__FieldTag::__current_text_input),
                            "current_text_input" => Ok(__FieldTag::__current_text_input),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestSmartRepliesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestSmartRepliesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__current_text_input => {
                            if !fields.insert(__FieldTag::__current_text_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for current_text_input"));
                            }
                            result.current_text_input = map.next_value::<std::option::Option<crate::model::TextInput>>()?
                                ;
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestSmartRepliesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __smart_reply_answers,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestSmartRepliesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "smartReplyAnswers" => Ok(__FieldTag::__smart_reply_answers),
                            "smart_reply_answers" => Ok(__FieldTag::__smart_reply_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestSmartRepliesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestSmartRepliesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__smart_reply_answers => {
                            if !fields.insert(__FieldTag::__smart_reply_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for smart_reply_answers"));
                            }
                            result.smart_reply_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SmartReplyAnswer>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AudioInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "audio" => Ok(__FieldTag::__audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AudioInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for config"));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::InputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OutputAudio {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputAudio")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "audio" => Ok(__FieldTag::__audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OutputAudio;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputAudio")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for config"));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutomatedAgentReply {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __detect_intent_response,
            __automated_agent_reply_type,
            __allow_cancellation,
            __cx_current_page,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomatedAgentReply")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "detectIntentResponse" => Ok(__FieldTag::__detect_intent_response),
                            "detect_intent_response" => Ok(__FieldTag::__detect_intent_response),
                            "automatedAgentReplyType" => Ok(__FieldTag::__automated_agent_reply_type),
                            "automated_agent_reply_type" => Ok(__FieldTag::__automated_agent_reply_type),
                            "allowCancellation" => Ok(__FieldTag::__allow_cancellation),
                            "allow_cancellation" => Ok(__FieldTag::__allow_cancellation),
                            "cxCurrentPage" => Ok(__FieldTag::__cx_current_page),
                            "cx_current_page" => Ok(__FieldTag::__cx_current_page),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutomatedAgentReply;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomatedAgentReply")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__detect_intent_response => {
                            if !fields.insert(__FieldTag::__detect_intent_response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for detect_intent_response"));
                            }
                            result.detect_intent_response = map.next_value::<std::option::Option<crate::model::DetectIntentResponse>>()?
                                ;
                        },
                        __FieldTag::__automated_agent_reply_type => {
                            if !fields.insert(__FieldTag::__automated_agent_reply_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for automated_agent_reply_type"));
                            }
                            result.automated_agent_reply_type = map.next_value::<std::option::Option<crate::model::automated_agent_reply::AutomatedAgentReplyType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__allow_cancellation => {
                            if !fields.insert(__FieldTag::__allow_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allow_cancellation"));
                            }
                            result.allow_cancellation = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cx_current_page => {
                            if !fields.insert(__FieldTag::__cx_current_page) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cx_current_page"));
                            }
                            result.cx_current_page = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ArticleAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __uri,
            __snippets,
            __confidence,
            __metadata,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArticleAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "uri" => Ok(__FieldTag::__uri),
                            "snippets" => Ok(__FieldTag::__snippets),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ArticleAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArticleAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__snippets => {
                            if !fields.insert(__FieldTag::__snippets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for snippets"));
                            }
                            result.snippets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FaqAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer,
            __confidence,
            __question,
            __source,
            __metadata,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FaqAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answer" => Ok(__FieldTag::__answer),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "question" => Ok(__FieldTag::__question),
                            "source" => Ok(__FieldTag::__source),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FaqAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FaqAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer"));
                            }
                            result.answer = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__question => {
                            if !fields.insert(__FieldTag::__question) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for question"));
                            }
                            result.question = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source"));
                            }
                            result.source = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SmartReplyAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reply,
            __confidence,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reply" => Ok(__FieldTag::__reply),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SmartReplyAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reply => {
                            if !fields.insert(__FieldTag::__reply) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reply"));
                            }
                            result.reply = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IntentSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __intent_v2,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "intentV2" => Ok(__FieldTag::__intent_v2),
                            "intent_v2" => Ok(__FieldTag::__intent_v2),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IntentSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent_v2 => {
                            if !fields.insert(__FieldTag::__intent_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_v2"));
                            }
                            if result.intent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intent`, a oneof with full ID .google.cloud.dialogflow.v2.IntentSuggestion.intent_v2, latest field was intentV2",
                                ));
                            }
                            result.intent = std::option::Option::Some(
                                crate::model::intent_suggestion::Intent::IntentV2(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DialogflowAssistAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_result,
            __intent_suggestion,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DialogflowAssistAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "intentSuggestion" => Ok(__FieldTag::__intent_suggestion),
                            "intent_suggestion" => Ok(__FieldTag::__intent_suggestion),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DialogflowAssistAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DialogflowAssistAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_result"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.DialogflowAssistAnswer.query_result, latest field was queryResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::dialogflow_assist_answer::Result::QueryResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::QueryResult>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__intent_suggestion => {
                            if !fields.insert(__FieldTag::__intent_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_suggestion"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.DialogflowAssistAnswer.intent_suggestion, latest field was intentSuggestion",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::dialogflow_assist_answer::Result::IntentSuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::IntentSuggestion>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            __suggest_articles_response,
            __suggest_knowledge_assist_response,
            __suggest_faq_answers_response,
            __suggest_smart_replies_response,
            __generate_suggestions_response,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            "suggestArticlesResponse" => Ok(__FieldTag::__suggest_articles_response),
                            "suggest_articles_response" => Ok(__FieldTag::__suggest_articles_response),
                            "suggestKnowledgeAssistResponse" => Ok(__FieldTag::__suggest_knowledge_assist_response),
                            "suggest_knowledge_assist_response" => Ok(__FieldTag::__suggest_knowledge_assist_response),
                            "suggestFaqAnswersResponse" => Ok(__FieldTag::__suggest_faq_answers_response),
                            "suggest_faq_answers_response" => Ok(__FieldTag::__suggest_faq_answers_response),
                            "suggestSmartRepliesResponse" => Ok(__FieldTag::__suggest_smart_replies_response),
                            "suggest_smart_replies_response" => Ok(__FieldTag::__suggest_smart_replies_response),
                            "generateSuggestionsResponse" => Ok(__FieldTag::__generate_suggestions_response),
                            "generate_suggestions_response" => Ok(__FieldTag::__generate_suggestions_response),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error"));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.error, latest field was error",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::Error(
                                    map.next_value::<std::option::Option<std::boxed::Box<rpc::model::Status>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__suggest_articles_response => {
                            if !fields.insert(__FieldTag::__suggest_articles_response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggest_articles_response"));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_articles_response, latest field was suggestArticlesResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestArticlesResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestArticlesResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__suggest_knowledge_assist_response => {
                            if !fields.insert(__FieldTag::__suggest_knowledge_assist_response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggest_knowledge_assist_response"));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_knowledge_assist_response, latest field was suggestKnowledgeAssistResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestKnowledgeAssistResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestKnowledgeAssistResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__suggest_faq_answers_response => {
                            if !fields.insert(__FieldTag::__suggest_faq_answers_response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggest_faq_answers_response"));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_faq_answers_response, latest field was suggestFaqAnswersResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestFaqAnswersResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestFaqAnswersResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__suggest_smart_replies_response => {
                            if !fields.insert(__FieldTag::__suggest_smart_replies_response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggest_smart_replies_response"));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_smart_replies_response, latest field was suggestSmartRepliesResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestSmartRepliesResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestSmartRepliesResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__generate_suggestions_response => {
                            if !fields.insert(__FieldTag::__generate_suggestions_response) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generate_suggestions_response"));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.generate_suggestions_response, latest field was generateSuggestionsResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::GenerateSuggestionsResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GenerateSuggestionsResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InputTextConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputTextConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InputTextConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputTextConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AnnotatedMessagePart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __entity_type,
            __formatted_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotatedMessagePart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "formattedValue" => Ok(__FieldTag::__formatted_value),
                            "formatted_value" => Ok(__FieldTag::__formatted_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AnnotatedMessagePart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotatedMessagePart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_type"));
                            }
                            result.entity_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__formatted_value => {
                            if !fields.insert(__FieldTag::__formatted_value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for formatted_value"));
                            }
                            result.formatted_value = map.next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null))
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parts,
            __contain_entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parts" => Ok(__FieldTag::__parts),
                            "containEntities" => Ok(__FieldTag::__contain_entities),
                            "contain_entities" => Ok(__FieldTag::__contain_entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parts => {
                            if !fields.insert(__FieldTag::__parts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parts"));
                            }
                            result.parts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AnnotatedMessagePart>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__contain_entities => {
                            if !fields.insert(__FieldTag::__contain_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for contain_entities"));
                            }
                            result.contain_entities = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestionInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_record,
            __parameters,
            __action,
            __send_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "action" => Ok(__FieldTag::__action),
                            "sendTime" => Ok(__FieldTag::__send_time),
                            "send_time" => Ok(__FieldTag::__send_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestionInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parameters"));
                            }
                            result.parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<crate::model::suggestion_input::Action>>()?.unwrap_or_default();
                        },
                        __FieldTag::__send_time => {
                            if !fields.insert(__FieldTag::__send_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for send_time"));
                            }
                            result.send_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AssistQueryParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents_metadata_filters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssistQueryParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documentsMetadataFilters" => Ok(__FieldTag::__documents_metadata_filters),
                            "documents_metadata_filters" => Ok(__FieldTag::__documents_metadata_filters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AssistQueryParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssistQueryParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents_metadata_filters => {
                            if !fields.insert(__FieldTag::__documents_metadata_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for documents_metadata_filters"));
                            }
                            result.documents_metadata_filters = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestKnowledgeAssistRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __latest_message,
            __context_size,
            __previous_suggested_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestKnowledgeAssistRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "previousSuggestedQuery" => Ok(__FieldTag::__previous_suggested_query),
                            "previous_suggested_query" => Ok(__FieldTag::__previous_suggested_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestKnowledgeAssistRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestKnowledgeAssistRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__previous_suggested_query => {
                            if !fields.insert(__FieldTag::__previous_suggested_query) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for previous_suggested_query"));
                            }
                            result.previous_suggested_query = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SuggestKnowledgeAssistResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_assist_answer,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestKnowledgeAssistResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeAssistAnswer" => Ok(__FieldTag::__knowledge_assist_answer),
                            "knowledge_assist_answer" => Ok(__FieldTag::__knowledge_assist_answer),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SuggestKnowledgeAssistResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestKnowledgeAssistResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_assist_answer => {
                            if !fields.insert(__FieldTag::__knowledge_assist_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for knowledge_assist_answer"));
                            }
                            result.knowledge_assist_answer = map.next_value::<std::option::Option<crate::model::KnowledgeAssistAnswer>>()?
                                ;
                        },
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latest_message"));
                            }
                            result.latest_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for context_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::KnowledgeAssistAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __suggested_query,
            __suggested_query_answer,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeAssistAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "suggestedQuery" => Ok(__FieldTag::__suggested_query),
                            "suggested_query" => Ok(__FieldTag::__suggested_query),
                            "suggestedQueryAnswer" => Ok(__FieldTag::__suggested_query_answer),
                            "suggested_query_answer" => Ok(__FieldTag::__suggested_query_answer),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::KnowledgeAssistAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeAssistAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__suggested_query => {
                            if !fields.insert(__FieldTag::__suggested_query) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggested_query"));
                            }
                            result.suggested_query = map.next_value::<std::option::Option<crate::model::knowledge_assist_answer::SuggestedQuery>>()?
                                ;
                        },
                        __FieldTag::__suggested_query_answer => {
                            if !fields.insert(__FieldTag::__suggested_query_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for suggested_query_answer"));
                            }
                            result.suggested_query_answer = map.next_value::<std::option::Option<crate::model::knowledge_assist_answer::KnowledgeAnswer>>()?
                                ;
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::knowledge_assist_answer::SuggestedQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestedQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryText" => Ok(__FieldTag::__query_text),
                            "query_text" => Ok(__FieldTag::__query_text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::knowledge_assist_answer::SuggestedQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestedQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_text => {
                            if !fields.insert(__FieldTag::__query_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_text"));
                            }
                            result.query_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::knowledge_assist_answer::KnowledgeAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_text,
            __faq_source,
            __generative_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerText" => Ok(__FieldTag::__answer_text),
                            "answer_text" => Ok(__FieldTag::__answer_text),
                            "faqSource" => Ok(__FieldTag::__faq_source),
                            "faq_source" => Ok(__FieldTag::__faq_source),
                            "generativeSource" => Ok(__FieldTag::__generative_source),
                            "generative_source" => Ok(__FieldTag::__generative_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::knowledge_assist_answer::KnowledgeAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_text => {
                            if !fields.insert(__FieldTag::__answer_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_text"));
                            }
                            result.answer_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__faq_source => {
                            if !fields.insert(__FieldTag::__faq_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for faq_source"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.faq_source, latest field was faqSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::knowledge_assist_answer::knowledge_answer::Source::FaqSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::knowledge_assist_answer::knowledge_answer::FaqSource>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__generative_source => {
                            if !fields.insert(__FieldTag::__generative_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generative_source"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.generative_source, latest field was generativeSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::knowledge_assist_answer::knowledge_answer::Source::GenerativeSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::knowledge_assist_answer::knowledge_answer::GenerativeSource>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::knowledge_assist_answer::knowledge_answer::FaqSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __question,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FaqSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "question" => Ok(__FieldTag::__question),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::knowledge_assist_answer::knowledge_answer::FaqSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FaqSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__question => {
                            if !fields.insert(__FieldTag::__question) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for question"));
                            }
                            result.question = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::knowledge_assist_answer::knowledge_answer::GenerativeSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snippets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerativeSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snippets" => Ok(__FieldTag::__snippets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::knowledge_assist_answer::knowledge_answer::GenerativeSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerativeSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snippets => {
                            if !fields.insert(__FieldTag::__snippets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for snippets"));
                            }
                            result.snippets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::knowledge_assist_answer::knowledge_answer::generative_source::Snippet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __text,
            __title,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Snippet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "text" => Ok(__FieldTag::__text),
                            "title" => Ok(__FieldTag::__title),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::knowledge_assist_answer::knowledge_answer::generative_source::Snippet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Snippet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for title"));
                            }
                            result.title = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __output_audio_config,
            __output_audio_config_mask,
            __input_audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "outputAudioConfigMask" => Ok(__FieldTag::__output_audio_config_mask),
                            "output_audio_config_mask" => Ok(__FieldTag::__output_audio_config_mask),
                            "inputAudio" => Ok(__FieldTag::__input_audio),
                            "input_audio" => Ok(__FieldTag::__input_audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session"));
                            }
                            result.session = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_params"));
                            }
                            result.query_params = map.next_value::<std::option::Option<crate::model::QueryParameters>>()?
                                ;
                        },
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_input"));
                            }
                            result.query_input = map.next_value::<std::option::Option<crate::model::QueryInput>>()?
                                ;
                        },
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_config"));
                            }
                            result.output_audio_config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__output_audio_config_mask => {
                            if !fields.insert(__FieldTag::__output_audio_config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_config_mask"));
                            }
                            result.output_audio_config_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__input_audio => {
                            if !fields.insert(__FieldTag::__input_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_audio = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DetectIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_id,
            __query_result,
            __webhook_status,
            __output_audio,
            __output_audio_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "webhookStatus" => Ok(__FieldTag::__webhook_status),
                            "webhook_status" => Ok(__FieldTag::__webhook_status),
                            "outputAudio" => Ok(__FieldTag::__output_audio),
                            "output_audio" => Ok(__FieldTag::__output_audio),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DetectIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response_id"));
                            }
                            result.response_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_result"));
                            }
                            result.query_result = map.next_value::<std::option::Option<crate::model::QueryResult>>()?
                                ;
                        },
                        __FieldTag::__webhook_status => {
                            if !fields.insert(__FieldTag::__webhook_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for webhook_status"));
                            }
                            result.webhook_status = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::__output_audio => {
                            if !fields.insert(__FieldTag::__output_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_audio = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_config"));
                            }
                            result.output_audio_config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_zone,
            __geo_location,
            __contexts,
            __reset_contexts,
            __session_entity_types,
            __payload,
            __sentiment_analysis_request_config,
            __webhook_headers,
            __platform,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "geoLocation" => Ok(__FieldTag::__geo_location),
                            "geo_location" => Ok(__FieldTag::__geo_location),
                            "contexts" => Ok(__FieldTag::__contexts),
                            "resetContexts" => Ok(__FieldTag::__reset_contexts),
                            "reset_contexts" => Ok(__FieldTag::__reset_contexts),
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            "payload" => Ok(__FieldTag::__payload),
                            "sentimentAnalysisRequestConfig" => Ok(__FieldTag::__sentiment_analysis_request_config),
                            "sentiment_analysis_request_config" => Ok(__FieldTag::__sentiment_analysis_request_config),
                            "webhookHeaders" => Ok(__FieldTag::__webhook_headers),
                            "webhook_headers" => Ok(__FieldTag::__webhook_headers),
                            "platform" => Ok(__FieldTag::__platform),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for time_zone"));
                            }
                            result.time_zone = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__geo_location => {
                            if !fields.insert(__FieldTag::__geo_location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for geo_location"));
                            }
                            result.geo_location = map.next_value::<std::option::Option<gtype::model::LatLng>>()?
                                ;
                        },
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for contexts"));
                            }
                            result.contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__reset_contexts => {
                            if !fields.insert(__FieldTag::__reset_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reset_contexts"));
                            }
                            result.reset_contexts = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_entity_types"));
                            }
                            result.session_entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SessionEntityType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for payload"));
                            }
                            result.payload = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__sentiment_analysis_request_config => {
                            if !fields.insert(__FieldTag::__sentiment_analysis_request_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sentiment_analysis_request_config"));
                            }
                            result.sentiment_analysis_request_config = map.next_value::<std::option::Option<crate::model::SentimentAnalysisRequestConfig>>()?
                                ;
                        },
                        __FieldTag::__webhook_headers => {
                            if !fields.insert(__FieldTag::__webhook_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for webhook_headers"));
                            }
                            result.webhook_headers = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for platform"));
                            }
                            result.platform = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_config,
            __text,
            __event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "text" => Ok(__FieldTag::__text),
                            "event" => Ok(__FieldTag::__event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_config"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.QueryInput.audio_config, latest field was audioConfig",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::query_input::Input::AudioConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InputAudioConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.QueryInput.text, latest field was text",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::query_input::Input::Text(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TextInput>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for event"));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.QueryInput.event, latest field was event",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::query_input::Input::Event(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::EventInput>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_text,
            __language_code,
            __speech_recognition_confidence,
            __action,
            __parameters,
            __all_required_params_present,
            __cancels_slot_filling,
            __fulfillment_text,
            __fulfillment_messages,
            __webhook_source,
            __webhook_payload,
            __output_contexts,
            __intent,
            __intent_detection_confidence,
            __diagnostic_info,
            __sentiment_analysis_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryText" => Ok(__FieldTag::__query_text),
                            "query_text" => Ok(__FieldTag::__query_text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "speechRecognitionConfidence" => Ok(__FieldTag::__speech_recognition_confidence),
                            "speech_recognition_confidence" => Ok(__FieldTag::__speech_recognition_confidence),
                            "action" => Ok(__FieldTag::__action),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "allRequiredParamsPresent" => Ok(__FieldTag::__all_required_params_present),
                            "all_required_params_present" => Ok(__FieldTag::__all_required_params_present),
                            "cancelsSlotFilling" => Ok(__FieldTag::__cancels_slot_filling),
                            "cancels_slot_filling" => Ok(__FieldTag::__cancels_slot_filling),
                            "fulfillmentText" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillment_text" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillmentMessages" => Ok(__FieldTag::__fulfillment_messages),
                            "fulfillment_messages" => Ok(__FieldTag::__fulfillment_messages),
                            "webhookSource" => Ok(__FieldTag::__webhook_source),
                            "webhook_source" => Ok(__FieldTag::__webhook_source),
                            "webhookPayload" => Ok(__FieldTag::__webhook_payload),
                            "webhook_payload" => Ok(__FieldTag::__webhook_payload),
                            "outputContexts" => Ok(__FieldTag::__output_contexts),
                            "output_contexts" => Ok(__FieldTag::__output_contexts),
                            "intent" => Ok(__FieldTag::__intent),
                            "intentDetectionConfidence" => Ok(__FieldTag::__intent_detection_confidence),
                            "intent_detection_confidence" => Ok(__FieldTag::__intent_detection_confidence),
                            "diagnosticInfo" => Ok(__FieldTag::__diagnostic_info),
                            "diagnostic_info" => Ok(__FieldTag::__diagnostic_info),
                            "sentimentAnalysisResult" => Ok(__FieldTag::__sentiment_analysis_result),
                            "sentiment_analysis_result" => Ok(__FieldTag::__sentiment_analysis_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_text => {
                            if !fields.insert(__FieldTag::__query_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_text"));
                            }
                            result.query_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__speech_recognition_confidence => {
                            if !fields.insert(__FieldTag::__speech_recognition_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_recognition_confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speech_recognition_confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parameters"));
                            }
                            result.parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__all_required_params_present => {
                            if !fields.insert(__FieldTag::__all_required_params_present) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for all_required_params_present"));
                            }
                            result.all_required_params_present = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cancels_slot_filling => {
                            if !fields.insert(__FieldTag::__cancels_slot_filling) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cancels_slot_filling"));
                            }
                            result.cancels_slot_filling = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__fulfillment_text => {
                            if !fields.insert(__FieldTag::__fulfillment_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fulfillment_text"));
                            }
                            result.fulfillment_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__fulfillment_messages => {
                            if !fields.insert(__FieldTag::__fulfillment_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fulfillment_messages"));
                            }
                            result.fulfillment_messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::Message>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__webhook_source => {
                            if !fields.insert(__FieldTag::__webhook_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for webhook_source"));
                            }
                            result.webhook_source = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__webhook_payload => {
                            if !fields.insert(__FieldTag::__webhook_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for webhook_payload"));
                            }
                            result.webhook_payload = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__output_contexts => {
                            if !fields.insert(__FieldTag::__output_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_contexts"));
                            }
                            result.output_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent"));
                            }
                            result.intent = map.next_value::<std::option::Option<crate::model::Intent>>()?
                                ;
                        },
                        __FieldTag::__intent_detection_confidence => {
                            if !fields.insert(__FieldTag::__intent_detection_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for intent_detection_confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intent_detection_confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__diagnostic_info => {
                            if !fields.insert(__FieldTag::__diagnostic_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for diagnostic_info"));
                            }
                            result.diagnostic_info = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__sentiment_analysis_result => {
                            if !fields.insert(__FieldTag::__sentiment_analysis_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sentiment_analysis_result"));
                            }
                            result.sentiment_analysis_result = map.next_value::<std::option::Option<crate::model::SentimentAnalysisResult>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingDetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __single_utterance,
            __output_audio_config,
            __output_audio_config_mask,
            __input_audio,
            __enable_debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingDetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "outputAudioConfigMask" => Ok(__FieldTag::__output_audio_config_mask),
                            "output_audio_config_mask" => Ok(__FieldTag::__output_audio_config_mask),
                            "inputAudio" => Ok(__FieldTag::__input_audio),
                            "input_audio" => Ok(__FieldTag::__input_audio),
                            "enableDebuggingInfo" => Ok(__FieldTag::__enable_debugging_info),
                            "enable_debugging_info" => Ok(__FieldTag::__enable_debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingDetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingDetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session"));
                            }
                            result.session = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_params"));
                            }
                            result.query_params = map.next_value::<std::option::Option<crate::model::QueryParameters>>()?
                                ;
                        },
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_input"));
                            }
                            result.query_input = map.next_value::<std::option::Option<crate::model::QueryInput>>()?
                                ;
                        },
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for single_utterance"));
                            }
                            result.single_utterance = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_config"));
                            }
                            result.output_audio_config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__output_audio_config_mask => {
                            if !fields.insert(__FieldTag::__output_audio_config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_config_mask"));
                            }
                            result.output_audio_config_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__input_audio => {
                            if !fields.insert(__FieldTag::__input_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_audio = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__enable_debugging_info => {
                            if !fields.insert(__FieldTag::__enable_debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_debugging_info"));
                            }
                            result.enable_debugging_info = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudConversationDebuggingInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_data_chunks,
            __result_end_time_offset,
            __first_audio_duration,
            __single_utterance,
            __speech_partial_results_end_times,
            __speech_final_results_end_times,
            __partial_responses,
            __speaker_id_passive_latency_ms_offset,
            __bargein_event_triggered,
            __speech_single_utterance,
            __dtmf_partial_results_times,
            __dtmf_final_results_times,
            __single_utterance_end_time_offset,
            __no_speech_timeout,
            __endpointing_timeout,
            __is_input_text,
            __client_half_close_time_offset,
            __client_half_close_streaming_time_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudConversationDebuggingInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioDataChunks" => Ok(__FieldTag::__audio_data_chunks),
                            "audio_data_chunks" => Ok(__FieldTag::__audio_data_chunks),
                            "resultEndTimeOffset" => Ok(__FieldTag::__result_end_time_offset),
                            "result_end_time_offset" => Ok(__FieldTag::__result_end_time_offset),
                            "firstAudioDuration" => Ok(__FieldTag::__first_audio_duration),
                            "first_audio_duration" => Ok(__FieldTag::__first_audio_duration),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "speechPartialResultsEndTimes" => Ok(__FieldTag::__speech_partial_results_end_times),
                            "speech_partial_results_end_times" => Ok(__FieldTag::__speech_partial_results_end_times),
                            "speechFinalResultsEndTimes" => Ok(__FieldTag::__speech_final_results_end_times),
                            "speech_final_results_end_times" => Ok(__FieldTag::__speech_final_results_end_times),
                            "partialResponses" => Ok(__FieldTag::__partial_responses),
                            "partial_responses" => Ok(__FieldTag::__partial_responses),
                            "speakerIdPassiveLatencyMsOffset" => Ok(__FieldTag::__speaker_id_passive_latency_ms_offset),
                            "speaker_id_passive_latency_ms_offset" => Ok(__FieldTag::__speaker_id_passive_latency_ms_offset),
                            "bargeinEventTriggered" => Ok(__FieldTag::__bargein_event_triggered),
                            "bargein_event_triggered" => Ok(__FieldTag::__bargein_event_triggered),
                            "speechSingleUtterance" => Ok(__FieldTag::__speech_single_utterance),
                            "speech_single_utterance" => Ok(__FieldTag::__speech_single_utterance),
                            "dtmfPartialResultsTimes" => Ok(__FieldTag::__dtmf_partial_results_times),
                            "dtmf_partial_results_times" => Ok(__FieldTag::__dtmf_partial_results_times),
                            "dtmfFinalResultsTimes" => Ok(__FieldTag::__dtmf_final_results_times),
                            "dtmf_final_results_times" => Ok(__FieldTag::__dtmf_final_results_times),
                            "singleUtteranceEndTimeOffset" => Ok(__FieldTag::__single_utterance_end_time_offset),
                            "single_utterance_end_time_offset" => Ok(__FieldTag::__single_utterance_end_time_offset),
                            "noSpeechTimeout" => Ok(__FieldTag::__no_speech_timeout),
                            "no_speech_timeout" => Ok(__FieldTag::__no_speech_timeout),
                            "endpointingTimeout" => Ok(__FieldTag::__endpointing_timeout),
                            "endpointing_timeout" => Ok(__FieldTag::__endpointing_timeout),
                            "isInputText" => Ok(__FieldTag::__is_input_text),
                            "is_input_text" => Ok(__FieldTag::__is_input_text),
                            "clientHalfCloseTimeOffset" => Ok(__FieldTag::__client_half_close_time_offset),
                            "client_half_close_time_offset" => Ok(__FieldTag::__client_half_close_time_offset),
                            "clientHalfCloseStreamingTimeOffset" => Ok(__FieldTag::__client_half_close_streaming_time_offset),
                            "client_half_close_streaming_time_offset" => Ok(__FieldTag::__client_half_close_streaming_time_offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudConversationDebuggingInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudConversationDebuggingInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_data_chunks => {
                            if !fields.insert(__FieldTag::__audio_data_chunks) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for audio_data_chunks"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_data_chunks = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__result_end_time_offset => {
                            if !fields.insert(__FieldTag::__result_end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for result_end_time_offset"));
                            }
                            result.result_end_time_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__first_audio_duration => {
                            if !fields.insert(__FieldTag::__first_audio_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for first_audio_duration"));
                            }
                            result.first_audio_duration = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for single_utterance"));
                            }
                            result.single_utterance = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__speech_partial_results_end_times => {
                            if !fields.insert(__FieldTag::__speech_partial_results_end_times) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_partial_results_end_times"));
                            }
                            result.speech_partial_results_end_times = map.next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__speech_final_results_end_times => {
                            if !fields.insert(__FieldTag::__speech_final_results_end_times) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_final_results_end_times"));
                            }
                            result.speech_final_results_end_times = map.next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__partial_responses => {
                            if !fields.insert(__FieldTag::__partial_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for partial_responses"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.partial_responses = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__speaker_id_passive_latency_ms_offset => {
                            if !fields.insert(__FieldTag::__speaker_id_passive_latency_ms_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speaker_id_passive_latency_ms_offset"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaker_id_passive_latency_ms_offset = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__bargein_event_triggered => {
                            if !fields.insert(__FieldTag::__bargein_event_triggered) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bargein_event_triggered"));
                            }
                            result.bargein_event_triggered = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__speech_single_utterance => {
                            if !fields.insert(__FieldTag::__speech_single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_single_utterance"));
                            }
                            result.speech_single_utterance = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dtmf_partial_results_times => {
                            if !fields.insert(__FieldTag::__dtmf_partial_results_times) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dtmf_partial_results_times"));
                            }
                            result.dtmf_partial_results_times = map.next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dtmf_final_results_times => {
                            if !fields.insert(__FieldTag::__dtmf_final_results_times) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dtmf_final_results_times"));
                            }
                            result.dtmf_final_results_times = map.next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__single_utterance_end_time_offset => {
                            if !fields.insert(__FieldTag::__single_utterance_end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for single_utterance_end_time_offset"));
                            }
                            result.single_utterance_end_time_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__no_speech_timeout => {
                            if !fields.insert(__FieldTag::__no_speech_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for no_speech_timeout"));
                            }
                            result.no_speech_timeout = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__endpointing_timeout => {
                            if !fields.insert(__FieldTag::__endpointing_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for endpointing_timeout"));
                            }
                            result.endpointing_timeout = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__is_input_text => {
                            if !fields.insert(__FieldTag::__is_input_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_input_text"));
                            }
                            result.is_input_text = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__client_half_close_time_offset => {
                            if !fields.insert(__FieldTag::__client_half_close_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for client_half_close_time_offset"));
                            }
                            result.client_half_close_time_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__client_half_close_streaming_time_offset => {
                            if !fields.insert(__FieldTag::__client_half_close_streaming_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for client_half_close_streaming_time_offset"));
                            }
                            result.client_half_close_streaming_time_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingDetectIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_id,
            __recognition_result,
            __query_result,
            __webhook_status,
            __output_audio,
            __output_audio_config,
            __debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingDetectIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "recognitionResult" => Ok(__FieldTag::__recognition_result),
                            "recognition_result" => Ok(__FieldTag::__recognition_result),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "webhookStatus" => Ok(__FieldTag::__webhook_status),
                            "webhook_status" => Ok(__FieldTag::__webhook_status),
                            "outputAudio" => Ok(__FieldTag::__output_audio),
                            "output_audio" => Ok(__FieldTag::__output_audio),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "debuggingInfo" => Ok(__FieldTag::__debugging_info),
                            "debugging_info" => Ok(__FieldTag::__debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingDetectIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingDetectIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response_id"));
                            }
                            result.response_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__recognition_result => {
                            if !fields.insert(__FieldTag::__recognition_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for recognition_result"));
                            }
                            result.recognition_result = map.next_value::<std::option::Option<crate::model::StreamingRecognitionResult>>()?
                                ;
                        },
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_result"));
                            }
                            result.query_result = map.next_value::<std::option::Option<crate::model::QueryResult>>()?
                                ;
                        },
                        __FieldTag::__webhook_status => {
                            if !fields.insert(__FieldTag::__webhook_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for webhook_status"));
                            }
                            result.webhook_status = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::__output_audio => {
                            if !fields.insert(__FieldTag::__output_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_audio = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_audio_config"));
                            }
                            result.output_audio_config = map.next_value::<std::option::Option<crate::model::OutputAudioConfig>>()?
                                ;
                        },
                        __FieldTag::__debugging_info => {
                            if !fields.insert(__FieldTag::__debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for debugging_info"));
                            }
                            result.debugging_info = map.next_value::<std::option::Option<crate::model::CloudConversationDebuggingInfo>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingRecognitionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_type,
            __transcript,
            __is_final,
            __confidence,
            __speech_word_info,
            __speech_end_offset,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognitionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "isFinal" => Ok(__FieldTag::__is_final),
                            "is_final" => Ok(__FieldTag::__is_final),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "speechWordInfo" => Ok(__FieldTag::__speech_word_info),
                            "speech_word_info" => Ok(__FieldTag::__speech_word_info),
                            "speechEndOffset" => Ok(__FieldTag::__speech_end_offset),
                            "speech_end_offset" => Ok(__FieldTag::__speech_end_offset),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingRecognitionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognitionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_type"));
                            }
                            result.message_type = map.next_value::<std::option::Option<crate::model::streaming_recognition_result::MessageType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for transcript"));
                            }
                            result.transcript = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__is_final => {
                            if !fields.insert(__FieldTag::__is_final) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_final"));
                            }
                            result.is_final = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for confidence"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__speech_word_info => {
                            if !fields.insert(__FieldTag::__speech_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_word_info"));
                            }
                            result.speech_word_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SpeechWordInfo>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__speech_end_offset => {
                            if !fields.insert(__FieldTag::__speech_end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for speech_end_offset"));
                            }
                            result.speech_end_offset = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "conversations",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TextInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TextInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text"));
                            }
                            result.text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EventInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __parameters,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EventInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parameters"));
                            }
                            result.parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for language_code"));
                            }
                            result.language_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SentimentAnalysisRequestConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analyze_query_text_sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SentimentAnalysisRequestConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analyzeQueryTextSentiment" => Ok(__FieldTag::__analyze_query_text_sentiment),
                            "analyze_query_text_sentiment" => Ok(__FieldTag::__analyze_query_text_sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SentimentAnalysisRequestConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SentimentAnalysisRequestConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analyze_query_text_sentiment => {
                            if !fields.insert(__FieldTag::__analyze_query_text_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for analyze_query_text_sentiment"));
                            }
                            result.analyze_query_text_sentiment = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SentimentAnalysisResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_text_sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SentimentAnalysisResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryTextSentiment" => Ok(__FieldTag::__query_text_sentiment),
                            "query_text_sentiment" => Ok(__FieldTag::__query_text_sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SentimentAnalysisResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SentimentAnalysisResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_text_sentiment => {
                            if !fields.insert(__FieldTag::__query_text_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_text_sentiment"));
                            }
                            result.query_text_sentiment = map.next_value::<std::option::Option<crate::model::Sentiment>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "participants",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Sentiment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            __magnitude,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sentiment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            "magnitude" => Ok(__FieldTag::__magnitude),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Sentiment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sentiment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for score"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__magnitude => {
                            if !fields.insert(__FieldTag::__magnitude) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for magnitude"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.magnitude = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "participants",feature = "session-entity-types",feature = "sessions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SessionEntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __entity_override_mode,
            __entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionEntityType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "entityOverrideMode" => Ok(__FieldTag::__entity_override_mode),
                            "entity_override_mode" => Ok(__FieldTag::__entity_override_mode),
                            "entities" => Ok(__FieldTag::__entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SessionEntityType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionEntityType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_override_mode => {
                            if !fields.insert(__FieldTag::__entity_override_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_override_mode"));
                            }
                            result.entity_override_mode = map.next_value::<std::option::Option<crate::model::session_entity_type::EntityOverrideMode>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entities"));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::entity_type::Entity>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListSessionEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListSessionEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListSessionEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_entity_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListSessionEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_entity_types"));
                            }
                            result.session_entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SessionEntityType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __session_entity_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sessionEntityType" => Ok(__FieldTag::__session_entity_type),
                            "session_entity_type" => Ok(__FieldTag::__session_entity_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__session_entity_type => {
                            if !fields.insert(__FieldTag::__session_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_entity_type"));
                            }
                            result.session_entity_type = map.next_value::<std::option::Option<crate::model::SessionEntityType>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_entity_type,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionEntityType" => Ok(__FieldTag::__session_entity_type),
                            "session_entity_type" => Ok(__FieldTag::__session_entity_type),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_entity_type => {
                            if !fields.insert(__FieldTag::__session_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_entity_type"));
                            }
                            result.session_entity_type = map.next_value::<std::option::Option<crate::model::SessionEntityType>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateSipTrunkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __sip_trunk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSipTrunkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sipTrunk" => Ok(__FieldTag::__sip_trunk),
                            "sip_trunk" => Ok(__FieldTag::__sip_trunk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateSipTrunkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSipTrunkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sip_trunk => {
                            if !fields.insert(__FieldTag::__sip_trunk) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sip_trunk"));
                            }
                            result.sip_trunk = map.next_value::<std::option::Option<crate::model::SipTrunk>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteSipTrunkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSipTrunkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteSipTrunkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSipTrunkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListSipTrunksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSipTrunksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListSipTrunksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSipTrunksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListSipTrunksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sip_trunks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSipTrunksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sipTrunks" => Ok(__FieldTag::__sip_trunks),
                            "sip_trunks" => Ok(__FieldTag::__sip_trunks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListSipTrunksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSipTrunksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sip_trunks => {
                            if !fields.insert(__FieldTag::__sip_trunks) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sip_trunks"));
                            }
                            result.sip_trunks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SipTrunk>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetSipTrunkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSipTrunkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetSipTrunkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSipTrunkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateSipTrunkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sip_trunk,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSipTrunkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sipTrunk" => Ok(__FieldTag::__sip_trunk),
                            "sip_trunk" => Ok(__FieldTag::__sip_trunk),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateSipTrunkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSipTrunkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sip_trunk => {
                            if !fields.insert(__FieldTag::__sip_trunk) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sip_trunk"));
                            }
                            result.sip_trunk = map.next_value::<std::option::Option<crate::model::SipTrunk>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SipTrunk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __expected_hostname,
            __connections,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SipTrunk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "expectedHostname" => Ok(__FieldTag::__expected_hostname),
                            "expected_hostname" => Ok(__FieldTag::__expected_hostname),
                            "connections" => Ok(__FieldTag::__connections),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SipTrunk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SipTrunk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__expected_hostname => {
                            if !fields.insert(__FieldTag::__expected_hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for expected_hostname"));
                            }
                            result.expected_hostname = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for connections"));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_id,
            __state,
            __update_time,
            __error_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "state" => Ok(__FieldTag::__state),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "errorDetails" => Ok(__FieldTag::__error_details),
                            "error_details" => Ok(__FieldTag::__error_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for connection_id"));
                            }
                            result.connection_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::connection::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__error_details => {
                            if !fields.insert(__FieldTag::__error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_details"));
                            }
                            result.error_details = map.next_value::<std::option::Option<crate::model::connection::ErrorDetails>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sip-trunks" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::connection::ErrorDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_state,
            __error_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateState" => Ok(__FieldTag::__certificate_state),
                            "certificate_state" => Ok(__FieldTag::__certificate_state),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::connection::ErrorDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_state => {
                            if !fields.insert(__FieldTag::__certificate_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for certificate_state"));
                            }
                            result.certificate_state = map.next_value::<std::option::Option<crate::model::connection::CertificateState>>()?
                                ;
                        },
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_message"));
                            }
                            result.error_message = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateToolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tool,
            __tool_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateToolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tool" => Ok(__FieldTag::__tool),
                            "toolId" => Ok(__FieldTag::__tool_id),
                            "tool_id" => Ok(__FieldTag::__tool_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateToolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateToolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tool => {
                            if !fields.insert(__FieldTag::__tool) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool"));
                            }
                            result.tool = map.next_value::<std::option::Option<crate::model::Tool>>()?
                                ;
                        },
                        __FieldTag::__tool_id => {
                            if !fields.insert(__FieldTag::__tool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_id"));
                            }
                            result.tool_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetToolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetToolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetToolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetToolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListToolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListToolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListToolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListToolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListToolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListToolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tools" => Ok(__FieldTag::__tools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListToolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListToolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tools => {
                            if !fields.insert(__FieldTag::__tools) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tools"));
                            }
                            result.tools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tool>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteToolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteToolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteToolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteToolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateToolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tool,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateToolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tool" => Ok(__FieldTag::__tool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateToolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateToolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tool => {
                            if !fields.insert(__FieldTag::__tool) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool"));
                            }
                            result.tool = map.next_value::<std::option::Option<crate::model::Tool>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Tool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tool_key,
            __display_name,
            __description,
            __action_confirmation_requirement,
            __extension_spec,
            __function_spec,
            __connector_spec,
            __open_api_spec,
            __create_time,
            __update_time,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "toolKey" => Ok(__FieldTag::__tool_key),
                            "tool_key" => Ok(__FieldTag::__tool_key),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "actionConfirmationRequirement" => Ok(__FieldTag::__action_confirmation_requirement),
                            "action_confirmation_requirement" => Ok(__FieldTag::__action_confirmation_requirement),
                            "extensionSpec" => Ok(__FieldTag::__extension_spec),
                            "extension_spec" => Ok(__FieldTag::__extension_spec),
                            "functionSpec" => Ok(__FieldTag::__function_spec),
                            "function_spec" => Ok(__FieldTag::__function_spec),
                            "connectorSpec" => Ok(__FieldTag::__connector_spec),
                            "connector_spec" => Ok(__FieldTag::__connector_spec),
                            "openApiSpec" => Ok(__FieldTag::__open_api_spec),
                            "open_api_spec" => Ok(__FieldTag::__open_api_spec),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Tool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tool_key => {
                            if !fields.insert(__FieldTag::__tool_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_key"));
                            }
                            result.tool_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__action_confirmation_requirement => {
                            if !fields.insert(__FieldTag::__action_confirmation_requirement) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action_confirmation_requirement"));
                            }
                            result.action_confirmation_requirement = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::tool::ConfirmationRequirement>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__extension_spec => {
                            if !fields.insert(__FieldTag::__extension_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for extension_spec"));
                            }
                            if result.specification.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `specification`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.extension_spec, latest field was extensionSpec",
                                ));
                            }
                            result.specification = std::option::Option::Some(
                                crate::model::tool::Specification::ExtensionSpec(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::ExtensionTool>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__function_spec => {
                            if !fields.insert(__FieldTag::__function_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for function_spec"));
                            }
                            if result.specification.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `specification`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.function_spec, latest field was functionSpec",
                                ));
                            }
                            result.specification = std::option::Option::Some(
                                crate::model::tool::Specification::FunctionSpec(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::FunctionTool>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__connector_spec => {
                            if !fields.insert(__FieldTag::__connector_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for connector_spec"));
                            }
                            if result.specification.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `specification`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.connector_spec, latest field was connectorSpec",
                                ));
                            }
                            result.specification = std::option::Option::Some(
                                crate::model::tool::Specification::ConnectorSpec(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::ConnectorTool>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__open_api_spec => {
                            if !fields.insert(__FieldTag::__open_api_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for open_api_spec"));
                            }
                            if result.specification.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `specification`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.open_api_spec, latest field was openApiSpec",
                                ));
                            }
                            result.specification = std::option::Option::Some(
                                crate::model::tool::Specification::OpenApiSpec(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::OpenApiTool>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzs"));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzi"));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::ExtensionTool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExtensionTool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::ExtensionTool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtensionTool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::FunctionTool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_schema,
            __output_schema,
            __method_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FunctionTool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputSchema" => Ok(__FieldTag::__input_schema),
                            "input_schema" => Ok(__FieldTag::__input_schema),
                            "outputSchema" => Ok(__FieldTag::__output_schema),
                            "output_schema" => Ok(__FieldTag::__output_schema),
                            "methodType" => Ok(__FieldTag::__method_type),
                            "method_type" => Ok(__FieldTag::__method_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::FunctionTool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FunctionTool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_schema => {
                            if !fields.insert(__FieldTag::__input_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_schema"));
                            }
                            result.input_schema = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__output_schema => {
                            if !fields.insert(__FieldTag::__output_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_schema"));
                            }
                            result.output_schema = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__method_type => {
                            if !fields.insert(__FieldTag::__method_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for method_type"));
                            }
                            result.method_type = map.next_value::<std::option::Option<crate::model::tool::MethodType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::OpenApiTool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text_schema,
            __authentication,
            __tls_config,
            __service_directory_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpenApiTool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "textSchema" => Ok(__FieldTag::__text_schema),
                            "text_schema" => Ok(__FieldTag::__text_schema),
                            "authentication" => Ok(__FieldTag::__authentication),
                            "tlsConfig" => Ok(__FieldTag::__tls_config),
                            "tls_config" => Ok(__FieldTag::__tls_config),
                            "serviceDirectoryConfig" => Ok(__FieldTag::__service_directory_config),
                            "service_directory_config" => Ok(__FieldTag::__service_directory_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::OpenApiTool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpenApiTool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text_schema => {
                            if !fields.insert(__FieldTag::__text_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_schema"));
                            }
                            if result.schema.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.OpenApiTool.text_schema, latest field was textSchema",
                                ));
                            }
                            result.schema = std::option::Option::Some(
                                crate::model::tool::open_api_tool::Schema::TextSchema(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__authentication => {
                            if !fields.insert(__FieldTag::__authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for authentication"));
                            }
                            result.authentication = map.next_value::<std::option::Option<crate::model::tool::Authentication>>()?
                                ;
                        },
                        __FieldTag::__tls_config => {
                            if !fields.insert(__FieldTag::__tls_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tls_config"));
                            }
                            result.tls_config = map.next_value::<std::option::Option<crate::model::tool::TLSConfig>>()?
                                ;
                        },
                        __FieldTag::__service_directory_config => {
                            if !fields.insert(__FieldTag::__service_directory_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_directory_config"));
                            }
                            result.service_directory_config = map.next_value::<std::option::Option<crate::model::tool::ServiceDirectoryConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::ConnectorTool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectorTool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::ConnectorTool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectorTool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for actions"));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::tool::connector_tool::Action>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::connector_tool::Action {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_action_id,
            __entity_operation,
            __input_fields,
            __output_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Action")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionActionId" => Ok(__FieldTag::__connection_action_id),
                            "connection_action_id" => Ok(__FieldTag::__connection_action_id),
                            "entityOperation" => Ok(__FieldTag::__entity_operation),
                            "entity_operation" => Ok(__FieldTag::__entity_operation),
                            "inputFields" => Ok(__FieldTag::__input_fields),
                            "input_fields" => Ok(__FieldTag::__input_fields),
                            "outputFields" => Ok(__FieldTag::__output_fields),
                            "output_fields" => Ok(__FieldTag::__output_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::connector_tool::Action;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Action")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_action_id => {
                            if !fields.insert(__FieldTag::__connection_action_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for connection_action_id"));
                            }
                            if result.action_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action_spec`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.ConnectorTool.Action.connection_action_id, latest field was connectionActionId",
                                ));
                            }
                            result.action_spec = std::option::Option::Some(
                                crate::model::tool::connector_tool::action::ActionSpec::ConnectionActionId(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__entity_operation => {
                            if !fields.insert(__FieldTag::__entity_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_operation"));
                            }
                            if result.action_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action_spec`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.ConnectorTool.Action.entity_operation, latest field was entityOperation",
                                ));
                            }
                            result.action_spec = std::option::Option::Some(
                                crate::model::tool::connector_tool::action::ActionSpec::EntityOperation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::connector_tool::action::EntityOperation>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__input_fields => {
                            if !fields.insert(__FieldTag::__input_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_fields"));
                            }
                            result.input_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__output_fields => {
                            if !fields.insert(__FieldTag::__output_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_fields"));
                            }
                            result.output_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::connector_tool::action::EntityOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_id,
            __operation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            "operation" => Ok(__FieldTag::__operation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::connector_tool::action::EntityOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_id"));
                            }
                            result.entity_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for operation"));
                            }
                            result.operation = map.next_value::<std::option::Option<crate::model::tool::connector_tool::action::entity_operation::OperationType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::Authentication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __api_key_config,
            __oauth_config,
            __service_agent_auth_config,
            __bearer_token_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Authentication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apiKeyConfig" => Ok(__FieldTag::__api_key_config),
                            "api_key_config" => Ok(__FieldTag::__api_key_config),
                            "oauthConfig" => Ok(__FieldTag::__oauth_config),
                            "oauth_config" => Ok(__FieldTag::__oauth_config),
                            "serviceAgentAuthConfig" => Ok(__FieldTag::__service_agent_auth_config),
                            "service_agent_auth_config" => Ok(__FieldTag::__service_agent_auth_config),
                            "bearerTokenConfig" => Ok(__FieldTag::__bearer_token_config),
                            "bearer_token_config" => Ok(__FieldTag::__bearer_token_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::Authentication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Authentication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__api_key_config => {
                            if !fields.insert(__FieldTag::__api_key_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for api_key_config"));
                            }
                            if result.auth_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `auth_config`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.Authentication.api_key_config, latest field was apiKeyConfig",
                                ));
                            }
                            result.auth_config = std::option::Option::Some(
                                crate::model::tool::authentication::AuthConfig::ApiKeyConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::authentication::ApiKeyConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__oauth_config => {
                            if !fields.insert(__FieldTag::__oauth_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for oauth_config"));
                            }
                            if result.auth_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `auth_config`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.Authentication.oauth_config, latest field was oauthConfig",
                                ));
                            }
                            result.auth_config = std::option::Option::Some(
                                crate::model::tool::authentication::AuthConfig::OauthConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::authentication::OAuthConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__service_agent_auth_config => {
                            if !fields.insert(__FieldTag::__service_agent_auth_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_agent_auth_config"));
                            }
                            if result.auth_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `auth_config`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.Authentication.service_agent_auth_config, latest field was serviceAgentAuthConfig",
                                ));
                            }
                            result.auth_config = std::option::Option::Some(
                                crate::model::tool::authentication::AuthConfig::ServiceAgentAuthConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::authentication::ServiceAgentAuthConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__bearer_token_config => {
                            if !fields.insert(__FieldTag::__bearer_token_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bearer_token_config"));
                            }
                            if result.auth_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `auth_config`, a oneof with full ID .google.cloud.dialogflow.v2.Tool.Authentication.bearer_token_config, latest field was bearerTokenConfig",
                                ));
                            }
                            result.auth_config = std::option::Option::Some(
                                crate::model::tool::authentication::AuthConfig::BearerTokenConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool::authentication::BearerTokenConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::authentication::ApiKeyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_name,
            __api_key,
            __secret_version_for_api_key,
            __request_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiKeyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyName" => Ok(__FieldTag::__key_name),
                            "key_name" => Ok(__FieldTag::__key_name),
                            "apiKey" => Ok(__FieldTag::__api_key),
                            "api_key" => Ok(__FieldTag::__api_key),
                            "secretVersionForApiKey" => Ok(__FieldTag::__secret_version_for_api_key),
                            "secret_version_for_api_key" => Ok(__FieldTag::__secret_version_for_api_key),
                            "requestLocation" => Ok(__FieldTag::__request_location),
                            "request_location" => Ok(__FieldTag::__request_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::authentication::ApiKeyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiKeyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_name => {
                            if !fields.insert(__FieldTag::__key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for key_name"));
                            }
                            result.key_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__api_key => {
                            if !fields.insert(__FieldTag::__api_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for api_key"));
                            }
                            result.api_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__secret_version_for_api_key => {
                            if !fields.insert(__FieldTag::__secret_version_for_api_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for secret_version_for_api_key"));
                            }
                            result.secret_version_for_api_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__request_location => {
                            if !fields.insert(__FieldTag::__request_location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_location"));
                            }
                            result.request_location = map.next_value::<std::option::Option<crate::model::tool::authentication::RequestLocation>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::authentication::OAuthConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oauth_grant_type,
            __client_id,
            __client_secret,
            __secret_version_for_client_secret,
            __token_endpoint,
            __scopes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OAuthConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oauthGrantType" => Ok(__FieldTag::__oauth_grant_type),
                            "oauth_grant_type" => Ok(__FieldTag::__oauth_grant_type),
                            "clientId" => Ok(__FieldTag::__client_id),
                            "client_id" => Ok(__FieldTag::__client_id),
                            "clientSecret" => Ok(__FieldTag::__client_secret),
                            "client_secret" => Ok(__FieldTag::__client_secret),
                            "secretVersionForClientSecret" => Ok(__FieldTag::__secret_version_for_client_secret),
                            "secret_version_for_client_secret" => Ok(__FieldTag::__secret_version_for_client_secret),
                            "tokenEndpoint" => Ok(__FieldTag::__token_endpoint),
                            "token_endpoint" => Ok(__FieldTag::__token_endpoint),
                            "scopes" => Ok(__FieldTag::__scopes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::authentication::OAuthConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OAuthConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oauth_grant_type => {
                            if !fields.insert(__FieldTag::__oauth_grant_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for oauth_grant_type"));
                            }
                            result.oauth_grant_type = map.next_value::<std::option::Option<crate::model::tool::authentication::o_auth_config::OauthGrantType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__client_id => {
                            if !fields.insert(__FieldTag::__client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for client_id"));
                            }
                            result.client_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__client_secret => {
                            if !fields.insert(__FieldTag::__client_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for client_secret"));
                            }
                            result.client_secret = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__secret_version_for_client_secret => {
                            if !fields.insert(__FieldTag::__secret_version_for_client_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for secret_version_for_client_secret"));
                            }
                            result.secret_version_for_client_secret = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__token_endpoint => {
                            if !fields.insert(__FieldTag::__token_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for token_endpoint"));
                            }
                            result.token_endpoint = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for scopes"));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::authentication::ServiceAgentAuthConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_agent_auth,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceAgentAuthConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAgentAuth" => Ok(__FieldTag::__service_agent_auth),
                            "service_agent_auth" => Ok(__FieldTag::__service_agent_auth),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::authentication::ServiceAgentAuthConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceAgentAuthConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_agent_auth => {
                            if !fields.insert(__FieldTag::__service_agent_auth) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_agent_auth"));
                            }
                            result.service_agent_auth = map.next_value::<std::option::Option<crate::model::tool::authentication::service_agent_auth_config::ServiceAgentAuth>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::authentication::BearerTokenConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token,
            __secret_version_for_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BearerTokenConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "token" => Ok(__FieldTag::__token),
                            "secretVersionForToken" => Ok(__FieldTag::__secret_version_for_token),
                            "secret_version_for_token" => Ok(__FieldTag::__secret_version_for_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::authentication::BearerTokenConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BearerTokenConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token => {
                            if !fields.insert(__FieldTag::__token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for token"));
                            }
                            result.token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__secret_version_for_token => {
                            if !fields.insert(__FieldTag::__secret_version_for_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for secret_version_for_token"));
                            }
                            result.secret_version_for_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::TLSConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_certs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TLSConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caCerts" => Ok(__FieldTag::__ca_certs),
                            "ca_certs" => Ok(__FieldTag::__ca_certs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::TLSConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TLSConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_certs => {
                            if !fields.insert(__FieldTag::__ca_certs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ca_certs"));
                            }
                            result.ca_certs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::tool::tls_config::CACert>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::tls_config::CACert {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __cert,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CACert")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "cert" => Ok(__FieldTag::__cert),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::tls_config::CACert;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CACert")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cert => {
                            if !fields.insert(__FieldTag::__cert) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cert"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cert = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "tools" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool::ServiceDirectoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceDirectoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool::ServiceDirectoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceDirectoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service"));
                            }
                            result.service = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ToolCall {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tool,
            __tool_display_name,
            __tool_display_details,
            __action,
            __input_parameters,
            __create_time,
            __answer_record,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ToolCall")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tool" => Ok(__FieldTag::__tool),
                            "toolDisplayName" => Ok(__FieldTag::__tool_display_name),
                            "tool_display_name" => Ok(__FieldTag::__tool_display_name),
                            "toolDisplayDetails" => Ok(__FieldTag::__tool_display_details),
                            "tool_display_details" => Ok(__FieldTag::__tool_display_details),
                            "action" => Ok(__FieldTag::__action),
                            "inputParameters" => Ok(__FieldTag::__input_parameters),
                            "input_parameters" => Ok(__FieldTag::__input_parameters),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ToolCall;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ToolCall")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tool => {
                            if !fields.insert(__FieldTag::__tool) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.ToolCall.tool, latest field was tool",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::tool_call::Source::Tool(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__tool_display_name => {
                            if !fields.insert(__FieldTag::__tool_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_display_name"));
                            }
                            result.tool_display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__tool_display_details => {
                            if !fields.insert(__FieldTag::__tool_display_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool_display_details"));
                            }
                            result.tool_display_details = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__input_parameters => {
                            if !fields.insert(__FieldTag::__input_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for input_parameters"));
                            }
                            result.input_parameters = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::tool_call::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ToolCallResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tool,
            __action,
            __error,
            __raw_content,
            __content,
            __create_time,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ToolCallResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tool" => Ok(__FieldTag::__tool),
                            "action" => Ok(__FieldTag::__action),
                            "error" => Ok(__FieldTag::__error),
                            "rawContent" => Ok(__FieldTag::__raw_content),
                            "raw_content" => Ok(__FieldTag::__raw_content),
                            "content" => Ok(__FieldTag::__content),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ToolCallResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ToolCallResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tool => {
                            if !fields.insert(__FieldTag::__tool) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for tool"));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.ToolCallResult.tool, latest field was tool",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::tool_call_result::Source::Tool(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.ToolCallResult.error, latest field was error",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::tool_call_result::Result::Error(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::tool_call_result::Error>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__raw_content => {
                            if !fields.insert(__FieldTag::__raw_content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for raw_content"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.ToolCallResult.raw_content, latest field was rawContent",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::tool_call_result::Result::RawContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.ToolCallResult.content, latest field was content",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::tool_call_result::Result::Content(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for answer_record"));
                            }
                            result.answer_record = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any ( feature = "answer-records",feature = "conversations",feature = "generator-evaluations",feature = "generators",feature = "participants", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::tool_call_result::Error {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Error")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::tool_call_result::Error;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Error")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message"));
                            }
                            result.message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ValidationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __severity,
            __entries,
            __error_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "severity" => Ok(__FieldTag::__severity),
                            "entries" => Ok(__FieldTag::__entries),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ValidationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for severity"));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::validation_error::Severity>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entries"));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_message"));
                            }
                            result.error_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ValidationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __validation_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "validationErrors" => Ok(__FieldTag::__validation_errors),
                            "validation_errors" => Ok(__FieldTag::__validation_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ValidationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__validation_errors => {
                            if !fields.insert(__FieldTag::__validation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for validation_errors"));
                            }
                            result.validation_errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ValidationError>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __version_number,
            __create_time,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "versionNumber" => Ok(__FieldTag::__version_number),
                            "version_number" => Ok(__FieldTag::__version_number),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__version_number => {
                            if !fields.insert(__FieldTag::__version_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version_number"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_number = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status"));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::version::VersionStatus>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versions" => Ok(__FieldTag::__versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for versions"));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Version>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version"));
                            }
                            result.version = map.next_value::<std::option::Option<crate::model::Version>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version"));
                            }
                            result.version = map.next_value::<std::option::Option<crate::model::Version>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions" )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all ( feature = "agents",feature = "answer-records",feature = "contexts",feature = "conversation-datasets",feature = "conversation-models",feature = "conversation-profiles",feature = "conversations",feature = "documents",feature = "encryption-spec-service",feature = "entity-types",feature = "environments",feature = "fulfillments",feature = "generator-evaluations",feature = "generators",feature = "intents",feature = "knowledge-bases",feature = "participants",feature = "session-entity-types",feature = "sessions",feature = "sip-trunks",feature = "tools",feature = "versions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __response_id,
            __query_result,
            __original_detect_intent_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "originalDetectIntentRequest" => Ok(__FieldTag::__original_detect_intent_request),
                            "original_detect_intent_request" => Ok(__FieldTag::__original_detect_intent_request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session"));
                            }
                            result.session = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response_id"));
                            }
                            result.response_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for query_result"));
                            }
                            result.query_result = map.next_value::<std::option::Option<crate::model::QueryResult>>()?
                                ;
                        },
                        __FieldTag::__original_detect_intent_request => {
                            if !fields.insert(__FieldTag::__original_detect_intent_request) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for original_detect_intent_request"));
                            }
                            result.original_detect_intent_request = map.next_value::<std::option::Option<crate::model::OriginalDetectIntentRequest>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all ( feature = "agents",feature = "answer-records",feature = "contexts",feature = "conversation-datasets",feature = "conversation-models",feature = "conversation-profiles",feature = "conversations",feature = "documents",feature = "encryption-spec-service",feature = "entity-types",feature = "environments",feature = "fulfillments",feature = "generator-evaluations",feature = "generators",feature = "intents",feature = "knowledge-bases",feature = "participants",feature = "session-entity-types",feature = "sessions",feature = "sip-trunks",feature = "tools",feature = "versions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WebhookResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fulfillment_text,
            __fulfillment_messages,
            __source,
            __payload,
            __output_contexts,
            __followup_event_input,
            __session_entity_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fulfillmentText" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillment_text" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillmentMessages" => Ok(__FieldTag::__fulfillment_messages),
                            "fulfillment_messages" => Ok(__FieldTag::__fulfillment_messages),
                            "source" => Ok(__FieldTag::__source),
                            "payload" => Ok(__FieldTag::__payload),
                            "outputContexts" => Ok(__FieldTag::__output_contexts),
                            "output_contexts" => Ok(__FieldTag::__output_contexts),
                            "followupEventInput" => Ok(__FieldTag::__followup_event_input),
                            "followup_event_input" => Ok(__FieldTag::__followup_event_input),
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WebhookResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fulfillment_text => {
                            if !fields.insert(__FieldTag::__fulfillment_text) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fulfillment_text"));
                            }
                            result.fulfillment_text = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__fulfillment_messages => {
                            if !fields.insert(__FieldTag::__fulfillment_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fulfillment_messages"));
                            }
                            result.fulfillment_messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::Message>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source"));
                            }
                            result.source = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for payload"));
                            }
                            result.payload = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::__output_contexts => {
                            if !fields.insert(__FieldTag::__output_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for output_contexts"));
                            }
                            result.output_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__followup_event_input => {
                            if !fields.insert(__FieldTag::__followup_event_input) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for followup_event_input"));
                            }
                            result.followup_event_input = map.next_value::<std::option::Option<crate::model::EventInput>>()?
                                ;
                        },
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_entity_types"));
                            }
                            result.session_entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SessionEntityType>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all ( feature = "agents",feature = "answer-records",feature = "contexts",feature = "conversation-datasets",feature = "conversation-models",feature = "conversation-profiles",feature = "conversations",feature = "documents",feature = "encryption-spec-service",feature = "entity-types",feature = "environments",feature = "fulfillments",feature = "generator-evaluations",feature = "generators",feature = "intents",feature = "knowledge-bases",feature = "participants",feature = "session-entity-types",feature = "sessions",feature = "sip-trunks",feature = "tools",feature = "versions", ) )]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OriginalDetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __version,
            __payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OriginalDetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "version" => Ok(__FieldTag::__version),
                            "payload" => Ok(__FieldTag::__payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OriginalDetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OriginalDetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source"));
                            }
                            result.source = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version"));
                            }
                            result.version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for payload"));
                            }
                            result.payload = map.next_value::<std::option::Option<wkt::Struct>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
