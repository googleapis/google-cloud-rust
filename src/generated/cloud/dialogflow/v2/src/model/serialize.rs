// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Agent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.default_language_code.is_empty() {
            state.serialize_entry("defaultLanguageCode", &self.default_language_code)?;
        }
        if !self.supported_language_codes.is_empty() {
            state.serialize_entry("supportedLanguageCodes", &self.supported_language_codes)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.avatar_uri.is_empty() {
            state.serialize_entry("avatarUri", &self.avatar_uri)?;
        }
        if !wkt::internal::is_default(&self.enable_logging) {
            state.serialize_entry("enableLogging", &self.enable_logging)?;
        }
        if !wkt::internal::is_default(&self.match_mode) {
            state.serialize_entry("matchMode", &self.match_mode)?;
        }
        if !wkt::internal::is_default(&self.classification_threshold) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "classificationThreshold",
                &__With(&self.classification_threshold),
            )?;
        }
        if !wkt::internal::is_default(&self.api_version) {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !wkt::internal::is_default(&self.tier) {
            state.serialize_entry("tier", &self.tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SetAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.agent.is_some() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchAgentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchAgentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agents.is_empty() {
            state.serialize_entry("agents", &self.agents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TrainAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.agent_uri.is_empty() {
            state.serialize_entry("agentUri", &self.agent_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportAgentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RestoreAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetValidationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnswerRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.answer_feedback.is_some() {
            state.serialize_entry("answerFeedback", &self.answer_feedback)?;
        }
        if let Some(value) = self.agent_assistant_record() {
            state.serialize_entry("agentAssistantRecord", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListAnswerRecordsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListAnswerRecordsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer_records.is_empty() {
            state.serialize_entry("answerRecords", &self.answer_records)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateAnswerRecordRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.answer_record.is_some() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnswerFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.correctness_level) {
            state.serialize_entry("correctnessLevel", &self.correctness_level)?;
        }
        if let Some(value) = self.agent_assistant_detail_feedback() {
            state.serialize_entry("agentAssistantDetailFeedback", value)?;
        }
        if !wkt::internal::is_default(&self.clicked) {
            state.serialize_entry("clicked", &self.clicked)?;
        }
        if self.click_time.is_some() {
            state.serialize_entry("clickTime", &self.click_time)?;
        }
        if !wkt::internal::is_default(&self.displayed) {
            state.serialize_entry("displayed", &self.displayed)?;
        }
        if self.display_time.is_some() {
            state.serialize_entry("displayTime", &self.display_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AgentAssistantFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.answer_relevance) {
            state.serialize_entry("answerRelevance", &self.answer_relevance)?;
        }
        if !wkt::internal::is_default(&self.document_correctness) {
            state.serialize_entry("documentCorrectness", &self.document_correctness)?;
        }
        if !wkt::internal::is_default(&self.document_efficiency) {
            state.serialize_entry("documentEfficiency", &self.document_efficiency)?;
        }
        if self.summarization_feedback.is_some() {
            state.serialize_entry("summarizationFeedback", &self.summarization_feedback)?;
        }
        if self.knowledge_search_feedback.is_some() {
            state.serialize_entry("knowledgeSearchFeedback", &self.knowledge_search_feedback)?;
        }
        if self.knowledge_assist_feedback.is_some() {
            state.serialize_entry("knowledgeAssistFeedback", &self.knowledge_assist_feedback)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent_assistant_feedback::SummarizationFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if !self.summary_text.is_empty() {
            state.serialize_entry("summaryText", &self.summary_text)?;
        }
        if !self.text_sections.is_empty() {
            state.serialize_entry("textSections", &self.text_sections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent_assistant_feedback::KnowledgeSearchFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.answer_copied) {
            state.serialize_entry("answerCopied", &self.answer_copied)?;
        }
        if !self.clicked_uris.is_empty() {
            state.serialize_entry("clickedUris", &self.clicked_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::agent_assistant_feedback::KnowledgeAssistFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.answer_copied) {
            state.serialize_entry("answerCopied", &self.answer_copied)?;
        }
        if !self.clicked_uris.is_empty() {
            state.serialize_entry("clickedUris", &self.clicked_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AgentAssistantRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.article_suggestion_answer() {
            state.serialize_entry("articleSuggestionAnswer", value)?;
        }
        if let Some(value) = self.faq_answer() {
            state.serialize_entry("faqAnswer", value)?;
        }
        if let Some(value) = self.dialogflow_assist_answer() {
            state.serialize_entry("dialogflowAssistAnswer", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SpeechContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phrases.is_empty() {
            state.serialize_entry("phrases", &self.phrases)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SpeechWordInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.word.is_empty() {
            state.serialize_entry("word", &self.word)?;
        }
        if self.start_offset.is_some() {
            state.serialize_entry("startOffset", &self.start_offset)?;
        }
        if self.end_offset.is_some() {
            state.serialize_entry("endOffset", &self.end_offset)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.enable_word_info) {
            state.serialize_entry("enableWordInfo", &self.enable_word_info)?;
        }
        if !self.phrase_hints.is_empty() {
            state.serialize_entry("phraseHints", &self.phrase_hints)?;
        }
        if !self.speech_contexts.is_empty() {
            state.serialize_entry("speechContexts", &self.speech_contexts)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.model_variant) {
            state.serialize_entry("modelVariant", &self.model_variant)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if !wkt::internal::is_default(&self.disable_no_speech_recognized_event) {
            state.serialize_entry(
                "disableNoSpeechRecognizedEvent",
                &self.disable_no_speech_recognized_event,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_automatic_punctuation) {
            state.serialize_entry(
                "enableAutomaticPunctuation",
                &self.enable_automatic_punctuation,
            )?;
        }
        if !self.phrase_sets.is_empty() {
            state.serialize_entry("phraseSets", &self.phrase_sets)?;
        }
        if !wkt::internal::is_default(&self.opt_out_conformer_model_migration) {
            state.serialize_entry(
                "optOutConformerModelMigration",
                &self.opt_out_conformer_model_migration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::VoiceSelectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ssml_gender) {
            state.serialize_entry("ssmlGender", &self.ssml_gender)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SynthesizeSpeechConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.speaking_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("speakingRate", &__With(&self.speaking_rate))?;
        }
        if !wkt::internal::is_default(&self.pitch) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pitch", &__With(&self.pitch))?;
        }
        if !wkt::internal::is_default(&self.volume_gain_db) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeGainDb", &__With(&self.volume_gain_db))?;
        }
        if !self.effects_profile_id.is_empty() {
            state.serialize_entry("effectsProfileId", &self.effects_profile_id)?;
        }
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::OutputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if self.synthesize_speech_config.is_some() {
            state.serialize_entry("synthesizeSpeechConfig", &self.synthesize_speech_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TelephonyDtmfEvents {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dtmf_events.is_empty() {
            state.serialize_entry("dtmfEvents", &self.dtmf_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SpeechToTextConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.speech_model_variant) {
            state.serialize_entry("speechModelVariant", &self.speech_model_variant)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.phrase_sets.is_empty() {
            state.serialize_entry("phraseSets", &self.phrase_sets)?;
        }
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.enable_word_info) {
            state.serialize_entry("enableWordInfo", &self.enable_word_info)?;
        }
        if !wkt::internal::is_default(&self.use_timeout_based_endpointing) {
            state.serialize_entry(
                "useTimeoutBasedEndpointing",
                &self.use_timeout_based_endpointing,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "contexts",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Context {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.lifespan_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lifespanCount", &__With(&self.lifespan_count))?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListContextsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListContextsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contexts.is_empty() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteAllContextsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Conversation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.lifecycle_state) {
            state.serialize_entry("lifecycleState", &self.lifecycle_state)?;
        }
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if self.phone_number.is_some() {
            state.serialize_entry("phoneNumber", &self.phone_number)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.conversation_stage) {
            state.serialize_entry("conversationStage", &self.conversation_stage)?;
        }
        if self.telephony_connection_info.is_some() {
            state.serialize_entry("telephonyConnectionInfo", &self.telephony_connection_info)?;
        }
        if !self.ingested_context_references.is_empty() {
            state.serialize_entry(
                "ingestedContextReferences",
                &self.ingested_context_references,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation::TelephonyConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dialed_number.is_empty() {
            state.serialize_entry("dialedNumber", &self.dialed_number)?;
        }
        if !self.sdp.is_empty() {
            state.serialize_entry("sdp", &self.sdp)?;
        }
        if !self.sip_headers.is_empty() {
            state.serialize_entry("sipHeaders", &self.sip_headers)?;
        }
        if !self.extra_mime_contents.is_empty() {
            state.serialize_entry("extraMimeContents", &self.extra_mime_contents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation::telephony_connection_info::SipHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation::telephony_connection_info::MimeContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation::ContextReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.context_contents.is_empty() {
            state.serialize_entry("contextContents", &self.context_contents)?;
        }
        if !wkt::internal::is_default(&self.update_mode) {
            state.serialize_entry("updateMode", &self.update_mode)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::conversation::context_reference::ContextContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.content_format) {
            state.serialize_entry("contentFormat", &self.content_format)?;
        }
        if self.ingestion_time.is_some() {
            state.serialize_entry("ingestionTime", &self.ingestion_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.conversation_id.is_empty() {
            state.serialize_entry("conversationId", &self.conversation_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversations.is_empty() {
            state.serialize_entry("conversations", &self.conversations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompleteConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListMessagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListMessagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationPhoneNumber {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.country_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("countryCode", &__With(&self.country_code))?;
        }
        if !self.phone_number.is_empty() {
            state.serialize_entry("phoneNumber", &self.phone_number)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IngestContextReferencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.context_references.is_empty() {
            state.serialize_entry("contextReferences", &self.context_references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IngestContextReferencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ingested_context_references.is_empty() {
            state.serialize_entry(
                "ingestedContextReferences",
                &self.ingested_context_references,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestConversationSummaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestConversationSummaryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::suggest_conversation_summary_response::Summary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.text_sections.is_empty() {
            state.serialize_entry("textSections", &self.text_sections)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self.baseline_model_version.is_empty() {
            state.serialize_entry("baselineModelVersion", &self.baseline_model_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateStatelessSummaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.stateless_conversation.is_some() {
            state.serialize_entry("statelessConversation", &self.stateless_conversation)?;
        }
        if self.conversation_profile.is_some() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.max_context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxContextSize", &__With(&self.max_context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_stateless_summary_request::MinimalConversation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateStatelessSummaryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_stateless_summary_response::Summary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.text_sections.is_empty() {
            state.serialize_entry("textSections", &self.text_sections)?;
        }
        if !self.baseline_model_version.is_empty() {
            state.serialize_entry("baselineModelVersion", &self.baseline_model_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateStatelessSuggestionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.generator() {
            state.serialize_entry("generator", value)?;
        }
        if let Some(value) = self.generator_name() {
            state.serialize_entry("generatorName", value)?;
        }
        if !self.context_references.is_empty() {
            state.serialize_entry("contextReferences", &self.context_references)?;
        }
        if self.conversation_context.is_some() {
            state.serialize_entry("conversationContext", &self.conversation_context)?;
        }
        if !self.trigger_events.is_empty() {
            state.serialize_entry("triggerEvents", &self.trigger_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateStatelessSuggestionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator_suggestion.is_some() {
            state.serialize_entry("generatorSuggestion", &self.generator_suggestion)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchKnowledgeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.query.is_some() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.query_source) {
            state.serialize_entry("querySource", &self.query_source)?;
        }
        if self.end_user_metadata.is_some() {
            state.serialize_entry("endUserMetadata", &self.end_user_metadata)?;
        }
        if self.search_config.is_some() {
            state.serialize_entry("searchConfig", &self.search_config)?;
        }
        if !wkt::internal::is_default(&self.exact_search) {
            state.serialize_entry("exactSearch", &self.exact_search)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_knowledge_request::SearchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.boost_specs.is_empty() {
            state.serialize_entry("boostSpecs", &self.boost_specs)?;
        }
        if !self.filter_specs.is_empty() {
            state.serialize_entry("filterSpecs", &self.filter_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_knowledge_request::search_config::BoostSpecs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.spec.is_empty() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::search_knowledge_request::search_config::boost_specs::BoostSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition_boost_specs.is_empty() {
            state.serialize_entry("conditionBoostSpecs", &self.condition_boost_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if self.boost_control_spec.is_some() {
            state.serialize_entry("boostControlSpec", &self.boost_control_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !wkt::internal::is_default(&self.attribute_type) {
            state.serialize_entry("attributeType", &self.attribute_type)?;
        }
        if !wkt::internal::is_default(&self.interpolation_type) {
            state.serialize_entry("interpolationType", &self.interpolation_type)?;
        }
        if !self.control_points.is_empty() {
            state.serialize_entry("controlPoints", &self.control_points)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute_value.is_empty() {
            state.serialize_entry("attributeValue", &self.attribute_value)?;
        }
        if !wkt::internal::is_default(&self.boost_amount) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boostAmount", &__With(&self.boost_amount))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_knowledge_request::search_config::FilterSpecs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchKnowledgeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answers.is_empty() {
            state.serialize_entry("answers", &self.answers)?;
        }
        if !self.rewritten_query.is_empty() {
            state.serialize_entry("rewrittenQuery", &self.rewritten_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchKnowledgeAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !wkt::internal::is_default(&self.answer_type) {
            state.serialize_entry("answerType", &self.answer_type)?;
        }
        if !self.answer_sources.is_empty() {
            state.serialize_entry("answerSources", &self.answer_sources)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_knowledge_answer::AnswerSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.snippet.is_empty() {
            state.serialize_entry("snippet", &self.snippet)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateSuggestionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !self.trigger_events.is_empty() {
            state.serialize_entry("triggerEvents", &self.trigger_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if self.conversation_info.is_some() {
            state.serialize_entry("conversationInfo", &self.conversation_info)?;
        }
        if !wkt::internal::is_default(&self.conversation_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("conversationCount", &__With(&self.conversation_count))?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_dataset.is_some() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetConversationDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationDatasetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationDatasetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_datasets.is_empty() {
            state.serialize_entry("conversationDatasets", &self.conversation_datasets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConversationDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportConversationDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportConversationDataOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_dataset.is_empty() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !self.partial_failures.is_empty() {
            state.serialize_entry("partialFailures", &self.partial_failures)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportConversationDataOperationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_dataset.is_empty() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !wkt::internal::is_default(&self.import_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("importCount", &__With(&self.import_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationDatasetOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_dataset.is_empty() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConversationDatasetOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.error_status.is_some() {
            state.serialize_entry("errorStatus", &self.error_status)?;
        }
        if let Some(value) = self.new_message_payload() {
            state.serialize_entry("newMessagePayload", value)?;
        }
        if let Some(value) = self.new_recognition_result_payload() {
            state.serialize_entry("newRecognitionResultPayload", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if let Some(value) = self.article_suggestion_model_metadata() {
            state.serialize_entry("articleSuggestionModelMetadata", value)?;
        }
        if let Some(value) = self.smart_reply_model_metadata() {
            state.serialize_entry("smartReplyModelMetadata", value)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationModelEvaluation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.evaluation_config.is_some() {
            state.serialize_entry("evaluationConfig", &self.evaluation_config)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if let Some(value) = self.smart_reply_metrics() {
            state.serialize_entry("smartReplyMetrics", value)?;
        }
        if !self.raw_human_eval_template_csv.is_empty() {
            state.serialize_entry("rawHumanEvalTemplateCsv", &self.raw_human_eval_template_csv)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EvaluationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if let Some(value) = self.smart_reply_config() {
            state.serialize_entry("smartReplyConfig", value)?;
        }
        if let Some(value) = self.smart_compose_config() {
            state.serialize_entry("smartComposeConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::evaluation_config::SmartReplyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowlist_document.is_empty() {
            state.serialize_entry("allowlistDocument", &self.allowlist_document)?;
        }
        if !wkt::internal::is_default(&self.max_result_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResultCount", &__With(&self.max_result_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::evaluation_config::SmartComposeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowlist_document.is_empty() {
            state.serialize_entry("allowlistDocument", &self.allowlist_document)?;
        }
        if !wkt::internal::is_default(&self.max_result_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResultCount", &__With(&self.max_result_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InputDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ArticleSuggestionModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.training_model_type) {
            state.serialize_entry("trainingModelType", &self.training_model_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SmartReplyModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.training_model_type) {
            state.serialize_entry("trainingModelType", &self.training_model_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SmartReplyMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.allowlist_coverage) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("allowlistCoverage", &__With(&self.allowlist_coverage))?;
        }
        if !self.top_n_metrics.is_empty() {
            state.serialize_entry("topNMetrics", &self.top_n_metrics)?;
        }
        if !wkt::internal::is_default(&self.conversation_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("conversationCount", &__With(&self.conversation_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::smart_reply_metrics::TopNMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.n) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("n", &__With(&self.n))?;
        }
        if !wkt::internal::is_default(&self.recall) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("recall", &__With(&self.recall))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_model.is_some() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_models.is_empty() {
            state.serialize_entry("conversationModels", &self.conversation_models)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeployConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UndeployConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetConversationModelEvaluationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationModelEvaluationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationModelEvaluationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model_evaluations.is_empty() {
            state.serialize_entry(
                "conversationModelEvaluations",
                &self.conversation_model_evaluations,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationModelEvaluationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_model_evaluation.is_some() {
            state.serialize_entry(
                "conversationModelEvaluation",
                &self.conversation_model_evaluation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeployConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UndeployConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationModelEvaluationOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model_evaluation.is_empty() {
            state.serialize_entry(
                "conversationModelEvaluation",
                &self.conversation_model_evaluation,
            )?;
        }
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.automated_agent_config.is_some() {
            state.serialize_entry("automatedAgentConfig", &self.automated_agent_config)?;
        }
        if self.human_agent_assistant_config.is_some() {
            state.serialize_entry(
                "humanAgentAssistantConfig",
                &self.human_agent_assistant_config,
            )?;
        }
        if self.human_agent_handoff_config.is_some() {
            state.serialize_entry("humanAgentHandoffConfig", &self.human_agent_handoff_config)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.new_message_event_notification_config.is_some() {
            state.serialize_entry(
                "newMessageEventNotificationConfig",
                &self.new_message_event_notification_config,
            )?;
        }
        if self.new_recognition_result_notification_config.is_some() {
            state.serialize_entry(
                "newRecognitionResultNotificationConfig",
                &self.new_recognition_result_notification_config,
            )?;
        }
        if self.stt_config.is_some() {
            state.serialize_entry("sttConfig", &self.stt_config)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.security_settings.is_empty() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if self.tts_config.is_some() {
            state.serialize_entry("ttsConfig", &self.tts_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profiles.is_empty() {
            state.serialize_entry("conversationProfiles", &self.conversation_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_profile.is_some() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.conversation_profile.is_some() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutomatedAgentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.session_ttl.is_some() {
            state.serialize_entry("sessionTtl", &self.session_ttl)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HumanAgentAssistantConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.human_agent_suggestion_config.is_some() {
            state.serialize_entry(
                "humanAgentSuggestionConfig",
                &self.human_agent_suggestion_config,
            )?;
        }
        if self.end_user_suggestion_config.is_some() {
            state.serialize_entry("endUserSuggestionConfig", &self.end_user_suggestion_config)?;
        }
        if self.message_analysis_config.is_some() {
            state.serialize_entry("messageAnalysisConfig", &self.message_analysis_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::SuggestionTriggerSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.no_smalltalk) {
            state.serialize_entry("noSmalltalk", &self.no_smalltalk)?;
        }
        if !wkt::internal::is_default(&self.only_end_user) {
            state.serialize_entry("onlyEndUser", &self.only_end_user)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::SuggestionFeatureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.suggestion_feature.is_some() {
            state.serialize_entry("suggestionFeature", &self.suggestion_feature)?;
        }
        if !wkt::internal::is_default(&self.enable_event_based_suggestion) {
            state.serialize_entry(
                "enableEventBasedSuggestion",
                &self.enable_event_based_suggestion,
            )?;
        }
        if !wkt::internal::is_default(&self.disable_agent_query_logging) {
            state.serialize_entry(
                "disableAgentQueryLogging",
                &self.disable_agent_query_logging,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_query_suggestion_when_no_answer) {
            state.serialize_entry(
                "enableQuerySuggestionWhenNoAnswer",
                &self.enable_query_suggestion_when_no_answer,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_conversation_augmented_query) {
            state.serialize_entry(
                "enableConversationAugmentedQuery",
                &self.enable_conversation_augmented_query,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_query_suggestion_only) {
            state.serialize_entry(
                "enableQuerySuggestionOnly",
                &self.enable_query_suggestion_only,
            )?;
        }
        if self.suggestion_trigger_settings.is_some() {
            state.serialize_entry(
                "suggestionTriggerSettings",
                &self.suggestion_trigger_settings,
            )?;
        }
        if self.query_config.is_some() {
            state.serialize_entry("queryConfig", &self.query_config)?;
        }
        if self.conversation_model_config.is_some() {
            state.serialize_entry("conversationModelConfig", &self.conversation_model_config)?;
        }
        if self.conversation_process_config.is_some() {
            state.serialize_entry(
                "conversationProcessConfig",
                &self.conversation_process_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::SuggestionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.feature_configs.is_empty() {
            state.serialize_entry("featureConfigs", &self.feature_configs)?;
        }
        if !wkt::internal::is_default(&self.group_suggestion_responses) {
            state.serialize_entry("groupSuggestionResponses", &self.group_suggestion_responses)?;
        }
        if !self.generators.is_empty() {
            state.serialize_entry("generators", &self.generators)?;
        }
        if !wkt::internal::is_default(&self.disable_high_latency_features_sync_delivery) {
            state.serialize_entry(
                "disableHighLatencyFeaturesSyncDelivery",
                &self.disable_high_latency_features_sync_delivery,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::SuggestionQueryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.knowledge_base_query_source() {
            state.serialize_entry("knowledgeBaseQuerySource", value)?;
        }
        if let Some(value) = self.document_query_source() {
            state.serialize_entry("documentQuerySource", value)?;
        }
        if let Some(value) = self.dialogflow_query_source() {
            state.serialize_entry("dialogflowQuerySource", value)?;
        }
        if !wkt::internal::is_default(&self.max_results) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !wkt::internal::is_default(&self.confidence_threshold) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceThreshold", &__With(&self.confidence_threshold))?;
        }
        if self.context_filter_settings.is_some() {
            state.serialize_entry("contextFilterSettings", &self.context_filter_settings)?;
        }
        if self.sections.is_some() {
            state.serialize_entry("sections", &self.sections)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.knowledge_bases.is_empty() {
            state.serialize_entry("knowledgeBases", &self.knowledge_bases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.human_agent_side_config.is_some() {
            state.serialize_entry("humanAgentSideConfig", &self.human_agent_side_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.drop_handoff_messages) {
            state.serialize_entry("dropHandoffMessages", &self.drop_handoff_messages)?;
        }
        if !wkt::internal::is_default(&self.drop_virtual_agent_messages) {
            state.serialize_entry(
                "dropVirtualAgentMessages",
                &self.drop_virtual_agent_messages,
            )?;
        }
        if !wkt::internal::is_default(&self.drop_ivr_messages) {
            state.serialize_entry("dropIvrMessages", &self.drop_ivr_messages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::human_agent_assistant_config::suggestion_query_config::Sections
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.section_types.is_empty() {
            state.serialize_entry("sectionTypes", &self.section_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::ConversationModelConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.baseline_model_version.is_empty() {
            state.serialize_entry("baselineModelVersion", &self.baseline_model_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::ConversationProcessConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.recent_sentences_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "recentSentencesCount",
                &__With(&self.recent_sentences_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_assistant_config::MessageAnalysisConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_entity_extraction) {
            state.serialize_entry("enableEntityExtraction", &self.enable_entity_extraction)?;
        }
        if !wkt::internal::is_default(&self.enable_sentiment_analysis) {
            state.serialize_entry("enableSentimentAnalysis", &self.enable_sentiment_analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HumanAgentHandoffConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.live_person_config() {
            state.serialize_entry("livePersonConfig", value)?;
        }
        if let Some(value) = self.salesforce_live_agent_config() {
            state.serialize_entry("salesforceLiveAgentConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_handoff_config::LivePersonConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.account_number.is_empty() {
            state.serialize_entry("accountNumber", &self.account_number)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::human_agent_handoff_config::SalesforceLiveAgentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.organization_id.is_empty() {
            state.serialize_entry("organizationId", &self.organization_id)?;
        }
        if !self.deployment_id.is_empty() {
            state.serialize_entry("deploymentId", &self.deployment_id)?;
        }
        if !self.button_id.is_empty() {
            state.serialize_entry("buttonId", &self.button_id)?;
        }
        if !self.endpoint_domain.is_empty() {
            state.serialize_entry("endpointDomain", &self.endpoint_domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NotificationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !wkt::internal::is_default(&self.message_format) {
            state.serialize_entry("messageFormat", &self.message_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_stackdriver_logging) {
            state.serialize_entry("enableStackdriverLogging", &self.enable_stackdriver_logging)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestionFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SetSuggestionFeatureConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if self.suggestion_feature_config.is_some() {
            state.serialize_entry("suggestionFeatureConfig", &self.suggestion_feature_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ClearSuggestionFeatureConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if !wkt::internal::is_default(&self.suggestion_feature_type) {
            state.serialize_entry("suggestionFeatureType", &self.suggestion_feature_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SetSuggestionFeatureConfigOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if !wkt::internal::is_default(&self.suggestion_feature_type) {
            state.serialize_entry("suggestionFeatureType", &self.suggestion_feature_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ClearSuggestionFeatureConfigOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if !wkt::internal::is_default(&self.suggestion_feature_type) {
            state.serialize_entry("suggestionFeatureType", &self.suggestion_feature_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Document {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.knowledge_types.is_empty() {
            state.serialize_entry("knowledgeTypes", &self.knowledge_types)?;
        }
        if let Some(value) = self.content_uri() {
            state.serialize_entry("contentUri", value)?;
        }
        if let Some(value) = self.raw_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rawContent", &__With(value))?;
        }
        if !wkt::internal::is_default(&self.enable_auto_reload) {
            state.serialize_entry("enableAutoReload", &self.enable_auto_reload)?;
        }
        if self.latest_reload_status.is_some() {
            state.serialize_entry("latestReloadStatus", &self.latest_reload_status)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::document::ReloadStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time.is_some() {
            state.serialize_entry("time", &self.time)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if self.document_template.is_some() {
            state.serialize_entry("documentTemplate", &self.document_template)?;
        }
        if !wkt::internal::is_default(&self.import_gcs_custom_metadata) {
            state.serialize_entry("importGcsCustomMetadata", &self.import_gcs_custom_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportDocumentTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.knowledge_types.is_empty() {
            state.serialize_entry("knowledgeTypes", &self.knowledge_types)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReloadDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.content_uri() {
            state.serialize_entry("contentUri", value)?;
        }
        if !wkt::internal::is_default(&self.import_gcs_custom_metadata) {
            state.serialize_entry("importGcsCustomMetadata", &self.import_gcs_custom_metadata)?;
        }
        if !wkt::internal::is_default(&self.smart_messaging_partial_update) {
            state.serialize_entry(
                "smartMessagingPartialUpdate",
                &self.smart_messaging_partial_update,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !wkt::internal::is_default(&self.export_full_content) {
            state.serialize_entry("exportFullContent", &self.export_full_content)?;
        }
        if !wkt::internal::is_default(&self.smart_messaging_partial_update) {
            state.serialize_entry(
                "smartMessagingPartialUpdate",
                &self.smart_messaging_partial_update,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExportOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.exported_gcs_destination.is_some() {
            state.serialize_entry("exportedGcsDestination", &self.exported_gcs_destination)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::KnowledgeOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.knowledge_base.is_empty() {
            state.serialize_entry("knowledgeBase", &self.knowledge_base)?;
        }
        if let Some(value) = self.export_operation_metadata() {
            state.serialize_entry("exportOperationMetadata", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEncryptionSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EncryptionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InitializeEncryptionSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.encryption_spec.is_some() {
            state.serialize_entry("encryptionSpec", &self.encryption_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InitializeEncryptionSpecResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InitializeEncryptionSpecMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::EntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.auto_expansion_mode) {
            state.serialize_entry("autoExpansionMode", &self.auto_expansion_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !wkt::internal::is_default(&self.enable_fuzzy_extraction) {
            state.serialize_entry("enableFuzzyExtraction", &self.enable_fuzzy_extraction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::entity_type::Entity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self.synonyms.is_empty() {
            state.serialize_entry("synonyms", &self.synonyms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.entity_type_batch_uri() {
            state.serialize_entry("entityTypeBatchUri", value)?;
        }
        if let Some(value) = self.entity_type_batch_inline() {
            state.serialize_entry("entityTypeBatchInline", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchDeleteEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entity_type_names.is_empty() {
            state.serialize_entry("entityTypeNames", &self.entity_type_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchCreateEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchDeleteEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entity_values.is_empty() {
            state.serialize_entry("entityValues", &self.entity_values)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EntityTypeBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.agent_version.is_empty() {
            state.serialize_entry("agentVersion", &self.agent_version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.text_to_speech_settings.is_some() {
            state.serialize_entry("textToSpeechSettings", &self.text_to_speech_settings)?;
        }
        if self.fulfillment.is_some() {
            state.serialize_entry("fulfillment", &self.fulfillment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TextToSpeechSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_text_to_speech) {
            state.serialize_entry("enableTextToSpeech", &self.enable_text_to_speech)?;
        }
        if !wkt::internal::is_default(&self.output_audio_encoding) {
            state.serialize_entry("outputAudioEncoding", &self.output_audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.synthesize_speech_configs.is_empty() {
            state.serialize_entry("synthesizeSpeechConfigs", &self.synthesize_speech_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEnvironmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEnvironmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.environment_id.is_empty() {
            state.serialize_entry("environmentId", &self.environment_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_load_to_draft_and_discard_changes) {
            state.serialize_entry(
                "allowLoadToDraftAndDiscardChanges",
                &self.allow_load_to_draft_and_discard_changes,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEnvironmentHistoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EnvironmentHistory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::environment_history::Entry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent_version.is_empty() {
            state.serialize_entry("agentVersion", &self.agent_version)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Fulfillment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.generic_web_service() {
            state.serialize_entry("genericWebService", value)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::GenericWebService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.request_headers.is_empty() {
            state.serialize_entry("requestHeaders", &self.request_headers)?;
        }
        if !wkt::internal::is_default(&self.is_cloud_function) {
            state.serialize_entry("isCloudFunction", &self.is_cloud_function)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::fulfillment::Feature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "fulfillments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetFulfillmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "fulfillments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateFulfillmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fulfillment.is_some() {
            state.serialize_entry("fulfillment", &self.fulfillment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversation-datasets", feature = "documents",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GcsSources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.generator_id.is_empty() {
            state.serialize_entry("generatorId", &self.generator_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListGeneratorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListGeneratorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generators.is_empty() {
            state.serialize_entry("generators", &self.generators)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::MessageEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message_entries.is_empty() {
            state.serialize_entry("messageEntries", &self.message_entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SummarizationSectionList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summarization_sections.is_empty() {
            state.serialize_entry("summarizationSections", &self.summarization_sections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FewShotExample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.conversation_context.is_some() {
            state.serialize_entry("conversationContext", &self.conversation_context)?;
        }
        if !self.extra_info.is_empty() {
            state.serialize_entry("extraInfo", &self.extra_info)?;
        }
        if let Some(value) = self.summarization_section_list() {
            state.serialize_entry("summarizationSectionList", value)?;
        }
        if self.output.is_some() {
            state.serialize_entry("output", &self.output)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InferenceParameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_output_tokens.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxOutputTokens", &__With(&self.max_output_tokens))?;
        }
        if self.temperature.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("temperature", &__With(&self.temperature))?;
        }
        if self.top_k.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topK", &__With(&self.top_k))?;
        }
        if self.top_p.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topP", &__With(&self.top_p))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SummarizationSection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.definition.is_empty() {
            state.serialize_entry("definition", &self.definition)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SummarizationContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summarization_sections.is_empty() {
            state.serialize_entry("summarizationSections", &self.summarization_sections)?;
        }
        if !self.few_shot_examples.is_empty() {
            state.serialize_entry("fewShotExamples", &self.few_shot_examples)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.output_language_code.is_empty() {
            state.serialize_entry("outputLanguageCode", &self.output_language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FreeFormContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Generator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.free_form_context() {
            state.serialize_entry("freeFormContext", value)?;
        }
        if let Some(value) = self.summarization_context() {
            state.serialize_entry("summarizationContext", value)?;
        }
        if self.inference_parameter.is_some() {
            state.serialize_entry("inferenceParameter", &self.inference_parameter)?;
        }
        if !wkt::internal::is_default(&self.trigger_event) {
            state.serialize_entry("triggerEvent", &self.trigger_event)?;
        }
        if let Some(value) = self.published_model() {
            state.serialize_entry("publishedModel", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FreeFormSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response.is_empty() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SummarySuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summary_sections.is_empty() {
            state.serialize_entry("summarySections", &self.summary_sections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::summary_suggestion::SummarySection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.section.is_empty() {
            state.serialize_entry("section", &self.section)?;
        }
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GeneratorSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.free_form_suggestion() {
            state.serialize_entry("freeFormSuggestion", value)?;
        }
        if let Some(value) = self.summary_suggestion() {
            state.serialize_entry("summarySuggestion", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HumanAgentAssistantEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if !self.suggestion_results.is_empty() {
            state.serialize_entry("suggestionResults", &self.suggestion_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Intent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.webhook_state) {
            state.serialize_entry("webhookState", &self.webhook_state)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !wkt::internal::is_default(&self.is_fallback) {
            state.serialize_entry("isFallback", &self.is_fallback)?;
        }
        if !wkt::internal::is_default(&self.ml_disabled) {
            state.serialize_entry("mlDisabled", &self.ml_disabled)?;
        }
        if !wkt::internal::is_default(&self.live_agent_handoff) {
            state.serialize_entry("liveAgentHandoff", &self.live_agent_handoff)?;
        }
        if !wkt::internal::is_default(&self.end_interaction) {
            state.serialize_entry("endInteraction", &self.end_interaction)?;
        }
        if !self.input_context_names.is_empty() {
            state.serialize_entry("inputContextNames", &self.input_context_names)?;
        }
        if !self.events.is_empty() {
            state.serialize_entry("events", &self.events)?;
        }
        if !self.training_phrases.is_empty() {
            state.serialize_entry("trainingPhrases", &self.training_phrases)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.output_contexts.is_empty() {
            state.serialize_entry("outputContexts", &self.output_contexts)?;
        }
        if !wkt::internal::is_default(&self.reset_contexts) {
            state.serialize_entry("resetContexts", &self.reset_contexts)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.default_response_platforms.is_empty() {
            state.serialize_entry("defaultResponsePlatforms", &self.default_response_platforms)?;
        }
        if !self.root_followup_intent_name.is_empty() {
            state.serialize_entry("rootFollowupIntentName", &self.root_followup_intent_name)?;
        }
        if !self.parent_followup_intent_name.is_empty() {
            state.serialize_entry(
                "parentFollowupIntentName",
                &self.parent_followup_intent_name,
            )?;
        }
        if !self.followup_intent_info.is_empty() {
            state.serialize_entry("followupIntentInfo", &self.followup_intent_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::TrainingPhrase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.parts.is_empty() {
            state.serialize_entry("parts", &self.parts)?;
        }
        if !wkt::internal::is_default(&self.times_added_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("timesAddedCount", &__With(&self.times_added_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::training_phrase::Part {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.entity_type.is_empty() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.alias.is_empty() {
            state.serialize_entry("alias", &self.alias)?;
        }
        if !wkt::internal::is_default(&self.user_defined) {
            state.serialize_entry("userDefined", &self.user_defined)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::Parameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self.default_value.is_empty() {
            state.serialize_entry("defaultValue", &self.default_value)?;
        }
        if !self.entity_type_display_name.is_empty() {
            state.serialize_entry("entityTypeDisplayName", &self.entity_type_display_name)?;
        }
        if !wkt::internal::is_default(&self.mandatory) {
            state.serialize_entry("mandatory", &self.mandatory)?;
        }
        if !self.prompts.is_empty() {
            state.serialize_entry("prompts", &self.prompts)?;
        }
        if !wkt::internal::is_default(&self.is_list) {
            state.serialize_entry("isList", &self.is_list)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::Message {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.image() {
            state.serialize_entry("image", value)?;
        }
        if let Some(value) = self.quick_replies() {
            state.serialize_entry("quickReplies", value)?;
        }
        if let Some(value) = self.card() {
            state.serialize_entry("card", value)?;
        }
        if let Some(value) = self.payload() {
            state.serialize_entry("payload", value)?;
        }
        if let Some(value) = self.simple_responses() {
            state.serialize_entry("simpleResponses", value)?;
        }
        if let Some(value) = self.basic_card() {
            state.serialize_entry("basicCard", value)?;
        }
        if let Some(value) = self.suggestions() {
            state.serialize_entry("suggestions", value)?;
        }
        if let Some(value) = self.link_out_suggestion() {
            state.serialize_entry("linkOutSuggestion", value)?;
        }
        if let Some(value) = self.list_select() {
            state.serialize_entry("listSelect", value)?;
        }
        if let Some(value) = self.carousel_select() {
            state.serialize_entry("carouselSelect", value)?;
        }
        if let Some(value) = self.browse_carousel_card() {
            state.serialize_entry("browseCarouselCard", value)?;
        }
        if let Some(value) = self.table_card() {
            state.serialize_entry("tableCard", value)?;
        }
        if let Some(value) = self.media_content() {
            state.serialize_entry("mediaContent", value)?;
        }
        if !wkt::internal::is_default(&self.platform) {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::Text {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::Image {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self.accessibility_text.is_empty() {
            state.serialize_entry("accessibilityText", &self.accessibility_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::QuickReplies {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.quick_replies.is_empty() {
            state.serialize_entry("quickReplies", &self.quick_replies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::Card {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.subtitle.is_empty() {
            state.serialize_entry("subtitle", &self.subtitle)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self.buttons.is_empty() {
            state.serialize_entry("buttons", &self.buttons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::card::Button {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.postback.is_empty() {
            state.serialize_entry("postback", &self.postback)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::SimpleResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text_to_speech.is_empty() {
            state.serialize_entry("textToSpeech", &self.text_to_speech)?;
        }
        if !self.ssml.is_empty() {
            state.serialize_entry("ssml", &self.ssml)?;
        }
        if !self.display_text.is_empty() {
            state.serialize_entry("displayText", &self.display_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::SimpleResponses {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.simple_responses.is_empty() {
            state.serialize_entry("simpleResponses", &self.simple_responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::BasicCard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.subtitle.is_empty() {
            state.serialize_entry("subtitle", &self.subtitle)?;
        }
        if !self.formatted_text.is_empty() {
            state.serialize_entry("formattedText", &self.formatted_text)?;
        }
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self.buttons.is_empty() {
            state.serialize_entry("buttons", &self.buttons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::basic_card::Button {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if self.open_uri_action.is_some() {
            state.serialize_entry("openUriAction", &self.open_uri_action)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::basic_card::button::OpenUriAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::Suggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::Suggestions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.suggestions.is_empty() {
            state.serialize_entry("suggestions", &self.suggestions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::LinkOutSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_name.is_empty() {
            state.serialize_entry("destinationName", &self.destination_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::ListSelect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self.subtitle.is_empty() {
            state.serialize_entry("subtitle", &self.subtitle)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::list_select::Item {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info.is_some() {
            state.serialize_entry("info", &self.info)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::CarouselSelect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::carousel_select::Item {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.info.is_some() {
            state.serialize_entry("info", &self.info)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::SelectItemInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.synonyms.is_empty() {
            state.serialize_entry("synonyms", &self.synonyms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::MediaContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.media_type) {
            state.serialize_entry("mediaType", &self.media_type)?;
        }
        if !self.media_objects.is_empty() {
            state.serialize_entry("mediaObjects", &self.media_objects)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::media_content::ResponseMediaObject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.large_image() {
            state.serialize_entry("largeImage", value)?;
        }
        if let Some(value) = self.icon() {
            state.serialize_entry("icon", value)?;
        }
        if !self.content_url.is_empty() {
            state.serialize_entry("contentUrl", &self.content_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::BrowseCarouselCard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !wkt::internal::is_default(&self.image_display_options) {
            state.serialize_entry("imageDisplayOptions", &self.image_display_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::intent::message::browse_carousel_card::BrowseCarouselCardItem
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.open_uri_action.is_some() {
            state.serialize_entry("openUriAction", &self.open_uri_action)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self.footer.is_empty() {
            state.serialize_entry("footer", &self.footer)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !wkt::internal::is_default(&self.url_type_hint) {
            state.serialize_entry("urlTypeHint", &self.url_type_hint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::TableCard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.subtitle.is_empty() {
            state.serialize_entry("subtitle", &self.subtitle)?;
        }
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self.column_properties.is_empty() {
            state.serialize_entry("columnProperties", &self.column_properties)?;
        }
        if !self.rows.is_empty() {
            state.serialize_entry("rows", &self.rows)?;
        }
        if !self.buttons.is_empty() {
            state.serialize_entry("buttons", &self.buttons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::ColumnProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.header.is_empty() {
            state.serialize_entry("header", &self.header)?;
        }
        if !wkt::internal::is_default(&self.horizontal_alignment) {
            state.serialize_entry("horizontalAlignment", &self.horizontal_alignment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::TableCardRow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cells.is_empty() {
            state.serialize_entry("cells", &self.cells)?;
        }
        if !wkt::internal::is_default(&self.divider_after) {
            state.serialize_entry("dividerAfter", &self.divider_after)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::message::TableCardCell {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::intent::FollowupIntentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.followup_intent_name.is_empty() {
            state.serialize_entry("followupIntentName", &self.followup_intent_name)?;
        }
        if !self.parent_followup_intent_name.is_empty() {
            state.serialize_entry(
                "parentFollowupIntentName",
                &self.parent_followup_intent_name,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.intent_batch_uri() {
            state.serialize_entry("intentBatchUri", value)?;
        }
        if let Some(value) = self.intent_batch_inline() {
            state.serialize_entry("intentBatchInline", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchDeleteIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IntentBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::KnowledgeBase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListKnowledgeBasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListKnowledgeBasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.knowledge_bases.is_empty() {
            state.serialize_entry("knowledgeBases", &self.knowledge_bases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.knowledge_base.is_some() {
            state.serialize_entry("knowledgeBase", &self.knowledge_base)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.knowledge_base.is_some() {
            state.serialize_entry("knowledgeBase", &self.knowledge_base)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Participant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.sip_recording_media_label.is_empty() {
            state.serialize_entry("sipRecordingMediaLabel", &self.sip_recording_media_label)?;
        }
        if !self.obfuscated_external_user_id.is_empty() {
            state.serialize_entry(
                "obfuscatedExternalUserId",
                &self.obfuscated_external_user_id,
            )?;
        }
        if !self.documents_metadata_filters.is_empty() {
            state.serialize_entry("documentsMetadataFilters", &self.documents_metadata_filters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Message {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.send_time.is_some() {
            state.serialize_entry("sendTime", &self.send_time)?;
        }
        if self.message_annotation.is_some() {
            state.serialize_entry("messageAnnotation", &self.message_annotation)?;
        }
        if self.sentiment_analysis.is_some() {
            state.serialize_entry("sentimentAnalysis", &self.sentiment_analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateParticipantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.participant.is_some() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetParticipantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListParticipantsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListParticipantsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.participants.is_empty() {
            state.serialize_entry("participants", &self.participants)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateParticipantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.participant.is_some() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnalyzeContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if let Some(value) = self.text_input() {
            state.serialize_entry("textInput", value)?;
        }
        if let Some(value) = self.audio_input() {
            state.serialize_entry("audioInput", value)?;
        }
        if let Some(value) = self.event_input() {
            state.serialize_entry("eventInput", value)?;
        }
        if let Some(value) = self.suggestion_input() {
            state.serialize_entry("suggestionInput", value)?;
        }
        if self.reply_audio_config.is_some() {
            state.serialize_entry("replyAudioConfig", &self.reply_audio_config)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if self.cx_parameters.is_some() {
            state.serialize_entry("cxParameters", &self.cx_parameters)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DtmfParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.accepts_dtmf_input) {
            state.serialize_entry("acceptsDtmfInput", &self.accepts_dtmf_input)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnalyzeContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reply_text.is_empty() {
            state.serialize_entry("replyText", &self.reply_text)?;
        }
        if self.reply_audio.is_some() {
            state.serialize_entry("replyAudio", &self.reply_audio)?;
        }
        if self.automated_agent_reply.is_some() {
            state.serialize_entry("automatedAgentReply", &self.automated_agent_reply)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.human_agent_suggestion_results.is_empty() {
            state.serialize_entry(
                "humanAgentSuggestionResults",
                &self.human_agent_suggestion_results,
            )?;
        }
        if !self.end_user_suggestion_results.is_empty() {
            state.serialize_entry(
                "endUserSuggestionResults",
                &self.end_user_suggestion_results,
            )?;
        }
        if self.dtmf_parameters.is_some() {
            state.serialize_entry("dtmfParameters", &self.dtmf_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingAnalyzeContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if let Some(value) = self.audio_config() {
            state.serialize_entry("audioConfig", value)?;
        }
        if let Some(value) = self.text_config() {
            state.serialize_entry("textConfig", value)?;
        }
        if self.reply_audio_config.is_some() {
            state.serialize_entry("replyAudioConfig", &self.reply_audio_config)?;
        }
        if let Some(value) = self.input_audio() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("inputAudio", &__With(value))?;
        }
        if let Some(value) = self.input_text() {
            state.serialize_entry("inputText", value)?;
        }
        if let Some(value) = self.input_dtmf() {
            state.serialize_entry("inputDtmf", value)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if self.cx_parameters.is_some() {
            state.serialize_entry("cxParameters", &self.cx_parameters)?;
        }
        if !wkt::internal::is_default(&self.enable_extended_streaming) {
            state.serialize_entry("enableExtendedStreaming", &self.enable_extended_streaming)?;
        }
        if !wkt::internal::is_default(&self.enable_partial_automated_agent_reply) {
            state.serialize_entry(
                "enablePartialAutomatedAgentReply",
                &self.enable_partial_automated_agent_reply,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_debugging_info) {
            state.serialize_entry("enableDebuggingInfo", &self.enable_debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingAnalyzeContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recognition_result.is_some() {
            state.serialize_entry("recognitionResult", &self.recognition_result)?;
        }
        if !self.reply_text.is_empty() {
            state.serialize_entry("replyText", &self.reply_text)?;
        }
        if self.reply_audio.is_some() {
            state.serialize_entry("replyAudio", &self.reply_audio)?;
        }
        if self.automated_agent_reply.is_some() {
            state.serialize_entry("automatedAgentReply", &self.automated_agent_reply)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.human_agent_suggestion_results.is_empty() {
            state.serialize_entry(
                "humanAgentSuggestionResults",
                &self.human_agent_suggestion_results,
            )?;
        }
        if !self.end_user_suggestion_results.is_empty() {
            state.serialize_entry(
                "endUserSuggestionResults",
                &self.end_user_suggestion_results,
            )?;
        }
        if self.dtmf_parameters.is_some() {
            state.serialize_entry("dtmfParameters", &self.dtmf_parameters)?;
        }
        if self.debugging_info.is_some() {
            state.serialize_entry("debuggingInfo", &self.debugging_info)?;
        }
        if !self.speech_model.is_empty() {
            state.serialize_entry("speechModel", &self.speech_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestArticlesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestArticlesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.article_answers.is_empty() {
            state.serialize_entry("articleAnswers", &self.article_answers)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestFaqAnswersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestFaqAnswersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.faq_answers.is_empty() {
            state.serialize_entry("faqAnswers", &self.faq_answers)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateSuggestionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generator_suggestion_answers.is_empty() {
            state.serialize_entry(
                "generatorSuggestionAnswers",
                &self.generator_suggestion_answers,
            )?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_suggestions_response::GeneratorSuggestionAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator_suggestion.is_some() {
            state.serialize_entry("generatorSuggestion", &self.generator_suggestion)?;
        }
        if !self.source_generator.is_empty() {
            state.serialize_entry("sourceGenerator", &self.source_generator)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestSmartRepliesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.current_text_input.is_some() {
            state.serialize_entry("currentTextInput", &self.current_text_input)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestSmartRepliesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.smart_reply_answers.is_empty() {
            state.serialize_entry("smartReplyAnswers", &self.smart_reply_answers)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AudioInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(&self.audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::OutputAudio {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(&self.audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutomatedAgentReply {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.detect_intent_response.is_some() {
            state.serialize_entry("detectIntentResponse", &self.detect_intent_response)?;
        }
        if !wkt::internal::is_default(&self.automated_agent_reply_type) {
            state.serialize_entry("automatedAgentReplyType", &self.automated_agent_reply_type)?;
        }
        if !wkt::internal::is_default(&self.allow_cancellation) {
            state.serialize_entry("allowCancellation", &self.allow_cancellation)?;
        }
        if !self.cx_current_page.is_empty() {
            state.serialize_entry("cxCurrentPage", &self.cx_current_page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ArticleAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.snippets.is_empty() {
            state.serialize_entry("snippets", &self.snippets)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FaqAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.question.is_empty() {
            state.serialize_entry("question", &self.question)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SmartReplyAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reply.is_empty() {
            state.serialize_entry("reply", &self.reply)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IntentSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.intent_v2() {
            state.serialize_entry("intentV2", value)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DialogflowAssistAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_result() {
            state.serialize_entry("queryResult", value)?;
        }
        if let Some(value) = self.intent_suggestion() {
            state.serialize_entry("intentSuggestion", value)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.suggest_articles_response() {
            state.serialize_entry("suggestArticlesResponse", value)?;
        }
        if let Some(value) = self.suggest_knowledge_assist_response() {
            state.serialize_entry("suggestKnowledgeAssistResponse", value)?;
        }
        if let Some(value) = self.suggest_faq_answers_response() {
            state.serialize_entry("suggestFaqAnswersResponse", value)?;
        }
        if let Some(value) = self.suggest_smart_replies_response() {
            state.serialize_entry("suggestSmartRepliesResponse", value)?;
        }
        if let Some(value) = self.generate_suggestions_response() {
            state.serialize_entry("generateSuggestionsResponse", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InputTextConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnnotatedMessagePart {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.entity_type.is_empty() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if self.formatted_value.is_some() {
            state.serialize_entry("formattedValue", &self.formatted_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::MessageAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parts.is_empty() {
            state.serialize_entry("parts", &self.parts)?;
        }
        if !wkt::internal::is_default(&self.contain_entities) {
            state.serialize_entry("containEntities", &self.contain_entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestionInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AssistQueryParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents_metadata_filters.is_empty() {
            state.serialize_entry("documentsMetadataFilters", &self.documents_metadata_filters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestKnowledgeAssistRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self.previous_suggested_query.is_empty() {
            state.serialize_entry("previousSuggestedQuery", &self.previous_suggested_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestKnowledgeAssistResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.knowledge_assist_answer.is_some() {
            state.serialize_entry("knowledgeAssistAnswer", &self.knowledge_assist_answer)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::KnowledgeAssistAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.suggested_query.is_some() {
            state.serialize_entry("suggestedQuery", &self.suggested_query)?;
        }
        if self.suggested_query_answer.is_some() {
            state.serialize_entry("suggestedQueryAnswer", &self.suggested_query_answer)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::knowledge_assist_answer::SuggestedQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_text.is_empty() {
            state.serialize_entry("queryText", &self.query_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::knowledge_assist_answer::KnowledgeAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer_text.is_empty() {
            state.serialize_entry("answerText", &self.answer_text)?;
        }
        if let Some(value) = self.faq_source() {
            state.serialize_entry("faqSource", value)?;
        }
        if let Some(value) = self.generative_source() {
            state.serialize_entry("generativeSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::knowledge_assist_answer::knowledge_answer::FaqSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.question.is_empty() {
            state.serialize_entry("question", &self.question)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for super::knowledge_assist_answer::knowledge_answer::GenerativeSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snippets.is_empty() {
            state.serialize_entry("snippets", &self.snippets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::knowledge_assist_answer::knowledge_answer::generative_source::Snippet
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if self.output_audio_config_mask.is_some() {
            state.serialize_entry("outputAudioConfigMask", &self.output_audio_config_mask)?;
        }
        if !self.input_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("inputAudio", &__With(&self.input_audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if self.webhook_status.is_some() {
            state.serialize_entry("webhookStatus", &self.webhook_status)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::QueryParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.geo_location.is_some() {
            state.serialize_entry("geoLocation", &self.geo_location)?;
        }
        if !self.contexts.is_empty() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if !wkt::internal::is_default(&self.reset_contexts) {
            state.serialize_entry("resetContexts", &self.reset_contexts)?;
        }
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if self.sentiment_analysis_request_config.is_some() {
            state.serialize_entry(
                "sentimentAnalysisRequestConfig",
                &self.sentiment_analysis_request_config,
            )?;
        }
        if !self.webhook_headers.is_empty() {
            state.serialize_entry("webhookHeaders", &self.webhook_headers)?;
        }
        if !self.platform.is_empty() {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::QueryInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.audio_config() {
            state.serialize_entry("audioConfig", value)?;
        }
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.event() {
            state.serialize_entry("event", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::QueryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_text.is_empty() {
            state.serialize_entry("queryText", &self.query_text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.speech_recognition_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "speechRecognitionConfidence",
                &__With(&self.speech_recognition_confidence),
            )?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !wkt::internal::is_default(&self.all_required_params_present) {
            state.serialize_entry(
                "allRequiredParamsPresent",
                &self.all_required_params_present,
            )?;
        }
        if !wkt::internal::is_default(&self.cancels_slot_filling) {
            state.serialize_entry("cancelsSlotFilling", &self.cancels_slot_filling)?;
        }
        if !self.fulfillment_text.is_empty() {
            state.serialize_entry("fulfillmentText", &self.fulfillment_text)?;
        }
        if !self.fulfillment_messages.is_empty() {
            state.serialize_entry("fulfillmentMessages", &self.fulfillment_messages)?;
        }
        if !self.webhook_source.is_empty() {
            state.serialize_entry("webhookSource", &self.webhook_source)?;
        }
        if self.webhook_payload.is_some() {
            state.serialize_entry("webhookPayload", &self.webhook_payload)?;
        }
        if !self.output_contexts.is_empty() {
            state.serialize_entry("outputContexts", &self.output_contexts)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !wkt::internal::is_default(&self.intent_detection_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "intentDetectionConfidence",
                &__With(&self.intent_detection_confidence),
            )?;
        }
        if self.diagnostic_info.is_some() {
            state.serialize_entry("diagnosticInfo", &self.diagnostic_info)?;
        }
        if self.sentiment_analysis_result.is_some() {
            state.serialize_entry("sentimentAnalysisResult", &self.sentiment_analysis_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingDetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if self.output_audio_config_mask.is_some() {
            state.serialize_entry("outputAudioConfigMask", &self.output_audio_config_mask)?;
        }
        if !self.input_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("inputAudio", &__With(&self.input_audio))?;
        }
        if !wkt::internal::is_default(&self.enable_debugging_info) {
            state.serialize_entry("enableDebuggingInfo", &self.enable_debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CloudConversationDebuggingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_data_chunks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioDataChunks", &__With(&self.audio_data_chunks))?;
        }
        if self.result_end_time_offset.is_some() {
            state.serialize_entry("resultEndTimeOffset", &self.result_end_time_offset)?;
        }
        if self.first_audio_duration.is_some() {
            state.serialize_entry("firstAudioDuration", &self.first_audio_duration)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if !self.speech_partial_results_end_times.is_empty() {
            state.serialize_entry(
                "speechPartialResultsEndTimes",
                &self.speech_partial_results_end_times,
            )?;
        }
        if !self.speech_final_results_end_times.is_empty() {
            state.serialize_entry(
                "speechFinalResultsEndTimes",
                &self.speech_final_results_end_times,
            )?;
        }
        if !wkt::internal::is_default(&self.partial_responses) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("partialResponses", &__With(&self.partial_responses))?;
        }
        if !wkt::internal::is_default(&self.speaker_id_passive_latency_ms_offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "speakerIdPassiveLatencyMsOffset",
                &__With(&self.speaker_id_passive_latency_ms_offset),
            )?;
        }
        if !wkt::internal::is_default(&self.bargein_event_triggered) {
            state.serialize_entry("bargeinEventTriggered", &self.bargein_event_triggered)?;
        }
        if !wkt::internal::is_default(&self.speech_single_utterance) {
            state.serialize_entry("speechSingleUtterance", &self.speech_single_utterance)?;
        }
        if !self.dtmf_partial_results_times.is_empty() {
            state.serialize_entry("dtmfPartialResultsTimes", &self.dtmf_partial_results_times)?;
        }
        if !self.dtmf_final_results_times.is_empty() {
            state.serialize_entry("dtmfFinalResultsTimes", &self.dtmf_final_results_times)?;
        }
        if self.single_utterance_end_time_offset.is_some() {
            state.serialize_entry(
                "singleUtteranceEndTimeOffset",
                &self.single_utterance_end_time_offset,
            )?;
        }
        if self.no_speech_timeout.is_some() {
            state.serialize_entry("noSpeechTimeout", &self.no_speech_timeout)?;
        }
        if self.endpointing_timeout.is_some() {
            state.serialize_entry("endpointingTimeout", &self.endpointing_timeout)?;
        }
        if !wkt::internal::is_default(&self.is_input_text) {
            state.serialize_entry("isInputText", &self.is_input_text)?;
        }
        if self.client_half_close_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseTimeOffset",
                &self.client_half_close_time_offset,
            )?;
        }
        if self.client_half_close_streaming_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseStreamingTimeOffset",
                &self.client_half_close_streaming_time_offset,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingDetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.recognition_result.is_some() {
            state.serialize_entry("recognitionResult", &self.recognition_result)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if self.webhook_status.is_some() {
            state.serialize_entry("webhookStatus", &self.webhook_status)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if self.debugging_info.is_some() {
            state.serialize_entry("debuggingInfo", &self.debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamingRecognitionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.message_type) {
            state.serialize_entry("messageType", &self.message_type)?;
        }
        if !self.transcript.is_empty() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !wkt::internal::is_default(&self.is_final) {
            state.serialize_entry("isFinal", &self.is_final)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.speech_word_info.is_empty() {
            state.serialize_entry("speechWordInfo", &self.speech_word_info)?;
        }
        if self.speech_end_offset.is_some() {
            state.serialize_entry("speechEndOffset", &self.speech_end_offset)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TextInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::EventInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SentimentAnalysisRequestConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.analyze_query_text_sentiment) {
            state.serialize_entry(
                "analyzeQueryTextSentiment",
                &self.analyze_query_text_sentiment,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SentimentAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.query_text_sentiment.is_some() {
            state.serialize_entry("queryTextSentiment", &self.query_text_sentiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Sentiment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SessionEntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.entity_override_mode) {
            state.serialize_entry("entityOverrideMode", &self.entity_override_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSessionEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSessionEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ValidationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.validation_errors.is_empty() {
            state.serialize_entry("validationErrors", &self.validation_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.version_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("versionNumber", &__With(&self.version_number))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if self.original_detect_intent_request.is_some() {
            state.serialize_entry(
                "originalDetectIntentRequest",
                &self.original_detect_intent_request,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WebhookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fulfillment_text.is_empty() {
            state.serialize_entry("fulfillmentText", &self.fulfillment_text)?;
        }
        if !self.fulfillment_messages.is_empty() {
            state.serialize_entry("fulfillmentMessages", &self.fulfillment_messages)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self.output_contexts.is_empty() {
            state.serialize_entry("outputContexts", &self.output_contexts)?;
        }
        if self.followup_event_input.is_some() {
            state.serialize_entry("followupEventInput", &self.followup_event_input)?;
        }
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::OriginalDetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
