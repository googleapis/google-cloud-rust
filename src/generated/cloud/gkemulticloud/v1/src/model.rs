// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An Anthos cluster running on customer own infrastructure.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedCluster {
    /// The name of this resource.
    ///
    /// Cluster names are formatted as
    /// `projects/<project-number>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    pub name: std::string::String,

    /// Optional. A human readable description of this cluster.
    /// Cannot be longer than 255 UTF-8 encoded bytes.
    pub description: std::string::String,

    /// Required. OpenID Connect (OIDC) configuration for the cluster.
    pub oidc_config: std::option::Option<crate::model::AttachedOidcConfig>,

    /// Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig]: crate::client::AttachedClusters::get_attached_server_config
    pub platform_version: std::string::String,

    /// Required. The Kubernetes distribution of the underlying attached cluster.
    ///
    /// Supported values: ["eks", "aks", "generic"].
    pub distribution: std::string::String,

    /// Output only. The region where this cluster runs.
    ///
    /// For EKS clusters, this is a AWS region. For AKS clusters,
    /// this is an Azure region.
    pub cluster_region: std::string::String,

    /// Required. Fleet configuration.
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Output only. The current state of the cluster.
    pub state: crate::model::attached_cluster::State,

    /// Output only. A globally unique identifier for the cluster.
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the cluster.
    pub reconciling: bool,

    /// Output only. The time at which this cluster was registered.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this cluster was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. The Kubernetes version of the cluster.
    pub kubernetes_version: std::string::String,

    /// Optional. Annotations on the cluster.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workload Identity settings.
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Optional. Logging configuration for this cluster.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Output only. A set of errors found in the cluster.
    pub errors: std::vec::Vec<crate::model::AttachedClusterError>,

    /// Optional. Configuration related to the cluster RBAC settings.
    pub authorization: std::option::Option<crate::model::AttachedClustersAuthorization>,

    /// Optional. Monitoring configuration for this cluster.
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AttachedProxyConfig>,

    /// Optional. Binary Authorization configuration for this cluster.
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Optional. Security Posture configuration for this cluster.
    pub security_posture_config: std::option::Option<crate::model::SecurityPostureConfig>,

    /// Optional. Input only. Tag keys/values directly bound to this resource.
    ///
    /// Tag key must be specified in the format \<tag namespace\>/\<tag key name\>
    /// where the tag namespace is the ID of the organization or name of the
    /// project that the tag key is defined in.
    /// The short name of a tag key or value can have a maximum length of 256
    /// characters. The permitted character set for the short name includes UTF-8
    /// encoded Unicode characters except single quotes ('), double quotes ("),
    /// backslashes (\), and forward slashes (/).
    ///
    /// See
    /// [Tags](https://cloud.google.com/resource-manager/docs/tags/tags-overview)
    /// for more details on Google Cloud Platform tags.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachedCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AttachedCluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [oidc_config][crate::model::AttachedCluster::oidc_config].
    pub fn set_oidc_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedOidcConfig>,
    {
        self.oidc_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oidc_config][crate::model::AttachedCluster::oidc_config].
    pub fn set_or_clear_oidc_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedOidcConfig>,
    {
        self.oidc_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [platform_version][crate::model::AttachedCluster::platform_version].
    pub fn set_platform_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_version = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::AttachedCluster::distribution].
    pub fn set_distribution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.distribution = v.into();
        self
    }

    /// Sets the value of [cluster_region][crate::model::AttachedCluster::cluster_region].
    pub fn set_cluster_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_region = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::AttachedCluster::fleet].
    pub fn set_fleet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fleet][crate::model::AttachedCluster::fleet].
    pub fn set_or_clear_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::AttachedCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::attached_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AttachedCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AttachedCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AttachedCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AttachedCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AttachedCluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AttachedCluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AttachedCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [kubernetes_version][crate::model::AttachedCluster::kubernetes_version].
    pub fn set_kubernetes_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_version = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AttachedCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::AttachedCluster::workload_identity_config].
    pub fn set_workload_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_identity_config][crate::model::AttachedCluster::workload_identity_config].
    pub fn set_or_clear_workload_identity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::AttachedCluster::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::AttachedCluster::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::AttachedCluster::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedClusterError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [authorization][crate::model::AttachedCluster::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedClustersAuthorization>,
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::AttachedCluster::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedClustersAuthorization>,
    {
        self.authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [monitoring_config][crate::model::AttachedCluster::monitoring_config].
    pub fn set_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monitoring_config][crate::model::AttachedCluster::monitoring_config].
    pub fn set_or_clear_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [proxy_config][crate::model::AttachedCluster::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::AttachedCluster::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [binary_authorization][crate::model::AttachedCluster::binary_authorization].
    pub fn set_binary_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary_authorization][crate::model::AttachedCluster::binary_authorization].
    pub fn set_or_clear_binary_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_posture_config][crate::model::AttachedCluster::security_posture_config].
    pub fn set_security_posture_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPostureConfig>,
    {
        self.security_posture_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_posture_config][crate::model::AttachedCluster::security_posture_config].
    pub fn set_or_clear_security_posture_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPostureConfig>,
    {
        self.security_posture_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::AttachedCluster::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AttachedCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __oidc_config,
            __platform_version,
            __distribution,
            __cluster_region,
            __fleet,
            __state,
            __uid,
            __reconciling,
            __create_time,
            __update_time,
            __etag,
            __kubernetes_version,
            __annotations,
            __workload_identity_config,
            __logging_config,
            __errors,
            __authorization,
            __monitoring_config,
            __proxy_config,
            __binary_authorization,
            __security_posture_config,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "oidcConfig" => Ok(__FieldTag::__oidc_config),
                            "oidc_config" => Ok(__FieldTag::__oidc_config),
                            "platformVersion" => Ok(__FieldTag::__platform_version),
                            "platform_version" => Ok(__FieldTag::__platform_version),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "clusterRegion" => Ok(__FieldTag::__cluster_region),
                            "cluster_region" => Ok(__FieldTag::__cluster_region),
                            "fleet" => Ok(__FieldTag::__fleet),
                            "state" => Ok(__FieldTag::__state),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "kubernetesVersion" => Ok(__FieldTag::__kubernetes_version),
                            "kubernetes_version" => Ok(__FieldTag::__kubernetes_version),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "workloadIdentityConfig" => Ok(__FieldTag::__workload_identity_config),
                            "workload_identity_config" => {
                                Ok(__FieldTag::__workload_identity_config)
                            }
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "errors" => Ok(__FieldTag::__errors),
                            "authorization" => Ok(__FieldTag::__authorization),
                            "monitoringConfig" => Ok(__FieldTag::__monitoring_config),
                            "monitoring_config" => Ok(__FieldTag::__monitoring_config),
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            "binaryAuthorization" => Ok(__FieldTag::__binary_authorization),
                            "binary_authorization" => Ok(__FieldTag::__binary_authorization),
                            "securityPostureConfig" => Ok(__FieldTag::__security_posture_config),
                            "security_posture_config" => Ok(__FieldTag::__security_posture_config),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oidc_config => {
                            if !fields.insert(__FieldTag::__oidc_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oidc_config",
                                ));
                            }
                            result.oidc_config = map.next_value::<std::option::Option<crate::model::AttachedOidcConfig>>()?
                                ;
                        }
                        __FieldTag::__platform_version => {
                            if !fields.insert(__FieldTag::__platform_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform_version",
                                ));
                            }
                            result.platform_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_region => {
                            if !fields.insert(__FieldTag::__cluster_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_region",
                                ));
                            }
                            result.cluster_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet => {
                            if !fields.insert(__FieldTag::__fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet",
                                ));
                            }
                            result.fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::attached_cluster::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kubernetes_version => {
                            if !fields.insert(__FieldTag::__kubernetes_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_version",
                                ));
                            }
                            result.kubernetes_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_identity_config => {
                            if !fields.insert(__FieldTag::__workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_identity_config",
                                ));
                            }
                            result.workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttachedClusterError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorization => {
                            if !fields.insert(__FieldTag::__authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization",
                                ));
                            }
                            result.authorization =
                                map.next_value::<std::option::Option<
                                    crate::model::AttachedClustersAuthorization,
                                >>()?;
                        }
                        __FieldTag::__monitoring_config => {
                            if !fields.insert(__FieldTag::__monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_config",
                                ));
                            }
                            result.monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map.next_value::<std::option::Option<crate::model::AttachedProxyConfig>>()?
                                ;
                        }
                        __FieldTag::__binary_authorization => {
                            if !fields.insert(__FieldTag::__binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_authorization",
                                ));
                            }
                            result.binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__security_posture_config => {
                            if !fields.insert(__FieldTag::__security_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_posture_config",
                                ));
                            }
                            result.security_posture_config = map.next_value::<std::option::Option<crate::model::SecurityPostureConfig>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.oidc_config.is_some() {
            state.serialize_entry("oidcConfig", &self.oidc_config)?;
        }
        if !self.platform_version.is_empty() {
            state.serialize_entry("platformVersion", &self.platform_version)?;
        }
        if !self.distribution.is_empty() {
            state.serialize_entry("distribution", &self.distribution)?;
        }
        if !self.cluster_region.is_empty() {
            state.serialize_entry("clusterRegion", &self.cluster_region)?;
        }
        if self.fleet.is_some() {
            state.serialize_entry("fleet", &self.fleet)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.kubernetes_version.is_empty() {
            state.serialize_entry("kubernetesVersion", &self.kubernetes_version)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.workload_identity_config.is_some() {
            state.serialize_entry("workloadIdentityConfig", &self.workload_identity_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.authorization.is_some() {
            state.serialize_entry("authorization", &self.authorization)?;
        }
        if self.monitoring_config.is_some() {
            state.serialize_entry("monitoringConfig", &self.monitoring_config)?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if self.binary_authorization.is_some() {
            state.serialize_entry("binaryAuthorization", &self.binary_authorization)?;
        }
        if self.security_posture_config.is_some() {
            state.serialize_entry("securityPostureConfig", &self.security_posture_config)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AttachedCluster].
pub mod attached_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the cluster is being registered.
        Provisioning,
        /// The RUNNING state indicates the cluster has been register and is fully
        /// usable.
        Running,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading software components.
        Reconciling,
        /// The STOPPING state indicates the cluster is being de-registered.
        Stopping,
        /// The ERROR state indicates the cluster is in a broken unrecoverable
        /// state.
        Error,
        /// The DEGRADED state indicates the cluster requires user action to
        /// restore full functionality.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkemulticloud.v1.AttachedCluster.State",
            ))
        }
    }
}

/// Configuration related to the cluster RBAC settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedClustersAuthorization {
    /// Optional. Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
    /// to the users. Up to ten admin users can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    pub admin_users: std::vec::Vec<crate::model::AttachedClusterUser>,

    /// Optional. Groups of users that can perform operations as a cluster admin. A
    /// managed ClusterRoleBinding will be created to grant the `cluster-admin`
    /// ClusterRole to the groups. Up to ten admin groups can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    pub admin_groups: std::vec::Vec<crate::model::AttachedClusterGroup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedClustersAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::AttachedClustersAuthorization::admin_users].
    pub fn set_admin_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedClusterUser>,
    {
        use std::iter::Iterator;
        self.admin_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin_groups][crate::model::AttachedClustersAuthorization::admin_groups].
    pub fn set_admin_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedClusterGroup>,
    {
        use std::iter::Iterator;
        self.admin_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttachedClustersAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClustersAuthorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedClustersAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __admin_users,
            __admin_groups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedClustersAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adminUsers" => Ok(__FieldTag::__admin_users),
                            "admin_users" => Ok(__FieldTag::__admin_users),
                            "adminGroups" => Ok(__FieldTag::__admin_groups),
                            "admin_groups" => Ok(__FieldTag::__admin_groups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedClustersAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedClustersAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__admin_users => {
                            if !fields.insert(__FieldTag::__admin_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_users",
                                ));
                            }
                            result.admin_users = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttachedClusterUser>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admin_groups => {
                            if !fields.insert(__FieldTag::__admin_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_groups",
                                ));
                            }
                            result.admin_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttachedClusterGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedClustersAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.admin_users.is_empty() {
            state.serialize_entry("adminUsers", &self.admin_users)?;
        }
        if !self.admin_groups.is_empty() {
            state.serialize_entry("adminGroups", &self.admin_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identities of a user-type subject for Attached clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedClusterUser {
    /// Required. The name of the user, e.g. `my-gcp-id@gmail.com`.
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::AttachedClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AttachedClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClusterUser"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedClusterUser {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedClusterUser")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedClusterUser;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedClusterUser")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedClusterUser {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identities of a group-type subject for Attached clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedClusterGroup {
    /// Required. The name of the group, e.g. `my-group@domain.com`.
    pub group: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedClusterGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AttachedClusterGroup::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }
}

impl wkt::message::Message for AttachedClusterGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClusterGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedClusterGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedClusterGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedClusterGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedClusterGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedClusterGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// OIDC discovery information of the target cluster.
///
/// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
/// API server. This fields indicates how Google Cloud Platform services
/// validate KSA tokens in order to allow system workloads (such as GKE Connect
/// and telemetry agents) to authenticate back to Google Cloud Platform.
///
/// Both clusters with public and private issuer URLs are supported.
/// Clusters with public issuers only need to specify the `issuer_url` field
/// while clusters with private issuers need to provide both
/// `issuer_url` and `oidc_jwks`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedOidcConfig {
    /// A JSON Web Token (JWT) issuer URI. `issuer` must start with `https://`.
    pub issuer_url: std::string::String,

    /// Optional. OIDC verification keys in JWKS format (RFC 7517).
    /// It contains a list of OIDC verification keys that can be used to verify
    /// OIDC JWTs.
    ///
    /// This field is required for cluster that doesn't have a publicly available
    /// discovery endpoint. When provided, it will be directly used
    /// to verify the OIDC JWT asserted by the IDP.
    pub jwks: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedOidcConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer_url][crate::model::AttachedOidcConfig::issuer_url].
    pub fn set_issuer_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer_url = v.into();
        self
    }

    /// Sets the value of [jwks][crate::model::AttachedOidcConfig::jwks].
    pub fn set_jwks<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.jwks = v.into();
        self
    }
}

impl wkt::message::Message for AttachedOidcConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedOidcConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedOidcConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issuer_url,
            __jwks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedOidcConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issuerUrl" => Ok(__FieldTag::__issuer_url),
                            "issuer_url" => Ok(__FieldTag::__issuer_url),
                            "jwks" => Ok(__FieldTag::__jwks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedOidcConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedOidcConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issuer_url => {
                            if !fields.insert(__FieldTag::__issuer_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer_url",
                                ));
                            }
                            result.issuer_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jwks => {
                            if !fields.insert(__FieldTag::__jwks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwks",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.jwks = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedOidcConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issuer_url.is_empty() {
            state.serialize_entry("issuerUrl", &self.issuer_url)?;
        }
        if !self.jwks.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("jwks", &__With(&self.jwks))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AttachedServerConfig provides information about supported
/// Kubernetes versions
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedServerConfig {
    /// The resource name of the config.
    pub name: std::string::String,

    /// List of valid platform versions.
    pub valid_versions: std::vec::Vec<crate::model::AttachedPlatformVersionInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachedServerConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [valid_versions][crate::model::AttachedServerConfig::valid_versions].
    pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedPlatformVersionInfo>,
    {
        use std::iter::Iterator;
        self.valid_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttachedServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __valid_versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validVersions" => Ok(__FieldTag::__valid_versions),
                            "valid_versions" => Ok(__FieldTag::__valid_versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_versions => {
                            if !fields.insert(__FieldTag::__valid_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_versions",
                                ));
                            }
                            result.valid_versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttachedPlatformVersionInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.valid_versions.is_empty() {
            state.serialize_entry("validVersions", &self.valid_versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about a supported Attached Clusters platform version.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedPlatformVersionInfo {
    /// Platform version name.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedPlatformVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AttachedPlatformVersionInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for AttachedPlatformVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedPlatformVersionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedPlatformVersionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedPlatformVersionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedPlatformVersionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedPlatformVersionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedPlatformVersionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AttachedClusterError describes errors found on attached clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedClusterError {
    /// Human-friendly description of the error.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedClusterError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AttachedClusterError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AttachedClusterError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClusterError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedClusterError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedClusterError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedClusterError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedClusterError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedClusterError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of a proxy config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedProxyConfig {
    /// The Kubernetes Secret resource that contains the HTTP(S) proxy
    /// configuration. The secret must be a JSON encoded proxy configuration
    /// as described in
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/attached/eks/how-to/use-a-proxy#configure-proxy-support>
    /// for EKS clusters and
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/attached/aks/how-to/use-a-proxy#configure-proxy-support>
    /// for AKS clusters.
    pub kubernetes_secret: std::option::Option<crate::model::KubernetesSecret>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachedProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kubernetes_secret][crate::model::AttachedProxyConfig::kubernetes_secret].
    pub fn set_kubernetes_secret<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KubernetesSecret>,
    {
        self.kubernetes_secret = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubernetes_secret][crate::model::AttachedProxyConfig::kubernetes_secret].
    pub fn set_or_clear_kubernetes_secret<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KubernetesSecret>,
    {
        self.kubernetes_secret = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttachedProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedProxyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachedProxyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kubernetes_secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachedProxyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kubernetesSecret" => Ok(__FieldTag::__kubernetes_secret),
                            "kubernetes_secret" => Ok(__FieldTag::__kubernetes_secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachedProxyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachedProxyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kubernetes_secret => {
                            if !fields.insert(__FieldTag::__kubernetes_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_secret",
                                ));
                            }
                            result.kubernetes_secret = map
                                .next_value::<std::option::Option<crate::model::KubernetesSecret>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachedProxyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kubernetes_secret.is_some() {
            state.serialize_entry("kubernetesSecret", &self.kubernetes_secret)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about a Kubernetes Secret
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KubernetesSecret {
    /// Name of the kubernetes secret.
    pub name: std::string::String,

    /// Namespace in which the kubernetes secret is stored.
    pub namespace: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KubernetesSecret::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [namespace][crate::model::KubernetesSecret::namespace].
    pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace = v.into();
        self
    }
}

impl wkt::message::Message for KubernetesSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.KubernetesSecret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KubernetesSecret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __namespace,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesSecret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "namespace" => Ok(__FieldTag::__namespace),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KubernetesSecret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesSecret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace => {
                            if !fields.insert(__FieldTag::__namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace",
                                ));
                            }
                            result.namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KubernetesSecret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.namespace.is_empty() {
            state.serialize_entry("namespace", &self.namespace)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.GenerateAttachedClusterInstallManifest`
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAttachedClusterInstallManifestRequest {
    /// Required. The parent location where this
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will be created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub parent: std::string::String,

    /// Required. A client provided ID of the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// name formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// When generating an install manifest for importing an existing Membership
    /// resource, the attached_cluster_id field must be the Membership id.
    ///
    /// Membership names are formatted as
    /// `projects/<project-id>/locations/<region>/memberships/<membership-id>`.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub attached_cluster_id: std::string::String,

    /// Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig]: crate::client::AttachedClusters::get_attached_server_config
    pub platform_version: std::string::String,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AttachedProxyConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAttachedClusterInstallManifestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateAttachedClusterInstallManifestRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attached_cluster_id][crate::model::GenerateAttachedClusterInstallManifestRequest::attached_cluster_id].
    pub fn set_attached_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster_id = v.into();
        self
    }

    /// Sets the value of [platform_version][crate::model::GenerateAttachedClusterInstallManifestRequest::platform_version].
    pub fn set_platform_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_version = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::GenerateAttachedClusterInstallManifestRequest::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::GenerateAttachedClusterInstallManifestRequest::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterInstallManifestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterInstallManifestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAttachedClusterInstallManifestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __attached_cluster_id,
            __platform_version,
            __proxy_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for GenerateAttachedClusterInstallManifestRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "attachedClusterId" => Ok(__FieldTag::__attached_cluster_id),
                            "attached_cluster_id" => Ok(__FieldTag::__attached_cluster_id),
                            "platformVersion" => Ok(__FieldTag::__platform_version),
                            "platform_version" => Ok(__FieldTag::__platform_version),
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAttachedClusterInstallManifestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAttachedClusterInstallManifestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attached_cluster_id => {
                            if !fields.insert(__FieldTag::__attached_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_cluster_id",
                                ));
                            }
                            result.attached_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__platform_version => {
                            if !fields.insert(__FieldTag::__platform_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform_version",
                                ));
                            }
                            result.platform_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map.next_value::<std::option::Option<crate::model::AttachedProxyConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAttachedClusterInstallManifestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.attached_cluster_id.is_empty() {
            state.serialize_entry("attachedClusterId", &self.attached_cluster_id)?;
        }
        if !self.platform_version.is_empty() {
            state.serialize_entry("platformVersion", &self.platform_version)?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// `AttachedClusters.GenerateAttachedClusterInstallManifest` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAttachedClusterInstallManifestResponse {
    /// A set of Kubernetes resources (in YAML format) to be applied
    /// to the cluster to be attached.
    pub manifest: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAttachedClusterInstallManifestResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [manifest][crate::model::GenerateAttachedClusterInstallManifestResponse::manifest].
    pub fn set_manifest<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.manifest = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterInstallManifestResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterInstallManifestResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAttachedClusterInstallManifestResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __manifest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for GenerateAttachedClusterInstallManifestResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "manifest" => Ok(__FieldTag::__manifest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAttachedClusterInstallManifestResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAttachedClusterInstallManifestResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__manifest => {
                            if !fields.insert(__FieldTag::__manifest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifest",
                                ));
                            }
                            result.manifest = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAttachedClusterInstallManifestResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.manifest.is_empty() {
            state.serialize_entry("manifest", &self.manifest)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.CreateAttachedCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAttachedClusterRequest {
    /// Required. The parent location where this
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will be created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub attached_cluster: std::option::Option<crate::model::AttachedCluster>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// name formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub attached_cluster_id: std::string::String,

    /// If set, only validate the request, but do not actually create the cluster.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAttachedClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attached_cluster][crate::model::CreateAttachedClusterRequest::attached_cluster].
    pub fn set_attached_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedCluster>,
    {
        self.attached_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attached_cluster][crate::model::CreateAttachedClusterRequest::attached_cluster].
    pub fn set_or_clear_attached_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedCluster>,
    {
        self.attached_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attached_cluster_id][crate::model::CreateAttachedClusterRequest::attached_cluster_id].
    pub fn set_attached_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAttachedClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAttachedClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __attached_cluster,
            __attached_cluster_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAttachedClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "attachedCluster" => Ok(__FieldTag::__attached_cluster),
                            "attached_cluster" => Ok(__FieldTag::__attached_cluster),
                            "attachedClusterId" => Ok(__FieldTag::__attached_cluster_id),
                            "attached_cluster_id" => Ok(__FieldTag::__attached_cluster_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAttachedClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAttachedClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attached_cluster => {
                            if !fields.insert(__FieldTag::__attached_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_cluster",
                                ));
                            }
                            result.attached_cluster = map
                                .next_value::<std::option::Option<crate::model::AttachedCluster>>(
                                )?;
                        }
                        __FieldTag::__attached_cluster_id => {
                            if !fields.insert(__FieldTag::__attached_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_cluster_id",
                                ));
                            }
                            result.attached_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAttachedClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.attached_cluster.is_some() {
            state.serialize_entry("attachedCluster", &self.attached_cluster)?;
        }
        if !self.attached_cluster_id.is_empty() {
            state.serialize_entry("attachedClusterId", &self.attached_cluster_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.ImportAttachedCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAttachedClusterRequest {
    /// Required. The parent location where this
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will be created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub parent: std::string::String,

    /// If set, only validate the request, but do not actually import the cluster.
    pub validate_only: bool,

    /// Required. The name of the fleet membership resource to import.
    pub fleet_membership: std::string::String,

    /// Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig]: crate::client::AttachedClusters::get_attached_server_config
    pub platform_version: std::string::String,

    /// Required. The Kubernetes distribution of the underlying attached cluster.
    ///
    /// Supported values: ["eks", "aks", "generic"].
    pub distribution: std::string::String,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AttachedProxyConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportAttachedClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::ImportAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [fleet_membership][crate::model::ImportAttachedClusterRequest::fleet_membership].
    pub fn set_fleet_membership<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet_membership = v.into();
        self
    }

    /// Sets the value of [platform_version][crate::model::ImportAttachedClusterRequest::platform_version].
    pub fn set_platform_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_version = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::ImportAttachedClusterRequest::distribution].
    pub fn set_distribution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.distribution = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::ImportAttachedClusterRequest::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::ImportAttachedClusterRequest::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ImportAttachedClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportAttachedClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __validate_only,
            __fleet_membership,
            __platform_version,
            __distribution,
            __proxy_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportAttachedClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "fleetMembership" => Ok(__FieldTag::__fleet_membership),
                            "fleet_membership" => Ok(__FieldTag::__fleet_membership),
                            "platformVersion" => Ok(__FieldTag::__platform_version),
                            "platform_version" => Ok(__FieldTag::__platform_version),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportAttachedClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportAttachedClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet_membership => {
                            if !fields.insert(__FieldTag::__fleet_membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet_membership",
                                ));
                            }
                            result.fleet_membership = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__platform_version => {
                            if !fields.insert(__FieldTag::__platform_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform_version",
                                ));
                            }
                            result.platform_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map.next_value::<std::option::Option<crate::model::AttachedProxyConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportAttachedClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.fleet_membership.is_empty() {
            state.serialize_entry("fleetMembership", &self.fleet_membership)?;
        }
        if !self.platform_version.is_empty() {
            state.serialize_entry("platformVersion", &self.platform_version)?;
        }
        if !self.distribution.is_empty() {
            state.serialize_entry("distribution", &self.distribution)?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.UpdateAttachedCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAttachedClusterRequest {
    /// Required. The
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub attached_cluster: std::option::Option<crate::model::AttachedCluster>,

    /// If set, only validate the request, but do not actually update the cluster.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]:
    ///
    /// * `annotations`.
    /// * `authorization.admin_groups`.
    /// * `authorization.admin_users`.
    /// * `binary_authorization.evaluation_mode`.
    /// * `description`.
    /// * `logging_config.component_config.enable_components`.
    /// * `monitoring_config.managed_prometheus_config.enabled`.
    /// * `platform_version`.
    /// * `proxy_config.kubernetes_secret.name`.
    /// * `proxy_config.kubernetes_secret.namespace`.
    /// * `security_posture_config.vulnerability_mode`
    /// * `monitoring_config.cloud_monitoring_config.enabled`
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_cluster][crate::model::UpdateAttachedClusterRequest::attached_cluster].
    pub fn set_attached_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedCluster>,
    {
        self.attached_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attached_cluster][crate::model::UpdateAttachedClusterRequest::attached_cluster].
    pub fn set_or_clear_attached_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedCluster>,
    {
        self.attached_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAttachedClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAttachedClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAttachedClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAttachedClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attached_cluster,
            __validate_only,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAttachedClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attachedCluster" => Ok(__FieldTag::__attached_cluster),
                            "attached_cluster" => Ok(__FieldTag::__attached_cluster),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAttachedClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAttachedClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attached_cluster => {
                            if !fields.insert(__FieldTag::__attached_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_cluster",
                                ));
                            }
                            result.attached_cluster = map
                                .next_value::<std::option::Option<crate::model::AttachedCluster>>(
                                )?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAttachedClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attached_cluster.is_some() {
            state.serialize_entry("attachedCluster", &self.attached_cluster)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.GetAttachedCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAttachedClusterRequest {
    /// Required. The name of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// to describe.
    ///
    /// `AttachedCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttachedClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAttachedClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAttachedClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAttachedClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAttachedClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAttachedClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAttachedClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.ListAttachedClusters` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttachedClustersRequest {
    /// Required. The parent location which owns this collection of
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAttachedClustersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAttachedClustersResponse.next_page_token]: crate::model::ListAttachedClustersResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [attachedClusters.list][google.cloud.gkemulticloud.v1.AttachedClusters.ListAttachedClusters]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.ListAttachedClusters]: crate::client::AttachedClusters::list_attached_clusters
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttachedClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttachedClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttachedClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttachedClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachedClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAttachedClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAttachedClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAttachedClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAttachedClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAttachedClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAttachedClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AttachedClusters.ListAttachedClusters` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttachedClustersResponse {
    /// A list of [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]
    /// resources in the specified Google Cloud Platform project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub attached_clusters: std::vec::Vec<crate::model::AttachedCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttachedClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_clusters][crate::model::ListAttachedClustersResponse::attached_clusters].
    pub fn set_attached_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedCluster>,
    {
        use std::iter::Iterator;
        self.attached_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAttachedClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachedClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAttachedClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAttachedClustersResponse {
    type PageItem = crate::model::AttachedCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attached_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAttachedClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attached_clusters,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAttachedClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attachedClusters" => Ok(__FieldTag::__attached_clusters),
                            "attached_clusters" => Ok(__FieldTag::__attached_clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAttachedClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAttachedClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attached_clusters => {
                            if !fields.insert(__FieldTag::__attached_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_clusters",
                                ));
                            }
                            result.attached_clusters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttachedCluster>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAttachedClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attached_clusters.is_empty() {
            state.serialize_entry("attachedClusters", &self.attached_clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AttachedClusters.DeleteAttachedCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAttachedClusterRequest {
    /// Required. The resource name the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] to delete.
    ///
    /// `AttachedCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// is not found, the request will succeed but no action will be taken on the
    /// server and a completed [Operation][google.longrunning.Operation] will be
    /// returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// If set to true, the deletion of
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will succeed even if errors occur during deleting in cluster resources.
    /// Using this parameter may result in orphaned resources in the cluster.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub ignore_errors: bool,

    /// The current etag of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided etag does not match the current etag of the cluster,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAttachedClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAttachedClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAttachedClusterRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAttachedClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAttachedClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAttachedClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __ignore_errors,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAttachedClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "ignoreErrors" => Ok(__FieldTag::__ignore_errors),
                            "ignore_errors" => Ok(__FieldTag::__ignore_errors),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAttachedClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAttachedClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_errors => {
                            if !fields.insert(__FieldTag::__ignore_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_errors",
                                ));
                            }
                            result.ignore_errors = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAttachedClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.ignore_errors) {
            state.serialize_entry("ignoreErrors", &self.ignore_errors)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAttachedServerConfigRequest gets the server config for attached
/// clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAttachedServerConfigRequest {
    /// Required. The name of the
    /// [AttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedServerConfig]
    /// resource to describe.
    ///
    /// `AttachedServerConfig` names are formatted as
    /// `projects/<project-id>/locations/<region>/attachedServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedServerConfig]: crate::model::AttachedServerConfig
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAttachedServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttachedServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttachedServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAttachedServerConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAttachedServerConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAttachedServerConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAttachedServerConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAttachedServerConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAttachedServerConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAttachedClusterAgentTokenRequest {
    /// Required.
    pub attached_cluster: std::string::String,

    /// Required.
    pub subject_token: std::string::String,

    /// Required.
    pub subject_token_type: std::string::String,

    /// Required.
    pub version: std::string::String,

    /// Optional.
    pub grant_type: std::string::String,

    /// Optional.
    pub audience: std::string::String,

    /// Optional.
    pub scope: std::string::String,

    /// Optional.
    pub requested_token_type: std::string::String,

    /// Optional.
    pub options: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAttachedClusterAgentTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_cluster][crate::model::GenerateAttachedClusterAgentTokenRequest::attached_cluster].
    pub fn set_attached_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster = v.into();
        self
    }

    /// Sets the value of [subject_token][crate::model::GenerateAttachedClusterAgentTokenRequest::subject_token].
    pub fn set_subject_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_token = v.into();
        self
    }

    /// Sets the value of [subject_token_type][crate::model::GenerateAttachedClusterAgentTokenRequest::subject_token_type].
    pub fn set_subject_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_token_type = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenerateAttachedClusterAgentTokenRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [grant_type][crate::model::GenerateAttachedClusterAgentTokenRequest::grant_type].
    pub fn set_grant_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grant_type = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::GenerateAttachedClusterAgentTokenRequest::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::GenerateAttachedClusterAgentTokenRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [requested_token_type][crate::model::GenerateAttachedClusterAgentTokenRequest::requested_token_type].
    pub fn set_requested_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_token_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::GenerateAttachedClusterAgentTokenRequest::options].
    pub fn set_options<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.options = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterAgentTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterAgentTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAttachedClusterAgentTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attached_cluster,
            __subject_token,
            __subject_token_type,
            __version,
            __grant_type,
            __audience,
            __scope,
            __requested_token_type,
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAttachedClusterAgentTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attachedCluster" => Ok(__FieldTag::__attached_cluster),
                            "attached_cluster" => Ok(__FieldTag::__attached_cluster),
                            "subjectToken" => Ok(__FieldTag::__subject_token),
                            "subject_token" => Ok(__FieldTag::__subject_token),
                            "subjectTokenType" => Ok(__FieldTag::__subject_token_type),
                            "subject_token_type" => Ok(__FieldTag::__subject_token_type),
                            "version" => Ok(__FieldTag::__version),
                            "grantType" => Ok(__FieldTag::__grant_type),
                            "grant_type" => Ok(__FieldTag::__grant_type),
                            "audience" => Ok(__FieldTag::__audience),
                            "scope" => Ok(__FieldTag::__scope),
                            "requestedTokenType" => Ok(__FieldTag::__requested_token_type),
                            "requested_token_type" => Ok(__FieldTag::__requested_token_type),
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAttachedClusterAgentTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAttachedClusterAgentTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attached_cluster => {
                            if !fields.insert(__FieldTag::__attached_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached_cluster",
                                ));
                            }
                            result.attached_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_token => {
                            if !fields.insert(__FieldTag::__subject_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_token",
                                ));
                            }
                            result.subject_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_token_type => {
                            if !fields.insert(__FieldTag::__subject_token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_token_type",
                                ));
                            }
                            result.subject_token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grant_type => {
                            if !fields.insert(__FieldTag::__grant_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_type",
                                ));
                            }
                            result.grant_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audience",
                                ));
                            }
                            result.audience = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_token_type => {
                            if !fields.insert(__FieldTag::__requested_token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_token_type",
                                ));
                            }
                            result.requested_token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAttachedClusterAgentTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attached_cluster.is_empty() {
            state.serialize_entry("attachedCluster", &self.attached_cluster)?;
        }
        if !self.subject_token.is_empty() {
            state.serialize_entry("subjectToken", &self.subject_token)?;
        }
        if !self.subject_token_type.is_empty() {
            state.serialize_entry("subjectTokenType", &self.subject_token_type)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.grant_type.is_empty() {
            state.serialize_entry("grantType", &self.grant_type)?;
        }
        if !self.audience.is_empty() {
            state.serialize_entry("audience", &self.audience)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.requested_token_type.is_empty() {
            state.serialize_entry("requestedTokenType", &self.requested_token_type)?;
        }
        if !self.options.is_empty() {
            state.serialize_entry("options", &self.options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAttachedClusterAgentTokenResponse {
    pub access_token: std::string::String,

    pub expires_in: i32,

    pub token_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAttachedClusterAgentTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAttachedClusterAgentTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expires_in][crate::model::GenerateAttachedClusterAgentTokenResponse::expires_in].
    pub fn set_expires_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expires_in = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::GenerateAttachedClusterAgentTokenResponse::token_type].
    pub fn set_token_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterAgentTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterAgentTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAttachedClusterAgentTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expires_in,
            __token_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAttachedClusterAgentTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expiresIn" => Ok(__FieldTag::__expires_in),
                            "expires_in" => Ok(__FieldTag::__expires_in),
                            "tokenType" => Ok(__FieldTag::__token_type),
                            "token_type" => Ok(__FieldTag::__token_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAttachedClusterAgentTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAttachedClusterAgentTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expires_in => {
                            if !fields.insert(__FieldTag::__expires_in) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expires_in",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expires_in = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__token_type => {
                            if !fields.insert(__FieldTag::__token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_type",
                                ));
                            }
                            result.token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAttachedClusterAgentTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if !wkt::internal::is_default(&self.expires_in) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expiresIn", &__With(&self.expires_in))?;
        }
        if !self.token_type.is_empty() {
            state.serialize_entry("tokenType", &self.token_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An Anthos cluster running on AWS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsCluster {
    /// The name of this resource.
    ///
    /// Cluster names are formatted as
    /// `projects/<project-number>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    pub name: std::string::String,

    /// Optional. A human readable description of this cluster.
    /// Cannot be longer than 255 UTF-8 encoded bytes.
    pub description: std::string::String,

    /// Required. Cluster-wide networking configuration.
    pub networking: std::option::Option<crate::model::AwsClusterNetworking>,

    /// Required. The AWS region where the cluster runs.
    ///
    /// Each Google Cloud region supports a subset of nearby AWS regions.
    /// You can call
    /// [GetAwsServerConfig][google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]
    /// to list all supported AWS regions within a given Google Cloud region.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]: crate::client::AwsClusters::get_aws_server_config
    pub aws_region: std::string::String,

    /// Required. Configuration related to the cluster control plane.
    pub control_plane: std::option::Option<crate::model::AwsControlPlane>,

    /// Required. Configuration related to the cluster RBAC settings.
    pub authorization: std::option::Option<crate::model::AwsAuthorization>,

    /// Output only. The current state of the cluster.
    pub state: crate::model::aws_cluster::State,

    /// Output only. The endpoint of the cluster's API server.
    pub endpoint: std::string::String,

    /// Output only. A globally unique identifier for the cluster.
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the cluster.
    pub reconciling: bool,

    /// Output only. The time at which this cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this cluster was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Annotations on the cluster.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workload Identity settings.
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Output only. PEM encoded x509 certificate of the cluster root of trust.
    pub cluster_ca_certificate: std::string::String,

    /// Required. Fleet configuration.
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Optional. Logging configuration for this cluster.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Output only. A set of errors found in the cluster.
    pub errors: std::vec::Vec<crate::model::AwsClusterError>,

    /// Optional. Monitoring configuration for this cluster.
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// Optional. Binary Authorization configuration for this cluster.
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AwsCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AwsCluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [networking][crate::model::AwsCluster::networking].
    pub fn set_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsClusterNetworking>,
    {
        self.networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [networking][crate::model::AwsCluster::networking].
    pub fn set_or_clear_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsClusterNetworking>,
    {
        self.networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aws_region][crate::model::AwsCluster::aws_region].
    pub fn set_aws_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_region = v.into();
        self
    }

    /// Sets the value of [control_plane][crate::model::AwsCluster::control_plane].
    pub fn set_control_plane<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsControlPlane>,
    {
        self.control_plane = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane][crate::model::AwsCluster::control_plane].
    pub fn set_or_clear_control_plane<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsControlPlane>,
    {
        self.control_plane = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization][crate::model::AwsCluster::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsAuthorization>,
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::AwsCluster::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsAuthorization>,
    {
        self.authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::AwsCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::AwsCluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AwsCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AwsCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AwsCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AwsCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AwsCluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AwsCluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AwsCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AwsCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::AwsCluster::workload_identity_config].
    pub fn set_workload_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_identity_config][crate::model::AwsCluster::workload_identity_config].
    pub fn set_or_clear_workload_identity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::AwsCluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::AwsCluster::fleet].
    pub fn set_fleet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fleet][crate::model::AwsCluster::fleet].
    pub fn set_or_clear_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::AwsCluster::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::AwsCluster::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::AwsCluster::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsClusterError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::AwsCluster::monitoring_config].
    pub fn set_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monitoring_config][crate::model::AwsCluster::monitoring_config].
    pub fn set_or_clear_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [binary_authorization][crate::model::AwsCluster::binary_authorization].
    pub fn set_binary_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary_authorization][crate::model::AwsCluster::binary_authorization].
    pub fn set_or_clear_binary_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __networking,
            __aws_region,
            __control_plane,
            __authorization,
            __state,
            __endpoint,
            __uid,
            __reconciling,
            __create_time,
            __update_time,
            __etag,
            __annotations,
            __workload_identity_config,
            __cluster_ca_certificate,
            __fleet,
            __logging_config,
            __errors,
            __monitoring_config,
            __binary_authorization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "networking" => Ok(__FieldTag::__networking),
                            "awsRegion" => Ok(__FieldTag::__aws_region),
                            "aws_region" => Ok(__FieldTag::__aws_region),
                            "controlPlane" => Ok(__FieldTag::__control_plane),
                            "control_plane" => Ok(__FieldTag::__control_plane),
                            "authorization" => Ok(__FieldTag::__authorization),
                            "state" => Ok(__FieldTag::__state),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "workloadIdentityConfig" => Ok(__FieldTag::__workload_identity_config),
                            "workload_identity_config" => {
                                Ok(__FieldTag::__workload_identity_config)
                            }
                            "clusterCaCertificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "cluster_ca_certificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "fleet" => Ok(__FieldTag::__fleet),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "errors" => Ok(__FieldTag::__errors),
                            "monitoringConfig" => Ok(__FieldTag::__monitoring_config),
                            "monitoring_config" => Ok(__FieldTag::__monitoring_config),
                            "binaryAuthorization" => Ok(__FieldTag::__binary_authorization),
                            "binary_authorization" => Ok(__FieldTag::__binary_authorization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__networking => {
                            if !fields.insert(__FieldTag::__networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networking",
                                ));
                            }
                            result.networking = map.next_value::<std::option::Option<crate::model::AwsClusterNetworking>>()?
                                ;
                        }
                        __FieldTag::__aws_region => {
                            if !fields.insert(__FieldTag::__aws_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_region",
                                ));
                            }
                            result.aws_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane => {
                            if !fields.insert(__FieldTag::__control_plane) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane",
                                ));
                            }
                            result.control_plane = map
                                .next_value::<std::option::Option<crate::model::AwsControlPlane>>(
                                )?;
                        }
                        __FieldTag::__authorization => {
                            if !fields.insert(__FieldTag::__authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization",
                                ));
                            }
                            result.authorization = map
                                .next_value::<std::option::Option<crate::model::AwsAuthorization>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::aws_cluster::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_identity_config => {
                            if !fields.insert(__FieldTag::__workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_identity_config",
                                ));
                            }
                            result.workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__cluster_ca_certificate => {
                            if !fields.insert(__FieldTag::__cluster_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca_certificate",
                                ));
                            }
                            result.cluster_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet => {
                            if !fields.insert(__FieldTag::__fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet",
                                ));
                            }
                            result.fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsClusterError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring_config => {
                            if !fields.insert(__FieldTag::__monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_config",
                                ));
                            }
                            result.monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::__binary_authorization => {
                            if !fields.insert(__FieldTag::__binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_authorization",
                                ));
                            }
                            result.binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.networking.is_some() {
            state.serialize_entry("networking", &self.networking)?;
        }
        if !self.aws_region.is_empty() {
            state.serialize_entry("awsRegion", &self.aws_region)?;
        }
        if self.control_plane.is_some() {
            state.serialize_entry("controlPlane", &self.control_plane)?;
        }
        if self.authorization.is_some() {
            state.serialize_entry("authorization", &self.authorization)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.workload_identity_config.is_some() {
            state.serialize_entry("workloadIdentityConfig", &self.workload_identity_config)?;
        }
        if !self.cluster_ca_certificate.is_empty() {
            state.serialize_entry("clusterCaCertificate", &self.cluster_ca_certificate)?;
        }
        if self.fleet.is_some() {
            state.serialize_entry("fleet", &self.fleet)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.monitoring_config.is_some() {
            state.serialize_entry("monitoringConfig", &self.monitoring_config)?;
        }
        if self.binary_authorization.is_some() {
            state.serialize_entry("binaryAuthorization", &self.binary_authorization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AwsCluster].
pub mod aws_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the cluster is being created.
        Provisioning,
        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        Running,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the control plane replicas.
        Reconciling,
        /// The STOPPING state indicates the cluster is being deleted.
        Stopping,
        /// The ERROR state indicates the cluster is in a broken unrecoverable
        /// state.
        Error,
        /// The DEGRADED state indicates the cluster requires user action to
        /// restore full functionality.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkemulticloud.v1.AwsCluster.State",
            ))
        }
    }
}

/// ControlPlane defines common parameters between control plane nodes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsControlPlane {
    /// Required. The Kubernetes version to run on control plane replicas
    /// (e.g. `1.19.10-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAwsServerConfig][google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]: crate::client::AwsClusters::get_aws_server_config
    pub version: std::string::String,

    /// Optional. The AWS instance type.
    ///
    /// When unspecified, it uses a default based on the cluster's version.
    pub instance_type: std::string::String,

    /// Optional. SSH configuration for how to access the underlying control plane
    /// machines.
    pub ssh_config: std::option::Option<crate::model::AwsSshConfig>,

    /// Required. The list of subnets where control plane replicas will run.
    /// A replica will be provisioned on each subnet and up to three values
    /// can be provided.
    /// Each subnet must be in a different AWS Availability Zone (AZ).
    pub subnet_ids: std::vec::Vec<std::string::String>,

    /// Optional. The IDs of additional security groups to add to control plane
    /// replicas. The Anthos Multi-Cloud API will automatically create and manage
    /// security groups with the minimum rules needed for a functioning cluster.
    pub security_group_ids: std::vec::Vec<std::string::String>,

    /// Required. The name or ARN of the AWS IAM instance profile to assign to each
    /// control plane replica.
    pub iam_instance_profile: std::string::String,

    /// Optional. Configuration related to the root volume provisioned for each
    /// control plane replica.
    ///
    /// Volumes will be provisioned in the availability zone associated
    /// with the corresponding subnet.
    ///
    /// When unspecified, it defaults to 32 GiB with the GP2 volume type.
    pub root_volume: std::option::Option<crate::model::AwsVolumeTemplate>,

    /// Optional. Configuration related to the main volume provisioned for each
    /// control plane replica.
    /// The main volume is in charge of storing all of the cluster's etcd state.
    ///
    /// Volumes will be provisioned in the availability zone associated
    /// with the corresponding subnet.
    ///
    /// When unspecified, it defaults to 8 GiB with the GP2 volume type.
    pub main_volume: std::option::Option<crate::model::AwsVolumeTemplate>,

    /// Required. The ARN of the AWS KMS key used to encrypt cluster secrets.
    pub database_encryption: std::option::Option<crate::model::AwsDatabaseEncryption>,

    /// Optional. A set of AWS resource tags to propagate to all underlying managed
    /// AWS resources.
    ///
    /// Specify at most 50 pairs containing alphanumerics, spaces, and symbols
    /// (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to
    /// 255 Unicode characters.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Authentication configuration for management of AWS resources.
    pub aws_services_authentication: std::option::Option<crate::model::AwsServicesAuthentication>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AwsProxyConfig>,

    /// Required. Config encryption for user data.
    pub config_encryption: std::option::Option<crate::model::AwsConfigEncryption>,

    /// Optional. The placement to use on control plane instances.
    /// When unspecified, the VPC's default tenancy will be used.
    pub instance_placement: std::option::Option<crate::model::AwsInstancePlacement>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsControlPlane {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AwsControlPlane::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::AwsControlPlane::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AwsControlPlane::ssh_config].
    pub fn set_ssh_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsSshConfig>,
    {
        self.ssh_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssh_config][crate::model::AwsControlPlane::ssh_config].
    pub fn set_or_clear_ssh_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsSshConfig>,
    {
        self.ssh_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnet_ids][crate::model::AwsControlPlane::subnet_ids].
    pub fn set_subnet_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subnet_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_group_ids][crate::model::AwsControlPlane::security_group_ids].
    pub fn set_security_group_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.security_group_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [iam_instance_profile][crate::model::AwsControlPlane::iam_instance_profile].
    pub fn set_iam_instance_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.iam_instance_profile = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AwsControlPlane::root_volume].
    pub fn set_root_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsVolumeTemplate>,
    {
        self.root_volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [root_volume][crate::model::AwsControlPlane::root_volume].
    pub fn set_or_clear_root_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsVolumeTemplate>,
    {
        self.root_volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [main_volume][crate::model::AwsControlPlane::main_volume].
    pub fn set_main_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsVolumeTemplate>,
    {
        self.main_volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [main_volume][crate::model::AwsControlPlane::main_volume].
    pub fn set_or_clear_main_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsVolumeTemplate>,
    {
        self.main_volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_encryption][crate::model::AwsControlPlane::database_encryption].
    pub fn set_database_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsDatabaseEncryption>,
    {
        self.database_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_encryption][crate::model::AwsControlPlane::database_encryption].
    pub fn set_or_clear_database_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsDatabaseEncryption>,
    {
        self.database_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::AwsControlPlane::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [aws_services_authentication][crate::model::AwsControlPlane::aws_services_authentication].
    pub fn set_aws_services_authentication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsServicesAuthentication>,
    {
        self.aws_services_authentication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_services_authentication][crate::model::AwsControlPlane::aws_services_authentication].
    pub fn set_or_clear_aws_services_authentication<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsServicesAuthentication>,
    {
        self.aws_services_authentication = v.map(|x| x.into());
        self
    }

    /// Sets the value of [proxy_config][crate::model::AwsControlPlane::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::AwsControlPlane::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_encryption][crate::model::AwsControlPlane::config_encryption].
    pub fn set_config_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsConfigEncryption>,
    {
        self.config_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_encryption][crate::model::AwsControlPlane::config_encryption].
    pub fn set_or_clear_config_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsConfigEncryption>,
    {
        self.config_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_placement][crate::model::AwsControlPlane::instance_placement].
    pub fn set_instance_placement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsInstancePlacement>,
    {
        self.instance_placement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_placement][crate::model::AwsControlPlane::instance_placement].
    pub fn set_or_clear_instance_placement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsInstancePlacement>,
    {
        self.instance_placement = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsControlPlane {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsControlPlane"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsControlPlane {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __instance_type,
            __ssh_config,
            __subnet_ids,
            __security_group_ids,
            __iam_instance_profile,
            __root_volume,
            __main_volume,
            __database_encryption,
            __tags,
            __aws_services_authentication,
            __proxy_config,
            __config_encryption,
            __instance_placement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsControlPlane")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "sshConfig" => Ok(__FieldTag::__ssh_config),
                            "ssh_config" => Ok(__FieldTag::__ssh_config),
                            "subnetIds" => Ok(__FieldTag::__subnet_ids),
                            "subnet_ids" => Ok(__FieldTag::__subnet_ids),
                            "securityGroupIds" => Ok(__FieldTag::__security_group_ids),
                            "security_group_ids" => Ok(__FieldTag::__security_group_ids),
                            "iamInstanceProfile" => Ok(__FieldTag::__iam_instance_profile),
                            "iam_instance_profile" => Ok(__FieldTag::__iam_instance_profile),
                            "rootVolume" => Ok(__FieldTag::__root_volume),
                            "root_volume" => Ok(__FieldTag::__root_volume),
                            "mainVolume" => Ok(__FieldTag::__main_volume),
                            "main_volume" => Ok(__FieldTag::__main_volume),
                            "databaseEncryption" => Ok(__FieldTag::__database_encryption),
                            "database_encryption" => Ok(__FieldTag::__database_encryption),
                            "tags" => Ok(__FieldTag::__tags),
                            "awsServicesAuthentication" => {
                                Ok(__FieldTag::__aws_services_authentication)
                            }
                            "aws_services_authentication" => {
                                Ok(__FieldTag::__aws_services_authentication)
                            }
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            "configEncryption" => Ok(__FieldTag::__config_encryption),
                            "config_encryption" => Ok(__FieldTag::__config_encryption),
                            "instancePlacement" => Ok(__FieldTag::__instance_placement),
                            "instance_placement" => Ok(__FieldTag::__instance_placement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsControlPlane;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsControlPlane")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_config => {
                            if !fields.insert(__FieldTag::__ssh_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_config",
                                ));
                            }
                            result.ssh_config = map
                                .next_value::<std::option::Option<crate::model::AwsSshConfig>>()?;
                        }
                        __FieldTag::__subnet_ids => {
                            if !fields.insert(__FieldTag::__subnet_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_ids",
                                ));
                            }
                            result.subnet_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__security_group_ids => {
                            if !fields.insert(__FieldTag::__security_group_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_group_ids",
                                ));
                            }
                            result.security_group_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__iam_instance_profile => {
                            if !fields.insert(__FieldTag::__iam_instance_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_instance_profile",
                                ));
                            }
                            result.iam_instance_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_volume => {
                            if !fields.insert(__FieldTag::__root_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_volume",
                                ));
                            }
                            result.root_volume = map
                                .next_value::<std::option::Option<crate::model::AwsVolumeTemplate>>(
                                )?;
                        }
                        __FieldTag::__main_volume => {
                            if !fields.insert(__FieldTag::__main_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_volume",
                                ));
                            }
                            result.main_volume = map
                                .next_value::<std::option::Option<crate::model::AwsVolumeTemplate>>(
                                )?;
                        }
                        __FieldTag::__database_encryption => {
                            if !fields.insert(__FieldTag::__database_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_encryption",
                                ));
                            }
                            result.database_encryption = map.next_value::<std::option::Option<crate::model::AwsDatabaseEncryption>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aws_services_authentication => {
                            if !fields.insert(__FieldTag::__aws_services_authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_services_authentication",
                                ));
                            }
                            result.aws_services_authentication = map.next_value::<std::option::Option<crate::model::AwsServicesAuthentication>>()?
                                ;
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map
                                .next_value::<std::option::Option<crate::model::AwsProxyConfig>>(
                                )?;
                        }
                        __FieldTag::__config_encryption => {
                            if !fields.insert(__FieldTag::__config_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_encryption",
                                ));
                            }
                            result.config_encryption = map.next_value::<std::option::Option<crate::model::AwsConfigEncryption>>()?
                                ;
                        }
                        __FieldTag::__instance_placement => {
                            if !fields.insert(__FieldTag::__instance_placement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_placement",
                                ));
                            }
                            result.instance_placement = map.next_value::<std::option::Option<crate::model::AwsInstancePlacement>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsControlPlane {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if self.ssh_config.is_some() {
            state.serialize_entry("sshConfig", &self.ssh_config)?;
        }
        if !self.subnet_ids.is_empty() {
            state.serialize_entry("subnetIds", &self.subnet_ids)?;
        }
        if !self.security_group_ids.is_empty() {
            state.serialize_entry("securityGroupIds", &self.security_group_ids)?;
        }
        if !self.iam_instance_profile.is_empty() {
            state.serialize_entry("iamInstanceProfile", &self.iam_instance_profile)?;
        }
        if self.root_volume.is_some() {
            state.serialize_entry("rootVolume", &self.root_volume)?;
        }
        if self.main_volume.is_some() {
            state.serialize_entry("mainVolume", &self.main_volume)?;
        }
        if self.database_encryption.is_some() {
            state.serialize_entry("databaseEncryption", &self.database_encryption)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.aws_services_authentication.is_some() {
            state.serialize_entry(
                "awsServicesAuthentication",
                &self.aws_services_authentication,
            )?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if self.config_encryption.is_some() {
            state.serialize_entry("configEncryption", &self.config_encryption)?;
        }
        if self.instance_placement.is_some() {
            state.serialize_entry("instancePlacement", &self.instance_placement)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Authentication configuration for the management of AWS resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsServicesAuthentication {
    /// Required. The Amazon Resource Name (ARN) of the role that the Anthos
    /// Multi-Cloud API will assume when managing AWS resources on your account.
    pub role_arn: std::string::String,

    /// Optional. An identifier for the assumed role session.
    ///
    /// When unspecified, it defaults to `multicloud-service-agent`.
    pub role_session_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsServicesAuthentication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role_arn][crate::model::AwsServicesAuthentication::role_arn].
    pub fn set_role_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role_arn = v.into();
        self
    }

    /// Sets the value of [role_session_name][crate::model::AwsServicesAuthentication::role_session_name].
    pub fn set_role_session_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.role_session_name = v.into();
        self
    }
}

impl wkt::message::Message for AwsServicesAuthentication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsServicesAuthentication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsServicesAuthentication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role_arn,
            __role_session_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsServicesAuthentication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "roleArn" => Ok(__FieldTag::__role_arn),
                            "role_arn" => Ok(__FieldTag::__role_arn),
                            "roleSessionName" => Ok(__FieldTag::__role_session_name),
                            "role_session_name" => Ok(__FieldTag::__role_session_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsServicesAuthentication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsServicesAuthentication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role_arn => {
                            if !fields.insert(__FieldTag::__role_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_arn",
                                ));
                            }
                            result.role_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role_session_name => {
                            if !fields.insert(__FieldTag::__role_session_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_session_name",
                                ));
                            }
                            result.role_session_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsServicesAuthentication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role_arn.is_empty() {
            state.serialize_entry("roleArn", &self.role_arn)?;
        }
        if !self.role_session_name.is_empty() {
            state.serialize_entry("roleSessionName", &self.role_session_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration related to the cluster RBAC settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsAuthorization {
    /// Optional. Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
    /// to the users. Up to ten admin users can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    pub admin_users: std::vec::Vec<crate::model::AwsClusterUser>,

    /// Optional. Groups of users that can perform operations as a cluster admin. A
    /// managed ClusterRoleBinding will be created to grant the `cluster-admin`
    /// ClusterRole to the groups. Up to ten admin groups can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    pub admin_groups: std::vec::Vec<crate::model::AwsClusterGroup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::AwsAuthorization::admin_users].
    pub fn set_admin_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsClusterUser>,
    {
        use std::iter::Iterator;
        self.admin_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin_groups][crate::model::AwsAuthorization::admin_groups].
    pub fn set_admin_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsClusterGroup>,
    {
        use std::iter::Iterator;
        self.admin_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsAuthorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __admin_users,
            __admin_groups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adminUsers" => Ok(__FieldTag::__admin_users),
                            "admin_users" => Ok(__FieldTag::__admin_users),
                            "adminGroups" => Ok(__FieldTag::__admin_groups),
                            "admin_groups" => Ok(__FieldTag::__admin_groups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__admin_users => {
                            if !fields.insert(__FieldTag::__admin_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_users",
                                ));
                            }
                            result.admin_users =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsClusterUser>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admin_groups => {
                            if !fields.insert(__FieldTag::__admin_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_groups",
                                ));
                            }
                            result.admin_groups =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsClusterGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.admin_users.is_empty() {
            state.serialize_entry("adminUsers", &self.admin_users)?;
        }
        if !self.admin_groups.is_empty() {
            state.serialize_entry("adminGroups", &self.admin_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identities of a user-type subject for AWS clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsClusterUser {
    /// Required. The name of the user, e.g. `my-gcp-id@gmail.com`.
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::AwsClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterUser"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsClusterUser {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsClusterUser")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsClusterUser;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsClusterUser")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsClusterUser {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identities of a group-type subject for AWS clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsClusterGroup {
    /// Required. The name of the group, e.g. `my-group@domain.com`.
    pub group: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsClusterGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AwsClusterGroup::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsClusterGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsClusterGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsClusterGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsClusterGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsClusterGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration related to application-layer secrets encryption.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsDatabaseEncryption {
    /// Required. The ARN of the AWS KMS key used to encrypt cluster secrets.
    pub kms_key_arn: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsDatabaseEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_arn][crate::model::AwsDatabaseEncryption::kms_key_arn].
    pub fn set_kms_key_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_arn = v.into();
        self
    }
}

impl wkt::message::Message for AwsDatabaseEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsDatabaseEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsDatabaseEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_arn,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsDatabaseEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyArn" => Ok(__FieldTag::__kms_key_arn),
                            "kms_key_arn" => Ok(__FieldTag::__kms_key_arn),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsDatabaseEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsDatabaseEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_arn => {
                            if !fields.insert(__FieldTag::__kms_key_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_arn",
                                ));
                            }
                            result.kms_key_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsDatabaseEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_arn.is_empty() {
            state.serialize_entry("kmsKeyArn", &self.kms_key_arn)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration template for AWS EBS volumes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsVolumeTemplate {
    /// Optional. The size of the volume, in GiBs.
    ///
    /// When unspecified, a default value is provided. See the specific reference
    /// in the parent resource.
    pub size_gib: i32,

    /// Optional. Type of the EBS volume.
    ///
    /// When unspecified, it defaults to GP2 volume.
    pub volume_type: crate::model::aws_volume_template::VolumeType,

    /// Optional. The number of I/O operations per second (IOPS) to provision for
    /// GP3 volume.
    pub iops: i32,

    /// Optional. The throughput that the volume supports, in MiB/s. Only valid if
    /// volume_type is GP3.
    ///
    /// If the volume_type is GP3 and this is not speficied, it defaults to 125.
    pub throughput: i32,

    /// Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK)
    /// used to encrypt AWS EBS volumes.
    ///
    /// If not specified, the default Amazon managed key associated to
    /// the AWS region where this cluster runs will be used.
    pub kms_key_arn: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVolumeTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_gib][crate::model::AwsVolumeTemplate::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::AwsVolumeTemplate::volume_type].
    pub fn set_volume_type<T: std::convert::Into<crate::model::aws_volume_template::VolumeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type = v.into();
        self
    }

    /// Sets the value of [iops][crate::model::AwsVolumeTemplate::iops].
    pub fn set_iops<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.iops = v.into();
        self
    }

    /// Sets the value of [throughput][crate::model::AwsVolumeTemplate::throughput].
    pub fn set_throughput<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.throughput = v.into();
        self
    }

    /// Sets the value of [kms_key_arn][crate::model::AwsVolumeTemplate::kms_key_arn].
    pub fn set_kms_key_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_arn = v.into();
        self
    }
}

impl wkt::message::Message for AwsVolumeTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsVolumeTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsVolumeTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __size_gib,
            __volume_type,
            __iops,
            __throughput,
            __kms_key_arn,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsVolumeTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sizeGib" => Ok(__FieldTag::__size_gib),
                            "size_gib" => Ok(__FieldTag::__size_gib),
                            "volumeType" => Ok(__FieldTag::__volume_type),
                            "volume_type" => Ok(__FieldTag::__volume_type),
                            "iops" => Ok(__FieldTag::__iops),
                            "throughput" => Ok(__FieldTag::__throughput),
                            "kmsKeyArn" => Ok(__FieldTag::__kms_key_arn),
                            "kms_key_arn" => Ok(__FieldTag::__kms_key_arn),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsVolumeTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsVolumeTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__size_gib => {
                            if !fields.insert(__FieldTag::__size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_type => {
                            if !fields.insert(__FieldTag::__volume_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_type",
                                ));
                            }
                            result.volume_type =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_volume_template::VolumeType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iops => {
                            if !fields.insert(__FieldTag::__iops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iops",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.iops = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__throughput => {
                            if !fields.insert(__FieldTag::__throughput) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for throughput",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.throughput = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__kms_key_arn => {
                            if !fields.insert(__FieldTag::__kms_key_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_arn",
                                ));
                            }
                            result.kms_key_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsVolumeTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.size_gib) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGib", &__With(&self.size_gib))?;
        }
        if !wkt::internal::is_default(&self.volume_type) {
            state.serialize_entry("volumeType", &self.volume_type)?;
        }
        if !wkt::internal::is_default(&self.iops) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("iops", &__With(&self.iops))?;
        }
        if !wkt::internal::is_default(&self.throughput) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("throughput", &__With(&self.throughput))?;
        }
        if !self.kms_key_arn.is_empty() {
            state.serialize_entry("kmsKeyArn", &self.kms_key_arn)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AwsVolumeTemplate].
pub mod aws_volume_template {
    #[allow(unused_imports)]
    use super::*;

    /// Types of supported EBS volumes. We currently only support GP2 or GP3
    /// volumes.
    /// See <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>
    /// for more information.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeType {
        /// Not set.
        Unspecified,
        /// GP2 (General Purpose SSD volume type).
        Gp2,
        /// GP3 (General Purpose SSD volume type).
        Gp3,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VolumeType::value] or
        /// [VolumeType::name].
        UnknownValue(volume_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod volume_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VolumeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gp2 => std::option::Option::Some(1),
                Self::Gp3 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VOLUME_TYPE_UNSPECIFIED"),
                Self::Gp2 => std::option::Option::Some("GP2"),
                Self::Gp3 => std::option::Option::Some("GP3"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VolumeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VolumeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VolumeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gp2,
                2 => Self::Gp3,
                _ => Self::UnknownValue(volume_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VolumeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VOLUME_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GP2" => Self::Gp2,
                "GP3" => Self::Gp3,
                _ => Self::UnknownValue(volume_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VolumeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gp2 => serializer.serialize_i32(1),
                Self::Gp3 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VolumeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumeType>::new(
                ".google.cloud.gkemulticloud.v1.AwsVolumeTemplate.VolumeType",
            ))
        }
    }
}

/// ClusterNetworking defines cluster-wide networking configuration.
///
/// Anthos clusters on AWS run on a single VPC. This includes control
/// plane replicas and node pool nodes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsClusterNetworking {
    /// Required. The VPC associated with the cluster. All component clusters
    /// (i.e. control plane and node pools) run on a single VPC.
    ///
    /// This field cannot be changed after creation.
    pub vpc_id: std::string::String,

    /// Required. All pods in the cluster are assigned an IPv4 address from these
    /// ranges. Only a single range is supported. This field cannot be changed
    /// after creation.
    pub pod_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. All services in the cluster are assigned an IPv4 address from
    /// these ranges. Only a single range is supported. This field cannot be
    /// changed after creation.
    pub service_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Optional. Disable the per node pool subnet security group rules on the
    /// control plane security group. When set to true, you must also provide one
    /// or more security groups that ensure node pools are able to send requests to
    /// the control plane on TCP/443 and TCP/8132. Failure to do so may result in
    /// unavailable node pools.
    pub per_node_pool_sg_rules_disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc_id][crate::model::AwsClusterNetworking::vpc_id].
    pub fn set_vpc_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_id = v.into();
        self
    }

    /// Sets the value of [pod_address_cidr_blocks][crate::model::AwsClusterNetworking::pod_address_cidr_blocks].
    pub fn set_pod_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_address_cidr_blocks][crate::model::AwsClusterNetworking::service_address_cidr_blocks].
    pub fn set_service_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [per_node_pool_sg_rules_disabled][crate::model::AwsClusterNetworking::per_node_pool_sg_rules_disabled].
    pub fn set_per_node_pool_sg_rules_disabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_node_pool_sg_rules_disabled = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterNetworking"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsClusterNetworking {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc_id,
            __pod_address_cidr_blocks,
            __service_address_cidr_blocks,
            __per_node_pool_sg_rules_disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsClusterNetworking")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpcId" => Ok(__FieldTag::__vpc_id),
                            "vpc_id" => Ok(__FieldTag::__vpc_id),
                            "podAddressCidrBlocks" => Ok(__FieldTag::__pod_address_cidr_blocks),
                            "pod_address_cidr_blocks" => Ok(__FieldTag::__pod_address_cidr_blocks),
                            "serviceAddressCidrBlocks" => {
                                Ok(__FieldTag::__service_address_cidr_blocks)
                            }
                            "service_address_cidr_blocks" => {
                                Ok(__FieldTag::__service_address_cidr_blocks)
                            }
                            "perNodePoolSgRulesDisabled" => {
                                Ok(__FieldTag::__per_node_pool_sg_rules_disabled)
                            }
                            "per_node_pool_sg_rules_disabled" => {
                                Ok(__FieldTag::__per_node_pool_sg_rules_disabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsClusterNetworking;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsClusterNetworking")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc_id => {
                            if !fields.insert(__FieldTag::__vpc_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_id",
                                ));
                            }
                            result.vpc_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_address_cidr_blocks => {
                            if !fields.insert(__FieldTag::__pod_address_cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_address_cidr_blocks",
                                ));
                            }
                            result.pod_address_cidr_blocks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_address_cidr_blocks => {
                            if !fields.insert(__FieldTag::__service_address_cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_address_cidr_blocks",
                                ));
                            }
                            result.service_address_cidr_blocks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__per_node_pool_sg_rules_disabled => {
                            if !fields.insert(__FieldTag::__per_node_pool_sg_rules_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for per_node_pool_sg_rules_disabled",
                                ));
                            }
                            result.per_node_pool_sg_rules_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsClusterNetworking {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc_id.is_empty() {
            state.serialize_entry("vpcId", &self.vpc_id)?;
        }
        if !self.pod_address_cidr_blocks.is_empty() {
            state.serialize_entry("podAddressCidrBlocks", &self.pod_address_cidr_blocks)?;
        }
        if !self.service_address_cidr_blocks.is_empty() {
            state.serialize_entry(
                "serviceAddressCidrBlocks",
                &self.service_address_cidr_blocks,
            )?;
        }
        if !wkt::internal::is_default(&self.per_node_pool_sg_rules_disabled) {
            state.serialize_entry(
                "perNodePoolSgRulesDisabled",
                &self.per_node_pool_sg_rules_disabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An Anthos node pool running on AWS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsNodePool {
    /// The name of this resource.
    ///
    /// Node pool names are formatted as
    /// `projects/<project-number>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// For more details on Google Cloud resource names,
    /// see [Resource Names](https://cloud.google.com/apis/design/resource_names)
    pub name: std::string::String,

    /// Required. The Kubernetes version to run on this node pool (e.g.
    /// `1.19.10-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAwsServerConfig][google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]: crate::client::AwsClusters::get_aws_server_config
    pub version: std::string::String,

    /// Required. The configuration of the node pool.
    pub config: std::option::Option<crate::model::AwsNodeConfig>,

    /// Required. Autoscaler configuration for this node pool.
    pub autoscaling: std::option::Option<crate::model::AwsNodePoolAutoscaling>,

    /// Required. The subnet where the node pool node run.
    pub subnet_id: std::string::String,

    /// Output only. The lifecycle state of the node pool.
    pub state: crate::model::aws_node_pool::State,

    /// Output only. A globally unique identifier for the node pool.
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the node
    /// pool.
    pub reconciling: bool,

    /// Output only. The time at which this node pool was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this node pool was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Annotations on the node pool.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    pub max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Output only. A set of errors found in the node pool.
    pub errors: std::vec::Vec<crate::model::AwsNodePoolError>,

    /// Optional. The Management configuration for this node pool.
    pub management: std::option::Option<crate::model::AwsNodeManagement>,

    /// Optional. Node kubelet configs.
    pub kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// Optional. Update settings control the speed and disruption of the update.
    pub update_settings: std::option::Option<crate::model::UpdateSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsNodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AwsNodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AwsNodePool::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [config][crate::model::AwsNodePool::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::AwsNodePool::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaling][crate::model::AwsNodePool::autoscaling].
    pub fn set_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodePoolAutoscaling>,
    {
        self.autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling][crate::model::AwsNodePool::autoscaling].
    pub fn set_or_clear_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodePoolAutoscaling>,
    {
        self.autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnet_id][crate::model::AwsNodePool::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AwsNodePool::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_node_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AwsNodePool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AwsNodePool::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AwsNodePool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AwsNodePool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AwsNodePool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AwsNodePool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AwsNodePool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AwsNodePool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [max_pods_constraint][crate::model::AwsNodePool::max_pods_constraint].
    pub fn set_max_pods_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_pods_constraint][crate::model::AwsNodePool::max_pods_constraint].
    pub fn set_or_clear_max_pods_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::AwsNodePool::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsNodePoolError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [management][crate::model::AwsNodePool::management].
    pub fn set_management<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodeManagement>,
    {
        self.management = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management][crate::model::AwsNodePool::management].
    pub fn set_or_clear_management<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodeManagement>,
    {
        self.management = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kubelet_config][crate::model::AwsNodePool::kubelet_config].
    pub fn set_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubelet_config][crate::model::AwsNodePool::kubelet_config].
    pub fn set_or_clear_kubelet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.kubelet_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_settings][crate::model::AwsNodePool::update_settings].
    pub fn set_update_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpdateSettings>,
    {
        self.update_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_settings][crate::model::AwsNodePool::update_settings].
    pub fn set_or_clear_update_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpdateSettings>,
    {
        self.update_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsNodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsNodePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __config,
            __autoscaling,
            __subnet_id,
            __state,
            __uid,
            __reconciling,
            __create_time,
            __update_time,
            __etag,
            __annotations,
            __max_pods_constraint,
            __errors,
            __management,
            __kubelet_config,
            __update_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsNodePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "config" => Ok(__FieldTag::__config),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "subnetId" => Ok(__FieldTag::__subnet_id),
                            "subnet_id" => Ok(__FieldTag::__subnet_id),
                            "state" => Ok(__FieldTag::__state),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "maxPodsConstraint" => Ok(__FieldTag::__max_pods_constraint),
                            "max_pods_constraint" => Ok(__FieldTag::__max_pods_constraint),
                            "errors" => Ok(__FieldTag::__errors),
                            "management" => Ok(__FieldTag::__management),
                            "kubeletConfig" => Ok(__FieldTag::__kubelet_config),
                            "kubelet_config" => Ok(__FieldTag::__kubelet_config),
                            "updateSettings" => Ok(__FieldTag::__update_settings),
                            "update_settings" => Ok(__FieldTag::__update_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsNodePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsNodePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::AwsNodeConfig>>()?;
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::AwsNodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__subnet_id => {
                            if !fields.insert(__FieldTag::__subnet_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_id",
                                ));
                            }
                            result.subnet_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::aws_node_pool::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_pods_constraint => {
                            if !fields.insert(__FieldTag::__max_pods_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_constraint",
                                ));
                            }
                            result.max_pods_constraint = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsNodePoolError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::AwsNodeManagement>>(
                                )?;
                        }
                        __FieldTag::__kubelet_config => {
                            if !fields.insert(__FieldTag::__kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubelet_config",
                                ));
                            }
                            result.kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__update_settings => {
                            if !fields.insert(__FieldTag::__update_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_settings",
                                ));
                            }
                            result.update_settings = map
                                .next_value::<std::option::Option<crate::model::UpdateSettings>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsNodePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if !self.subnet_id.is_empty() {
            state.serialize_entry("subnetId", &self.subnet_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.max_pods_constraint.is_some() {
            state.serialize_entry("maxPodsConstraint", &self.max_pods_constraint)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if self.kubelet_config.is_some() {
            state.serialize_entry("kubeletConfig", &self.kubelet_config)?;
        }
        if self.update_settings.is_some() {
            state.serialize_entry("updateSettings", &self.update_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AwsNodePool].
pub mod aws_node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the node pool.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the node pool is being created.
        Provisioning,
        /// The RUNNING state indicates the node pool has been created
        /// and is fully usable.
        Running,
        /// The RECONCILING state indicates that the node pool is being reconciled.
        Reconciling,
        /// The STOPPING state indicates the node pool is being deleted.
        Stopping,
        /// The ERROR state indicates the node pool is in a broken unrecoverable
        /// state.
        Error,
        /// The DEGRADED state indicates the node pool requires user action to
        /// restore full functionality.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkemulticloud.v1.AwsNodePool.State",
            ))
        }
    }
}

/// UpdateSettings control the level of parallelism and the level of
/// disruption caused during the update of a node pool.
///
/// These settings are applicable when the node pool update requires replacing
/// the existing node pool nodes with the updated ones.
///
/// UpdateSettings are optional. When UpdateSettings are not specified during the
/// node pool creation, a default is chosen based on the parent cluster's
/// version. For clusters with minor version 1.27 and later, a default
/// surge_settings configuration with max_surge = 1 and max_unavailable = 0 is
/// used. For clusters with older versions, node pool updates use the traditional
/// rolling update mechanism of updating one node at a time in a
/// "terminate before create" fashion and update_settings is not applicable.
///
/// Set the surge_settings parameter to use the Surge Update mechanism for
/// the rolling update of node pool nodes.
///
/// 1. max_surge controls the number of additional nodes that can be created
///    beyond the current size of the node pool temporarily for the time of the
///    update to increase the number of available nodes.
/// 1. max_unavailable controls the number of nodes that can be simultaneously
///    unavailable during the update.
/// 1. (max_surge + max_unavailable) determines the level of parallelism (i.e.,
///    the number of nodes being updated at the same time).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSettings {
    /// Optional. Settings for surge update.
    pub surge_settings: std::option::Option<crate::model::SurgeSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [surge_settings][crate::model::UpdateSettings::surge_settings].
    pub fn set_surge_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SurgeSettings>,
    {
        self.surge_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [surge_settings][crate::model::UpdateSettings::surge_settings].
    pub fn set_or_clear_surge_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SurgeSettings>,
    {
        self.surge_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __surge_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "surgeSettings" => Ok(__FieldTag::__surge_settings),
                            "surge_settings" => Ok(__FieldTag::__surge_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__surge_settings => {
                            if !fields.insert(__FieldTag::__surge_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for surge_settings",
                                ));
                            }
                            result.surge_settings = map
                                .next_value::<std::option::Option<crate::model::SurgeSettings>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.surge_settings.is_some() {
            state.serialize_entry("surgeSettings", &self.surge_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SurgeSettings contains the parameters for Surge update.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SurgeSettings {
    /// Optional. The maximum number of nodes that can be created beyond the
    /// current size of the node pool during the update process.
    pub max_surge: i32,

    /// Optional. The maximum number of nodes that can be simultaneously
    /// unavailable during the update process. A node is considered unavailable if
    /// its status is not Ready.
    pub max_unavailable: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SurgeSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_surge][crate::model::SurgeSettings::max_surge].
    pub fn set_max_surge<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_surge = v.into();
        self
    }

    /// Sets the value of [max_unavailable][crate::model::SurgeSettings::max_unavailable].
    pub fn set_max_unavailable<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_unavailable = v.into();
        self
    }
}

impl wkt::message::Message for SurgeSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.SurgeSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SurgeSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_surge,
            __max_unavailable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SurgeSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxSurge" => Ok(__FieldTag::__max_surge),
                            "max_surge" => Ok(__FieldTag::__max_surge),
                            "maxUnavailable" => Ok(__FieldTag::__max_unavailable),
                            "max_unavailable" => Ok(__FieldTag::__max_unavailable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SurgeSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SurgeSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_surge => {
                            if !fields.insert(__FieldTag::__max_surge) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_surge",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_surge = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_unavailable => {
                            if !fields.insert(__FieldTag::__max_unavailable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_unavailable",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_unavailable =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SurgeSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_surge) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSurge", &__With(&self.max_surge))?;
        }
        if !wkt::internal::is_default(&self.max_unavailable) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxUnavailable", &__With(&self.max_unavailable))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsNodeManagement defines the set of node management features turned on for
/// an AWS node pool.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsNodeManagement {
    /// Optional. Whether or not the nodes will be automatically repaired. When set
    /// to true, the nodes in this node pool will be monitored and if they fail
    /// health checks consistently over a period of time, an automatic repair
    /// action will be triggered to replace them with new nodes.
    pub auto_repair: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsNodeManagement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_repair][crate::model::AwsNodeManagement::auto_repair].
    pub fn set_auto_repair<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_repair = v.into();
        self
    }
}

impl wkt::message::Message for AwsNodeManagement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodeManagement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsNodeManagement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_repair,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsNodeManagement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoRepair" => Ok(__FieldTag::__auto_repair),
                            "auto_repair" => Ok(__FieldTag::__auto_repair),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsNodeManagement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsNodeManagement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_repair => {
                            if !fields.insert(__FieldTag::__auto_repair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_repair",
                                ));
                            }
                            result.auto_repair = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsNodeManagement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auto_repair) {
            state.serialize_entry("autoRepair", &self.auto_repair)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that describe the nodes in a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsNodeConfig {
    /// Optional. The EC2 instance type when creating on-Demand instances.
    ///
    /// If unspecified during node pool creation, a default will be chosen based on
    /// the node pool version, and assigned to this field.
    pub instance_type: std::string::String,

    /// Optional. Template for the root volume provisioned for node pool nodes.
    /// Volumes will be provisioned in the availability zone assigned
    /// to the node pool subnet.
    ///
    /// When unspecified, it defaults to 32 GiB with the GP2 volume type.
    pub root_volume: std::option::Option<crate::model::AwsVolumeTemplate>,

    /// Optional. The initial taints assigned to nodes of this node pool.
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    /// Optional. The initial labels assigned to nodes of this node pool. An object
    /// containing a list of "key": value pairs. Example: { "name": "wrench",
    /// "mass": "1.3kg", "count": "3" }.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Key/value metadata to assign to each underlying AWS resource.
    /// Specify at most 50 pairs containing alphanumerics, spaces, and symbols
    /// (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to
    /// 255 Unicode characters.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The name or ARN of the AWS IAM instance profile to assign to
    /// nodes in the pool.
    pub iam_instance_profile: std::string::String,

    /// Optional. The OS image type to use on node pool instances.
    /// Can be unspecified, or have a value of `ubuntu`.
    ///
    /// When unspecified, it defaults to `ubuntu`.
    pub image_type: std::string::String,

    /// Optional. The SSH configuration.
    pub ssh_config: std::option::Option<crate::model::AwsSshConfig>,

    /// Optional. The IDs of additional security groups to add to nodes in this
    /// pool. The manager will automatically create security groups with minimum
    /// rules needed for a functioning cluster.
    pub security_group_ids: std::vec::Vec<std::string::String>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AwsProxyConfig>,

    /// Required. Config encryption for user data.
    pub config_encryption: std::option::Option<crate::model::AwsConfigEncryption>,

    /// Optional. Placement related info for this node.
    /// When unspecified, the VPC's default tenancy will be used.
    pub instance_placement: std::option::Option<crate::model::AwsInstancePlacement>,

    /// Optional. Configuration related to CloudWatch metrics collection on the
    /// Auto Scaling group of the node pool.
    ///
    /// When unspecified, metrics collection is disabled.
    pub autoscaling_metrics_collection:
        std::option::Option<crate::model::AwsAutoscalingGroupMetricsCollection>,

    /// Optional. Configuration for provisioning EC2 Spot instances
    ///
    /// When specified, the node pool will provision Spot instances from the set
    /// of spot_config.instance_types.
    /// This field is mutually exclusive with `instance_type`.
    pub spot_config: std::option::Option<crate::model::SpotConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_type][crate::model::AwsNodeConfig::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AwsNodeConfig::root_volume].
    pub fn set_root_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsVolumeTemplate>,
    {
        self.root_volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [root_volume][crate::model::AwsNodeConfig::root_volume].
    pub fn set_or_clear_root_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsVolumeTemplate>,
    {
        self.root_volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [taints][crate::model::AwsNodeConfig::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AwsNodeConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AwsNodeConfig::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [iam_instance_profile][crate::model::AwsNodeConfig::iam_instance_profile].
    pub fn set_iam_instance_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.iam_instance_profile = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::AwsNodeConfig::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AwsNodeConfig::ssh_config].
    pub fn set_ssh_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsSshConfig>,
    {
        self.ssh_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssh_config][crate::model::AwsNodeConfig::ssh_config].
    pub fn set_or_clear_ssh_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsSshConfig>,
    {
        self.ssh_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_group_ids][crate::model::AwsNodeConfig::security_group_ids].
    pub fn set_security_group_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.security_group_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [proxy_config][crate::model::AwsNodeConfig::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::AwsNodeConfig::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_encryption][crate::model::AwsNodeConfig::config_encryption].
    pub fn set_config_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsConfigEncryption>,
    {
        self.config_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_encryption][crate::model::AwsNodeConfig::config_encryption].
    pub fn set_or_clear_config_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsConfigEncryption>,
    {
        self.config_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_placement][crate::model::AwsNodeConfig::instance_placement].
    pub fn set_instance_placement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsInstancePlacement>,
    {
        self.instance_placement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_placement][crate::model::AwsNodeConfig::instance_placement].
    pub fn set_or_clear_instance_placement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsInstancePlacement>,
    {
        self.instance_placement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaling_metrics_collection][crate::model::AwsNodeConfig::autoscaling_metrics_collection].
    pub fn set_autoscaling_metrics_collection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsAutoscalingGroupMetricsCollection>,
    {
        self.autoscaling_metrics_collection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_metrics_collection][crate::model::AwsNodeConfig::autoscaling_metrics_collection].
    pub fn set_or_clear_autoscaling_metrics_collection<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AwsAutoscalingGroupMetricsCollection>,
    {
        self.autoscaling_metrics_collection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spot_config][crate::model::AwsNodeConfig::spot_config].
    pub fn set_spot_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpotConfig>,
    {
        self.spot_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spot_config][crate::model::AwsNodeConfig::spot_config].
    pub fn set_or_clear_spot_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpotConfig>,
    {
        self.spot_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsNodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_type,
            __root_volume,
            __taints,
            __labels,
            __tags,
            __iam_instance_profile,
            __image_type,
            __ssh_config,
            __security_group_ids,
            __proxy_config,
            __config_encryption,
            __instance_placement,
            __autoscaling_metrics_collection,
            __spot_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsNodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "rootVolume" => Ok(__FieldTag::__root_volume),
                            "root_volume" => Ok(__FieldTag::__root_volume),
                            "taints" => Ok(__FieldTag::__taints),
                            "labels" => Ok(__FieldTag::__labels),
                            "tags" => Ok(__FieldTag::__tags),
                            "iamInstanceProfile" => Ok(__FieldTag::__iam_instance_profile),
                            "iam_instance_profile" => Ok(__FieldTag::__iam_instance_profile),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "sshConfig" => Ok(__FieldTag::__ssh_config),
                            "ssh_config" => Ok(__FieldTag::__ssh_config),
                            "securityGroupIds" => Ok(__FieldTag::__security_group_ids),
                            "security_group_ids" => Ok(__FieldTag::__security_group_ids),
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            "configEncryption" => Ok(__FieldTag::__config_encryption),
                            "config_encryption" => Ok(__FieldTag::__config_encryption),
                            "instancePlacement" => Ok(__FieldTag::__instance_placement),
                            "instance_placement" => Ok(__FieldTag::__instance_placement),
                            "autoscalingMetricsCollection" => {
                                Ok(__FieldTag::__autoscaling_metrics_collection)
                            }
                            "autoscaling_metrics_collection" => {
                                Ok(__FieldTag::__autoscaling_metrics_collection)
                            }
                            "spotConfig" => Ok(__FieldTag::__spot_config),
                            "spot_config" => Ok(__FieldTag::__spot_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsNodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsNodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_volume => {
                            if !fields.insert(__FieldTag::__root_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_volume",
                                ));
                            }
                            result.root_volume = map
                                .next_value::<std::option::Option<crate::model::AwsVolumeTemplate>>(
                                )?;
                        }
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodeTaint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iam_instance_profile => {
                            if !fields.insert(__FieldTag::__iam_instance_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_instance_profile",
                                ));
                            }
                            result.iam_instance_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_config => {
                            if !fields.insert(__FieldTag::__ssh_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_config",
                                ));
                            }
                            result.ssh_config = map
                                .next_value::<std::option::Option<crate::model::AwsSshConfig>>()?;
                        }
                        __FieldTag::__security_group_ids => {
                            if !fields.insert(__FieldTag::__security_group_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_group_ids",
                                ));
                            }
                            result.security_group_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map
                                .next_value::<std::option::Option<crate::model::AwsProxyConfig>>(
                                )?;
                        }
                        __FieldTag::__config_encryption => {
                            if !fields.insert(__FieldTag::__config_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_encryption",
                                ));
                            }
                            result.config_encryption = map.next_value::<std::option::Option<crate::model::AwsConfigEncryption>>()?
                                ;
                        }
                        __FieldTag::__instance_placement => {
                            if !fields.insert(__FieldTag::__instance_placement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_placement",
                                ));
                            }
                            result.instance_placement = map.next_value::<std::option::Option<crate::model::AwsInstancePlacement>>()?
                                ;
                        }
                        __FieldTag::__autoscaling_metrics_collection => {
                            if !fields.insert(__FieldTag::__autoscaling_metrics_collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_metrics_collection",
                                ));
                            }
                            result.autoscaling_metrics_collection = map
                                .next_value::<std::option::Option<
                                    crate::model::AwsAutoscalingGroupMetricsCollection,
                                >>()?;
                        }
                        __FieldTag::__spot_config => {
                            if !fields.insert(__FieldTag::__spot_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spot_config",
                                ));
                            }
                            result.spot_config =
                                map.next_value::<std::option::Option<crate::model::SpotConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsNodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if self.root_volume.is_some() {
            state.serialize_entry("rootVolume", &self.root_volume)?;
        }
        if !self.taints.is_empty() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.iam_instance_profile.is_empty() {
            state.serialize_entry("iamInstanceProfile", &self.iam_instance_profile)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if self.ssh_config.is_some() {
            state.serialize_entry("sshConfig", &self.ssh_config)?;
        }
        if !self.security_group_ids.is_empty() {
            state.serialize_entry("securityGroupIds", &self.security_group_ids)?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if self.config_encryption.is_some() {
            state.serialize_entry("configEncryption", &self.config_encryption)?;
        }
        if self.instance_placement.is_some() {
            state.serialize_entry("instancePlacement", &self.instance_placement)?;
        }
        if self.autoscaling_metrics_collection.is_some() {
            state.serialize_entry(
                "autoscalingMetricsCollection",
                &self.autoscaling_metrics_collection,
            )?;
        }
        if self.spot_config.is_some() {
            state.serialize_entry("spotConfig", &self.spot_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsNodePoolAutoscaling contains information required by cluster autoscaler
/// to adjust the size of the node pool to the current cluster usage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsNodePoolAutoscaling {
    /// Required. Minimum number of nodes in the node pool. Must be greater than or
    /// equal to 1 and less than or equal to max_node_count.
    pub min_node_count: i32,

    /// Required. Maximum number of nodes in the node pool. Must be greater than or
    /// equal to min_node_count and less than or equal to 50.
    pub max_node_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsNodePoolAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_node_count][crate::model::AwsNodePoolAutoscaling::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::AwsNodePoolAutoscaling::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for AwsNodePoolAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodePoolAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsNodePoolAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_node_count,
            __max_node_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsNodePoolAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsNodePoolAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsNodePoolAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsNodePoolAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
        }
        if !wkt::internal::is_default(&self.max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsOpenIdConfig is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsOpenIdConfig {
    /// OIDC Issuer.
    pub issuer: std::string::String,

    /// JSON Web Key uri.
    pub jwks_uri: std::string::String,

    /// Supported response types.
    pub response_types_supported: std::vec::Vec<std::string::String>,

    /// Supported subject types.
    pub subject_types_supported: std::vec::Vec<std::string::String>,

    /// supported ID Token signing Algorithms.
    pub id_token_signing_alg_values_supported: std::vec::Vec<std::string::String>,

    /// Supported claims.
    pub claims_supported: std::vec::Vec<std::string::String>,

    /// Supported grant types.
    pub grant_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsOpenIdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer][crate::model::AwsOpenIdConfig::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [jwks_uri][crate::model::AwsOpenIdConfig::jwks_uri].
    pub fn set_jwks_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.jwks_uri = v.into();
        self
    }

    /// Sets the value of [response_types_supported][crate::model::AwsOpenIdConfig::response_types_supported].
    pub fn set_response_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.response_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subject_types_supported][crate::model::AwsOpenIdConfig::subject_types_supported].
    pub fn set_subject_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id_token_signing_alg_values_supported][crate::model::AwsOpenIdConfig::id_token_signing_alg_values_supported].
    pub fn set_id_token_signing_alg_values_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_token_signing_alg_values_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims_supported][crate::model::AwsOpenIdConfig::claims_supported].
    pub fn set_claims_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.claims_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grant_types][crate::model::AwsOpenIdConfig::grant_types].
    pub fn set_grant_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grant_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsOpenIdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsOpenIdConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsOpenIdConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issuer,
            __jwks_uri,
            __response_types_supported,
            __subject_types_supported,
            __id_token_signing_alg_values_supported,
            __claims_supported,
            __grant_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsOpenIdConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issuer" => Ok(__FieldTag::__issuer),
                            "jwksUri" => Ok(__FieldTag::__jwks_uri),
                            "jwks_uri" => Ok(__FieldTag::__jwks_uri),
                            "responseTypesSupported" => Ok(__FieldTag::__response_types_supported),
                            "response_types_supported" => {
                                Ok(__FieldTag::__response_types_supported)
                            }
                            "subjectTypesSupported" => Ok(__FieldTag::__subject_types_supported),
                            "subject_types_supported" => Ok(__FieldTag::__subject_types_supported),
                            "idTokenSigningAlgValuesSupported" => {
                                Ok(__FieldTag::__id_token_signing_alg_values_supported)
                            }
                            "id_token_signing_alg_values_supported" => {
                                Ok(__FieldTag::__id_token_signing_alg_values_supported)
                            }
                            "claimsSupported" => Ok(__FieldTag::__claims_supported),
                            "claims_supported" => Ok(__FieldTag::__claims_supported),
                            "grantTypes" => Ok(__FieldTag::__grant_types),
                            "grant_types" => Ok(__FieldTag::__grant_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsOpenIdConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsOpenIdConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issuer => {
                            if !fields.insert(__FieldTag::__issuer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer",
                                ));
                            }
                            result.issuer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jwks_uri => {
                            if !fields.insert(__FieldTag::__jwks_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwks_uri",
                                ));
                            }
                            result.jwks_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_types_supported => {
                            if !fields.insert(__FieldTag::__response_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_types_supported",
                                ));
                            }
                            result.response_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__subject_types_supported => {
                            if !fields.insert(__FieldTag::__subject_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_types_supported",
                                ));
                            }
                            result.subject_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__id_token_signing_alg_values_supported => {
                            if !fields.insert(__FieldTag::__id_token_signing_alg_values_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id_token_signing_alg_values_supported",
                                ));
                            }
                            result.id_token_signing_alg_values_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__claims_supported => {
                            if !fields.insert(__FieldTag::__claims_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for claims_supported",
                                ));
                            }
                            result.claims_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__grant_types => {
                            if !fields.insert(__FieldTag::__grant_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_types",
                                ));
                            }
                            result.grant_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsOpenIdConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issuer.is_empty() {
            state.serialize_entry("issuer", &self.issuer)?;
        }
        if !self.jwks_uri.is_empty() {
            state.serialize_entry("jwksUri", &self.jwks_uri)?;
        }
        if !self.response_types_supported.is_empty() {
            state.serialize_entry("responseTypesSupported", &self.response_types_supported)?;
        }
        if !self.subject_types_supported.is_empty() {
            state.serialize_entry("subjectTypesSupported", &self.subject_types_supported)?;
        }
        if !self.id_token_signing_alg_values_supported.is_empty() {
            state.serialize_entry(
                "idTokenSigningAlgValuesSupported",
                &self.id_token_signing_alg_values_supported,
            )?;
        }
        if !self.claims_supported.is_empty() {
            state.serialize_entry("claimsSupported", &self.claims_supported)?;
        }
        if !self.grant_types.is_empty() {
            state.serialize_entry("grantTypes", &self.grant_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsJsonWebKeys is a valid JSON Web Key Set as specififed in RFC 7517.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsJsonWebKeys {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    pub keys: std::vec::Vec<crate::model::Jwk>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsJsonWebKeys {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::AwsJsonWebKeys::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwk>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsJsonWebKeys {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsJsonWebKeys"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsJsonWebKeys {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsJsonWebKeys")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keys" => Ok(__FieldTag::__keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsJsonWebKeys;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsJsonWebKeys")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__keys => {
                            if !fields.insert(__FieldTag::__keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keys",
                                ));
                            }
                            result.keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Jwk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsJsonWebKeys {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.keys.is_empty() {
            state.serialize_entry("keys", &self.keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsServerConfig is the configuration of GKE cluster on AWS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsServerConfig {
    /// The resource name of the config.
    pub name: std::string::String,

    /// List of all released Kubernetes versions, including ones which are end of
    /// life and can no longer be used.  Filter by the `enabled`
    /// property to limit to currently available versions.
    /// Valid versions supported for both create and update operations
    pub valid_versions: std::vec::Vec<crate::model::AwsK8sVersionInfo>,

    /// The list of supported AWS regions.
    pub supported_aws_regions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AwsServerConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [valid_versions][crate::model::AwsServerConfig::valid_versions].
    pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsK8sVersionInfo>,
    {
        use std::iter::Iterator;
        self.valid_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_aws_regions][crate::model::AwsServerConfig::supported_aws_regions].
    pub fn set_supported_aws_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_aws_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __valid_versions,
            __supported_aws_regions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validVersions" => Ok(__FieldTag::__valid_versions),
                            "valid_versions" => Ok(__FieldTag::__valid_versions),
                            "supportedAwsRegions" => Ok(__FieldTag::__supported_aws_regions),
                            "supported_aws_regions" => Ok(__FieldTag::__supported_aws_regions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_versions => {
                            if !fields.insert(__FieldTag::__valid_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_versions",
                                ));
                            }
                            result.valid_versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsK8sVersionInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_aws_regions => {
                            if !fields.insert(__FieldTag::__supported_aws_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_aws_regions",
                                ));
                            }
                            result.supported_aws_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.valid_versions.is_empty() {
            state.serialize_entry("validVersions", &self.valid_versions)?;
        }
        if !self.supported_aws_regions.is_empty() {
            state.serialize_entry("supportedAwsRegions", &self.supported_aws_regions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Kubernetes version information of GKE cluster on AWS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsK8sVersionInfo {
    /// Kubernetes version name.
    pub version: std::string::String,

    /// Optional. True if the version is available for cluster creation. If a
    /// version is enabled for creation, it can be used to create new clusters.
    /// Otherwise, cluster creation will fail. However, cluster upgrade operations
    /// may succeed, even if the version is not enabled.
    pub enabled: bool,

    /// Optional. True if this cluster version belongs to a minor version that has
    /// reached its end of life and is no longer in scope to receive security and
    /// bug fixes.
    pub end_of_life: bool,

    /// Optional. The estimated date (in Pacific Time) when this cluster version
    /// will reach its end of life. Or if this version is no longer supported (the
    /// `end_of_life` field is true), this is the actual date (in Pacific time)
    /// when the version reached its end of life.
    pub end_of_life_date: std::option::Option<gtype::model::Date>,

    /// Optional. The date (in Pacific Time) when the cluster version was released.
    pub release_date: std::option::Option<gtype::model::Date>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsK8sVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AwsK8sVersionInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::AwsK8sVersionInfo::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [end_of_life][crate::model::AwsK8sVersionInfo::end_of_life].
    pub fn set_end_of_life<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.end_of_life = v.into();
        self
    }

    /// Sets the value of [end_of_life_date][crate::model::AwsK8sVersionInfo::end_of_life_date].
    pub fn set_end_of_life_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_of_life_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_of_life_date][crate::model::AwsK8sVersionInfo::end_of_life_date].
    pub fn set_or_clear_end_of_life_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_of_life_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [release_date][crate::model::AwsK8sVersionInfo::release_date].
    pub fn set_release_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_date][crate::model::AwsK8sVersionInfo::release_date].
    pub fn set_or_clear_release_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsK8sVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsK8sVersionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsK8sVersionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __enabled,
            __end_of_life,
            __end_of_life_date,
            __release_date,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsK8sVersionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "endOfLife" => Ok(__FieldTag::__end_of_life),
                            "end_of_life" => Ok(__FieldTag::__end_of_life),
                            "endOfLifeDate" => Ok(__FieldTag::__end_of_life_date),
                            "end_of_life_date" => Ok(__FieldTag::__end_of_life_date),
                            "releaseDate" => Ok(__FieldTag::__release_date),
                            "release_date" => Ok(__FieldTag::__release_date),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsK8sVersionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsK8sVersionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_life => {
                            if !fields.insert(__FieldTag::__end_of_life) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_life",
                                ));
                            }
                            result.end_of_life = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_life_date => {
                            if !fields.insert(__FieldTag::__end_of_life_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_life_date",
                                ));
                            }
                            result.end_of_life_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__release_date => {
                            if !fields.insert(__FieldTag::__release_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_date",
                                ));
                            }
                            result.release_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsK8sVersionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.end_of_life) {
            state.serialize_entry("endOfLife", &self.end_of_life)?;
        }
        if self.end_of_life_date.is_some() {
            state.serialize_entry("endOfLifeDate", &self.end_of_life_date)?;
        }
        if self.release_date.is_some() {
            state.serialize_entry("releaseDate", &self.release_date)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SSH configuration for AWS resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSshConfig {
    /// Required. The name of the EC2 key pair used to login into cluster machines.
    pub ec2_key_pair: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSshConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ec2_key_pair][crate::model::AwsSshConfig::ec2_key_pair].
    pub fn set_ec2_key_pair<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ec2_key_pair = v.into();
        self
    }
}

impl wkt::message::Message for AwsSshConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsSshConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSshConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ec2_key_pair,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSshConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ec2KeyPair" => Ok(__FieldTag::__ec2_key_pair),
                            "ec2_key_pair" => Ok(__FieldTag::__ec2_key_pair),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSshConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSshConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ec2_key_pair => {
                            if !fields.insert(__FieldTag::__ec2_key_pair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ec2_key_pair",
                                ));
                            }
                            result.ec2_key_pair = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSshConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ec2_key_pair.is_empty() {
            state.serialize_entry("ec2KeyPair", &self.ec2_key_pair)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of a proxy config stored in AWS Secret Manager.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsProxyConfig {
    /// The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy
    /// configuration.
    ///
    /// The secret must be a JSON encoded proxy configuration
    /// as described in
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/aws/how-to/use-a-proxy#create_a_proxy_configuration_file>
    pub secret_arn: std::string::String,

    /// The version string of the AWS Secret Manager secret that contains the
    /// HTTP(S) proxy configuration.
    pub secret_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_arn][crate::model::AwsProxyConfig::secret_arn].
    pub fn set_secret_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_arn = v.into();
        self
    }

    /// Sets the value of [secret_version][crate::model::AwsProxyConfig::secret_version].
    pub fn set_secret_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_version = v.into();
        self
    }
}

impl wkt::message::Message for AwsProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsProxyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsProxyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_arn,
            __secret_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsProxyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretArn" => Ok(__FieldTag::__secret_arn),
                            "secret_arn" => Ok(__FieldTag::__secret_arn),
                            "secretVersion" => Ok(__FieldTag::__secret_version),
                            "secret_version" => Ok(__FieldTag::__secret_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsProxyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsProxyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_arn => {
                            if !fields.insert(__FieldTag::__secret_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_arn",
                                ));
                            }
                            result.secret_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_version => {
                            if !fields.insert(__FieldTag::__secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_version",
                                ));
                            }
                            result.secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsProxyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret_arn.is_empty() {
            state.serialize_entry("secretArn", &self.secret_arn)?;
        }
        if !self.secret_version.is_empty() {
            state.serialize_entry("secretVersion", &self.secret_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Config encryption for user data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsConfigEncryption {
    /// Required. The ARN of the AWS KMS key used to encrypt user data.
    pub kms_key_arn: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsConfigEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_arn][crate::model::AwsConfigEncryption::kms_key_arn].
    pub fn set_kms_key_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_arn = v.into();
        self
    }
}

impl wkt::message::Message for AwsConfigEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsConfigEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsConfigEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_arn,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsConfigEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyArn" => Ok(__FieldTag::__kms_key_arn),
                            "kms_key_arn" => Ok(__FieldTag::__kms_key_arn),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsConfigEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsConfigEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_arn => {
                            if !fields.insert(__FieldTag::__kms_key_arn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_arn",
                                ));
                            }
                            result.kms_key_arn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsConfigEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_arn.is_empty() {
            state.serialize_entry("kmsKeyArn", &self.kms_key_arn)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of placement information for an instance.
/// Limitations for using the `host` tenancy:
///
/// * T3 instances that use the unlimited CPU credit option don't support host
///   tenancy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsInstancePlacement {
    /// Required. The tenancy for instance.
    pub tenancy: crate::model::aws_instance_placement::Tenancy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsInstancePlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenancy][crate::model::AwsInstancePlacement::tenancy].
    pub fn set_tenancy<T: std::convert::Into<crate::model::aws_instance_placement::Tenancy>>(
        mut self,
        v: T,
    ) -> Self {
        self.tenancy = v.into();
        self
    }
}

impl wkt::message::Message for AwsInstancePlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsInstancePlacement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsInstancePlacement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tenancy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsInstancePlacement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tenancy" => Ok(__FieldTag::__tenancy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsInstancePlacement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsInstancePlacement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tenancy => {
                            if !fields.insert(__FieldTag::__tenancy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenancy",
                                ));
                            }
                            result.tenancy =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_instance_placement::Tenancy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsInstancePlacement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.tenancy) {
            state.serialize_entry("tenancy", &self.tenancy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AwsInstancePlacement].
pub mod aws_instance_placement {
    #[allow(unused_imports)]
    use super::*;

    /// Tenancy defines how EC2 instances are distributed across physical hardware.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tenancy {
        /// Not set.
        Unspecified,
        /// Use default VPC tenancy.
        Default,
        /// Run a dedicated instance.
        Dedicated,
        /// Launch this instance to a dedicated host.
        Host,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tenancy::value] or
        /// [Tenancy::name].
        UnknownValue(tenancy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tenancy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Tenancy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::Dedicated => std::option::Option::Some(2),
                Self::Host => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TENANCY_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Dedicated => std::option::Option::Some("DEDICATED"),
                Self::Host => std::option::Option::Some("HOST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Tenancy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Tenancy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Tenancy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::Dedicated,
                3 => Self::Host,
                _ => Self::UnknownValue(tenancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Tenancy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TENANCY_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "DEDICATED" => Self::Dedicated,
                "HOST" => Self::Host,
                _ => Self::UnknownValue(tenancy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Tenancy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::Dedicated => serializer.serialize_i32(2),
                Self::Host => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tenancy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tenancy>::new(
                ".google.cloud.gkemulticloud.v1.AwsInstancePlacement.Tenancy",
            ))
        }
    }
}

/// Configuration related to CloudWatch metrics collection in an AWS
/// Auto Scaling group.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsAutoscalingGroupMetricsCollection {
    /// Required. The frequency at which EC2 Auto Scaling sends aggregated data to
    /// AWS CloudWatch. The only valid value is "1Minute".
    pub granularity: std::string::String,

    /// Optional. The metrics to enable. For a list of valid metrics, see
    /// <https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_EnableMetricsCollection.html>.
    /// If you specify Granularity and don't specify any metrics, all metrics are
    /// enabled.
    pub metrics: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAutoscalingGroupMetricsCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [granularity][crate::model::AwsAutoscalingGroupMetricsCollection::granularity].
    pub fn set_granularity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.granularity = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::AwsAutoscalingGroupMetricsCollection::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsAutoscalingGroupMetricsCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsAutoscalingGroupMetricsCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsAutoscalingGroupMetricsCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __granularity,
            __metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAutoscalingGroupMetricsCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "granularity" => Ok(__FieldTag::__granularity),
                            "metrics" => Ok(__FieldTag::__metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsAutoscalingGroupMetricsCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAutoscalingGroupMetricsCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__granularity => {
                            if !fields.insert(__FieldTag::__granularity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for granularity",
                                ));
                            }
                            result.granularity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsAutoscalingGroupMetricsCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.granularity.is_empty() {
            state.serialize_entry("granularity", &self.granularity)?;
        }
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SpotConfig has configuration info for Spot node.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpotConfig {
    /// Required. A list of instance types for creating spot node pool.
    pub instance_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpotConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_types][crate::model::SpotConfig::instance_types].
    pub fn set_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpotConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.SpotConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpotConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpotConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceTypes" => Ok(__FieldTag::__instance_types),
                            "instance_types" => Ok(__FieldTag::__instance_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpotConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpotConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_types => {
                            if !fields.insert(__FieldTag::__instance_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_types",
                                ));
                            }
                            result.instance_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpotConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_types.is_empty() {
            state.serialize_entry("instanceTypes", &self.instance_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsClusterError describes errors found on AWS clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsClusterError {
    /// Human-friendly description of the error.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsClusterError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AwsClusterError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsClusterError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsClusterError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsClusterError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsClusterError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsClusterError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AwsNodePoolError describes errors found on AWS node pools.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsNodePoolError {
    /// Human-friendly description of the error.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsNodePoolError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AwsNodePoolError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AwsNodePoolError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodePoolError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsNodePoolError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsNodePoolError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsNodePoolError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsNodePoolError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsNodePoolError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.CreateAwsCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAwsClusterRequest {
    /// Required. The parent location where this
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource will be
    /// created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub aws_cluster: std::option::Option<crate::model::AwsCluster>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub aws_cluster_id: std::string::String,

    /// If set, only validate the request, but do not actually create the cluster.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAwsClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aws_cluster][crate::model::CreateAwsClusterRequest::aws_cluster].
    pub fn set_aws_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsCluster>,
    {
        self.aws_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_cluster][crate::model::CreateAwsClusterRequest::aws_cluster].
    pub fn set_or_clear_aws_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsCluster>,
    {
        self.aws_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aws_cluster_id][crate::model::CreateAwsClusterRequest::aws_cluster_id].
    pub fn set_aws_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAwsClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAwsClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAwsClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __aws_cluster,
            __aws_cluster_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAwsClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "awsCluster" => Ok(__FieldTag::__aws_cluster),
                            "aws_cluster" => Ok(__FieldTag::__aws_cluster),
                            "awsClusterId" => Ok(__FieldTag::__aws_cluster_id),
                            "aws_cluster_id" => Ok(__FieldTag::__aws_cluster_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAwsClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAwsClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aws_cluster => {
                            if !fields.insert(__FieldTag::__aws_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster",
                                ));
                            }
                            result.aws_cluster =
                                map.next_value::<std::option::Option<crate::model::AwsCluster>>()?;
                        }
                        __FieldTag::__aws_cluster_id => {
                            if !fields.insert(__FieldTag::__aws_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster_id",
                                ));
                            }
                            result.aws_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAwsClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.aws_cluster.is_some() {
            state.serialize_entry("awsCluster", &self.aws_cluster)?;
        }
        if !self.aws_cluster_id.is_empty() {
            state.serialize_entry("awsClusterId", &self.aws_cluster_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.UpdateAwsCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAwsClusterRequest {
    /// Required. The [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub aws_cluster: std::option::Option<crate::model::AwsCluster>,

    /// If set, only validate the request, but do not actually update the cluster.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster]:
    ///
    /// * `description`.
    /// * `annotations`.
    /// * `control_plane.version`.
    /// * `authorization.admin_users`.
    /// * `authorization.admin_groups`.
    /// * `binary_authorization.evaluation_mode`.
    /// * `control_plane.aws_services_authentication.role_arn`.
    /// * `control_plane.aws_services_authentication.role_session_name`.
    /// * `control_plane.config_encryption.kms_key_arn`.
    /// * `control_plane.instance_type`.
    /// * `control_plane.security_group_ids`.
    /// * `control_plane.proxy_config`.
    /// * `control_plane.proxy_config.secret_arn`.
    /// * `control_plane.proxy_config.secret_version`.
    /// * `control_plane.root_volume.size_gib`.
    /// * `control_plane.root_volume.volume_type`.
    /// * `control_plane.root_volume.iops`.
    /// * `control_plane.root_volume.throughput`.
    /// * `control_plane.root_volume.kms_key_arn`.
    /// * `control_plane.ssh_config`.
    /// * `control_plane.ssh_config.ec2_key_pair`.
    /// * `control_plane.instance_placement.tenancy`.
    /// * `control_plane.iam_instance_profile`.
    /// * `logging_config.component_config.enable_components`.
    /// * `control_plane.tags`.
    /// * `monitoring_config.managed_prometheus_config.enabled`.
    /// * `networking.per_node_pool_sg_rules_disabled`.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::UpdateAwsClusterRequest::aws_cluster].
    pub fn set_aws_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsCluster>,
    {
        self.aws_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_cluster][crate::model::UpdateAwsClusterRequest::aws_cluster].
    pub fn set_or_clear_aws_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsCluster>,
    {
        self.aws_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAwsClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAwsClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAwsClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAwsClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAwsClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_cluster,
            __validate_only,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAwsClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsCluster" => Ok(__FieldTag::__aws_cluster),
                            "aws_cluster" => Ok(__FieldTag::__aws_cluster),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAwsClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAwsClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_cluster => {
                            if !fields.insert(__FieldTag::__aws_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster",
                                ));
                            }
                            result.aws_cluster =
                                map.next_value::<std::option::Option<crate::model::AwsCluster>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAwsClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aws_cluster.is_some() {
            state.serialize_entry("awsCluster", &self.aws_cluster)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.GetAwsCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAwsClusterRequest {
    /// Required. The name of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource to
    /// describe.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAwsClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAwsClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAwsClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAwsClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAwsClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAwsClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.ListAwsClusters` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAwsClustersRequest {
    /// Required. The parent location which owns this collection of
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAwsClustersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAwsClustersResponse.next_page_token]: crate::model::ListAwsClustersResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [awsClusters.list][google.cloud.gkemulticloud.v1.AwsClusters.ListAwsClusters]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.ListAwsClusters]: crate::client::AwsClusters::list_aws_clusters
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAwsClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAwsClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAwsClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAwsClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAwsClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAwsClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAwsClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAwsClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAwsClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAwsClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AwsClusters.ListAwsClusters` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAwsClustersResponse {
    /// A list of [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resources
    /// in the specified Google Cloud Platform project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub aws_clusters: std::vec::Vec<crate::model::AwsCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAwsClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_clusters][crate::model::ListAwsClustersResponse::aws_clusters].
    pub fn set_aws_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsCluster>,
    {
        use std::iter::Iterator;
        self.aws_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAwsClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAwsClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAwsClustersResponse {
    type PageItem = crate::model::AwsCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.aws_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAwsClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_clusters,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAwsClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsClusters" => Ok(__FieldTag::__aws_clusters),
                            "aws_clusters" => Ok(__FieldTag::__aws_clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAwsClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAwsClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_clusters => {
                            if !fields.insert(__FieldTag::__aws_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_clusters",
                                ));
                            }
                            result.aws_clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AwsCluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAwsClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aws_clusters.is_empty() {
            state.serialize_entry("awsClusters", &self.aws_clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.DeleteAwsCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAwsClusterRequest {
    /// Required. The resource name the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] to delete.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// Optional. If set to true, the deletion of
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource will
    /// succeed even if errors occur during deleting in cluster resources. Using
    /// this parameter may result in orphaned resources in the cluster.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub ignore_errors: bool,

    /// The current etag of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided etag does not match the current etag of the cluster,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAwsClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAwsClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAwsClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAwsClusterRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAwsClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAwsClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAwsClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __ignore_errors,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAwsClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "ignoreErrors" => Ok(__FieldTag::__ignore_errors),
                            "ignore_errors" => Ok(__FieldTag::__ignore_errors),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAwsClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAwsClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_errors => {
                            if !fields.insert(__FieldTag::__ignore_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_errors",
                                ));
                            }
                            result.ignore_errors = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAwsClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.ignore_errors) {
            state.serialize_entry("ignoreErrors", &self.ignore_errors)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AwsClusters.CreateAwsNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAwsNodePoolRequest {
    /// Required. The [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster]
    /// resource where this node pool will be created.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub aws_node_pool: std::option::Option<crate::model::AwsNodePool>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub aws_node_pool_id: std::string::String,

    /// If set, only validate the request, but do not actually create the node
    /// pool.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAwsNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aws_node_pool][crate::model::CreateAwsNodePoolRequest::aws_node_pool].
    pub fn set_aws_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodePool>,
    {
        self.aws_node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_node_pool][crate::model::CreateAwsNodePoolRequest::aws_node_pool].
    pub fn set_or_clear_aws_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodePool>,
    {
        self.aws_node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aws_node_pool_id][crate::model::CreateAwsNodePoolRequest::aws_node_pool_id].
    pub fn set_aws_node_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.aws_node_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAwsNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAwsNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAwsNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __aws_node_pool,
            __aws_node_pool_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAwsNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "awsNodePool" => Ok(__FieldTag::__aws_node_pool),
                            "aws_node_pool" => Ok(__FieldTag::__aws_node_pool),
                            "awsNodePoolId" => Ok(__FieldTag::__aws_node_pool_id),
                            "aws_node_pool_id" => Ok(__FieldTag::__aws_node_pool_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAwsNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAwsNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aws_node_pool => {
                            if !fields.insert(__FieldTag::__aws_node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_node_pool",
                                ));
                            }
                            result.aws_node_pool =
                                map.next_value::<std::option::Option<crate::model::AwsNodePool>>()?;
                        }
                        __FieldTag::__aws_node_pool_id => {
                            if !fields.insert(__FieldTag::__aws_node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_node_pool_id",
                                ));
                            }
                            result.aws_node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAwsNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.aws_node_pool.is_some() {
            state.serialize_entry("awsNodePool", &self.aws_node_pool)?;
        }
        if !self.aws_node_pool_id.is_empty() {
            state.serialize_entry("awsNodePoolId", &self.aws_node_pool_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.UpdateAwsNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAwsNodePoolRequest {
    /// Required. The [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub aws_node_pool: std::option::Option<crate::model::AwsNodePool>,

    /// If set, only validate the request, but don't actually update the node pool.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool]:
    ///
    /// * `annotations`.
    /// * `version`.
    /// * `autoscaling.min_node_count`.
    /// * `autoscaling.max_node_count`.
    /// * `config.config_encryption.kms_key_arn`.
    /// * `config.security_group_ids`.
    /// * `config.root_volume.iops`.
    /// * `config.root_volume.throughput`.
    /// * `config.root_volume.kms_key_arn`.
    /// * `config.root_volume.volume_type`.
    /// * `config.root_volume.size_gib`.
    /// * `config.proxy_config`.
    /// * `config.proxy_config.secret_arn`.
    /// * `config.proxy_config.secret_version`.
    /// * `config.ssh_config`.
    /// * `config.ssh_config.ec2_key_pair`.
    /// * `config.instance_placement.tenancy`.
    /// * `config.iam_instance_profile`.
    /// * `config.labels`.
    /// * `config.tags`.
    /// * `config.autoscaling_metrics_collection`.
    /// * `config.autoscaling_metrics_collection.granularity`.
    /// * `config.autoscaling_metrics_collection.metrics`.
    /// * `config.instance_type`.
    /// * `management.auto_repair`.
    /// * `management`.
    /// * `update_settings`.
    /// * `update_settings.surge_settings`.
    /// * `update_settings.surge_settings.max_surge`.
    /// * `update_settings.surge_settings.max_unavailable`.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_node_pool][crate::model::UpdateAwsNodePoolRequest::aws_node_pool].
    pub fn set_aws_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodePool>,
    {
        self.aws_node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aws_node_pool][crate::model::UpdateAwsNodePoolRequest::aws_node_pool].
    pub fn set_or_clear_aws_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AwsNodePool>,
    {
        self.aws_node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAwsNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAwsNodePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAwsNodePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAwsNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAwsNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_node_pool,
            __validate_only,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAwsNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsNodePool" => Ok(__FieldTag::__aws_node_pool),
                            "aws_node_pool" => Ok(__FieldTag::__aws_node_pool),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAwsNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAwsNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_node_pool => {
                            if !fields.insert(__FieldTag::__aws_node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_node_pool",
                                ));
                            }
                            result.aws_node_pool =
                                map.next_value::<std::option::Option<crate::model::AwsNodePool>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAwsNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aws_node_pool.is_some() {
            state.serialize_entry("awsNodePool", &self.aws_node_pool)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.RollbackAwsNodePoolUpdate` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackAwsNodePoolUpdateRequest {
    /// Required. The name of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource to
    /// rollback.
    ///
    /// `AwsNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub name: std::string::String,

    /// Optional. Option for rollback to ignore the PodDisruptionBudget when
    /// draining the node pool nodes. Default value is false.
    pub respect_pdb: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackAwsNodePoolUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackAwsNodePoolUpdateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [respect_pdb][crate::model::RollbackAwsNodePoolUpdateRequest::respect_pdb].
    pub fn set_respect_pdb<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.respect_pdb = v.into();
        self
    }
}

impl wkt::message::Message for RollbackAwsNodePoolUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.RollbackAwsNodePoolUpdateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackAwsNodePoolUpdateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __respect_pdb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackAwsNodePoolUpdateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "respectPdb" => Ok(__FieldTag::__respect_pdb),
                            "respect_pdb" => Ok(__FieldTag::__respect_pdb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackAwsNodePoolUpdateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackAwsNodePoolUpdateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__respect_pdb => {
                            if !fields.insert(__FieldTag::__respect_pdb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for respect_pdb",
                                ));
                            }
                            result.respect_pdb = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackAwsNodePoolUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.respect_pdb) {
            state.serialize_entry("respectPdb", &self.respect_pdb)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.GetAwsNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAwsNodePoolRequest {
    /// Required. The name of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource to
    /// describe.
    ///
    /// `AwsNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAwsNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAwsNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAwsNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAwsNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAwsNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAwsNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.ListAwsNodePools` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAwsNodePoolsRequest {
    /// Required. The parent `AwsCluster` which owns this collection of
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resources.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAwsNodePoolsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAwsNodePoolsResponse.next_page_token]: crate::model::ListAwsNodePoolsResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [awsNodePools.list][google.cloud.gkemulticloud.v1.AwsClusters.ListAwsNodePools]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.ListAwsNodePools]: crate::client::AwsClusters::list_aws_node_pools
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAwsNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAwsNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAwsNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAwsNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAwsNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsNodePoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAwsNodePoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAwsNodePoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAwsNodePoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAwsNodePoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAwsNodePoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AwsClusters.ListAwsNodePools` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAwsNodePoolsResponse {
    /// A list of [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool]
    /// resources in the specified `AwsCluster`.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub aws_node_pools: std::vec::Vec<crate::model::AwsNodePool>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAwsNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_node_pools][crate::model::ListAwsNodePoolsResponse::aws_node_pools].
    pub fn set_aws_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsNodePool>,
    {
        use std::iter::Iterator;
        self.aws_node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAwsNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAwsNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsNodePoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAwsNodePoolsResponse {
    type PageItem = crate::model::AwsNodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.aws_node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAwsNodePoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_node_pools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAwsNodePoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsNodePools" => Ok(__FieldTag::__aws_node_pools),
                            "aws_node_pools" => Ok(__FieldTag::__aws_node_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAwsNodePoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAwsNodePoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_node_pools => {
                            if !fields.insert(__FieldTag::__aws_node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_node_pools",
                                ));
                            }
                            result.aws_node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AwsNodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAwsNodePoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aws_node_pools.is_empty() {
            state.serialize_entry("awsNodePools", &self.aws_node_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.DeleteAwsNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAwsNodePoolRequest {
    /// Required. The resource name the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] to delete.
    ///
    /// `AwsNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the node
    /// pool.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// Optional. If set to true, the deletion of
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource will
    /// succeed even if errors occur during deleting in node pool resources. Using
    /// this parameter may result in orphaned resources in the node pool.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub ignore_errors: bool,

    /// The current ETag of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided ETag does not match the current etag of the node pool,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAwsNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAwsNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAwsNodePoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAwsNodePoolRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAwsNodePoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAwsNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAwsNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __ignore_errors,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAwsNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "ignoreErrors" => Ok(__FieldTag::__ignore_errors),
                            "ignore_errors" => Ok(__FieldTag::__ignore_errors),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAwsNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAwsNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_errors => {
                            if !fields.insert(__FieldTag::__ignore_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_errors",
                                ));
                            }
                            result.ignore_errors = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAwsNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.ignore_errors) {
            state.serialize_entry("ignoreErrors", &self.ignore_errors)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAwsOpenIdConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAwsOpenIdConfigRequest {
    /// Required. The AwsCluster, which owns the OIDC discovery document.
    /// Format:
    /// projects/{project}/locations/{location}/awsClusters/{cluster}
    pub aws_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAwsOpenIdConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GetAwsOpenIdConfigRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsOpenIdConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsOpenIdConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAwsOpenIdConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAwsOpenIdConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsCluster" => Ok(__FieldTag::__aws_cluster),
                            "aws_cluster" => Ok(__FieldTag::__aws_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAwsOpenIdConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAwsOpenIdConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_cluster => {
                            if !fields.insert(__FieldTag::__aws_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster",
                                ));
                            }
                            result.aws_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAwsOpenIdConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aws_cluster.is_empty() {
            state.serialize_entry("awsCluster", &self.aws_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAwsJsonWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAwsJsonWebKeysRequest {
    /// Required. The AwsCluster, which owns the JsonWebKeys.
    /// Format:
    /// projects/{project}/locations/{location}/awsClusters/{cluster}
    pub aws_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAwsJsonWebKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GetAwsJsonWebKeysRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsJsonWebKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsJsonWebKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAwsJsonWebKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAwsJsonWebKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsCluster" => Ok(__FieldTag::__aws_cluster),
                            "aws_cluster" => Ok(__FieldTag::__aws_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAwsJsonWebKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAwsJsonWebKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_cluster => {
                            if !fields.insert(__FieldTag::__aws_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster",
                                ));
                            }
                            result.aws_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAwsJsonWebKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aws_cluster.is_empty() {
            state.serialize_entry("awsCluster", &self.aws_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAwsServerConfigRequest gets the server config of GKE cluster on AWS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAwsServerConfigRequest {
    /// Required. The name of the
    /// [AwsServerConfig][google.cloud.gkemulticloud.v1.AwsServerConfig] resource
    /// to describe.
    ///
    /// `AwsServerConfig` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsServerConfig]: crate::model::AwsServerConfig
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAwsServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAwsServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsServerConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAwsServerConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAwsServerConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAwsServerConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAwsServerConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAwsServerConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AwsClusters.GenerateAwsAccessToken` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAwsAccessTokenRequest {
    /// Required. The name of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource to
    /// authenticate to.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub aws_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAwsAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GenerateAwsAccessTokenRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsAccessTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAwsAccessTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAwsAccessTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsCluster" => Ok(__FieldTag::__aws_cluster),
                            "aws_cluster" => Ok(__FieldTag::__aws_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAwsAccessTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAwsAccessTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_cluster => {
                            if !fields.insert(__FieldTag::__aws_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster",
                                ));
                            }
                            result.aws_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAwsAccessTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aws_cluster.is_empty() {
            state.serialize_entry("awsCluster", &self.aws_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AwsClusters.GenerateAwsAccessToken` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAwsAccessTokenResponse {
    /// Output only. Access token to authenticate to k8s api-server.
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAwsAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAwsAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::GenerateAwsAccessTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::GenerateAwsAccessTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateAwsAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsAccessTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAwsAccessTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAwsAccessTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAwsAccessTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAwsAccessTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAwsAccessTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAwsClusterAgentTokenRequest {
    /// Required.
    pub aws_cluster: std::string::String,

    /// Required.
    pub subject_token: std::string::String,

    /// Required.
    pub subject_token_type: std::string::String,

    /// Required.
    pub version: std::string::String,

    /// Optional.
    pub node_pool_id: std::string::String,

    /// Optional.
    pub grant_type: std::string::String,

    /// Optional.
    pub audience: std::string::String,

    /// Optional.
    pub scope: std::string::String,

    /// Optional.
    pub requested_token_type: std::string::String,

    /// Optional.
    pub options: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAwsClusterAgentTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GenerateAwsClusterAgentTokenRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }

    /// Sets the value of [subject_token][crate::model::GenerateAwsClusterAgentTokenRequest::subject_token].
    pub fn set_subject_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_token = v.into();
        self
    }

    /// Sets the value of [subject_token_type][crate::model::GenerateAwsClusterAgentTokenRequest::subject_token_type].
    pub fn set_subject_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_token_type = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenerateAwsClusterAgentTokenRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::GenerateAwsClusterAgentTokenRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [grant_type][crate::model::GenerateAwsClusterAgentTokenRequest::grant_type].
    pub fn set_grant_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grant_type = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::GenerateAwsClusterAgentTokenRequest::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::GenerateAwsClusterAgentTokenRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [requested_token_type][crate::model::GenerateAwsClusterAgentTokenRequest::requested_token_type].
    pub fn set_requested_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_token_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::GenerateAwsClusterAgentTokenRequest::options].
    pub fn set_options<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.options = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsClusterAgentTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsClusterAgentTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAwsClusterAgentTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_cluster,
            __subject_token,
            __subject_token_type,
            __version,
            __node_pool_id,
            __grant_type,
            __audience,
            __scope,
            __requested_token_type,
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAwsClusterAgentTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsCluster" => Ok(__FieldTag::__aws_cluster),
                            "aws_cluster" => Ok(__FieldTag::__aws_cluster),
                            "subjectToken" => Ok(__FieldTag::__subject_token),
                            "subject_token" => Ok(__FieldTag::__subject_token),
                            "subjectTokenType" => Ok(__FieldTag::__subject_token_type),
                            "subject_token_type" => Ok(__FieldTag::__subject_token_type),
                            "version" => Ok(__FieldTag::__version),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "grantType" => Ok(__FieldTag::__grant_type),
                            "grant_type" => Ok(__FieldTag::__grant_type),
                            "audience" => Ok(__FieldTag::__audience),
                            "scope" => Ok(__FieldTag::__scope),
                            "requestedTokenType" => Ok(__FieldTag::__requested_token_type),
                            "requested_token_type" => Ok(__FieldTag::__requested_token_type),
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAwsClusterAgentTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAwsClusterAgentTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_cluster => {
                            if !fields.insert(__FieldTag::__aws_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_cluster",
                                ));
                            }
                            result.aws_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_token => {
                            if !fields.insert(__FieldTag::__subject_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_token",
                                ));
                            }
                            result.subject_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_token_type => {
                            if !fields.insert(__FieldTag::__subject_token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_token_type",
                                ));
                            }
                            result.subject_token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grant_type => {
                            if !fields.insert(__FieldTag::__grant_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_type",
                                ));
                            }
                            result.grant_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audience",
                                ));
                            }
                            result.audience = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_token_type => {
                            if !fields.insert(__FieldTag::__requested_token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_token_type",
                                ));
                            }
                            result.requested_token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAwsClusterAgentTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aws_cluster.is_empty() {
            state.serialize_entry("awsCluster", &self.aws_cluster)?;
        }
        if !self.subject_token.is_empty() {
            state.serialize_entry("subjectToken", &self.subject_token)?;
        }
        if !self.subject_token_type.is_empty() {
            state.serialize_entry("subjectTokenType", &self.subject_token_type)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.grant_type.is_empty() {
            state.serialize_entry("grantType", &self.grant_type)?;
        }
        if !self.audience.is_empty() {
            state.serialize_entry("audience", &self.audience)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.requested_token_type.is_empty() {
            state.serialize_entry("requestedTokenType", &self.requested_token_type)?;
        }
        if !self.options.is_empty() {
            state.serialize_entry("options", &self.options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAwsClusterAgentTokenResponse {
    pub access_token: std::string::String,

    pub expires_in: i32,

    pub token_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAwsClusterAgentTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAwsClusterAgentTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expires_in][crate::model::GenerateAwsClusterAgentTokenResponse::expires_in].
    pub fn set_expires_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expires_in = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::GenerateAwsClusterAgentTokenResponse::token_type].
    pub fn set_token_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsClusterAgentTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsClusterAgentTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAwsClusterAgentTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expires_in,
            __token_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAwsClusterAgentTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expiresIn" => Ok(__FieldTag::__expires_in),
                            "expires_in" => Ok(__FieldTag::__expires_in),
                            "tokenType" => Ok(__FieldTag::__token_type),
                            "token_type" => Ok(__FieldTag::__token_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAwsClusterAgentTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAwsClusterAgentTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expires_in => {
                            if !fields.insert(__FieldTag::__expires_in) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expires_in",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expires_in = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__token_type => {
                            if !fields.insert(__FieldTag::__token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_type",
                                ));
                            }
                            result.token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAwsClusterAgentTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if !wkt::internal::is_default(&self.expires_in) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expiresIn", &__With(&self.expires_in))?;
        }
        if !self.token_type.is_empty() {
            state.serialize_entry("tokenType", &self.token_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An Anthos cluster running on Azure.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureCluster {
    /// The name of this resource.
    ///
    /// Cluster names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    pub name: std::string::String,

    /// Optional. A human readable description of this cluster.
    /// Cannot be longer than 255 UTF-8 encoded bytes.
    pub description: std::string::String,

    /// Required. The Azure region where the cluster runs.
    ///
    /// Each Google Cloud region supports a subset of nearby Azure regions.
    /// You can call
    /// [GetAzureServerConfig][google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig]
    /// to list all supported Azure regions within a given Google Cloud region.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig]: crate::client::AzureClusters::get_azure_server_config
    pub azure_region: std::string::String,

    /// Required. The ARM ID of the resource group where the cluster resources are
    /// deployed. For example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-name>`
    pub resource_group_id: std::string::String,

    /// Optional. Name of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] that contains
    /// authentication configuration for how the Anthos Multi-Cloud API connects to
    /// Azure APIs.
    ///
    /// Either azure_client or azure_services_authentication should be provided.
    ///
    /// The `AzureClient` resource must reside on the same Google Cloud Platform
    /// project and region as the `AzureCluster`.
    ///
    /// `AzureClient` names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub azure_client: std::string::String,

    /// Required. Cluster-wide networking configuration.
    pub networking: std::option::Option<crate::model::AzureClusterNetworking>,

    /// Required. Configuration related to the cluster control plane.
    pub control_plane: std::option::Option<crate::model::AzureControlPlane>,

    /// Required. Configuration related to the cluster RBAC settings.
    pub authorization: std::option::Option<crate::model::AzureAuthorization>,

    /// Optional. Authentication configuration for management of Azure resources.
    ///
    /// Either azure_client or azure_services_authentication should be provided.
    pub azure_services_authentication:
        std::option::Option<crate::model::AzureServicesAuthentication>,

    /// Output only. The current state of the cluster.
    pub state: crate::model::azure_cluster::State,

    /// Output only. The endpoint of the cluster's API server.
    pub endpoint: std::string::String,

    /// Output only. A globally unique identifier for the cluster.
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the cluster.
    pub reconciling: bool,

    /// Output only. The time at which this cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this cluster was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Annotations on the cluster.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Keys can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workload Identity settings.
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Output only. PEM encoded x509 certificate of the cluster root of trust.
    pub cluster_ca_certificate: std::string::String,

    /// Required. Fleet configuration.
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Output only. Managed Azure resources for this cluster.
    pub managed_resources: std::option::Option<crate::model::AzureClusterResources>,

    /// Optional. Logging configuration for this cluster.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Output only. A set of errors found in the cluster.
    pub errors: std::vec::Vec<crate::model::AzureClusterError>,

    /// Optional. Monitoring configuration for this cluster.
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AzureCluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [azure_region][crate::model::AzureCluster::azure_region].
    pub fn set_azure_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_region = v.into();
        self
    }

    /// Sets the value of [resource_group_id][crate::model::AzureCluster::resource_group_id].
    pub fn set_resource_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_group_id = v.into();
        self
    }

    /// Sets the value of [azure_client][crate::model::AzureCluster::azure_client].
    pub fn set_azure_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_client = v.into();
        self
    }

    /// Sets the value of [networking][crate::model::AzureCluster::networking].
    pub fn set_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureClusterNetworking>,
    {
        self.networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [networking][crate::model::AzureCluster::networking].
    pub fn set_or_clear_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureClusterNetworking>,
    {
        self.networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [control_plane][crate::model::AzureCluster::control_plane].
    pub fn set_control_plane<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureControlPlane>,
    {
        self.control_plane = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane][crate::model::AzureCluster::control_plane].
    pub fn set_or_clear_control_plane<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureControlPlane>,
    {
        self.control_plane = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization][crate::model::AzureCluster::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureAuthorization>,
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::AzureCluster::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureAuthorization>,
    {
        self.authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [azure_services_authentication][crate::model::AzureCluster::azure_services_authentication].
    pub fn set_azure_services_authentication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureServicesAuthentication>,
    {
        self.azure_services_authentication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_services_authentication][crate::model::AzureCluster::azure_services_authentication].
    pub fn set_or_clear_azure_services_authentication<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AzureServicesAuthentication>,
    {
        self.azure_services_authentication = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::AzureCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::azure_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::AzureCluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AzureCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AzureCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AzureCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AzureCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AzureCluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AzureCluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AzureCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AzureCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::AzureCluster::workload_identity_config].
    pub fn set_workload_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_identity_config][crate::model::AzureCluster::workload_identity_config].
    pub fn set_or_clear_workload_identity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::AzureCluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::AzureCluster::fleet].
    pub fn set_fleet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fleet][crate::model::AzureCluster::fleet].
    pub fn set_or_clear_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [managed_resources][crate::model::AzureCluster::managed_resources].
    pub fn set_managed_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureClusterResources>,
    {
        self.managed_resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [managed_resources][crate::model::AzureCluster::managed_resources].
    pub fn set_or_clear_managed_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureClusterResources>,
    {
        self.managed_resources = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::AzureCluster::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::AzureCluster::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::AzureCluster::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClusterError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::AzureCluster::monitoring_config].
    pub fn set_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monitoring_config][crate::model::AzureCluster::monitoring_config].
    pub fn set_or_clear_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AzureCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __azure_region,
            __resource_group_id,
            __azure_client,
            __networking,
            __control_plane,
            __authorization,
            __azure_services_authentication,
            __state,
            __endpoint,
            __uid,
            __reconciling,
            __create_time,
            __update_time,
            __etag,
            __annotations,
            __workload_identity_config,
            __cluster_ca_certificate,
            __fleet,
            __managed_resources,
            __logging_config,
            __errors,
            __monitoring_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "azureRegion" => Ok(__FieldTag::__azure_region),
                            "azure_region" => Ok(__FieldTag::__azure_region),
                            "resourceGroupId" => Ok(__FieldTag::__resource_group_id),
                            "resource_group_id" => Ok(__FieldTag::__resource_group_id),
                            "azureClient" => Ok(__FieldTag::__azure_client),
                            "azure_client" => Ok(__FieldTag::__azure_client),
                            "networking" => Ok(__FieldTag::__networking),
                            "controlPlane" => Ok(__FieldTag::__control_plane),
                            "control_plane" => Ok(__FieldTag::__control_plane),
                            "authorization" => Ok(__FieldTag::__authorization),
                            "azureServicesAuthentication" => {
                                Ok(__FieldTag::__azure_services_authentication)
                            }
                            "azure_services_authentication" => {
                                Ok(__FieldTag::__azure_services_authentication)
                            }
                            "state" => Ok(__FieldTag::__state),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "workloadIdentityConfig" => Ok(__FieldTag::__workload_identity_config),
                            "workload_identity_config" => {
                                Ok(__FieldTag::__workload_identity_config)
                            }
                            "clusterCaCertificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "cluster_ca_certificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "fleet" => Ok(__FieldTag::__fleet),
                            "managedResources" => Ok(__FieldTag::__managed_resources),
                            "managed_resources" => Ok(__FieldTag::__managed_resources),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "errors" => Ok(__FieldTag::__errors),
                            "monitoringConfig" => Ok(__FieldTag::__monitoring_config),
                            "monitoring_config" => Ok(__FieldTag::__monitoring_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_region => {
                            if !fields.insert(__FieldTag::__azure_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_region",
                                ));
                            }
                            result.azure_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_group_id => {
                            if !fields.insert(__FieldTag::__resource_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_group_id",
                                ));
                            }
                            result.resource_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_client => {
                            if !fields.insert(__FieldTag::__azure_client) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_client",
                                ));
                            }
                            result.azure_client = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__networking => {
                            if !fields.insert(__FieldTag::__networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networking",
                                ));
                            }
                            result.networking = map.next_value::<std::option::Option<crate::model::AzureClusterNetworking>>()?
                                ;
                        }
                        __FieldTag::__control_plane => {
                            if !fields.insert(__FieldTag::__control_plane) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane",
                                ));
                            }
                            result.control_plane = map
                                .next_value::<std::option::Option<crate::model::AzureControlPlane>>(
                                )?;
                        }
                        __FieldTag::__authorization => {
                            if !fields.insert(__FieldTag::__authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization",
                                ));
                            }
                            result.authorization = map.next_value::<std::option::Option<crate::model::AzureAuthorization>>()?
                                ;
                        }
                        __FieldTag::__azure_services_authentication => {
                            if !fields.insert(__FieldTag::__azure_services_authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_services_authentication",
                                ));
                            }
                            result.azure_services_authentication = map.next_value::<std::option::Option<crate::model::AzureServicesAuthentication>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::azure_cluster::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_identity_config => {
                            if !fields.insert(__FieldTag::__workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_identity_config",
                                ));
                            }
                            result.workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__cluster_ca_certificate => {
                            if !fields.insert(__FieldTag::__cluster_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca_certificate",
                                ));
                            }
                            result.cluster_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet => {
                            if !fields.insert(__FieldTag::__fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet",
                                ));
                            }
                            result.fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__managed_resources => {
                            if !fields.insert(__FieldTag::__managed_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_resources",
                                ));
                            }
                            result.managed_resources = map.next_value::<std::option::Option<crate::model::AzureClusterResources>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AzureClusterError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring_config => {
                            if !fields.insert(__FieldTag::__monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_config",
                                ));
                            }
                            result.monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.azure_region.is_empty() {
            state.serialize_entry("azureRegion", &self.azure_region)?;
        }
        if !self.resource_group_id.is_empty() {
            state.serialize_entry("resourceGroupId", &self.resource_group_id)?;
        }
        if !self.azure_client.is_empty() {
            state.serialize_entry("azureClient", &self.azure_client)?;
        }
        if self.networking.is_some() {
            state.serialize_entry("networking", &self.networking)?;
        }
        if self.control_plane.is_some() {
            state.serialize_entry("controlPlane", &self.control_plane)?;
        }
        if self.authorization.is_some() {
            state.serialize_entry("authorization", &self.authorization)?;
        }
        if self.azure_services_authentication.is_some() {
            state.serialize_entry(
                "azureServicesAuthentication",
                &self.azure_services_authentication,
            )?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.workload_identity_config.is_some() {
            state.serialize_entry("workloadIdentityConfig", &self.workload_identity_config)?;
        }
        if !self.cluster_ca_certificate.is_empty() {
            state.serialize_entry("clusterCaCertificate", &self.cluster_ca_certificate)?;
        }
        if self.fleet.is_some() {
            state.serialize_entry("fleet", &self.fleet)?;
        }
        if self.managed_resources.is_some() {
            state.serialize_entry("managedResources", &self.managed_resources)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.monitoring_config.is_some() {
            state.serialize_entry("monitoringConfig", &self.monitoring_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AzureCluster].
pub mod azure_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the cluster is being created.
        Provisioning,
        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        Running,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the control plane replicas.
        Reconciling,
        /// The STOPPING state indicates the cluster is being deleted.
        Stopping,
        /// The ERROR state indicates the cluster is in a broken unrecoverable
        /// state.
        Error,
        /// The DEGRADED state indicates the cluster requires user action to
        /// restore full functionality.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkemulticloud.v1.AzureCluster.State",
            ))
        }
    }
}

/// ClusterNetworking contains cluster-wide networking configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureClusterNetworking {
    /// Required. The Azure Resource Manager (ARM) ID of the VNet associated with
    /// your cluster.
    ///
    /// All components in the cluster (i.e. control plane and node pools) run on a
    /// single VNet.
    ///
    /// Example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.Network/virtualNetworks/<vnet-id>`
    ///
    /// This field cannot be changed after creation.
    pub virtual_network_id: std::string::String,

    /// Required. The IP address range of the pods in this cluster, in CIDR
    /// notation (e.g. `10.96.0.0/14`).
    ///
    /// All pods in the cluster get assigned a unique IPv4 address from these
    /// ranges. Only a single range is supported.
    ///
    /// This field cannot be changed after creation.
    pub pod_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. The IP address range for services in this cluster, in CIDR
    /// notation (e.g. `10.96.0.0/14`).
    ///
    /// All services in the cluster get assigned a unique IPv4 address from these
    /// ranges. Only a single range is supported.
    ///
    /// This field cannot be changed after creating a cluster.
    pub service_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Optional. The ARM ID of the subnet where Kubernetes private service type
    /// load balancers are deployed. When unspecified, it defaults to
    /// AzureControlPlane.subnet_id.
    ///
    /// Example:
    /// "/subscriptions/d00494d6-6f3c-4280-bbb2-899e163d1d30/resourceGroups/anthos_cluster_gkeust4/providers/Microsoft.Network/virtualNetworks/gke-vnet-gkeust4/subnets/subnetid456"
    pub service_load_balancer_subnet_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [virtual_network_id][crate::model::AzureClusterNetworking::virtual_network_id].
    pub fn set_virtual_network_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.virtual_network_id = v.into();
        self
    }

    /// Sets the value of [pod_address_cidr_blocks][crate::model::AzureClusterNetworking::pod_address_cidr_blocks].
    pub fn set_pod_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_address_cidr_blocks][crate::model::AzureClusterNetworking::service_address_cidr_blocks].
    pub fn set_service_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_load_balancer_subnet_id][crate::model::AzureClusterNetworking::service_load_balancer_subnet_id].
    pub fn set_service_load_balancer_subnet_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_load_balancer_subnet_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterNetworking"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureClusterNetworking {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __virtual_network_id,
            __pod_address_cidr_blocks,
            __service_address_cidr_blocks,
            __service_load_balancer_subnet_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureClusterNetworking")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "virtualNetworkId" => Ok(__FieldTag::__virtual_network_id),
                            "virtual_network_id" => Ok(__FieldTag::__virtual_network_id),
                            "podAddressCidrBlocks" => Ok(__FieldTag::__pod_address_cidr_blocks),
                            "pod_address_cidr_blocks" => Ok(__FieldTag::__pod_address_cidr_blocks),
                            "serviceAddressCidrBlocks" => {
                                Ok(__FieldTag::__service_address_cidr_blocks)
                            }
                            "service_address_cidr_blocks" => {
                                Ok(__FieldTag::__service_address_cidr_blocks)
                            }
                            "serviceLoadBalancerSubnetId" => {
                                Ok(__FieldTag::__service_load_balancer_subnet_id)
                            }
                            "service_load_balancer_subnet_id" => {
                                Ok(__FieldTag::__service_load_balancer_subnet_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureClusterNetworking;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureClusterNetworking")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__virtual_network_id => {
                            if !fields.insert(__FieldTag::__virtual_network_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virtual_network_id",
                                ));
                            }
                            result.virtual_network_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_address_cidr_blocks => {
                            if !fields.insert(__FieldTag::__pod_address_cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_address_cidr_blocks",
                                ));
                            }
                            result.pod_address_cidr_blocks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_address_cidr_blocks => {
                            if !fields.insert(__FieldTag::__service_address_cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_address_cidr_blocks",
                                ));
                            }
                            result.service_address_cidr_blocks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_load_balancer_subnet_id => {
                            if !fields.insert(__FieldTag::__service_load_balancer_subnet_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_load_balancer_subnet_id",
                                ));
                            }
                            result.service_load_balancer_subnet_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureClusterNetworking {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.virtual_network_id.is_empty() {
            state.serialize_entry("virtualNetworkId", &self.virtual_network_id)?;
        }
        if !self.pod_address_cidr_blocks.is_empty() {
            state.serialize_entry("podAddressCidrBlocks", &self.pod_address_cidr_blocks)?;
        }
        if !self.service_address_cidr_blocks.is_empty() {
            state.serialize_entry(
                "serviceAddressCidrBlocks",
                &self.service_address_cidr_blocks,
            )?;
        }
        if !self.service_load_balancer_subnet_id.is_empty() {
            state.serialize_entry(
                "serviceLoadBalancerSubnetId",
                &self.service_load_balancer_subnet_id,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AzureControlPlane represents the control plane configurations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureControlPlane {
    /// Required. The Kubernetes version to run on control plane replicas
    /// (e.g. `1.19.10-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAzureServerConfig][google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig]: crate::client::AzureClusters::get_azure_server_config
    pub version: std::string::String,

    /// Optional. The ARM ID of the default subnet for the control plane. The
    /// control plane VMs are deployed in this subnet, unless
    /// `AzureControlPlane.replica_placements` is specified. This subnet will also
    /// be used as default for `AzureControlPlane.endpoint_subnet_id` if
    /// `AzureControlPlane.endpoint_subnet_id` is not specified. Similarly it will
    /// be used as default for
    /// `AzureClusterNetworking.service_load_balancer_subnet_id`.
    ///
    /// Example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.Network/virtualNetworks/<vnet-id>/subnets/default`.
    pub subnet_id: std::string::String,

    /// Optional. The Azure VM size name. Example: `Standard_DS2_v2`.
    ///
    /// For available VM sizes, see
    /// <https://docs.microsoft.com/en-us/azure/virtual-machines/vm-naming-conventions>.
    ///
    /// When unspecified, it defaults to `Standard_DS2_v2`.
    pub vm_size: std::string::String,

    /// Required. SSH configuration for how to access the underlying control plane
    /// machines.
    pub ssh_config: std::option::Option<crate::model::AzureSshConfig>,

    /// Optional. Configuration related to the root volume provisioned for each
    /// control plane replica.
    ///
    /// When unspecified, it defaults to 32-GiB Azure Disk.
    pub root_volume: std::option::Option<crate::model::AzureDiskTemplate>,

    /// Optional. Configuration related to the main volume provisioned for each
    /// control plane replica.
    /// The main volume is in charge of storing all of the cluster's etcd state.
    ///
    /// When unspecified, it defaults to a 8-GiB Azure Disk.
    pub main_volume: std::option::Option<crate::model::AzureDiskTemplate>,

    /// Optional. Configuration related to application-layer secrets encryption.
    pub database_encryption: std::option::Option<crate::model::AzureDatabaseEncryption>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AzureProxyConfig>,

    /// Optional. Configuration related to vm config encryption.
    pub config_encryption: std::option::Option<crate::model::AzureConfigEncryption>,

    /// Optional. A set of tags to apply to all underlying control plane Azure
    /// resources.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Configuration for where to place the control plane replicas.
    ///
    /// Up to three replica placement instances can be specified. If
    /// replica_placements is set, the replica placement instances will be applied
    /// to the three control plane replicas as evenly as possible.
    pub replica_placements: std::vec::Vec<crate::model::ReplicaPlacement>,

    /// Optional. The ARM ID of the subnet where the control plane load balancer is
    /// deployed. When unspecified, it defaults to AzureControlPlane.subnet_id.
    ///
    /// Example:
    /// "/subscriptions/d00494d6-6f3c-4280-bbb2-899e163d1d30/resourceGroups/anthos_cluster_gkeust4/providers/Microsoft.Network/virtualNetworks/gke-vnet-gkeust4/subnets/subnetid123"
    pub endpoint_subnet_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureControlPlane {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AzureControlPlane::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [subnet_id][crate::model::AzureControlPlane::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [vm_size][crate::model::AzureControlPlane::vm_size].
    pub fn set_vm_size<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_size = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AzureControlPlane::ssh_config].
    pub fn set_ssh_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureSshConfig>,
    {
        self.ssh_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssh_config][crate::model::AzureControlPlane::ssh_config].
    pub fn set_or_clear_ssh_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureSshConfig>,
    {
        self.ssh_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [root_volume][crate::model::AzureControlPlane::root_volume].
    pub fn set_root_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureDiskTemplate>,
    {
        self.root_volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [root_volume][crate::model::AzureControlPlane::root_volume].
    pub fn set_or_clear_root_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureDiskTemplate>,
    {
        self.root_volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [main_volume][crate::model::AzureControlPlane::main_volume].
    pub fn set_main_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureDiskTemplate>,
    {
        self.main_volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [main_volume][crate::model::AzureControlPlane::main_volume].
    pub fn set_or_clear_main_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureDiskTemplate>,
    {
        self.main_volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_encryption][crate::model::AzureControlPlane::database_encryption].
    pub fn set_database_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureDatabaseEncryption>,
    {
        self.database_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_encryption][crate::model::AzureControlPlane::database_encryption].
    pub fn set_or_clear_database_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureDatabaseEncryption>,
    {
        self.database_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [proxy_config][crate::model::AzureControlPlane::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::AzureControlPlane::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_encryption][crate::model::AzureControlPlane::config_encryption].
    pub fn set_config_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureConfigEncryption>,
    {
        self.config_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_encryption][crate::model::AzureControlPlane::config_encryption].
    pub fn set_or_clear_config_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureConfigEncryption>,
    {
        self.config_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::AzureControlPlane::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [replica_placements][crate::model::AzureControlPlane::replica_placements].
    pub fn set_replica_placements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaPlacement>,
    {
        use std::iter::Iterator;
        self.replica_placements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [endpoint_subnet_id][crate::model::AzureControlPlane::endpoint_subnet_id].
    pub fn set_endpoint_subnet_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_subnet_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureControlPlane {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureControlPlane"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureControlPlane {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __subnet_id,
            __vm_size,
            __ssh_config,
            __root_volume,
            __main_volume,
            __database_encryption,
            __proxy_config,
            __config_encryption,
            __tags,
            __replica_placements,
            __endpoint_subnet_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureControlPlane")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "subnetId" => Ok(__FieldTag::__subnet_id),
                            "subnet_id" => Ok(__FieldTag::__subnet_id),
                            "vmSize" => Ok(__FieldTag::__vm_size),
                            "vm_size" => Ok(__FieldTag::__vm_size),
                            "sshConfig" => Ok(__FieldTag::__ssh_config),
                            "ssh_config" => Ok(__FieldTag::__ssh_config),
                            "rootVolume" => Ok(__FieldTag::__root_volume),
                            "root_volume" => Ok(__FieldTag::__root_volume),
                            "mainVolume" => Ok(__FieldTag::__main_volume),
                            "main_volume" => Ok(__FieldTag::__main_volume),
                            "databaseEncryption" => Ok(__FieldTag::__database_encryption),
                            "database_encryption" => Ok(__FieldTag::__database_encryption),
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            "configEncryption" => Ok(__FieldTag::__config_encryption),
                            "config_encryption" => Ok(__FieldTag::__config_encryption),
                            "tags" => Ok(__FieldTag::__tags),
                            "replicaPlacements" => Ok(__FieldTag::__replica_placements),
                            "replica_placements" => Ok(__FieldTag::__replica_placements),
                            "endpointSubnetId" => Ok(__FieldTag::__endpoint_subnet_id),
                            "endpoint_subnet_id" => Ok(__FieldTag::__endpoint_subnet_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureControlPlane;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureControlPlane")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnet_id => {
                            if !fields.insert(__FieldTag::__subnet_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_id",
                                ));
                            }
                            result.subnet_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_size => {
                            if !fields.insert(__FieldTag::__vm_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_size",
                                ));
                            }
                            result.vm_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_config => {
                            if !fields.insert(__FieldTag::__ssh_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_config",
                                ));
                            }
                            result.ssh_config = map
                                .next_value::<std::option::Option<crate::model::AzureSshConfig>>(
                                )?;
                        }
                        __FieldTag::__root_volume => {
                            if !fields.insert(__FieldTag::__root_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_volume",
                                ));
                            }
                            result.root_volume = map
                                .next_value::<std::option::Option<crate::model::AzureDiskTemplate>>(
                                )?;
                        }
                        __FieldTag::__main_volume => {
                            if !fields.insert(__FieldTag::__main_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_volume",
                                ));
                            }
                            result.main_volume = map
                                .next_value::<std::option::Option<crate::model::AzureDiskTemplate>>(
                                )?;
                        }
                        __FieldTag::__database_encryption => {
                            if !fields.insert(__FieldTag::__database_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_encryption",
                                ));
                            }
                            result.database_encryption = map.next_value::<std::option::Option<crate::model::AzureDatabaseEncryption>>()?
                                ;
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map
                                .next_value::<std::option::Option<crate::model::AzureProxyConfig>>(
                                )?;
                        }
                        __FieldTag::__config_encryption => {
                            if !fields.insert(__FieldTag::__config_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_encryption",
                                ));
                            }
                            result.config_encryption = map.next_value::<std::option::Option<crate::model::AzureConfigEncryption>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_placements => {
                            if !fields.insert(__FieldTag::__replica_placements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_placements",
                                ));
                            }
                            result.replica_placements =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ReplicaPlacement>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint_subnet_id => {
                            if !fields.insert(__FieldTag::__endpoint_subnet_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_subnet_id",
                                ));
                            }
                            result.endpoint_subnet_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureControlPlane {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.subnet_id.is_empty() {
            state.serialize_entry("subnetId", &self.subnet_id)?;
        }
        if !self.vm_size.is_empty() {
            state.serialize_entry("vmSize", &self.vm_size)?;
        }
        if self.ssh_config.is_some() {
            state.serialize_entry("sshConfig", &self.ssh_config)?;
        }
        if self.root_volume.is_some() {
            state.serialize_entry("rootVolume", &self.root_volume)?;
        }
        if self.main_volume.is_some() {
            state.serialize_entry("mainVolume", &self.main_volume)?;
        }
        if self.database_encryption.is_some() {
            state.serialize_entry("databaseEncryption", &self.database_encryption)?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if self.config_encryption.is_some() {
            state.serialize_entry("configEncryption", &self.config_encryption)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.replica_placements.is_empty() {
            state.serialize_entry("replicaPlacements", &self.replica_placements)?;
        }
        if !self.endpoint_subnet_id.is_empty() {
            state.serialize_entry("endpointSubnetId", &self.endpoint_subnet_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for the placement of a control plane replica.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaPlacement {
    /// Required. For a given replica, the ARM ID of the subnet where the control
    /// plane VM is deployed. Make sure it's a subnet under the virtual network in
    /// the cluster configuration.
    pub subnet_id: std::string::String,

    /// Required. For a given replica, the Azure availability zone where to
    /// provision the control plane VM and the ETCD disk.
    pub azure_availability_zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaPlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnet_id][crate::model::ReplicaPlacement::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [azure_availability_zone][crate::model::ReplicaPlacement::azure_availability_zone].
    pub fn set_azure_availability_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_availability_zone = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaPlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ReplicaPlacement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicaPlacement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnet_id,
            __azure_availability_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicaPlacement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetId" => Ok(__FieldTag::__subnet_id),
                            "subnet_id" => Ok(__FieldTag::__subnet_id),
                            "azureAvailabilityZone" => Ok(__FieldTag::__azure_availability_zone),
                            "azure_availability_zone" => Ok(__FieldTag::__azure_availability_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicaPlacement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicaPlacement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnet_id => {
                            if !fields.insert(__FieldTag::__subnet_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_id",
                                ));
                            }
                            result.subnet_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_availability_zone => {
                            if !fields.insert(__FieldTag::__azure_availability_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_availability_zone",
                                ));
                            }
                            result.azure_availability_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicaPlacement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnet_id.is_empty() {
            state.serialize_entry("subnetId", &self.subnet_id)?;
        }
        if !self.azure_availability_zone.is_empty() {
            state.serialize_entry("azureAvailabilityZone", &self.azure_availability_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of a proxy config stored in Azure Key Vault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureProxyConfig {
    /// The ARM ID the of the resource group containing proxy keyvault.
    ///
    /// Resource group ids are formatted as
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-name>`.
    pub resource_group_id: std::string::String,

    /// The URL the of the proxy setting secret with its version.
    ///
    /// The secret must be a JSON encoded proxy configuration
    /// as described in
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/azure/how-to/use-a-proxy#create_a_proxy_configuration_file>
    ///
    /// Secret ids are formatted as
    /// `https://<key-vault-name>.vault.azure.net/secrets/<secret-name>/<secret-version>`.
    pub secret_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_group_id][crate::model::AzureProxyConfig::resource_group_id].
    pub fn set_resource_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_group_id = v.into();
        self
    }

    /// Sets the value of [secret_id][crate::model::AzureProxyConfig::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureProxyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureProxyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_group_id,
            __secret_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureProxyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceGroupId" => Ok(__FieldTag::__resource_group_id),
                            "resource_group_id" => Ok(__FieldTag::__resource_group_id),
                            "secretId" => Ok(__FieldTag::__secret_id),
                            "secret_id" => Ok(__FieldTag::__secret_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureProxyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureProxyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_group_id => {
                            if !fields.insert(__FieldTag::__resource_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_group_id",
                                ));
                            }
                            result.resource_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_id => {
                            if !fields.insert(__FieldTag::__secret_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_id",
                                ));
                            }
                            result.secret_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureProxyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_group_id.is_empty() {
            state.serialize_entry("resourceGroupId", &self.resource_group_id)?;
        }
        if !self.secret_id.is_empty() {
            state.serialize_entry("secretId", &self.secret_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration related to application-layer secrets encryption.
///
/// Anthos clusters on Azure encrypts your Kubernetes data at rest
/// in etcd using Azure Key Vault.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureDatabaseEncryption {
    /// Required. The ARM ID of the Azure Key Vault key to encrypt / decrypt data.
    ///
    /// For example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.KeyVault/vaults/<key-vault-id>/keys/<key-name>`
    /// Encryption will always take the latest version of the key and hence
    /// specific version is not supported.
    pub key_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureDatabaseEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_id][crate::model::AzureDatabaseEncryption::key_id].
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureDatabaseEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureDatabaseEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureDatabaseEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureDatabaseEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyId" => Ok(__FieldTag::__key_id),
                            "key_id" => Ok(__FieldTag::__key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureDatabaseEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureDatabaseEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_id => {
                            if !fields.insert(__FieldTag::__key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_id",
                                ));
                            }
                            result.key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureDatabaseEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_id.is_empty() {
            state.serialize_entry("keyId", &self.key_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration related to config data encryption.
///
/// Azure VM bootstrap secret is envelope encrypted with the provided key vault
/// key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureConfigEncryption {
    /// Required. The ARM ID of the Azure Key Vault key to encrypt / decrypt config
    /// data.
    ///
    /// For example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.KeyVault/vaults/<key-vault-id>/keys/<key-name>`
    pub key_id: std::string::String,

    /// Optional. RSA key of the Azure Key Vault public key to use for encrypting
    /// the data.
    ///
    /// This key must be formatted as a PEM-encoded SubjectPublicKeyInfo (RFC 5280)
    /// in ASN.1 DER form. The string must be comprised of a single PEM block of
    /// type "PUBLIC KEY".
    pub public_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureConfigEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_id][crate::model::AzureConfigEncryption::key_id].
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::AzureConfigEncryption::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }
}

impl wkt::message::Message for AzureConfigEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureConfigEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureConfigEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_id,
            __public_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureConfigEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyId" => Ok(__FieldTag::__key_id),
                            "key_id" => Ok(__FieldTag::__key_id),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureConfigEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureConfigEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_id => {
                            if !fields.insert(__FieldTag::__key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_id",
                                ));
                            }
                            result.key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureConfigEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_id.is_empty() {
            state.serialize_entry("keyId", &self.key_id)?;
        }
        if !self.public_key.is_empty() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for Azure Disks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureDiskTemplate {
    /// Optional. The size of the disk, in GiBs.
    ///
    /// When unspecified, a default value is provided. See the specific reference
    /// in the parent resource.
    pub size_gib: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureDiskTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_gib][crate::model::AzureDiskTemplate::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }
}

impl wkt::message::Message for AzureDiskTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureDiskTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureDiskTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __size_gib,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureDiskTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sizeGib" => Ok(__FieldTag::__size_gib),
                            "size_gib" => Ok(__FieldTag::__size_gib),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureDiskTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureDiskTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__size_gib => {
                            if !fields.insert(__FieldTag::__size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureDiskTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.size_gib) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGib", &__With(&self.size_gib))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `AzureClient` resources hold client authentication information needed by the
/// Anthos Multi-Cloud API to manage Azure resources on your Azure subscription.
///
/// When an [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] is
/// created, an `AzureClient` resource needs to be provided and all operations on
/// Azure resources associated to that cluster will authenticate to Azure
/// services using the given client.
///
/// `AzureClient` resources are immutable and cannot be modified upon creation.
///
/// Each `AzureClient` resource is bound to a single Azure Active Directory
/// Application and tenant.
///
/// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureClient {
    /// The name of this resource.
    ///
    /// `AzureClient` resource names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    pub name: std::string::String,

    /// Required. The Azure Active Directory Tenant ID.
    pub tenant_id: std::string::String,

    /// Required. The Azure Active Directory Application ID.
    pub application_id: std::string::String,

    /// Output only. If set, there are currently pending changes to the client.
    pub reconciling: bool,

    /// Optional. Annotations on the resource.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Keys can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The PEM encoded x509 certificate.
    pub pem_certificate: std::string::String,

    /// Output only. A globally unique identifier for the client.
    pub uid: std::string::String,

    /// Output only. The time at which this resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this client was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureClient {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureClient::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tenant_id][crate::model::AzureClient::tenant_id].
    pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant_id = v.into();
        self
    }

    /// Sets the value of [application_id][crate::model::AzureClient::application_id].
    pub fn set_application_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.application_id = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AzureClient::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AzureClient::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [pem_certificate][crate::model::AzureClient::pem_certificate].
    pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem_certificate = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AzureClient::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AzureClient::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AzureClient::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AzureClient::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AzureClient::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AzureClient {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClient"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureClient {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tenant_id,
            __application_id,
            __reconciling,
            __annotations,
            __pem_certificate,
            __uid,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureClient")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tenantId" => Ok(__FieldTag::__tenant_id),
                            "tenant_id" => Ok(__FieldTag::__tenant_id),
                            "applicationId" => Ok(__FieldTag::__application_id),
                            "application_id" => Ok(__FieldTag::__application_id),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "pemCertificate" => Ok(__FieldTag::__pem_certificate),
                            "pem_certificate" => Ok(__FieldTag::__pem_certificate),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureClient;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureClient")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tenant_id => {
                            if !fields.insert(__FieldTag::__tenant_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant_id",
                                ));
                            }
                            result.tenant_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__application_id => {
                            if !fields.insert(__FieldTag::__application_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_id",
                                ));
                            }
                            result.application_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pem_certificate => {
                            if !fields.insert(__FieldTag::__pem_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificate",
                                ));
                            }
                            result.pem_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureClient {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.tenant_id.is_empty() {
            state.serialize_entry("tenantId", &self.tenant_id)?;
        }
        if !self.application_id.is_empty() {
            state.serialize_entry("applicationId", &self.application_id)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.pem_certificate.is_empty() {
            state.serialize_entry("pemCertificate", &self.pem_certificate)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration related to the cluster RBAC settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureAuthorization {
    /// Optional. Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
    /// to the users. Up to ten admin users can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    pub admin_users: std::vec::Vec<crate::model::AzureClusterUser>,

    /// Optional. Groups of users that can perform operations as a cluster admin. A
    /// managed ClusterRoleBinding will be created to grant the `cluster-admin`
    /// ClusterRole to the groups. Up to ten admin groups can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    pub admin_groups: std::vec::Vec<crate::model::AzureClusterGroup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::AzureAuthorization::admin_users].
    pub fn set_admin_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClusterUser>,
    {
        use std::iter::Iterator;
        self.admin_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin_groups][crate::model::AzureAuthorization::admin_groups].
    pub fn set_admin_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClusterGroup>,
    {
        use std::iter::Iterator;
        self.admin_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureAuthorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __admin_users,
            __admin_groups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adminUsers" => Ok(__FieldTag::__admin_users),
                            "admin_users" => Ok(__FieldTag::__admin_users),
                            "adminGroups" => Ok(__FieldTag::__admin_groups),
                            "admin_groups" => Ok(__FieldTag::__admin_groups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__admin_users => {
                            if !fields.insert(__FieldTag::__admin_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_users",
                                ));
                            }
                            result.admin_users =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AzureClusterUser>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admin_groups => {
                            if !fields.insert(__FieldTag::__admin_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_groups",
                                ));
                            }
                            result.admin_groups =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AzureClusterGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.admin_users.is_empty() {
            state.serialize_entry("adminUsers", &self.admin_users)?;
        }
        if !self.admin_groups.is_empty() {
            state.serialize_entry("adminGroups", &self.admin_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Authentication configuration for the management of Azure resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureServicesAuthentication {
    /// Required. The Azure Active Directory Tenant ID.
    pub tenant_id: std::string::String,

    /// Required. The Azure Active Directory Application ID.
    pub application_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureServicesAuthentication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenant_id][crate::model::AzureServicesAuthentication::tenant_id].
    pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant_id = v.into();
        self
    }

    /// Sets the value of [application_id][crate::model::AzureServicesAuthentication::application_id].
    pub fn set_application_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.application_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureServicesAuthentication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureServicesAuthentication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureServicesAuthentication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tenant_id,
            __application_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureServicesAuthentication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tenantId" => Ok(__FieldTag::__tenant_id),
                            "tenant_id" => Ok(__FieldTag::__tenant_id),
                            "applicationId" => Ok(__FieldTag::__application_id),
                            "application_id" => Ok(__FieldTag::__application_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureServicesAuthentication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureServicesAuthentication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tenant_id => {
                            if !fields.insert(__FieldTag::__tenant_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant_id",
                                ));
                            }
                            result.tenant_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__application_id => {
                            if !fields.insert(__FieldTag::__application_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_id",
                                ));
                            }
                            result.application_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureServicesAuthentication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tenant_id.is_empty() {
            state.serialize_entry("tenantId", &self.tenant_id)?;
        }
        if !self.application_id.is_empty() {
            state.serialize_entry("applicationId", &self.application_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identities of a user-type subject for Azure clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureClusterUser {
    /// Required. The name of the user, e.g. `my-gcp-id@gmail.com`.
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::AzureClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterUser"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureClusterUser {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureClusterUser")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureClusterUser;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureClusterUser")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureClusterUser {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identities of a group-type subject for Azure clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureClusterGroup {
    /// Required. The name of the group, e.g. `my-group@domain.com`.
    pub group: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureClusterGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AzureClusterGroup::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureClusterGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureClusterGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureClusterGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureClusterGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureClusterGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An Anthos node pool running on Azure.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureNodePool {
    /// The name of this resource.
    ///
    /// Node pool names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// For more details on Google Cloud resource names,
    /// see [Resource Names](https://cloud.google.com/apis/design/resource_names)
    pub name: std::string::String,

    /// Required. The Kubernetes version (e.g. `1.19.10-gke.1000`) running on this
    /// node pool.
    pub version: std::string::String,

    /// Required. The node configuration of the node pool.
    pub config: std::option::Option<crate::model::AzureNodeConfig>,

    /// Required. The ARM ID of the subnet where the node pool VMs run. Make sure
    /// it's a subnet under the virtual network in the cluster configuration.
    pub subnet_id: std::string::String,

    /// Required. Autoscaler configuration for this node pool.
    pub autoscaling: std::option::Option<crate::model::AzureNodePoolAutoscaling>,

    /// Output only. The current state of the node pool.
    pub state: crate::model::azure_node_pool::State,

    /// Output only. A globally unique identifier for the node pool.
    pub uid: std::string::String,

    /// Output only. If set, there are currently pending changes to the node
    /// pool.
    pub reconciling: bool,

    /// Output only. The time at which this node pool was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this node pool was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Annotations on the node pool.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Keys can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    pub max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Optional. The Azure availability zone of the nodes in this nodepool.
    ///
    /// When unspecified, it defaults to `1`.
    pub azure_availability_zone: std::string::String,

    /// Output only. A set of errors found in the node pool.
    pub errors: std::vec::Vec<crate::model::AzureNodePoolError>,

    /// Optional. The Management configuration for this node pool.
    pub management: std::option::Option<crate::model::AzureNodeManagement>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureNodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureNodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AzureNodePool::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [config][crate::model::AzureNodePool::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::AzureNodePool::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnet_id][crate::model::AzureNodePool::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::AzureNodePool::autoscaling].
    pub fn set_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodePoolAutoscaling>,
    {
        self.autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling][crate::model::AzureNodePool::autoscaling].
    pub fn set_or_clear_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodePoolAutoscaling>,
    {
        self.autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::AzureNodePool::state].
    pub fn set_state<T: std::convert::Into<crate::model::azure_node_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AzureNodePool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AzureNodePool::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AzureNodePool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AzureNodePool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AzureNodePool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AzureNodePool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AzureNodePool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AzureNodePool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [max_pods_constraint][crate::model::AzureNodePool::max_pods_constraint].
    pub fn set_max_pods_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_pods_constraint][crate::model::AzureNodePool::max_pods_constraint].
    pub fn set_or_clear_max_pods_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [azure_availability_zone][crate::model::AzureNodePool::azure_availability_zone].
    pub fn set_azure_availability_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_availability_zone = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::AzureNodePool::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureNodePoolError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [management][crate::model::AzureNodePool::management].
    pub fn set_management<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodeManagement>,
    {
        self.management = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management][crate::model::AzureNodePool::management].
    pub fn set_or_clear_management<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodeManagement>,
    {
        self.management = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AzureNodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureNodePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __config,
            __subnet_id,
            __autoscaling,
            __state,
            __uid,
            __reconciling,
            __create_time,
            __update_time,
            __etag,
            __annotations,
            __max_pods_constraint,
            __azure_availability_zone,
            __errors,
            __management,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureNodePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "config" => Ok(__FieldTag::__config),
                            "subnetId" => Ok(__FieldTag::__subnet_id),
                            "subnet_id" => Ok(__FieldTag::__subnet_id),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "state" => Ok(__FieldTag::__state),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "maxPodsConstraint" => Ok(__FieldTag::__max_pods_constraint),
                            "max_pods_constraint" => Ok(__FieldTag::__max_pods_constraint),
                            "azureAvailabilityZone" => Ok(__FieldTag::__azure_availability_zone),
                            "azure_availability_zone" => Ok(__FieldTag::__azure_availability_zone),
                            "errors" => Ok(__FieldTag::__errors),
                            "management" => Ok(__FieldTag::__management),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureNodePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureNodePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::AzureNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__subnet_id => {
                            if !fields.insert(__FieldTag::__subnet_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_id",
                                ));
                            }
                            result.subnet_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::AzureNodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::azure_node_pool::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_pods_constraint => {
                            if !fields.insert(__FieldTag::__max_pods_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_constraint",
                                ));
                            }
                            result.max_pods_constraint = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::__azure_availability_zone => {
                            if !fields.insert(__FieldTag::__azure_availability_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_availability_zone",
                                ));
                            }
                            result.azure_availability_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AzureNodePoolError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map.next_value::<std::option::Option<crate::model::AzureNodeManagement>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureNodePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.subnet_id.is_empty() {
            state.serialize_entry("subnetId", &self.subnet_id)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.max_pods_constraint.is_some() {
            state.serialize_entry("maxPodsConstraint", &self.max_pods_constraint)?;
        }
        if !self.azure_availability_zone.is_empty() {
            state.serialize_entry("azureAvailabilityZone", &self.azure_availability_zone)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AzureNodePool].
pub mod azure_node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the node pool.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the node pool is being created.
        Provisioning,
        /// The RUNNING state indicates the node pool has been created and is fully
        /// usable.
        Running,
        /// The RECONCILING state indicates that the node pool is being reconciled.
        Reconciling,
        /// The STOPPING state indicates the node pool is being deleted.
        Stopping,
        /// The ERROR state indicates the node pool is in a broken unrecoverable
        /// state.
        Error,
        /// The DEGRADED state indicates the node pool requires user action to
        /// restore full functionality.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkemulticloud.v1.AzureNodePool.State",
            ))
        }
    }
}

/// AzureNodeManagement defines the set of node management features turned on for
/// an Azure node pool.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureNodeManagement {
    /// Optional. Whether or not the nodes will be automatically repaired. When set
    /// to true, the nodes in this node pool will be monitored and if they fail
    /// health checks consistently over a period of time, an automatic repair
    /// action will be triggered to replace them with new nodes.
    pub auto_repair: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureNodeManagement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_repair][crate::model::AzureNodeManagement::auto_repair].
    pub fn set_auto_repair<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_repair = v.into();
        self
    }
}

impl wkt::message::Message for AzureNodeManagement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodeManagement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureNodeManagement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_repair,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureNodeManagement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoRepair" => Ok(__FieldTag::__auto_repair),
                            "auto_repair" => Ok(__FieldTag::__auto_repair),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureNodeManagement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureNodeManagement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_repair => {
                            if !fields.insert(__FieldTag::__auto_repair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_repair",
                                ));
                            }
                            result.auto_repair = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureNodeManagement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auto_repair) {
            state.serialize_entry("autoRepair", &self.auto_repair)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that describe the configuration of all node machines
/// on a given node pool.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureNodeConfig {
    /// Optional. The Azure VM size name. Example: `Standard_DS2_v2`.
    ///
    /// See [Supported VM
    /// sizes](/anthos/clusters/docs/azure/reference/supported-vms) for options.
    ///
    /// When unspecified, it defaults to `Standard_DS2_v2`.
    pub vm_size: std::string::String,

    /// Optional. Configuration related to the root volume provisioned for each
    /// node pool machine.
    ///
    /// When unspecified, it defaults to a 32-GiB Azure Disk.
    pub root_volume: std::option::Option<crate::model::AzureDiskTemplate>,

    /// Optional. A set of tags to apply to all underlying Azure resources for this
    /// node pool. This currently only includes Virtual Machine Scale Sets.
    ///
    /// Specify at most 50 pairs containing alphanumerics, spaces, and symbols
    /// (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to
    /// 255 Unicode characters.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The OS image type to use on node pool instances.
    /// Can be unspecified, or have a value of `ubuntu`.
    ///
    /// When unspecified, it defaults to `ubuntu`.
    pub image_type: std::string::String,

    /// Required. SSH configuration for how to access the node pool machines.
    pub ssh_config: std::option::Option<crate::model::AzureSshConfig>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    pub proxy_config: std::option::Option<crate::model::AzureProxyConfig>,

    /// Optional. Configuration related to vm config encryption.
    pub config_encryption: std::option::Option<crate::model::AzureConfigEncryption>,

    /// Optional. The initial taints assigned to nodes of this node pool.
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    /// Optional. The initial labels assigned to nodes of this node pool. An object
    /// containing a list of "key": value pairs. Example: { "name": "wrench",
    /// "mass": "1.3kg", "count": "3" }.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_size][crate::model::AzureNodeConfig::vm_size].
    pub fn set_vm_size<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_size = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AzureNodeConfig::root_volume].
    pub fn set_root_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureDiskTemplate>,
    {
        self.root_volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [root_volume][crate::model::AzureNodeConfig::root_volume].
    pub fn set_or_clear_root_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureDiskTemplate>,
    {
        self.root_volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::AzureNodeConfig::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [image_type][crate::model::AzureNodeConfig::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AzureNodeConfig::ssh_config].
    pub fn set_ssh_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureSshConfig>,
    {
        self.ssh_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssh_config][crate::model::AzureNodeConfig::ssh_config].
    pub fn set_or_clear_ssh_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureSshConfig>,
    {
        self.ssh_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [proxy_config][crate::model::AzureNodeConfig::proxy_config].
    pub fn set_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureProxyConfig>,
    {
        self.proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [proxy_config][crate::model::AzureNodeConfig::proxy_config].
    pub fn set_or_clear_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureProxyConfig>,
    {
        self.proxy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_encryption][crate::model::AzureNodeConfig::config_encryption].
    pub fn set_config_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureConfigEncryption>,
    {
        self.config_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_encryption][crate::model::AzureNodeConfig::config_encryption].
    pub fn set_or_clear_config_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureConfigEncryption>,
    {
        self.config_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [taints][crate::model::AzureNodeConfig::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AzureNodeConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AzureNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureNodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_size,
            __root_volume,
            __tags,
            __image_type,
            __ssh_config,
            __proxy_config,
            __config_encryption,
            __taints,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureNodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmSize" => Ok(__FieldTag::__vm_size),
                            "vm_size" => Ok(__FieldTag::__vm_size),
                            "rootVolume" => Ok(__FieldTag::__root_volume),
                            "root_volume" => Ok(__FieldTag::__root_volume),
                            "tags" => Ok(__FieldTag::__tags),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "sshConfig" => Ok(__FieldTag::__ssh_config),
                            "ssh_config" => Ok(__FieldTag::__ssh_config),
                            "proxyConfig" => Ok(__FieldTag::__proxy_config),
                            "proxy_config" => Ok(__FieldTag::__proxy_config),
                            "configEncryption" => Ok(__FieldTag::__config_encryption),
                            "config_encryption" => Ok(__FieldTag::__config_encryption),
                            "taints" => Ok(__FieldTag::__taints),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureNodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureNodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_size => {
                            if !fields.insert(__FieldTag::__vm_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_size",
                                ));
                            }
                            result.vm_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_volume => {
                            if !fields.insert(__FieldTag::__root_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_volume",
                                ));
                            }
                            result.root_volume = map
                                .next_value::<std::option::Option<crate::model::AzureDiskTemplate>>(
                                )?;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_config => {
                            if !fields.insert(__FieldTag::__ssh_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_config",
                                ));
                            }
                            result.ssh_config = map
                                .next_value::<std::option::Option<crate::model::AzureSshConfig>>(
                                )?;
                        }
                        __FieldTag::__proxy_config => {
                            if !fields.insert(__FieldTag::__proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_config",
                                ));
                            }
                            result.proxy_config = map
                                .next_value::<std::option::Option<crate::model::AzureProxyConfig>>(
                                )?;
                        }
                        __FieldTag::__config_encryption => {
                            if !fields.insert(__FieldTag::__config_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_encryption",
                                ));
                            }
                            result.config_encryption = map.next_value::<std::option::Option<crate::model::AzureConfigEncryption>>()?
                                ;
                        }
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodeTaint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureNodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_size.is_empty() {
            state.serialize_entry("vmSize", &self.vm_size)?;
        }
        if self.root_volume.is_some() {
            state.serialize_entry("rootVolume", &self.root_volume)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if self.ssh_config.is_some() {
            state.serialize_entry("sshConfig", &self.ssh_config)?;
        }
        if self.proxy_config.is_some() {
            state.serialize_entry("proxyConfig", &self.proxy_config)?;
        }
        if self.config_encryption.is_some() {
            state.serialize_entry("configEncryption", &self.config_encryption)?;
        }
        if !self.taints.is_empty() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration related to Kubernetes cluster autoscaler.
///
/// The Kubernetes cluster autoscaler will automatically adjust the
/// size of the node pool based on the cluster load.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureNodePoolAutoscaling {
    /// Required. Minimum number of nodes in the node pool. Must be greater than or
    /// equal to 1 and less than or equal to max_node_count.
    pub min_node_count: i32,

    /// Required. Maximum number of nodes in the node pool. Must be greater than or
    /// equal to min_node_count and less than or equal to 50.
    pub max_node_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureNodePoolAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_node_count][crate::model::AzureNodePoolAutoscaling::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::AzureNodePoolAutoscaling::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for AzureNodePoolAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodePoolAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureNodePoolAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_node_count,
            __max_node_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureNodePoolAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureNodePoolAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureNodePoolAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureNodePoolAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
        }
        if !wkt::internal::is_default(&self.max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AzureOpenIdConfig is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureOpenIdConfig {
    /// OIDC Issuer.
    pub issuer: std::string::String,

    /// JSON Web Key uri.
    pub jwks_uri: std::string::String,

    /// Supported response types.
    pub response_types_supported: std::vec::Vec<std::string::String>,

    /// Supported subject types.
    pub subject_types_supported: std::vec::Vec<std::string::String>,

    /// supported ID Token signing Algorithms.
    pub id_token_signing_alg_values_supported: std::vec::Vec<std::string::String>,

    /// Supported claims.
    pub claims_supported: std::vec::Vec<std::string::String>,

    /// Supported grant types.
    pub grant_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureOpenIdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer][crate::model::AzureOpenIdConfig::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [jwks_uri][crate::model::AzureOpenIdConfig::jwks_uri].
    pub fn set_jwks_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.jwks_uri = v.into();
        self
    }

    /// Sets the value of [response_types_supported][crate::model::AzureOpenIdConfig::response_types_supported].
    pub fn set_response_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.response_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subject_types_supported][crate::model::AzureOpenIdConfig::subject_types_supported].
    pub fn set_subject_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id_token_signing_alg_values_supported][crate::model::AzureOpenIdConfig::id_token_signing_alg_values_supported].
    pub fn set_id_token_signing_alg_values_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_token_signing_alg_values_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims_supported][crate::model::AzureOpenIdConfig::claims_supported].
    pub fn set_claims_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.claims_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grant_types][crate::model::AzureOpenIdConfig::grant_types].
    pub fn set_grant_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grant_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureOpenIdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureOpenIdConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureOpenIdConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issuer,
            __jwks_uri,
            __response_types_supported,
            __subject_types_supported,
            __id_token_signing_alg_values_supported,
            __claims_supported,
            __grant_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureOpenIdConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issuer" => Ok(__FieldTag::__issuer),
                            "jwksUri" => Ok(__FieldTag::__jwks_uri),
                            "jwks_uri" => Ok(__FieldTag::__jwks_uri),
                            "responseTypesSupported" => Ok(__FieldTag::__response_types_supported),
                            "response_types_supported" => {
                                Ok(__FieldTag::__response_types_supported)
                            }
                            "subjectTypesSupported" => Ok(__FieldTag::__subject_types_supported),
                            "subject_types_supported" => Ok(__FieldTag::__subject_types_supported),
                            "idTokenSigningAlgValuesSupported" => {
                                Ok(__FieldTag::__id_token_signing_alg_values_supported)
                            }
                            "id_token_signing_alg_values_supported" => {
                                Ok(__FieldTag::__id_token_signing_alg_values_supported)
                            }
                            "claimsSupported" => Ok(__FieldTag::__claims_supported),
                            "claims_supported" => Ok(__FieldTag::__claims_supported),
                            "grantTypes" => Ok(__FieldTag::__grant_types),
                            "grant_types" => Ok(__FieldTag::__grant_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureOpenIdConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureOpenIdConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issuer => {
                            if !fields.insert(__FieldTag::__issuer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer",
                                ));
                            }
                            result.issuer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jwks_uri => {
                            if !fields.insert(__FieldTag::__jwks_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwks_uri",
                                ));
                            }
                            result.jwks_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_types_supported => {
                            if !fields.insert(__FieldTag::__response_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_types_supported",
                                ));
                            }
                            result.response_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__subject_types_supported => {
                            if !fields.insert(__FieldTag::__subject_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_types_supported",
                                ));
                            }
                            result.subject_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__id_token_signing_alg_values_supported => {
                            if !fields.insert(__FieldTag::__id_token_signing_alg_values_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id_token_signing_alg_values_supported",
                                ));
                            }
                            result.id_token_signing_alg_values_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__claims_supported => {
                            if !fields.insert(__FieldTag::__claims_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for claims_supported",
                                ));
                            }
                            result.claims_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__grant_types => {
                            if !fields.insert(__FieldTag::__grant_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_types",
                                ));
                            }
                            result.grant_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureOpenIdConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issuer.is_empty() {
            state.serialize_entry("issuer", &self.issuer)?;
        }
        if !self.jwks_uri.is_empty() {
            state.serialize_entry("jwksUri", &self.jwks_uri)?;
        }
        if !self.response_types_supported.is_empty() {
            state.serialize_entry("responseTypesSupported", &self.response_types_supported)?;
        }
        if !self.subject_types_supported.is_empty() {
            state.serialize_entry("subjectTypesSupported", &self.subject_types_supported)?;
        }
        if !self.id_token_signing_alg_values_supported.is_empty() {
            state.serialize_entry(
                "idTokenSigningAlgValuesSupported",
                &self.id_token_signing_alg_values_supported,
            )?;
        }
        if !self.claims_supported.is_empty() {
            state.serialize_entry("claimsSupported", &self.claims_supported)?;
        }
        if !self.grant_types.is_empty() {
            state.serialize_entry("grantTypes", &self.grant_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AzureJsonWebKeys is a valid JSON Web Key Set as specififed in RFC 7517.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureJsonWebKeys {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    pub keys: std::vec::Vec<crate::model::Jwk>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureJsonWebKeys {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::AzureJsonWebKeys::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwk>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureJsonWebKeys {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureJsonWebKeys"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureJsonWebKeys {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureJsonWebKeys")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keys" => Ok(__FieldTag::__keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureJsonWebKeys;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureJsonWebKeys")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__keys => {
                            if !fields.insert(__FieldTag::__keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keys",
                                ));
                            }
                            result.keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Jwk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureJsonWebKeys {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.keys.is_empty() {
            state.serialize_entry("keys", &self.keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AzureServerConfig contains information about a Google Cloud location, such as
/// supported Azure regions and Kubernetes versions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureServerConfig {
    /// The `AzureServerConfig` resource name.
    ///
    /// `AzureServerConfig` names are formatted as
    /// `projects/<project-number>/locations/<region>/azureServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    pub name: std::string::String,

    /// List of all released Kubernetes versions, including ones which are end of
    /// life and can no longer be used.  Filter by the `enabled`
    /// property to limit to currently available versions.
    /// Valid versions supported for both create and update operations
    pub valid_versions: std::vec::Vec<crate::model::AzureK8sVersionInfo>,

    /// The list of supported Azure regions.
    pub supported_azure_regions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureServerConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [valid_versions][crate::model::AzureServerConfig::valid_versions].
    pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureK8sVersionInfo>,
    {
        use std::iter::Iterator;
        self.valid_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_azure_regions][crate::model::AzureServerConfig::supported_azure_regions].
    pub fn set_supported_azure_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_azure_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __valid_versions,
            __supported_azure_regions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validVersions" => Ok(__FieldTag::__valid_versions),
                            "valid_versions" => Ok(__FieldTag::__valid_versions),
                            "supportedAzureRegions" => Ok(__FieldTag::__supported_azure_regions),
                            "supported_azure_regions" => Ok(__FieldTag::__supported_azure_regions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_versions => {
                            if !fields.insert(__FieldTag::__valid_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_versions",
                                ));
                            }
                            result.valid_versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AzureK8sVersionInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_azure_regions => {
                            if !fields.insert(__FieldTag::__supported_azure_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_azure_regions",
                                ));
                            }
                            result.supported_azure_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.valid_versions.is_empty() {
            state.serialize_entry("validVersions", &self.valid_versions)?;
        }
        if !self.supported_azure_regions.is_empty() {
            state.serialize_entry("supportedAzureRegions", &self.supported_azure_regions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Kubernetes version information of GKE cluster on Azure.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureK8sVersionInfo {
    /// Kubernetes version name (for example, `1.19.10-gke.1000`)
    pub version: std::string::String,

    /// Optional. True if the version is available for cluster creation. If a
    /// version is enabled for creation, it can be used to create new clusters.
    /// Otherwise, cluster creation will fail. However, cluster upgrade operations
    /// may succeed, even if the version is not enabled.
    pub enabled: bool,

    /// Optional. True if this cluster version belongs to a minor version that has
    /// reached its end of life and is no longer in scope to receive security and
    /// bug fixes.
    pub end_of_life: bool,

    /// Optional. The estimated date (in Pacific Time) when this cluster version
    /// will reach its end of life. Or if this version is no longer supported (the
    /// `end_of_life` field is true), this is the actual date (in Pacific time)
    /// when the version reached its end of life.
    pub end_of_life_date: std::option::Option<gtype::model::Date>,

    /// Optional. The date (in Pacific Time) when the cluster version was released.
    pub release_date: std::option::Option<gtype::model::Date>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureK8sVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AzureK8sVersionInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::AzureK8sVersionInfo::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [end_of_life][crate::model::AzureK8sVersionInfo::end_of_life].
    pub fn set_end_of_life<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.end_of_life = v.into();
        self
    }

    /// Sets the value of [end_of_life_date][crate::model::AzureK8sVersionInfo::end_of_life_date].
    pub fn set_end_of_life_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_of_life_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_of_life_date][crate::model::AzureK8sVersionInfo::end_of_life_date].
    pub fn set_or_clear_end_of_life_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_of_life_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [release_date][crate::model::AzureK8sVersionInfo::release_date].
    pub fn set_release_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_date][crate::model::AzureK8sVersionInfo::release_date].
    pub fn set_or_clear_release_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.release_date = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AzureK8sVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureK8sVersionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureK8sVersionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __enabled,
            __end_of_life,
            __end_of_life_date,
            __release_date,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureK8sVersionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "endOfLife" => Ok(__FieldTag::__end_of_life),
                            "end_of_life" => Ok(__FieldTag::__end_of_life),
                            "endOfLifeDate" => Ok(__FieldTag::__end_of_life_date),
                            "end_of_life_date" => Ok(__FieldTag::__end_of_life_date),
                            "releaseDate" => Ok(__FieldTag::__release_date),
                            "release_date" => Ok(__FieldTag::__release_date),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureK8sVersionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureK8sVersionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_life => {
                            if !fields.insert(__FieldTag::__end_of_life) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_life",
                                ));
                            }
                            result.end_of_life = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_life_date => {
                            if !fields.insert(__FieldTag::__end_of_life_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_life_date",
                                ));
                            }
                            result.end_of_life_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__release_date => {
                            if !fields.insert(__FieldTag::__release_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_date",
                                ));
                            }
                            result.release_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureK8sVersionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.end_of_life) {
            state.serialize_entry("endOfLife", &self.end_of_life)?;
        }
        if self.end_of_life_date.is_some() {
            state.serialize_entry("endOfLifeDate", &self.end_of_life_date)?;
        }
        if self.release_date.is_some() {
            state.serialize_entry("releaseDate", &self.release_date)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SSH configuration for Azure resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureSshConfig {
    /// Required. The SSH public key data for VMs managed by Anthos. This accepts
    /// the authorized_keys file format used in OpenSSH according to the sshd(8)
    /// manual page.
    pub authorized_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureSshConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authorized_key][crate::model::AzureSshConfig::authorized_key].
    pub fn set_authorized_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authorized_key = v.into();
        self
    }
}

impl wkt::message::Message for AzureSshConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureSshConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureSshConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __authorized_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureSshConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authorizedKey" => Ok(__FieldTag::__authorized_key),
                            "authorized_key" => Ok(__FieldTag::__authorized_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureSshConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureSshConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__authorized_key => {
                            if !fields.insert(__FieldTag::__authorized_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_key",
                                ));
                            }
                            result.authorized_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureSshConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.authorized_key.is_empty() {
            state.serialize_entry("authorizedKey", &self.authorized_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Managed Azure resources for the cluster.
///
/// The values could change and be empty, depending on the state of the cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureClusterResources {
    /// Output only. The ARM ID of the cluster network security group.
    pub network_security_group_id: std::string::String,

    /// Output only. The ARM ID of the control plane application security group.
    pub control_plane_application_security_group_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureClusterResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_security_group_id][crate::model::AzureClusterResources::network_security_group_id].
    pub fn set_network_security_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_security_group_id = v.into();
        self
    }

    /// Sets the value of [control_plane_application_security_group_id][crate::model::AzureClusterResources::control_plane_application_security_group_id].
    pub fn set_control_plane_application_security_group_id<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_application_security_group_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterResources"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureClusterResources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_security_group_id,
            __control_plane_application_security_group_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureClusterResources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkSecurityGroupId" => Ok(__FieldTag::__network_security_group_id),
                            "network_security_group_id" => {
                                Ok(__FieldTag::__network_security_group_id)
                            }
                            "controlPlaneApplicationSecurityGroupId" => {
                                Ok(__FieldTag::__control_plane_application_security_group_id)
                            }
                            "control_plane_application_security_group_id" => {
                                Ok(__FieldTag::__control_plane_application_security_group_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureClusterResources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureClusterResources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_security_group_id => {
                            if !fields.insert(__FieldTag::__network_security_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_security_group_id",
                                ));
                            }
                            result.network_security_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane_application_security_group_id => {
                            if !fields
                                .insert(__FieldTag::__control_plane_application_security_group_id)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_application_security_group_id",
                                ));
                            }
                            result.control_plane_application_security_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureClusterResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_security_group_id.is_empty() {
            state.serialize_entry("networkSecurityGroupId", &self.network_security_group_id)?;
        }
        if !self.control_plane_application_security_group_id.is_empty() {
            state.serialize_entry(
                "controlPlaneApplicationSecurityGroupId",
                &self.control_plane_application_security_group_id,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AzureClusterError describes errors found on Azure clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureClusterError {
    /// Human-friendly description of the error.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureClusterError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AzureClusterError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureClusterError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureClusterError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureClusterError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureClusterError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureClusterError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AzureNodePoolError describes errors found on Azure node pools.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureNodePoolError {
    /// Human-friendly description of the error.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureNodePoolError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AzureNodePoolError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AzureNodePoolError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodePoolError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureNodePoolError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureNodePoolError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureNodePoolError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureNodePoolError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureNodePoolError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.CreateAzureCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAzureClusterRequest {
    /// Required. The parent location where this
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource will be
    /// created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub azure_cluster: std::option::Option<crate::model::AzureCluster>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub azure_cluster_id: std::string::String,

    /// If set, only validate the request, but do not actually create the cluster.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAzureClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [azure_cluster][crate::model::CreateAzureClusterRequest::azure_cluster].
    pub fn set_azure_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureCluster>,
    {
        self.azure_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_cluster][crate::model::CreateAzureClusterRequest::azure_cluster].
    pub fn set_or_clear_azure_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureCluster>,
    {
        self.azure_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [azure_cluster_id][crate::model::CreateAzureClusterRequest::azure_cluster_id].
    pub fn set_azure_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_cluster_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAzureClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAzureClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAzureClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __azure_cluster,
            __azure_cluster_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAzureClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "azureCluster" => Ok(__FieldTag::__azure_cluster),
                            "azure_cluster" => Ok(__FieldTag::__azure_cluster),
                            "azureClusterId" => Ok(__FieldTag::__azure_cluster_id),
                            "azure_cluster_id" => Ok(__FieldTag::__azure_cluster_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAzureClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAzureClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_cluster => {
                            if !fields.insert(__FieldTag::__azure_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster",
                                ));
                            }
                            result.azure_cluster = map
                                .next_value::<std::option::Option<crate::model::AzureCluster>>()?;
                        }
                        __FieldTag::__azure_cluster_id => {
                            if !fields.insert(__FieldTag::__azure_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster_id",
                                ));
                            }
                            result.azure_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAzureClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.azure_cluster.is_some() {
            state.serialize_entry("azureCluster", &self.azure_cluster)?;
        }
        if !self.azure_cluster_id.is_empty() {
            state.serialize_entry("azureClusterId", &self.azure_cluster_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.UpdateAzureCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAzureClusterRequest {
    /// Required. The [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub azure_cluster: std::option::Option<crate::model::AzureCluster>,

    /// If set, only validate the request, but do not actually update the cluster.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]:
    ///
    /// * `description`.
    /// * `azureClient`.
    /// * `control_plane.version`.
    /// * `control_plane.vm_size`.
    /// * `annotations`.
    /// * `authorization.admin_users`.
    /// * `authorization.admin_groups`.
    /// * `control_plane.root_volume.size_gib`.
    /// * `azure_services_authentication`.
    /// * `azure_services_authentication.tenant_id`.
    /// * `azure_services_authentication.application_id`.
    /// * `control_plane.proxy_config`.
    /// * `control_plane.proxy_config.resource_group_id`.
    /// * `control_plane.proxy_config.secret_id`.
    /// * `control_plane.ssh_config.authorized_key`.
    /// * `logging_config.component_config.enable_components`
    /// * `monitoring_config.managed_prometheus_config.enabled`.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::UpdateAzureClusterRequest::azure_cluster].
    pub fn set_azure_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureCluster>,
    {
        self.azure_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_cluster][crate::model::UpdateAzureClusterRequest::azure_cluster].
    pub fn set_or_clear_azure_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureCluster>,
    {
        self.azure_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAzureClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAzureClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAzureClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAzureClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAzureClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_cluster,
            __validate_only,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAzureClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureCluster" => Ok(__FieldTag::__azure_cluster),
                            "azure_cluster" => Ok(__FieldTag::__azure_cluster),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAzureClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAzureClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_cluster => {
                            if !fields.insert(__FieldTag::__azure_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster",
                                ));
                            }
                            result.azure_cluster = map
                                .next_value::<std::option::Option<crate::model::AzureCluster>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAzureClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.azure_cluster.is_some() {
            state.serialize_entry("azureCluster", &self.azure_cluster)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.GetAzureCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAzureClusterRequest {
    /// Required. The name of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource to
    /// describe.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAzureClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAzureClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAzureClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAzureClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAzureClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.ListAzureClusters` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAzureClustersRequest {
    /// Required. The parent location which owns this collection of
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAzureClustersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAzureClustersResponse.next_page_token]: crate::model::ListAzureClustersResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [azureClusters.list][google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClusters]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClusters]: crate::client::AzureClusters::list_azure_clusters
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAzureClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAzureClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAzureClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAzureClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAzureClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAzureClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAzureClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAzureClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAzureClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AzureClusters.ListAzureClusters` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAzureClustersResponse {
    /// A list of [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]
    /// resources in the specified Google Cloud Platform project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub azure_clusters: std::vec::Vec<crate::model::AzureCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAzureClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_clusters][crate::model::ListAzureClustersResponse::azure_clusters].
    pub fn set_azure_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureCluster>,
    {
        use std::iter::Iterator;
        self.azure_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAzureClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAzureClustersResponse {
    type PageItem = crate::model::AzureCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.azure_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAzureClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_clusters,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAzureClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureClusters" => Ok(__FieldTag::__azure_clusters),
                            "azure_clusters" => Ok(__FieldTag::__azure_clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAzureClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAzureClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_clusters => {
                            if !fields.insert(__FieldTag::__azure_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_clusters",
                                ));
                            }
                            result.azure_clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AzureCluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAzureClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_clusters.is_empty() {
            state.serialize_entry("azureClusters", &self.azure_clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.DeleteAzureCluster` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAzureClusterRequest {
    /// Required. The resource name the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] to delete.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub name: std::string::String,

    /// If set to true, and the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    /// The current etag of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided etag does not match the current etag of the cluster,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub etag: std::string::String,

    /// Optional. If set to true, the deletion of
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource will
    /// succeed even if errors occur during deleting in cluster resources. Using
    /// this parameter may result in orphaned resources in the cluster.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub ignore_errors: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAzureClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAzureClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAzureClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAzureClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAzureClusterRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAzureClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAzureClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __allow_missing,
            __validate_only,
            __etag,
            __ignore_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAzureClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            "ignoreErrors" => Ok(__FieldTag::__ignore_errors),
                            "ignore_errors" => Ok(__FieldTag::__ignore_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAzureClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAzureClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_errors => {
                            if !fields.insert(__FieldTag::__ignore_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_errors",
                                ));
                            }
                            result.ignore_errors = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAzureClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.ignore_errors) {
            state.serialize_entry("ignoreErrors", &self.ignore_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AzureClusters.CreateAzureNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAzureNodePoolRequest {
    /// Required. The [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]
    /// resource where this node pool will be created.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub azure_node_pool: std::option::Option<crate::model::AzureNodePool>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub azure_node_pool_id: std::string::String,

    /// If set, only validate the request, but do not actually create the node
    /// pool.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAzureNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [azure_node_pool][crate::model::CreateAzureNodePoolRequest::azure_node_pool].
    pub fn set_azure_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodePool>,
    {
        self.azure_node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_node_pool][crate::model::CreateAzureNodePoolRequest::azure_node_pool].
    pub fn set_or_clear_azure_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodePool>,
    {
        self.azure_node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [azure_node_pool_id][crate::model::CreateAzureNodePoolRequest::azure_node_pool_id].
    pub fn set_azure_node_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_node_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAzureNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAzureNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAzureNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __azure_node_pool,
            __azure_node_pool_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAzureNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "azureNodePool" => Ok(__FieldTag::__azure_node_pool),
                            "azure_node_pool" => Ok(__FieldTag::__azure_node_pool),
                            "azureNodePoolId" => Ok(__FieldTag::__azure_node_pool_id),
                            "azure_node_pool_id" => Ok(__FieldTag::__azure_node_pool_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAzureNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAzureNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_node_pool => {
                            if !fields.insert(__FieldTag::__azure_node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_node_pool",
                                ));
                            }
                            result.azure_node_pool = map
                                .next_value::<std::option::Option<crate::model::AzureNodePool>>()?;
                        }
                        __FieldTag::__azure_node_pool_id => {
                            if !fields.insert(__FieldTag::__azure_node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_node_pool_id",
                                ));
                            }
                            result.azure_node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAzureNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.azure_node_pool.is_some() {
            state.serialize_entry("azureNodePool", &self.azure_node_pool)?;
        }
        if !self.azure_node_pool_id.is_empty() {
            state.serialize_entry("azureNodePoolId", &self.azure_node_pool_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.UpdateAzureNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAzureNodePoolRequest {
    /// Required. The [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub azure_node_pool: std::option::Option<crate::model::AzureNodePool>,

    /// If set, only validate the request, but don't actually update the node pool.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool]:
    ///
    /// *.  `annotations`.
    ///
    /// * `version`.
    /// * `autoscaling.min_node_count`.
    /// * `autoscaling.max_node_count`.
    /// * `config.ssh_config.authorized_key`.
    /// * `management.auto_repair`.
    /// * `management`.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_node_pool][crate::model::UpdateAzureNodePoolRequest::azure_node_pool].
    pub fn set_azure_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodePool>,
    {
        self.azure_node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_node_pool][crate::model::UpdateAzureNodePoolRequest::azure_node_pool].
    pub fn set_or_clear_azure_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureNodePool>,
    {
        self.azure_node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAzureNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAzureNodePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAzureNodePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAzureNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAzureNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_node_pool,
            __validate_only,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAzureNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureNodePool" => Ok(__FieldTag::__azure_node_pool),
                            "azure_node_pool" => Ok(__FieldTag::__azure_node_pool),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAzureNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAzureNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_node_pool => {
                            if !fields.insert(__FieldTag::__azure_node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_node_pool",
                                ));
                            }
                            result.azure_node_pool = map
                                .next_value::<std::option::Option<crate::model::AzureNodePool>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAzureNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.azure_node_pool.is_some() {
            state.serialize_entry("azureNodePool", &self.azure_node_pool)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.GetAzureNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAzureNodePoolRequest {
    /// Required. The name of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource to
    /// describe.
    ///
    /// `AzureNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAzureNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAzureNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAzureNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAzureNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAzureNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.ListAzureNodePools` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAzureNodePoolsRequest {
    /// Required. The parent `AzureCluster` which owns this collection of
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resources.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAzureNodePoolsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAzureNodePoolsResponse.next_page_token]: crate::model::ListAzureNodePoolsResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [azureNodePools.list][google.cloud.gkemulticloud.v1.AzureClusters.ListAzureNodePools]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.ListAzureNodePools]: crate::client::AzureClusters::list_azure_node_pools
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAzureNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAzureNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAzureNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAzureNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureNodePoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAzureNodePoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAzureNodePoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAzureNodePoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAzureNodePoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAzureNodePoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AzureClusters.ListAzureNodePools` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAzureNodePoolsResponse {
    /// A list of [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool]
    /// resources in the specified `AzureCluster`.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub azure_node_pools: std::vec::Vec<crate::model::AzureNodePool>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAzureNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_node_pools][crate::model::ListAzureNodePoolsResponse::azure_node_pools].
    pub fn set_azure_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureNodePool>,
    {
        use std::iter::Iterator;
        self.azure_node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAzureNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureNodePoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAzureNodePoolsResponse {
    type PageItem = crate::model::AzureNodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.azure_node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAzureNodePoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_node_pools,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAzureNodePoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureNodePools" => Ok(__FieldTag::__azure_node_pools),
                            "azure_node_pools" => Ok(__FieldTag::__azure_node_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAzureNodePoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAzureNodePoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_node_pools => {
                            if !fields.insert(__FieldTag::__azure_node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_node_pools",
                                ));
                            }
                            result.azure_node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AzureNodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAzureNodePoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_node_pools.is_empty() {
            state.serialize_entry("azureNodePools", &self.azure_node_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.DeleteAzureNodePool` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAzureNodePoolRequest {
    /// Required. The resource name the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] to delete.
    ///
    /// `AzureNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the node
    /// pool.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource is
    /// not found, the request will succeed but no action will be taken on the
    /// server and a completed [Operation][google.longrunning.Operation] will be
    /// returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// The current ETag of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided ETag does not match the current etag of the node pool,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub etag: std::string::String,

    /// Optional. If set to true, the deletion of
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource will
    /// succeed even if errors occur during deleting in node pool resources. Using
    /// this parameter may result in orphaned resources in the node pool.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub ignore_errors: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAzureNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAzureNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAzureNodePoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAzureNodePoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAzureNodePoolRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAzureNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAzureNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __etag,
            __ignore_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAzureNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "etag" => Ok(__FieldTag::__etag),
                            "ignoreErrors" => Ok(__FieldTag::__ignore_errors),
                            "ignore_errors" => Ok(__FieldTag::__ignore_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAzureNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAzureNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_errors => {
                            if !fields.insert(__FieldTag::__ignore_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_errors",
                                ));
                            }
                            result.ignore_errors = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAzureNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.ignore_errors) {
            state.serialize_entry("ignoreErrors", &self.ignore_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAzureOpenIdConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAzureOpenIdConfigRequest {
    /// Required. The AzureCluster, which owns the OIDC discovery document.
    /// Format:
    /// projects/\<project-id\>/locations/\<region\>/azureClusters/\<cluster-id\>
    pub azure_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAzureOpenIdConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GetAzureOpenIdConfigRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureOpenIdConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureOpenIdConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAzureOpenIdConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAzureOpenIdConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureCluster" => Ok(__FieldTag::__azure_cluster),
                            "azure_cluster" => Ok(__FieldTag::__azure_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAzureOpenIdConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAzureOpenIdConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_cluster => {
                            if !fields.insert(__FieldTag::__azure_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster",
                                ));
                            }
                            result.azure_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAzureOpenIdConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_cluster.is_empty() {
            state.serialize_entry("azureCluster", &self.azure_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAzureJsonWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAzureJsonWebKeysRequest {
    /// Required. The AzureCluster, which owns the JsonWebKeys.
    /// Format:
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`
    pub azure_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAzureJsonWebKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GetAzureJsonWebKeysRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureJsonWebKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureJsonWebKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAzureJsonWebKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAzureJsonWebKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureCluster" => Ok(__FieldTag::__azure_cluster),
                            "azure_cluster" => Ok(__FieldTag::__azure_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAzureJsonWebKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAzureJsonWebKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_cluster => {
                            if !fields.insert(__FieldTag::__azure_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster",
                                ));
                            }
                            result.azure_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAzureJsonWebKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_cluster.is_empty() {
            state.serialize_entry("azureCluster", &self.azure_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GetAzureServerConfigRequest gets the server config of GKE cluster on Azure.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAzureServerConfigRequest {
    /// Required. The name of the
    /// [AzureServerConfig][google.cloud.gkemulticloud.v1.AzureServerConfig]
    /// resource to describe.
    ///
    /// `AzureServerConfig` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureServerConfig]: crate::model::AzureServerConfig
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAzureServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureServerConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAzureServerConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAzureServerConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAzureServerConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAzureServerConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAzureServerConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.CreateAzureClient` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAzureClientRequest {
    /// Required. The parent location where this
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource will be
    /// created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub azure_client: std::option::Option<crate::model::AzureClient>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClients/<client-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub azure_client_id: std::string::String,

    /// If set, only validate the request, but do not actually create the client.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAzureClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAzureClientRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [azure_client][crate::model::CreateAzureClientRequest::azure_client].
    pub fn set_azure_client<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AzureClient>,
    {
        self.azure_client = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [azure_client][crate::model::CreateAzureClientRequest::azure_client].
    pub fn set_or_clear_azure_client<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AzureClient>,
    {
        self.azure_client = v.map(|x| x.into());
        self
    }

    /// Sets the value of [azure_client_id][crate::model::CreateAzureClientRequest::azure_client_id].
    pub fn set_azure_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_client_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAzureClientRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAzureClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAzureClientRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAzureClientRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __azure_client,
            __azure_client_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAzureClientRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "azureClient" => Ok(__FieldTag::__azure_client),
                            "azure_client" => Ok(__FieldTag::__azure_client),
                            "azureClientId" => Ok(__FieldTag::__azure_client_id),
                            "azure_client_id" => Ok(__FieldTag::__azure_client_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAzureClientRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAzureClientRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_client => {
                            if !fields.insert(__FieldTag::__azure_client) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_client",
                                ));
                            }
                            result.azure_client =
                                map.next_value::<std::option::Option<crate::model::AzureClient>>()?;
                        }
                        __FieldTag::__azure_client_id => {
                            if !fields.insert(__FieldTag::__azure_client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_client_id",
                                ));
                            }
                            result.azure_client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAzureClientRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.azure_client.is_some() {
            state.serialize_entry("azureClient", &self.azure_client)?;
        }
        if !self.azure_client_id.is_empty() {
            state.serialize_entry("azureClientId", &self.azure_client_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.GetAzureClient` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAzureClientRequest {
    /// Required. The name of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource to
    /// describe.
    ///
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] names are
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAzureClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureClientRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureClientRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAzureClientRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAzureClientRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAzureClientRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAzureClientRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAzureClientRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.ListAzureClients` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAzureClientsRequest {
    /// Required. The parent location which owns this collection of
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAzureClientsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAzureClientsResponse.next_page_token]: crate::model::ListAzureClientsResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [azureClients.list][google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClients]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClients]: crate::client::AzureClusters::list_azure_clients
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAzureClientsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAzureClientsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAzureClientsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAzureClientsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureClientsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClientsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAzureClientsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAzureClientsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAzureClientsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAzureClientsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAzureClientsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AzureClusters.ListAzureClients` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAzureClientsResponse {
    /// A list of [AzureClient][google.cloud.gkemulticloud.v1.AzureClient]
    /// resources in the specified Google Cloud project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub azure_clients: std::vec::Vec<crate::model::AzureClient>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAzureClientsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_clients][crate::model::ListAzureClientsResponse::azure_clients].
    pub fn set_azure_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClient>,
    {
        use std::iter::Iterator;
        self.azure_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAzureClientsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureClientsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClientsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAzureClientsResponse {
    type PageItem = crate::model::AzureClient;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.azure_clients
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAzureClientsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_clients,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAzureClientsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureClients" => Ok(__FieldTag::__azure_clients),
                            "azure_clients" => Ok(__FieldTag::__azure_clients),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAzureClientsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAzureClientsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_clients => {
                            if !fields.insert(__FieldTag::__azure_clients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_clients",
                                ));
                            }
                            result.azure_clients = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AzureClient>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAzureClientsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_clients.is_empty() {
            state.serialize_entry("azureClients", &self.azure_clients)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.DeleteAzureClient` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAzureClientRequest {
    /// Required. The resource name the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] to delete.
    ///
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] names are
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    pub name: std::string::String,

    /// If set to true, and the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAzureClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAzureClientRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAzureClientRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAzureClientRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAzureClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAzureClientRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAzureClientRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAzureClientRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAzureClientRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAzureClientRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAzureClientRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `AzureClusters.GenerateAzureAccessToken` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAzureAccessTokenRequest {
    /// Required. The name of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource to
    /// authenticate to.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub azure_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAzureAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GenerateAzureAccessTokenRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureAccessTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAzureAccessTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAzureAccessTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureCluster" => Ok(__FieldTag::__azure_cluster),
                            "azure_cluster" => Ok(__FieldTag::__azure_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAzureAccessTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAzureAccessTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_cluster => {
                            if !fields.insert(__FieldTag::__azure_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster",
                                ));
                            }
                            result.azure_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAzureAccessTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_cluster.is_empty() {
            state.serialize_entry("azureCluster", &self.azure_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `AzureClusters.GenerateAzureAccessToken` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAzureAccessTokenResponse {
    /// Output only. Access token to authenticate to k8s api-server.
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAzureAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAzureAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::GenerateAzureAccessTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::GenerateAzureAccessTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateAzureAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureAccessTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAzureAccessTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAzureAccessTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAzureAccessTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAzureAccessTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAzureAccessTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAzureClusterAgentTokenRequest {
    /// Required.
    pub azure_cluster: std::string::String,

    /// Required.
    pub subject_token: std::string::String,

    /// Required.
    pub subject_token_type: std::string::String,

    /// Required.
    pub version: std::string::String,

    /// Optional.
    pub node_pool_id: std::string::String,

    /// Optional.
    pub grant_type: std::string::String,

    /// Optional.
    pub audience: std::string::String,

    /// Optional.
    pub scope: std::string::String,

    /// Optional.
    pub requested_token_type: std::string::String,

    /// Optional.
    pub options: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAzureClusterAgentTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GenerateAzureClusterAgentTokenRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }

    /// Sets the value of [subject_token][crate::model::GenerateAzureClusterAgentTokenRequest::subject_token].
    pub fn set_subject_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_token = v.into();
        self
    }

    /// Sets the value of [subject_token_type][crate::model::GenerateAzureClusterAgentTokenRequest::subject_token_type].
    pub fn set_subject_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_token_type = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenerateAzureClusterAgentTokenRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::GenerateAzureClusterAgentTokenRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [grant_type][crate::model::GenerateAzureClusterAgentTokenRequest::grant_type].
    pub fn set_grant_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grant_type = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::GenerateAzureClusterAgentTokenRequest::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::GenerateAzureClusterAgentTokenRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [requested_token_type][crate::model::GenerateAzureClusterAgentTokenRequest::requested_token_type].
    pub fn set_requested_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_token_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::GenerateAzureClusterAgentTokenRequest::options].
    pub fn set_options<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.options = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureClusterAgentTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureClusterAgentTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAzureClusterAgentTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __azure_cluster,
            __subject_token,
            __subject_token_type,
            __version,
            __node_pool_id,
            __grant_type,
            __audience,
            __scope,
            __requested_token_type,
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAzureClusterAgentTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "azureCluster" => Ok(__FieldTag::__azure_cluster),
                            "azure_cluster" => Ok(__FieldTag::__azure_cluster),
                            "subjectToken" => Ok(__FieldTag::__subject_token),
                            "subject_token" => Ok(__FieldTag::__subject_token),
                            "subjectTokenType" => Ok(__FieldTag::__subject_token_type),
                            "subject_token_type" => Ok(__FieldTag::__subject_token_type),
                            "version" => Ok(__FieldTag::__version),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "grantType" => Ok(__FieldTag::__grant_type),
                            "grant_type" => Ok(__FieldTag::__grant_type),
                            "audience" => Ok(__FieldTag::__audience),
                            "scope" => Ok(__FieldTag::__scope),
                            "requestedTokenType" => Ok(__FieldTag::__requested_token_type),
                            "requested_token_type" => Ok(__FieldTag::__requested_token_type),
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAzureClusterAgentTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAzureClusterAgentTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__azure_cluster => {
                            if !fields.insert(__FieldTag::__azure_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_cluster",
                                ));
                            }
                            result.azure_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_token => {
                            if !fields.insert(__FieldTag::__subject_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_token",
                                ));
                            }
                            result.subject_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_token_type => {
                            if !fields.insert(__FieldTag::__subject_token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_token_type",
                                ));
                            }
                            result.subject_token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grant_type => {
                            if !fields.insert(__FieldTag::__grant_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_type",
                                ));
                            }
                            result.grant_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audience",
                                ));
                            }
                            result.audience = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_token_type => {
                            if !fields.insert(__FieldTag::__requested_token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_token_type",
                                ));
                            }
                            result.requested_token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAzureClusterAgentTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.azure_cluster.is_empty() {
            state.serialize_entry("azureCluster", &self.azure_cluster)?;
        }
        if !self.subject_token.is_empty() {
            state.serialize_entry("subjectToken", &self.subject_token)?;
        }
        if !self.subject_token_type.is_empty() {
            state.serialize_entry("subjectTokenType", &self.subject_token_type)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.grant_type.is_empty() {
            state.serialize_entry("grantType", &self.grant_type)?;
        }
        if !self.audience.is_empty() {
            state.serialize_entry("audience", &self.audience)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.requested_token_type.is_empty() {
            state.serialize_entry("requestedTokenType", &self.requested_token_type)?;
        }
        if !self.options.is_empty() {
            state.serialize_entry("options", &self.options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAzureClusterAgentTokenResponse {
    pub access_token: std::string::String,

    pub expires_in: i32,

    pub token_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAzureClusterAgentTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAzureClusterAgentTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expires_in][crate::model::GenerateAzureClusterAgentTokenResponse::expires_in].
    pub fn set_expires_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expires_in = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::GenerateAzureClusterAgentTokenResponse::token_type].
    pub fn set_token_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureClusterAgentTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureClusterAgentTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAzureClusterAgentTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expires_in,
            __token_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GenerateAzureClusterAgentTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expiresIn" => Ok(__FieldTag::__expires_in),
                            "expires_in" => Ok(__FieldTag::__expires_in),
                            "tokenType" => Ok(__FieldTag::__token_type),
                            "token_type" => Ok(__FieldTag::__token_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAzureClusterAgentTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAzureClusterAgentTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expires_in => {
                            if !fields.insert(__FieldTag::__expires_in) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expires_in",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expires_in = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__token_type => {
                            if !fields.insert(__FieldTag::__token_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_type",
                                ));
                            }
                            result.token_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAzureClusterAgentTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if !wkt::internal::is_default(&self.expires_in) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expiresIn", &__With(&self.expires_in))?;
        }
        if !self.token_type.is_empty() {
            state.serialize_entry("tokenType", &self.token_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Jwk is a JSON Web Key as specified in RFC 7517.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Jwk {
    /// Key Type.
    pub kty: std::string::String,

    /// Algorithm.
    pub alg: std::string::String,

    /// Permitted uses for the public keys.
    pub r#use: std::string::String,

    /// Key ID.
    pub kid: std::string::String,

    /// Used for RSA keys.
    pub n: std::string::String,

    /// Used for RSA keys.
    pub e: std::string::String,

    /// Used for ECDSA keys.
    pub x: std::string::String,

    /// Used for ECDSA keys.
    pub y: std::string::String,

    /// Used for ECDSA keys.
    pub crv: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Jwk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kty][crate::model::Jwk::kty].
    pub fn set_kty<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kty = v.into();
        self
    }

    /// Sets the value of [alg][crate::model::Jwk::alg].
    pub fn set_alg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alg = v.into();
        self
    }

    /// Sets the value of [r#use][crate::model::Jwk::use].
    pub fn set_use<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#use = v.into();
        self
    }

    /// Sets the value of [kid][crate::model::Jwk::kid].
    pub fn set_kid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kid = v.into();
        self
    }

    /// Sets the value of [n][crate::model::Jwk::n].
    pub fn set_n<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n = v.into();
        self
    }

    /// Sets the value of [e][crate::model::Jwk::e].
    pub fn set_e<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.e = v.into();
        self
    }

    /// Sets the value of [x][crate::model::Jwk::x].
    pub fn set_x<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Jwk::y].
    pub fn set_y<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [crv][crate::model::Jwk::crv].
    pub fn set_crv<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crv = v.into();
        self
    }
}

impl wkt::message::Message for Jwk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.Jwk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Jwk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kty,
            __alg,
            __use,
            __kid,
            __n,
            __e,
            __x,
            __y,
            __crv,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Jwk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kty" => Ok(__FieldTag::__kty),
                            "alg" => Ok(__FieldTag::__alg),
                            "use" => Ok(__FieldTag::__use),
                            "kid" => Ok(__FieldTag::__kid),
                            "n" => Ok(__FieldTag::__n),
                            "e" => Ok(__FieldTag::__e),
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            "crv" => Ok(__FieldTag::__crv),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Jwk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Jwk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kty => {
                            if !fields.insert(__FieldTag::__kty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kty",
                                ));
                            }
                            result.kty = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__alg => {
                            if !fields.insert(__FieldTag::__alg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alg",
                                ));
                            }
                            result.alg = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use => {
                            if !fields.insert(__FieldTag::__use) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use",
                                ));
                            }
                            result.r#use = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kid => {
                            if !fields.insert(__FieldTag::__kid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kid",
                                ));
                            }
                            result.kid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__n => {
                            if !fields.insert(__FieldTag::__n) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for n",
                                ));
                            }
                            result.n = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__e => {
                            if !fields.insert(__FieldTag::__e) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for e",
                                ));
                            }
                            result.e = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            result.x = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            result.y = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crv => {
                            if !fields.insert(__FieldTag::__crv) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crv",
                                ));
                            }
                            result.crv = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Jwk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kty.is_empty() {
            state.serialize_entry("kty", &self.kty)?;
        }
        if !self.alg.is_empty() {
            state.serialize_entry("alg", &self.alg)?;
        }
        if !self.r#use.is_empty() {
            state.serialize_entry("use", &self.r#use)?;
        }
        if !self.kid.is_empty() {
            state.serialize_entry("kid", &self.kid)?;
        }
        if !self.n.is_empty() {
            state.serialize_entry("n", &self.n)?;
        }
        if !self.e.is_empty() {
            state.serialize_entry("e", &self.e)?;
        }
        if !self.x.is_empty() {
            state.serialize_entry("x", &self.x)?;
        }
        if !self.y.is_empty() {
            state.serialize_entry("y", &self.y)?;
        }
        if !self.crv.is_empty() {
            state.serialize_entry("crv", &self.crv)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Workload Identity settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadIdentityConfig {
    /// The OIDC issuer URL for this cluster.
    pub issuer_uri: std::string::String,

    /// The Workload Identity Pool associated to the cluster.
    pub workload_pool: std::string::String,

    /// The ID of the OIDC Identity Provider (IdP) associated to the Workload
    /// Identity Pool.
    pub identity_provider: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadIdentityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer_uri][crate::model::WorkloadIdentityConfig::issuer_uri].
    pub fn set_issuer_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer_uri = v.into();
        self
    }

    /// Sets the value of [workload_pool][crate::model::WorkloadIdentityConfig::workload_pool].
    pub fn set_workload_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_pool = v.into();
        self
    }

    /// Sets the value of [identity_provider][crate::model::WorkloadIdentityConfig::identity_provider].
    pub fn set_identity_provider<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.identity_provider = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadIdentityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.WorkloadIdentityConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadIdentityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issuer_uri,
            __workload_pool,
            __identity_provider,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadIdentityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issuerUri" => Ok(__FieldTag::__issuer_uri),
                            "issuer_uri" => Ok(__FieldTag::__issuer_uri),
                            "workloadPool" => Ok(__FieldTag::__workload_pool),
                            "workload_pool" => Ok(__FieldTag::__workload_pool),
                            "identityProvider" => Ok(__FieldTag::__identity_provider),
                            "identity_provider" => Ok(__FieldTag::__identity_provider),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadIdentityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadIdentityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issuer_uri => {
                            if !fields.insert(__FieldTag::__issuer_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer_uri",
                                ));
                            }
                            result.issuer_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_pool => {
                            if !fields.insert(__FieldTag::__workload_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_pool",
                                ));
                            }
                            result.workload_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__identity_provider => {
                            if !fields.insert(__FieldTag::__identity_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_provider",
                                ));
                            }
                            result.identity_provider = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadIdentityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issuer_uri.is_empty() {
            state.serialize_entry("issuerUri", &self.issuer_uri)?;
        }
        if !self.workload_pool.is_empty() {
            state.serialize_entry("workloadPool", &self.workload_pool)?;
        }
        if !self.identity_provider.is_empty() {
            state.serialize_entry("identityProvider", &self.identity_provider)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Constraints applied to pods.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaxPodsConstraint {
    /// Required. The maximum number of pods to schedule on a single node.
    pub max_pods_per_node: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaxPodsConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_pods_per_node][crate::model::MaxPodsConstraint::max_pods_per_node].
    pub fn set_max_pods_per_node<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_pods_per_node = v.into();
        self
    }
}

impl wkt::message::Message for MaxPodsConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.MaxPodsConstraint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaxPodsConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_pods_per_node,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaxPodsConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxPodsPerNode" => Ok(__FieldTag::__max_pods_per_node),
                            "max_pods_per_node" => Ok(__FieldTag::__max_pods_per_node),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaxPodsConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaxPodsConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_pods_per_node => {
                            if !fields.insert(__FieldTag::__max_pods_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_pods_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaxPodsConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_pods_per_node) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxPodsPerNode", &__With(&self.max_pods_per_node))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata about a long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time at which this operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this operation was completed.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the resource associated to this operation.
    pub target: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_detail: std::string::String,

    /// Output only. Human-readable status of any error that occurred during the
    /// operation.
    pub error_detail: std::string::String,

    /// Output only. The verb associated with the API method which triggered this
    /// operation. Possible values are "create", "delete", "update" and "import".
    pub verb: std::string::String,

    /// Output only. Identifies whether it has been requested cancellation
    /// for the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::OperationMetadata::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [error_detail][crate::model::OperationMetadata::error_detail].
    pub fn set_error_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_detail = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __status_detail,
            __error_detail,
            __verb,
            __requested_cancellation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "statusDetail" => Ok(__FieldTag::__status_detail),
                            "status_detail" => Ok(__FieldTag::__status_detail),
                            "errorDetail" => Ok(__FieldTag::__error_detail),
                            "error_detail" => Ok(__FieldTag::__error_detail),
                            "verb" => Ok(__FieldTag::__verb),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_detail => {
                            if !fields.insert(__FieldTag::__status_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_detail",
                                ));
                            }
                            result.status_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_detail => {
                            if !fields.insert(__FieldTag::__error_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_detail",
                                ));
                            }
                            result.error_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.status_detail.is_empty() {
            state.serialize_entry("statusDetail", &self.status_detail)?;
        }
        if !self.error_detail.is_empty() {
            state.serialize_entry("errorDetail", &self.error_detail)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The taint content for the node taint.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeTaint {
    /// Required. Key for the taint.
    pub key: std::string::String,

    /// Required. Value for the taint.
    pub value: std::string::String,

    /// Required. The taint effect.
    pub effect: crate::model::node_taint::Effect,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeTaint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::NodeTaint::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::NodeTaint::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [effect][crate::model::NodeTaint::effect].
    pub fn set_effect<T: std::convert::Into<crate::model::node_taint::Effect>>(
        mut self,
        v: T,
    ) -> Self {
        self.effect = v.into();
        self
    }
}

impl wkt::message::Message for NodeTaint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.NodeTaint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeTaint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __value,
            __effect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeTaint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "value" => Ok(__FieldTag::__value),
                            "effect" => Ok(__FieldTag::__effect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeTaint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeTaint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__effect => {
                            if !fields.insert(__FieldTag::__effect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effect",
                                ));
                            }
                            result.effect = map.next_value::<std::option::Option<crate::model::node_taint::Effect>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeTaint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.effect) {
            state.serialize_entry("effect", &self.effect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NodeTaint].
pub mod node_taint {
    #[allow(unused_imports)]
    use super::*;

    /// The taint effect.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Effect {
        /// Not set.
        Unspecified,
        /// Do not allow new pods to schedule onto the node unless they tolerate the
        /// taint, but allow all pods submitted to Kubelet without going through the
        /// scheduler to start, and allow all already-running pods to continue
        /// running. Enforced by the scheduler.
        NoSchedule,
        /// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
        /// new pods onto the node, rather than prohibiting new pods from scheduling
        /// onto the node entirely. Enforced by the scheduler.
        PreferNoSchedule,
        /// Evict any already-running pods that do not tolerate the taint.
        /// Currently enforced by NodeController.
        NoExecute,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Effect::value] or
        /// [Effect::name].
        UnknownValue(effect::UnknownValue),
    }

    #[doc(hidden)]
    pub mod effect {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Effect {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoSchedule => std::option::Option::Some(1),
                Self::PreferNoSchedule => std::option::Option::Some(2),
                Self::NoExecute => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EFFECT_UNSPECIFIED"),
                Self::NoSchedule => std::option::Option::Some("NO_SCHEDULE"),
                Self::PreferNoSchedule => std::option::Option::Some("PREFER_NO_SCHEDULE"),
                Self::NoExecute => std::option::Option::Some("NO_EXECUTE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Effect {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Effect {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Effect {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoSchedule,
                2 => Self::PreferNoSchedule,
                3 => Self::NoExecute,
                _ => Self::UnknownValue(effect::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Effect {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECT_UNSPECIFIED" => Self::Unspecified,
                "NO_SCHEDULE" => Self::NoSchedule,
                "PREFER_NO_SCHEDULE" => Self::PreferNoSchedule,
                "NO_EXECUTE" => Self::NoExecute,
                _ => Self::UnknownValue(effect::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Effect {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoSchedule => serializer.serialize_i32(1),
                Self::PreferNoSchedule => serializer.serialize_i32(2),
                Self::NoExecute => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Effect {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Effect>::new(
                ".google.cloud.gkemulticloud.v1.NodeTaint.Effect",
            ))
        }
    }
}

/// Configuration for node pool kubelet options.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeKubeletConfig {
    /// Optional. Enable the insecure kubelet read only port.
    pub insecure_kubelet_readonly_port_enabled: bool,

    /// Optional. Control the CPU management policy on the node.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/>
    ///
    /// The following values are allowed.
    ///
    /// * "none": the default, which represents the existing scheduling behavior.
    /// * "static": allows pods with certain resource characteristics to be granted
    ///   increased CPU affinity and exclusivity on the node.
    ///   The default value is 'none' if unspecified.
    pub cpu_manager_policy: std::option::Option<std::string::String>,

    /// Optional. Enable CPU CFS quota enforcement for containers that specify CPU
    /// limits.
    ///
    /// This option is enabled by default which makes kubelet use CFS quota
    /// (<https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt>) to
    /// enforce container CPU limits. Otherwise, CPU limits will not be enforced at
    /// all.
    ///
    /// Disable this option to mitigate CPU throttling problems while still having
    /// your pods to be in Guaranteed QoS class by specifying the CPU limits.
    ///
    /// The default value is 'true' if unspecified.
    pub cpu_cfs_quota: std::option::Option<bool>,

    /// Optional. Set the CPU CFS quota period value 'cpu.cfs_period_us'.
    ///
    /// The string must be a sequence of decimal numbers, each with optional
    /// fraction and a unit suffix, such as "300ms".
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// The value must be a positive duration.
    ///
    /// The default value is '100ms' if unspecified.
    pub cpu_cfs_quota_period: std::option::Option<std::string::String>,

    /// Optional. Set the Pod PID limits. See
    /// <https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits>
    ///
    /// Controls the maximum number of processes allowed to run in a pod. The value
    /// must be greater than or equal to 1024 and less than 4194304.
    pub pod_pids_limit: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeKubeletConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insecure_kubelet_readonly_port_enabled][crate::model::NodeKubeletConfig::insecure_kubelet_readonly_port_enabled].
    pub fn set_insecure_kubelet_readonly_port_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.insecure_kubelet_readonly_port_enabled = v.into();
        self
    }

    /// Sets the value of [cpu_manager_policy][crate::model::NodeKubeletConfig::cpu_manager_policy].
    pub fn set_cpu_manager_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_manager_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_manager_policy][crate::model::NodeKubeletConfig::cpu_manager_policy].
    pub fn set_or_clear_cpu_manager_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_manager_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_cfs_quota][crate::model::NodeKubeletConfig::cpu_cfs_quota].
    pub fn set_cpu_cfs_quota<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.cpu_cfs_quota = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_cfs_quota][crate::model::NodeKubeletConfig::cpu_cfs_quota].
    pub fn set_or_clear_cpu_cfs_quota<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.cpu_cfs_quota = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_cfs_quota_period][crate::model::NodeKubeletConfig::cpu_cfs_quota_period].
    pub fn set_cpu_cfs_quota_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_cfs_quota_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_cfs_quota_period][crate::model::NodeKubeletConfig::cpu_cfs_quota_period].
    pub fn set_or_clear_cpu_cfs_quota_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_cfs_quota_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pod_pids_limit][crate::model::NodeKubeletConfig::pod_pids_limit].
    pub fn set_pod_pids_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.pod_pids_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pod_pids_limit][crate::model::NodeKubeletConfig::pod_pids_limit].
    pub fn set_or_clear_pod_pids_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.pod_pids_limit = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodeKubeletConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.NodeKubeletConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeKubeletConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insecure_kubelet_readonly_port_enabled,
            __cpu_manager_policy,
            __cpu_cfs_quota,
            __cpu_cfs_quota_period,
            __pod_pids_limit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeKubeletConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insecureKubeletReadonlyPortEnabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "insecure_kubelet_readonly_port_enabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "cpuManagerPolicy" => Ok(__FieldTag::__cpu_manager_policy),
                            "cpu_manager_policy" => Ok(__FieldTag::__cpu_manager_policy),
                            "cpuCfsQuota" => Ok(__FieldTag::__cpu_cfs_quota),
                            "cpu_cfs_quota" => Ok(__FieldTag::__cpu_cfs_quota),
                            "cpuCfsQuotaPeriod" => Ok(__FieldTag::__cpu_cfs_quota_period),
                            "cpu_cfs_quota_period" => Ok(__FieldTag::__cpu_cfs_quota_period),
                            "podPidsLimit" => Ok(__FieldTag::__pod_pids_limit),
                            "pod_pids_limit" => Ok(__FieldTag::__pod_pids_limit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeKubeletConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeKubeletConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insecure_kubelet_readonly_port_enabled => {
                            if !fields.insert(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insecure_kubelet_readonly_port_enabled",
                                ));
                            }
                            result.insecure_kubelet_readonly_port_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_manager_policy => {
                            if !fields.insert(__FieldTag::__cpu_manager_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_manager_policy",
                                ));
                            }
                            result.cpu_manager_policy =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__cpu_cfs_quota => {
                            if !fields.insert(__FieldTag::__cpu_cfs_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_cfs_quota",
                                ));
                            }
                            result.cpu_cfs_quota = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__cpu_cfs_quota_period => {
                            if !fields.insert(__FieldTag::__cpu_cfs_quota_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_cfs_quota_period",
                                ));
                            }
                            result.cpu_cfs_quota_period =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__pod_pids_limit => {
                            if !fields.insert(__FieldTag::__pod_pids_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_pids_limit",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_pids_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeKubeletConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.insecure_kubelet_readonly_port_enabled) {
            state.serialize_entry(
                "insecureKubeletReadonlyPortEnabled",
                &self.insecure_kubelet_readonly_port_enabled,
            )?;
        }
        if self.cpu_manager_policy.is_some() {
            state.serialize_entry("cpuManagerPolicy", &self.cpu_manager_policy)?;
        }
        if self.cpu_cfs_quota.is_some() {
            state.serialize_entry("cpuCfsQuota", &self.cpu_cfs_quota)?;
        }
        if self.cpu_cfs_quota_period.is_some() {
            state.serialize_entry("cpuCfsQuotaPeriod", &self.cpu_cfs_quota_period)?;
        }
        if self.pod_pids_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("podPidsLimit", &__With(&self.pod_pids_limit))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Fleet related configuration.
///
/// Fleets are a Google Cloud concept for logically organizing clusters,
/// letting you use and manage multi-cluster capabilities and apply
/// consistent policies across your systems.
///
/// See [Anthos
/// Fleets](https://cloud.google.com/anthos/multicluster-management/fleets) for
/// more details on Anthos multi-cluster capabilities using Fleets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Fleet {
    /// Required. The name of the Fleet host project where this cluster will be
    /// registered.
    ///
    /// Project names are formatted as
    /// `projects/<project-number>`.
    pub project: std::string::String,

    /// Output only. The name of the managed Hub Membership resource associated to
    /// this cluster.
    ///
    /// Membership names are formatted as
    /// `projects/<project-number>/locations/global/membership/<cluster-id>`.
    pub membership: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.Fleet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fleet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __membership,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fleet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "membership" => Ok(__FieldTag::__membership),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fleet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fleet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Fleet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.membership.is_empty() {
            state.serialize_entry("membership", &self.membership)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that describe the Logging configuration in a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingConfig {
    /// The configuration of the logging components;
    pub component_config: std::option::Option<crate::model::LoggingComponentConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_config][crate::model::LoggingConfig::component_config].
    pub fn set_component_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingComponentConfig>,
    {
        self.component_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [component_config][crate::model::LoggingConfig::component_config].
    pub fn set_or_clear_component_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingComponentConfig>,
    {
        self.component_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.LoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __component_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "componentConfig" => Ok(__FieldTag::__component_config),
                            "component_config" => Ok(__FieldTag::__component_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__component_config => {
                            if !fields.insert(__FieldTag::__component_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_config",
                                ));
                            }
                            result.component_config = map.next_value::<std::option::Option<crate::model::LoggingComponentConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.component_config.is_some() {
            state.serialize_entry("componentConfig", &self.component_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that describe the Logging component configuration in a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingComponentConfig {
    /// The components to be enabled.
    pub enable_components: std::vec::Vec<crate::model::logging_component_config::Component>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingComponentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_components][crate::model::LoggingComponentConfig::enable_components].
    pub fn set_enable_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_component_config::Component>,
    {
        use std::iter::Iterator;
        self.enable_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoggingComponentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.LoggingComponentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingComponentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingComponentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableComponents" => Ok(__FieldTag::__enable_components),
                            "enable_components" => Ok(__FieldTag::__enable_components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingComponentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingComponentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_components => {
                            if !fields.insert(__FieldTag::__enable_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_components",
                                ));
                            }
                            result.enable_components = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::logging_component_config::Component,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingComponentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enable_components.is_empty() {
            state.serialize_entry("enableComponents", &self.enable_components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LoggingComponentConfig].
pub mod logging_component_config {
    #[allow(unused_imports)]
    use super::*;

    /// The components of the logging configuration;
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Component {
        /// No component is specified
        Unspecified,
        /// This indicates that system logging components is enabled.
        SystemComponents,
        /// This indicates that user workload logging component is enabled.
        Workloads,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Component::value] or
        /// [Component::name].
        UnknownValue(component::UnknownValue),
    }

    #[doc(hidden)]
    pub mod component {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Component {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemComponents => std::option::Option::Some(1),
                Self::Workloads => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
                Self::SystemComponents => std::option::Option::Some("SYSTEM_COMPONENTS"),
                Self::Workloads => std::option::Option::Some("WORKLOADS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Component {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Component {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Component {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemComponents,
                2 => Self::Workloads,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Component {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPONENT_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_COMPONENTS" => Self::SystemComponents,
                "WORKLOADS" => Self::Workloads,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Component {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemComponents => serializer.serialize_i32(1),
                Self::Workloads => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Component {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
                ".google.cloud.gkemulticloud.v1.LoggingComponentConfig.Component",
            ))
        }
    }
}

/// Parameters that describe the Monitoring configuration in a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MonitoringConfig {
    /// Enable Google Cloud Managed Service for Prometheus in the cluster.
    pub managed_prometheus_config: std::option::Option<crate::model::ManagedPrometheusConfig>,

    /// Optionally enable GKE metrics.
    /// Only for Attached Clusters.
    pub cloud_monitoring_config: std::option::Option<crate::model::CloudMonitoringConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [managed_prometheus_config][crate::model::MonitoringConfig::managed_prometheus_config].
    pub fn set_managed_prometheus_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedPrometheusConfig>,
    {
        self.managed_prometheus_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [managed_prometheus_config][crate::model::MonitoringConfig::managed_prometheus_config].
    pub fn set_or_clear_managed_prometheus_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedPrometheusConfig>,
    {
        self.managed_prometheus_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_monitoring_config][crate::model::MonitoringConfig::cloud_monitoring_config].
    pub fn set_cloud_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudMonitoringConfig>,
    {
        self.cloud_monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_monitoring_config][crate::model::MonitoringConfig::cloud_monitoring_config].
    pub fn set_or_clear_cloud_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudMonitoringConfig>,
    {
        self.cloud_monitoring_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.MonitoringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __managed_prometheus_config,
            __cloud_monitoring_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "managedPrometheusConfig" => {
                                Ok(__FieldTag::__managed_prometheus_config)
                            }
                            "managed_prometheus_config" => {
                                Ok(__FieldTag::__managed_prometheus_config)
                            }
                            "cloudMonitoringConfig" => Ok(__FieldTag::__cloud_monitoring_config),
                            "cloud_monitoring_config" => Ok(__FieldTag::__cloud_monitoring_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__managed_prometheus_config => {
                            if !fields.insert(__FieldTag::__managed_prometheus_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_prometheus_config",
                                ));
                            }
                            result.managed_prometheus_config = map.next_value::<std::option::Option<crate::model::ManagedPrometheusConfig>>()?
                                ;
                        }
                        __FieldTag::__cloud_monitoring_config => {
                            if !fields.insert(__FieldTag::__cloud_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_monitoring_config",
                                ));
                            }
                            result.cloud_monitoring_config = map.next_value::<std::option::Option<crate::model::CloudMonitoringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.managed_prometheus_config.is_some() {
            state.serialize_entry("managedPrometheusConfig", &self.managed_prometheus_config)?;
        }
        if self.cloud_monitoring_config.is_some() {
            state.serialize_entry("cloudMonitoringConfig", &self.cloud_monitoring_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ManagedPrometheusConfig defines the configuration for
/// Google Cloud Managed Service for Prometheus.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedPrometheusConfig {
    /// Enable Managed Collection.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedPrometheusConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ManagedPrometheusConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ManagedPrometheusConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ManagedPrometheusConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagedPrometheusConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedPrometheusConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagedPrometheusConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedPrometheusConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagedPrometheusConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// CloudMonitoringConfig defines the configuration for
/// built-in Cloud Logging and Monitoring.
/// Only for Attached Clusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudMonitoringConfig {
    /// Enable GKE-native logging and metrics.
    /// Only for Attached Clusters.
    pub enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::CloudMonitoringConfig::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::CloudMonitoringConfig::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CloudMonitoringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudMonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudMonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudMonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudMonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudMonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for Binary Authorization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BinaryAuthorization {
    /// Mode of operation for binauthz policy evaluation. If unspecified, defaults
    /// to DISABLED.
    pub evaluation_mode: crate::model::binary_authorization::EvaluationMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinaryAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation_mode][crate::model::BinaryAuthorization::evaluation_mode].
    pub fn set_evaluation_mode<
        T: std::convert::Into<crate::model::binary_authorization::EvaluationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_mode = v.into();
        self
    }
}

impl wkt::message::Message for BinaryAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.BinaryAuthorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BinaryAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __evaluation_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinaryAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "evaluationMode" => Ok(__FieldTag::__evaluation_mode),
                            "evaluation_mode" => Ok(__FieldTag::__evaluation_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BinaryAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinaryAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__evaluation_mode => {
                            if !fields.insert(__FieldTag::__evaluation_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_mode",
                                ));
                            }
                            result.evaluation_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::binary_authorization::EvaluationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BinaryAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.evaluation_mode) {
            state.serialize_entry("evaluationMode", &self.evaluation_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BinaryAuthorization].
pub mod binary_authorization {
    #[allow(unused_imports)]
    use super::*;

    /// Binary Authorization mode of operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluationMode {
        /// Default value
        Unspecified,
        /// Disable BinaryAuthorization
        Disabled,
        /// Enforce Kubernetes admission requests with BinaryAuthorization using the
        /// project's singleton policy.
        ProjectSingletonPolicyEnforce,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluationMode::value] or
        /// [EvaluationMode::name].
        UnknownValue(evaluation_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod evaluation_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EvaluationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::ProjectSingletonPolicyEnforce => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVALUATION_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::ProjectSingletonPolicyEnforce => {
                    std::option::Option::Some("PROJECT_SINGLETON_POLICY_ENFORCE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EvaluationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EvaluationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EvaluationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::ProjectSingletonPolicyEnforce,
                _ => Self::UnknownValue(evaluation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EvaluationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "PROJECT_SINGLETON_POLICY_ENFORCE" => Self::ProjectSingletonPolicyEnforce,
                _ => Self::UnknownValue(evaluation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EvaluationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::ProjectSingletonPolicyEnforce => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EvaluationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EvaluationMode>::new(
                ".google.cloud.gkemulticloud.v1.BinaryAuthorization.EvaluationMode",
            ))
        }
    }
}

/// SecurityPostureConfig defines the flags needed to enable/disable features for
/// the Security Posture API.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityPostureConfig {
    /// Sets which mode to use for vulnerability scanning.
    pub vulnerability_mode: crate::model::security_posture_config::VulnerabilityMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityPostureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vulnerability_mode][crate::model::SecurityPostureConfig::vulnerability_mode].
    pub fn set_vulnerability_mode<
        T: std::convert::Into<crate::model::security_posture_config::VulnerabilityMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerability_mode = v.into();
        self
    }
}

impl wkt::message::Message for SecurityPostureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.SecurityPostureConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityPostureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vulnerability_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityPostureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vulnerabilityMode" => Ok(__FieldTag::__vulnerability_mode),
                            "vulnerability_mode" => Ok(__FieldTag::__vulnerability_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityPostureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityPostureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vulnerability_mode => {
                            if !fields.insert(__FieldTag::__vulnerability_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_mode",
                                ));
                            }
                            result.vulnerability_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::security_posture_config::VulnerabilityMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityPostureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.vulnerability_mode) {
            state.serialize_entry("vulnerabilityMode", &self.vulnerability_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SecurityPostureConfig].
pub mod security_posture_config {
    #[allow(unused_imports)]
    use super::*;

    /// VulnerabilityMode defines enablement mode for vulnerability scanning.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VulnerabilityMode {
        /// Default value not specified.
        Unspecified,
        /// Disables vulnerability scanning on the cluster.
        VulnerabilityDisabled,
        /// Applies the Security Posture's vulnerability on cluster Enterprise level
        /// features.
        VulnerabilityEnterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VulnerabilityMode::value] or
        /// [VulnerabilityMode::name].
        UnknownValue(vulnerability_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vulnerability_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VulnerabilityMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VulnerabilityDisabled => std::option::Option::Some(1),
                Self::VulnerabilityEnterprise => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VULNERABILITY_MODE_UNSPECIFIED"),
                Self::VulnerabilityDisabled => std::option::Option::Some("VULNERABILITY_DISABLED"),
                Self::VulnerabilityEnterprise => {
                    std::option::Option::Some("VULNERABILITY_ENTERPRISE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VulnerabilityMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VulnerabilityMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VulnerabilityMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VulnerabilityDisabled,
                2 => Self::VulnerabilityEnterprise,
                _ => Self::UnknownValue(vulnerability_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VulnerabilityMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VULNERABILITY_MODE_UNSPECIFIED" => Self::Unspecified,
                "VULNERABILITY_DISABLED" => Self::VulnerabilityDisabled,
                "VULNERABILITY_ENTERPRISE" => Self::VulnerabilityEnterprise,
                _ => Self::UnknownValue(vulnerability_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VulnerabilityMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VulnerabilityDisabled => serializer.serialize_i32(1),
                Self::VulnerabilityEnterprise => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VulnerabilityMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VulnerabilityMode>::new(
                ".google.cloud.gkemulticloud.v1.SecurityPostureConfig.VulnerabilityMode",
            ))
        }
    }
}
