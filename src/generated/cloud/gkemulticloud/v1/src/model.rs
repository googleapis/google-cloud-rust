// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An Anthos cluster running on customer own infrastructure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedCluster {
    /// The name of this resource.
    ///
    /// Cluster names are formatted as
    /// `projects/<project-number>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human readable description of this cluster.
    /// Cannot be longer than 255 UTF-8 encoded bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. OpenID Connect (OIDC) configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oidc_config: std::option::Option<crate::model::AttachedOidcConfig>,

    /// Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig]: crate::client::AttachedClusters::get_attached_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub platform_version: std::string::String,

    /// Required. The Kubernetes distribution of the underlying attached cluster.
    ///
    /// Supported values: ["eks", "aks", "generic"].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub distribution: std::string::String,

    /// Output only. The region where this cluster runs.
    ///
    /// For EKS clusters, this is a AWS region. For AKS clusters,
    /// this is an Azure region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_region: std::string::String,

    /// Required. Fleet configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Output only. The current state of the cluster.
    pub state: crate::model::attached_cluster::State,

    /// Output only. A globally unique identifier for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the cluster.
    pub reconciling: bool,

    /// Output only. The time at which this cluster was registered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this cluster was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The Kubernetes version of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kubernetes_version: std::string::String,

    /// Optional. Annotations on the cluster.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workload Identity settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Optional. Logging configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Output only. A set of errors found in the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::AttachedClusterError>,

    /// Optional. Configuration related to the cluster RBAC settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization: std::option::Option<crate::model::AttachedClustersAuthorization>,

    /// Optional. Monitoring configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AttachedProxyConfig>,

    /// Optional. Binary Authorization configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Optional. Security Posture configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub security_posture_config: std::option::Option<crate::model::SecurityPostureConfig>,

    /// Optional. Input only. Tag keys/values directly bound to this resource.
    ///
    /// Tag key must be specified in the format \<tag namespace\>/\<tag key name\>
    /// where the tag namespace is the ID of the organization or name of the
    /// project that the tag key is defined in.
    /// The short name of a tag key or value can have a maximum length of 256
    /// characters. The permitted character set for the short name includes UTF-8
    /// encoded Unicode characters except single quotes ('), double quotes ("),
    /// backslashes (\), and forward slashes (/).
    ///
    /// See
    /// [Tags](https://cloud.google.com/resource-manager/docs/tags/tags-overview)
    /// for more details on Google Cloud Platform tags.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,
}

impl AttachedCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachedCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AttachedCluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [oidc_config][crate::model::AttachedCluster::oidc_config].
    pub fn set_oidc_config<
        T: std::convert::Into<std::option::Option<crate::model::AttachedOidcConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oidc_config = v.into();
        self
    }

    /// Sets the value of [platform_version][crate::model::AttachedCluster::platform_version].
    pub fn set_platform_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_version = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::AttachedCluster::distribution].
    pub fn set_distribution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.distribution = v.into();
        self
    }

    /// Sets the value of [cluster_region][crate::model::AttachedCluster::cluster_region].
    pub fn set_cluster_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_region = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::AttachedCluster::fleet].
    pub fn set_fleet<T: std::convert::Into<std::option::Option<crate::model::Fleet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AttachedCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::attached_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AttachedCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AttachedCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AttachedCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AttachedCluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AttachedCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [kubernetes_version][crate::model::AttachedCluster::kubernetes_version].
    pub fn set_kubernetes_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_version = v.into();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::AttachedCluster::workload_identity_config].
    pub fn set_workload_identity_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadIdentityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_identity_config = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::AttachedCluster::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [authorization][crate::model::AttachedCluster::authorization].
    pub fn set_authorization<
        T: std::convert::Into<std::option::Option<crate::model::AttachedClustersAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization = v.into();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::AttachedCluster::monitoring_config].
    pub fn set_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::MonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_config = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::AttachedCluster::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AttachedProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::AttachedCluster::binary_authorization].
    pub fn set_binary_authorization<
        T: std::convert::Into<std::option::Option<crate::model::BinaryAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binary_authorization = v.into();
        self
    }

    /// Sets the value of [security_posture_config][crate::model::AttachedCluster::security_posture_config].
    pub fn set_security_posture_config<
        T: std::convert::Into<std::option::Option<crate::model::SecurityPostureConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.security_posture_config = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::AttachedCluster::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedClusterError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::AttachedCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AttachedCluster::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AttachedCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedCluster"
    }
}

/// Defines additional types related to AttachedCluster
pub mod attached_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The PROVISIONING state indicates the cluster is being registered.
        pub const PROVISIONING: State = State::new(1);

        /// The RUNNING state indicates the cluster has been register and is fully
        /// usable.
        pub const RUNNING: State = State::new(2);

        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading software components.
        pub const RECONCILING: State = State::new(3);

        /// The STOPPING state indicates the cluster is being de-registered.
        pub const STOPPING: State = State::new(4);

        /// The ERROR state indicates the cluster is in a broken unrecoverable
        /// state.
        pub const ERROR: State = State::new(5);

        /// The DEGRADED state indicates the cluster requires user action to
        /// restore full functionality.
        pub const DEGRADED: State = State::new(6);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("RECONCILING"),
                4 => std::borrow::Cow::Borrowed("STOPPING"),
                5 => std::borrow::Cow::Borrowed("ERROR"),
                6 => std::borrow::Cow::Borrowed("DEGRADED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "RECONCILING" => std::option::Option::Some(Self::RECONCILING),
                "STOPPING" => std::option::Option::Some(Self::STOPPING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "DEGRADED" => std::option::Option::Some(Self::DEGRADED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration related to the cluster RBAC settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedClustersAuthorization {
    /// Optional. Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
    /// to the users. Up to ten admin users can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admin_users: std::vec::Vec<crate::model::AttachedClusterUser>,

    /// Optional. Groups of users that can perform operations as a cluster admin. A
    /// managed ClusterRoleBinding will be created to grant the `cluster-admin`
    /// ClusterRole to the groups. Up to ten admin groups can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admin_groups: std::vec::Vec<crate::model::AttachedClusterGroup>,
}

impl AttachedClustersAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::AttachedClustersAuthorization::admin_users].
    pub fn set_admin_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedClusterUser>,
    {
        use std::iter::Iterator;
        self.admin_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin_groups][crate::model::AttachedClustersAuthorization::admin_groups].
    pub fn set_admin_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedClusterGroup>,
    {
        use std::iter::Iterator;
        self.admin_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttachedClustersAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClustersAuthorization"
    }
}

/// Identities of a user-type subject for Attached clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedClusterUser {
    /// Required. The name of the user, e.g. `my-gcp-id@gmail.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,
}

impl AttachedClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::AttachedClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AttachedClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClusterUser"
    }
}

/// Identities of a group-type subject for Attached clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedClusterGroup {
    /// Required. The name of the group, e.g. `my-group@domain.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,
}

impl AttachedClusterGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AttachedClusterGroup::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }
}

impl wkt::message::Message for AttachedClusterGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClusterGroup"
    }
}

/// OIDC discovery information of the target cluster.
///
/// Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
/// API server. This fields indicates how Google Cloud Platform services
/// validate KSA tokens in order to allow system workloads (such as GKE Connect
/// and telemetry agents) to authenticate back to Google Cloud Platform.
///
/// Both clusters with public and private issuer URLs are supported.
/// Clusters with public issuers only need to specify the `issuer_url` field
/// while clusters with private issuers need to provide both
/// `issuer_url` and `oidc_jwks`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedOidcConfig {
    /// A JSON Web Token (JWT) issuer URI. `issuer` must start with `https://`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issuer_url: std::string::String,

    /// Optional. OIDC verification keys in JWKS format (RFC 7517).
    /// It contains a list of OIDC verification keys that can be used to verify
    /// OIDC JWTs.
    ///
    /// This field is required for cluster that doesn't have a publicly available
    /// discovery endpoint. When provided, it will be directly used
    /// to verify the OIDC JWT asserted by the IDP.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub jwks: ::bytes::Bytes,
}

impl AttachedOidcConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer_url][crate::model::AttachedOidcConfig::issuer_url].
    pub fn set_issuer_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer_url = v.into();
        self
    }

    /// Sets the value of [jwks][crate::model::AttachedOidcConfig::jwks].
    pub fn set_jwks<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.jwks = v.into();
        self
    }
}

impl wkt::message::Message for AttachedOidcConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedOidcConfig"
    }
}

/// AttachedServerConfig provides information about supported
/// Kubernetes versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedServerConfig {
    /// The resource name of the config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// List of valid platform versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub valid_versions: std::vec::Vec<crate::model::AttachedPlatformVersionInfo>,
}

impl AttachedServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachedServerConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [valid_versions][crate::model::AttachedServerConfig::valid_versions].
    pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedPlatformVersionInfo>,
    {
        use std::iter::Iterator;
        self.valid_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttachedServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedServerConfig"
    }
}

/// Information about a supported Attached Clusters platform version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedPlatformVersionInfo {
    /// Platform version name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl AttachedPlatformVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AttachedPlatformVersionInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for AttachedPlatformVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedPlatformVersionInfo"
    }
}

/// AttachedClusterError describes errors found on attached clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedClusterError {
    /// Human-friendly description of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl AttachedClusterError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AttachedClusterError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AttachedClusterError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedClusterError"
    }
}

/// Details of a proxy config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachedProxyConfig {
    /// The Kubernetes Secret resource that contains the HTTP(S) proxy
    /// configuration. The secret must be a JSON encoded proxy configuration
    /// as described in
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/attached/eks/how-to/use-a-proxy#configure-proxy-support>
    /// for EKS clusters and
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/attached/aks/how-to/use-a-proxy#configure-proxy-support>
    /// for AKS clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kubernetes_secret: std::option::Option<crate::model::KubernetesSecret>,
}

impl AttachedProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kubernetes_secret][crate::model::AttachedProxyConfig::kubernetes_secret].
    pub fn set_kubernetes_secret<
        T: std::convert::Into<std::option::Option<crate::model::KubernetesSecret>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_secret = v.into();
        self
    }
}

impl wkt::message::Message for AttachedProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AttachedProxyConfig"
    }
}

/// Information about a Kubernetes Secret
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KubernetesSecret {
    /// Name of the kubernetes secret.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Namespace in which the kubernetes secret is stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub namespace: std::string::String,
}

impl KubernetesSecret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KubernetesSecret::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [namespace][crate::model::KubernetesSecret::namespace].
    pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace = v.into();
        self
    }
}

impl wkt::message::Message for KubernetesSecret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.KubernetesSecret"
    }
}

/// Request message for `AttachedClusters.GenerateAttachedClusterInstallManifest`
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAttachedClusterInstallManifestRequest {
    /// Required. The parent location where this
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will be created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A client provided ID of the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// name formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// When generating an install manifest for importing an existing Membership
    /// resource, the attached_cluster_id field must be the Membership id.
    ///
    /// Membership names are formatted as
    /// `projects/<project-id>/locations/<region>/memberships/<membership-id>`.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attached_cluster_id: std::string::String,

    /// Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig]: crate::client::AttachedClusters::get_attached_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub platform_version: std::string::String,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AttachedProxyConfig>,
}

impl GenerateAttachedClusterInstallManifestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateAttachedClusterInstallManifestRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attached_cluster_id][crate::model::GenerateAttachedClusterInstallManifestRequest::attached_cluster_id].
    pub fn set_attached_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster_id = v.into();
        self
    }

    /// Sets the value of [platform_version][crate::model::GenerateAttachedClusterInstallManifestRequest::platform_version].
    pub fn set_platform_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_version = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::GenerateAttachedClusterInstallManifestRequest::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AttachedProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterInstallManifestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterInstallManifestRequest"
    }
}

/// Response message for
/// `AttachedClusters.GenerateAttachedClusterInstallManifest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAttachedClusterInstallManifestResponse {
    /// A set of Kubernetes resources (in YAML format) to be applied
    /// to the cluster to be attached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub manifest: std::string::String,
}

impl GenerateAttachedClusterInstallManifestResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [manifest][crate::model::GenerateAttachedClusterInstallManifestResponse::manifest].
    pub fn set_manifest<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.manifest = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterInstallManifestResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterInstallManifestResponse"
    }
}

/// Request message for `AttachedClusters.CreateAttachedCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAttachedClusterRequest {
    /// Required. The parent location where this
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will be created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attached_cluster: std::option::Option<crate::model::AttachedCluster>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// name formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attached_cluster_id: std::string::String,

    /// If set, only validate the request, but do not actually create the cluster.
    pub validate_only: bool,
}

impl CreateAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAttachedClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attached_cluster][crate::model::CreateAttachedClusterRequest::attached_cluster].
    pub fn set_attached_cluster<
        T: std::convert::Into<std::option::Option<crate::model::AttachedCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster = v.into();
        self
    }

    /// Sets the value of [attached_cluster_id][crate::model::CreateAttachedClusterRequest::attached_cluster_id].
    pub fn set_attached_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAttachedClusterRequest"
    }
}

/// Request message for `AttachedClusters.ImportAttachedCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAttachedClusterRequest {
    /// Required. The parent location where this
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will be created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// If set, only validate the request, but do not actually import the cluster.
    pub validate_only: bool,

    /// Required. The name of the fleet membership resource to import.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fleet_membership: std::string::String,

    /// Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig]: crate::client::AttachedClusters::get_attached_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub platform_version: std::string::String,

    /// Required. The Kubernetes distribution of the underlying attached cluster.
    ///
    /// Supported values: ["eks", "aks", "generic"].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub distribution: std::string::String,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AttachedProxyConfig>,
}

impl ImportAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportAttachedClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::ImportAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [fleet_membership][crate::model::ImportAttachedClusterRequest::fleet_membership].
    pub fn set_fleet_membership<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet_membership = v.into();
        self
    }

    /// Sets the value of [platform_version][crate::model::ImportAttachedClusterRequest::platform_version].
    pub fn set_platform_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_version = v.into();
        self
    }

    /// Sets the value of [distribution][crate::model::ImportAttachedClusterRequest::distribution].
    pub fn set_distribution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.distribution = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::ImportAttachedClusterRequest::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AttachedProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }
}

impl wkt::message::Message for ImportAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ImportAttachedClusterRequest"
    }
}

/// Request message for `AttachedClusters.UpdateAttachedCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAttachedClusterRequest {
    /// Required. The
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attached_cluster: std::option::Option<crate::model::AttachedCluster>,

    /// If set, only validate the request, but do not actually update the cluster.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]:
    ///
    /// * `annotations`.
    /// * `authorization.admin_groups`.
    /// * `authorization.admin_users`.
    /// * `binary_authorization.evaluation_mode`.
    /// * `description`.
    /// * `logging_config.component_config.enable_components`.
    /// * `monitoring_config.managed_prometheus_config.enabled`.
    /// * `platform_version`.
    /// * `proxy_config.kubernetes_secret.name`.
    /// * `proxy_config.kubernetes_secret.namespace`.
    /// * `security_posture_config.vulnerability_mode`
    /// * `monitoring_config.cloud_monitoring_config.enabled`
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_cluster][crate::model::UpdateAttachedClusterRequest::attached_cluster].
    pub fn set_attached_cluster<
        T: std::convert::Into<std::option::Option<crate::model::AttachedCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAttachedClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAttachedClusterRequest"
    }
}

/// Request message for `AttachedClusters.GetAttachedCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAttachedClusterRequest {
    /// Required. The name of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// to describe.
    ///
    /// `AttachedCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttachedClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAttachedClusterRequest"
    }
}

/// Request message for `AttachedClusters.ListAttachedClusters` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttachedClustersRequest {
    /// Required. The parent location which owns this collection of
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAttachedClustersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAttachedClustersResponse.next_page_token]: crate::model::ListAttachedClustersResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [attachedClusters.list][google.cloud.gkemulticloud.v1.AttachedClusters.ListAttachedClusters]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedClusters.ListAttachedClusters]: crate::client::AttachedClusters::list_attached_clusters
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAttachedClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttachedClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttachedClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttachedClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachedClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAttachedClustersRequest"
    }
}

/// Response message for `AttachedClusters.ListAttachedClusters` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttachedClustersResponse {
    /// A list of [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]
    /// resources in the specified Google Cloud Platform project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attached_clusters: std::vec::Vec<crate::model::AttachedCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAttachedClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAttachedClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [attached_clusters][crate::model::ListAttachedClustersResponse::attached_clusters].
    pub fn set_attached_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedCluster>,
    {
        use std::iter::Iterator;
        self.attached_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAttachedClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAttachedClustersResponse"
    }
}

impl gax::paginator::PageableResponse for ListAttachedClustersResponse {
    type PageItem = crate::model::AttachedCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attached_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AttachedClusters.DeleteAttachedCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAttachedClusterRequest {
    /// Required. The resource name the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] to delete.
    ///
    /// `AttachedCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// is not found, the request will succeed but no action will be taken on the
    /// server and a completed [Operation][google.longrunning.Operation] will be
    /// returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// If set to true, the deletion of
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
    /// will succeed even if errors occur during deleting in cluster resources.
    /// Using this parameter may result in orphaned resources in the cluster.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    pub ignore_errors: bool,

    /// The current etag of the
    /// [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided etag does not match the current etag of the cluster,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedCluster]: crate::model::AttachedCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteAttachedClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAttachedClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAttachedClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAttachedClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAttachedClusterRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAttachedClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAttachedClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAttachedClusterRequest"
    }
}

/// GetAttachedServerConfigRequest gets the server config for attached
/// clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAttachedServerConfigRequest {
    /// Required. The name of the
    /// [AttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedServerConfig]
    /// resource to describe.
    ///
    /// `AttachedServerConfig` names are formatted as
    /// `projects/<project-id>/locations/<region>/attachedServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AttachedServerConfig]: crate::model::AttachedServerConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAttachedServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttachedServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttachedServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAttachedServerConfigRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAttachedClusterAgentTokenRequest {
    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attached_cluster: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_token: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_token_type: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub grant_type: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audience: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scope: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub requested_token_type: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub options: std::string::String,
}

impl GenerateAttachedClusterAgentTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attached_cluster][crate::model::GenerateAttachedClusterAgentTokenRequest::attached_cluster].
    pub fn set_attached_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attached_cluster = v.into();
        self
    }

    /// Sets the value of [subject_token][crate::model::GenerateAttachedClusterAgentTokenRequest::subject_token].
    pub fn set_subject_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_token = v.into();
        self
    }

    /// Sets the value of [subject_token_type][crate::model::GenerateAttachedClusterAgentTokenRequest::subject_token_type].
    pub fn set_subject_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_token_type = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenerateAttachedClusterAgentTokenRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [grant_type][crate::model::GenerateAttachedClusterAgentTokenRequest::grant_type].
    pub fn set_grant_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grant_type = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::GenerateAttachedClusterAgentTokenRequest::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::GenerateAttachedClusterAgentTokenRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [requested_token_type][crate::model::GenerateAttachedClusterAgentTokenRequest::requested_token_type].
    pub fn set_requested_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_token_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::GenerateAttachedClusterAgentTokenRequest::options].
    pub fn set_options<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.options = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterAgentTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterAgentTokenRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAttachedClusterAgentTokenResponse {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    pub expires_in: i32,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token_type: std::string::String,
}

impl GenerateAttachedClusterAgentTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAttachedClusterAgentTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expires_in][crate::model::GenerateAttachedClusterAgentTokenResponse::expires_in].
    pub fn set_expires_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expires_in = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::GenerateAttachedClusterAgentTokenResponse::token_type].
    pub fn set_token_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAttachedClusterAgentTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAttachedClusterAgentTokenResponse"
    }
}

/// An Anthos cluster running on AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsCluster {
    /// The name of this resource.
    ///
    /// Cluster names are formatted as
    /// `projects/<project-number>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human readable description of this cluster.
    /// Cannot be longer than 255 UTF-8 encoded bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Cluster-wide networking configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub networking: std::option::Option<crate::model::AwsClusterNetworking>,

    /// Required. The AWS region where the cluster runs.
    ///
    /// Each Google Cloud region supports a subset of nearby AWS regions.
    /// You can call
    /// [GetAwsServerConfig][google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]
    /// to list all supported AWS regions within a given Google Cloud region.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]: crate::client::AwsClusters::get_aws_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_region: std::string::String,

    /// Required. Configuration related to the cluster control plane.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control_plane: std::option::Option<crate::model::AwsControlPlane>,

    /// Required. Configuration related to the cluster RBAC settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization: std::option::Option<crate::model::AwsAuthorization>,

    /// Output only. The current state of the cluster.
    pub state: crate::model::aws_cluster::State,

    /// Output only. The endpoint of the cluster's API server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Output only. A globally unique identifier for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the cluster.
    pub reconciling: bool,

    /// Output only. The time at which this cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this cluster was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Annotations on the cluster.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workload Identity settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Output only. PEM encoded x509 certificate of the cluster root of trust.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ca_certificate: std::string::String,

    /// Required. Fleet configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Optional. Logging configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Output only. A set of errors found in the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::AwsClusterError>,

    /// Optional. Monitoring configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// Optional. Binary Authorization configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,
}

impl AwsCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AwsCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AwsCluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [networking][crate::model::AwsCluster::networking].
    pub fn set_networking<
        T: std::convert::Into<std::option::Option<crate::model::AwsClusterNetworking>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.networking = v.into();
        self
    }

    /// Sets the value of [aws_region][crate::model::AwsCluster::aws_region].
    pub fn set_aws_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_region = v.into();
        self
    }

    /// Sets the value of [control_plane][crate::model::AwsCluster::control_plane].
    pub fn set_control_plane<
        T: std::convert::Into<std::option::Option<crate::model::AwsControlPlane>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane = v.into();
        self
    }

    /// Sets the value of [authorization][crate::model::AwsCluster::authorization].
    pub fn set_authorization<
        T: std::convert::Into<std::option::Option<crate::model::AwsAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AwsCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::AwsCluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AwsCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AwsCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AwsCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AwsCluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AwsCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::AwsCluster::workload_identity_config].
    pub fn set_workload_identity_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadIdentityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_identity_config = v.into();
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::AwsCluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::AwsCluster::fleet].
    pub fn set_fleet<T: std::convert::Into<std::option::Option<crate::model::Fleet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::AwsCluster::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::AwsCluster::monitoring_config].
    pub fn set_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::MonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_config = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::AwsCluster::binary_authorization].
    pub fn set_binary_authorization<
        T: std::convert::Into<std::option::Option<crate::model::BinaryAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binary_authorization = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::AwsCluster::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsClusterError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::AwsCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AwsCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsCluster"
    }
}

/// Defines additional types related to AwsCluster
pub mod aws_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The PROVISIONING state indicates the cluster is being created.
        pub const PROVISIONING: State = State::new(1);

        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        pub const RUNNING: State = State::new(2);

        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the control plane replicas.
        pub const RECONCILING: State = State::new(3);

        /// The STOPPING state indicates the cluster is being deleted.
        pub const STOPPING: State = State::new(4);

        /// The ERROR state indicates the cluster is in a broken unrecoverable
        /// state.
        pub const ERROR: State = State::new(5);

        /// The DEGRADED state indicates the cluster requires user action to
        /// restore full functionality.
        pub const DEGRADED: State = State::new(6);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("RECONCILING"),
                4 => std::borrow::Cow::Borrowed("STOPPING"),
                5 => std::borrow::Cow::Borrowed("ERROR"),
                6 => std::borrow::Cow::Borrowed("DEGRADED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "RECONCILING" => std::option::Option::Some(Self::RECONCILING),
                "STOPPING" => std::option::Option::Some(Self::STOPPING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "DEGRADED" => std::option::Option::Some(Self::DEGRADED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ControlPlane defines common parameters between control plane nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsControlPlane {
    /// Required. The Kubernetes version to run on control plane replicas
    /// (e.g. `1.19.10-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAwsServerConfig][google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]: crate::client::AwsClusters::get_aws_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional. The AWS instance type.
    ///
    /// When unspecified, it uses a default based on the cluster's version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_type: std::string::String,

    /// Optional. SSH configuration for how to access the underlying control plane
    /// machines.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssh_config: std::option::Option<crate::model::AwsSshConfig>,

    /// Required. The list of subnets where control plane replicas will run.
    /// A replica will be provisioned on each subnet and up to three values
    /// can be provided.
    /// Each subnet must be in a different AWS Availability Zone (AZ).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subnet_ids: std::vec::Vec<std::string::String>,

    /// Optional. The IDs of additional security groups to add to control plane
    /// replicas. The Anthos Multi-Cloud API will automatically create and manage
    /// security groups with the minimum rules needed for a functioning cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub security_group_ids: std::vec::Vec<std::string::String>,

    /// Required. The name or ARN of the AWS IAM instance profile to assign to each
    /// control plane replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub iam_instance_profile: std::string::String,

    /// Optional. Configuration related to the root volume provisioned for each
    /// control plane replica.
    ///
    /// Volumes will be provisioned in the availability zone associated
    /// with the corresponding subnet.
    ///
    /// When unspecified, it defaults to 32 GiB with the GP2 volume type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub root_volume: std::option::Option<crate::model::AwsVolumeTemplate>,

    /// Optional. Configuration related to the main volume provisioned for each
    /// control plane replica.
    /// The main volume is in charge of storing all of the cluster's etcd state.
    ///
    /// Volumes will be provisioned in the availability zone associated
    /// with the corresponding subnet.
    ///
    /// When unspecified, it defaults to 8 GiB with the GP2 volume type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub main_volume: std::option::Option<crate::model::AwsVolumeTemplate>,

    /// Required. The ARN of the AWS KMS key used to encrypt cluster secrets.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_encryption: std::option::Option<crate::model::AwsDatabaseEncryption>,

    /// Optional. A set of AWS resource tags to propagate to all underlying managed
    /// AWS resources.
    ///
    /// Specify at most 50 pairs containing alphanumerics, spaces, and symbols
    /// (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to
    /// 255 Unicode characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Authentication configuration for management of AWS resources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_services_authentication: std::option::Option<crate::model::AwsServicesAuthentication>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AwsProxyConfig>,

    /// Required. Config encryption for user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_encryption: std::option::Option<crate::model::AwsConfigEncryption>,

    /// Optional. The placement to use on control plane instances.
    /// When unspecified, the VPC's default tenancy will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_placement: std::option::Option<crate::model::AwsInstancePlacement>,
}

impl AwsControlPlane {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AwsControlPlane::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::AwsControlPlane::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AwsControlPlane::ssh_config].
    pub fn set_ssh_config<
        T: std::convert::Into<std::option::Option<crate::model::AwsSshConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssh_config = v.into();
        self
    }

    /// Sets the value of [iam_instance_profile][crate::model::AwsControlPlane::iam_instance_profile].
    pub fn set_iam_instance_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.iam_instance_profile = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AwsControlPlane::root_volume].
    pub fn set_root_volume<
        T: std::convert::Into<std::option::Option<crate::model::AwsVolumeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.root_volume = v.into();
        self
    }

    /// Sets the value of [main_volume][crate::model::AwsControlPlane::main_volume].
    pub fn set_main_volume<
        T: std::convert::Into<std::option::Option<crate::model::AwsVolumeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.main_volume = v.into();
        self
    }

    /// Sets the value of [database_encryption][crate::model::AwsControlPlane::database_encryption].
    pub fn set_database_encryption<
        T: std::convert::Into<std::option::Option<crate::model::AwsDatabaseEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_encryption = v.into();
        self
    }

    /// Sets the value of [aws_services_authentication][crate::model::AwsControlPlane::aws_services_authentication].
    pub fn set_aws_services_authentication<
        T: std::convert::Into<std::option::Option<crate::model::AwsServicesAuthentication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aws_services_authentication = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::AwsControlPlane::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AwsProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }

    /// Sets the value of [config_encryption][crate::model::AwsControlPlane::config_encryption].
    pub fn set_config_encryption<
        T: std::convert::Into<std::option::Option<crate::model::AwsConfigEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_encryption = v.into();
        self
    }

    /// Sets the value of [instance_placement][crate::model::AwsControlPlane::instance_placement].
    pub fn set_instance_placement<
        T: std::convert::Into<std::option::Option<crate::model::AwsInstancePlacement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_placement = v.into();
        self
    }

    /// Sets the value of [subnet_ids][crate::model::AwsControlPlane::subnet_ids].
    pub fn set_subnet_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subnet_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_group_ids][crate::model::AwsControlPlane::security_group_ids].
    pub fn set_security_group_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.security_group_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AwsControlPlane::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AwsControlPlane {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsControlPlane"
    }
}

/// Authentication configuration for the management of AWS resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsServicesAuthentication {
    /// Required. The Amazon Resource Name (ARN) of the role that the Anthos
    /// Multi-Cloud API will assume when managing AWS resources on your account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role_arn: std::string::String,

    /// Optional. An identifier for the assumed role session.
    ///
    /// When unspecified, it defaults to `multicloud-service-agent`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role_session_name: std::string::String,
}

impl AwsServicesAuthentication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role_arn][crate::model::AwsServicesAuthentication::role_arn].
    pub fn set_role_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role_arn = v.into();
        self
    }

    /// Sets the value of [role_session_name][crate::model::AwsServicesAuthentication::role_session_name].
    pub fn set_role_session_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.role_session_name = v.into();
        self
    }
}

impl wkt::message::Message for AwsServicesAuthentication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsServicesAuthentication"
    }
}

/// Configuration related to the cluster RBAC settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAuthorization {
    /// Optional. Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
    /// to the users. Up to ten admin users can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admin_users: std::vec::Vec<crate::model::AwsClusterUser>,

    /// Optional. Groups of users that can perform operations as a cluster admin. A
    /// managed ClusterRoleBinding will be created to grant the `cluster-admin`
    /// ClusterRole to the groups. Up to ten admin groups can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admin_groups: std::vec::Vec<crate::model::AwsClusterGroup>,
}

impl AwsAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::AwsAuthorization::admin_users].
    pub fn set_admin_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsClusterUser>,
    {
        use std::iter::Iterator;
        self.admin_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin_groups][crate::model::AwsAuthorization::admin_groups].
    pub fn set_admin_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsClusterGroup>,
    {
        use std::iter::Iterator;
        self.admin_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsAuthorization"
    }
}

/// Identities of a user-type subject for AWS clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsClusterUser {
    /// Required. The name of the user, e.g. `my-gcp-id@gmail.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,
}

impl AwsClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::AwsClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterUser"
    }
}

/// Identities of a group-type subject for AWS clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsClusterGroup {
    /// Required. The name of the group, e.g. `my-group@domain.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,
}

impl AwsClusterGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AwsClusterGroup::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterGroup"
    }
}

/// Configuration related to application-layer secrets encryption.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsDatabaseEncryption {
    /// Required. The ARN of the AWS KMS key used to encrypt cluster secrets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_arn: std::string::String,
}

impl AwsDatabaseEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_arn][crate::model::AwsDatabaseEncryption::kms_key_arn].
    pub fn set_kms_key_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_arn = v.into();
        self
    }
}

impl wkt::message::Message for AwsDatabaseEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsDatabaseEncryption"
    }
}

/// Configuration template for AWS EBS volumes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsVolumeTemplate {
    /// Optional. The size of the volume, in GiBs.
    ///
    /// When unspecified, a default value is provided. See the specific reference
    /// in the parent resource.
    pub size_gib: i32,

    /// Optional. Type of the EBS volume.
    ///
    /// When unspecified, it defaults to GP2 volume.
    pub volume_type: crate::model::aws_volume_template::VolumeType,

    /// Optional. The number of I/O operations per second (IOPS) to provision for
    /// GP3 volume.
    pub iops: i32,

    /// Optional. The throughput that the volume supports, in MiB/s. Only valid if
    /// volume_type is GP3.
    ///
    /// If the volume_type is GP3 and this is not speficied, it defaults to 125.
    pub throughput: i32,

    /// Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK)
    /// used to encrypt AWS EBS volumes.
    ///
    /// If not specified, the default Amazon managed key associated to
    /// the AWS region where this cluster runs will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_arn: std::string::String,
}

impl AwsVolumeTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_gib][crate::model::AwsVolumeTemplate::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::AwsVolumeTemplate::volume_type].
    pub fn set_volume_type<T: std::convert::Into<crate::model::aws_volume_template::VolumeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type = v.into();
        self
    }

    /// Sets the value of [iops][crate::model::AwsVolumeTemplate::iops].
    pub fn set_iops<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.iops = v.into();
        self
    }

    /// Sets the value of [throughput][crate::model::AwsVolumeTemplate::throughput].
    pub fn set_throughput<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.throughput = v.into();
        self
    }

    /// Sets the value of [kms_key_arn][crate::model::AwsVolumeTemplate::kms_key_arn].
    pub fn set_kms_key_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_arn = v.into();
        self
    }
}

impl wkt::message::Message for AwsVolumeTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsVolumeTemplate"
    }
}

/// Defines additional types related to AwsVolumeTemplate
pub mod aws_volume_template {
    #[allow(unused_imports)]
    use super::*;

    /// Types of supported EBS volumes. We currently only support GP2 or GP3
    /// volumes.
    /// See <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>
    /// for more information.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VolumeType(i32);

    impl VolumeType {
        /// Not set.
        pub const VOLUME_TYPE_UNSPECIFIED: VolumeType = VolumeType::new(0);

        /// GP2 (General Purpose SSD volume type).
        pub const GP2: VolumeType = VolumeType::new(1);

        /// GP3 (General Purpose SSD volume type).
        pub const GP3: VolumeType = VolumeType::new(2);

        /// Creates a new VolumeType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VOLUME_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GP2"),
                2 => std::borrow::Cow::Borrowed("GP3"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VOLUME_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::VOLUME_TYPE_UNSPECIFIED)
                }
                "GP2" => std::option::Option::Some(Self::GP2),
                "GP3" => std::option::Option::Some(Self::GP3),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for VolumeType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for VolumeType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ClusterNetworking defines cluster-wide networking configuration.
///
/// Anthos clusters on AWS run on a single VPC. This includes control
/// plane replicas and node pool nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsClusterNetworking {
    /// Required. The VPC associated with the cluster. All component clusters
    /// (i.e. control plane and node pools) run on a single VPC.
    ///
    /// This field cannot be changed after creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_id: std::string::String,

    /// Required. All pods in the cluster are assigned an IPv4 address from these
    /// ranges. Only a single range is supported. This field cannot be changed
    /// after creation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pod_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. All services in the cluster are assigned an IPv4 address from
    /// these ranges. Only a single range is supported. This field cannot be
    /// changed after creation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Optional. Disable the per node pool subnet security group rules on the
    /// control plane security group. When set to true, you must also provide one
    /// or more security groups that ensure node pools are able to send requests to
    /// the control plane on TCP/443 and TCP/8132. Failure to do so may result in
    /// unavailable node pools.
    pub per_node_pool_sg_rules_disabled: bool,
}

impl AwsClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc_id][crate::model::AwsClusterNetworking::vpc_id].
    pub fn set_vpc_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_id = v.into();
        self
    }

    /// Sets the value of [per_node_pool_sg_rules_disabled][crate::model::AwsClusterNetworking::per_node_pool_sg_rules_disabled].
    pub fn set_per_node_pool_sg_rules_disabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.per_node_pool_sg_rules_disabled = v.into();
        self
    }

    /// Sets the value of [pod_address_cidr_blocks][crate::model::AwsClusterNetworking::pod_address_cidr_blocks].
    pub fn set_pod_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_address_cidr_blocks][crate::model::AwsClusterNetworking::service_address_cidr_blocks].
    pub fn set_service_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterNetworking"
    }
}

/// An Anthos node pool running on AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsNodePool {
    /// The name of this resource.
    ///
    /// Node pool names are formatted as
    /// `projects/<project-number>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// For more details on Google Cloud resource names,
    /// see [Resource Names](https://cloud.google.com/apis/design/resource_names)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The Kubernetes version to run on this node pool (e.g.
    /// `1.19.10-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAwsServerConfig][google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.GetAwsServerConfig]: crate::client::AwsClusters::get_aws_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Required. The configuration of the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::AwsNodeConfig>,

    /// Required. Autoscaler configuration for this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling: std::option::Option<crate::model::AwsNodePoolAutoscaling>,

    /// Required. The subnet where the node pool node run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_id: std::string::String,

    /// Output only. The lifecycle state of the node pool.
    pub state: crate::model::aws_node_pool::State,

    /// Output only. A globally unique identifier for the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the node
    /// pool.
    pub reconciling: bool,

    /// Output only. The time at which this node pool was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this node pool was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Annotations on the node pool.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Output only. A set of errors found in the node pool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::AwsNodePoolError>,

    /// Optional. The Management configuration for this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management: std::option::Option<crate::model::AwsNodeManagement>,

    /// Optional. Node kubelet configs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// Optional. Update settings control the speed and disruption of the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_settings: std::option::Option<crate::model::UpdateSettings>,
}

impl AwsNodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AwsNodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AwsNodePool::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [config][crate::model::AwsNodePool::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::AwsNodeConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::AwsNodePool::autoscaling].
    pub fn set_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::AwsNodePoolAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling = v.into();
        self
    }

    /// Sets the value of [subnet_id][crate::model::AwsNodePool::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AwsNodePool::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_node_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AwsNodePool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AwsNodePool::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AwsNodePool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AwsNodePool::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AwsNodePool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [max_pods_constraint][crate::model::AwsNodePool::max_pods_constraint].
    pub fn set_max_pods_constraint<
        T: std::convert::Into<std::option::Option<crate::model::MaxPodsConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.max_pods_constraint = v.into();
        self
    }

    /// Sets the value of [management][crate::model::AwsNodePool::management].
    pub fn set_management<
        T: std::convert::Into<std::option::Option<crate::model::AwsNodeManagement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management = v.into();
        self
    }

    /// Sets the value of [kubelet_config][crate::model::AwsNodePool::kubelet_config].
    pub fn set_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kubelet_config = v.into();
        self
    }

    /// Sets the value of [update_settings][crate::model::AwsNodePool::update_settings].
    pub fn set_update_settings<
        T: std::convert::Into<std::option::Option<crate::model::UpdateSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.update_settings = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::AwsNodePool::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsNodePoolError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::AwsNodePool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AwsNodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodePool"
    }
}

/// Defines additional types related to AwsNodePool
pub mod aws_node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the node pool.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The PROVISIONING state indicates the node pool is being created.
        pub const PROVISIONING: State = State::new(1);

        /// The RUNNING state indicates the node pool has been created
        /// and is fully usable.
        pub const RUNNING: State = State::new(2);

        /// The RECONCILING state indicates that the node pool is being reconciled.
        pub const RECONCILING: State = State::new(3);

        /// The STOPPING state indicates the node pool is being deleted.
        pub const STOPPING: State = State::new(4);

        /// The ERROR state indicates the node pool is in a broken unrecoverable
        /// state.
        pub const ERROR: State = State::new(5);

        /// The DEGRADED state indicates the node pool requires user action to
        /// restore full functionality.
        pub const DEGRADED: State = State::new(6);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("RECONCILING"),
                4 => std::borrow::Cow::Borrowed("STOPPING"),
                5 => std::borrow::Cow::Borrowed("ERROR"),
                6 => std::borrow::Cow::Borrowed("DEGRADED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "RECONCILING" => std::option::Option::Some(Self::RECONCILING),
                "STOPPING" => std::option::Option::Some(Self::STOPPING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "DEGRADED" => std::option::Option::Some(Self::DEGRADED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// UpdateSettings control the level of parallelism and the level of
/// disruption caused during the update of a node pool.
///
/// These settings are applicable when the node pool update requires replacing
/// the existing node pool nodes with the updated ones.
///
/// UpdateSettings are optional. When UpdateSettings are not specified during the
/// node pool creation, a default is chosen based on the parent cluster's
/// version. For clusters with minor version 1.27 and later, a default
/// surge_settings configuration with max_surge = 1 and max_unavailable = 0 is
/// used. For clusters with older versions, node pool updates use the traditional
/// rolling update mechanism of updating one node at a time in a
/// "terminate before create" fashion and update_settings is not applicable.
///
/// Set the surge_settings parameter to use the Surge Update mechanism for
/// the rolling update of node pool nodes.
///
/// . max_surge controls the number of additional nodes that can be created
///   beyond the current size of the node pool temporarily for the time of the
///   update to increase the number of available nodes.
/// . max_unavailable controls the number of nodes that can be simultaneously
///   unavailable during the update.
/// . (max_surge + max_unavailable) determines the level of parallelism (i.e.,
///   the number of nodes being updated at the same time).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSettings {
    /// Optional. Settings for surge update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub surge_settings: std::option::Option<crate::model::SurgeSettings>,
}

impl UpdateSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [surge_settings][crate::model::UpdateSettings::surge_settings].
    pub fn set_surge_settings<
        T: std::convert::Into<std::option::Option<crate::model::SurgeSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.surge_settings = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateSettings"
    }
}

/// SurgeSettings contains the parameters for Surge update.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SurgeSettings {
    /// Optional. The maximum number of nodes that can be created beyond the
    /// current size of the node pool during the update process.
    pub max_surge: i32,

    /// Optional. The maximum number of nodes that can be simultaneously
    /// unavailable during the update process. A node is considered unavailable if
    /// its status is not Ready.
    pub max_unavailable: i32,
}

impl SurgeSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_surge][crate::model::SurgeSettings::max_surge].
    pub fn set_max_surge<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_surge = v.into();
        self
    }

    /// Sets the value of [max_unavailable][crate::model::SurgeSettings::max_unavailable].
    pub fn set_max_unavailable<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_unavailable = v.into();
        self
    }
}

impl wkt::message::Message for SurgeSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.SurgeSettings"
    }
}

/// AwsNodeManagement defines the set of node management features turned on for
/// an AWS node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsNodeManagement {
    /// Optional. Whether or not the nodes will be automatically repaired. When set
    /// to true, the nodes in this node pool will be monitored and if they fail
    /// health checks consistently over a period of time, an automatic repair
    /// action will be triggered to replace them with new nodes.
    pub auto_repair: bool,
}

impl AwsNodeManagement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_repair][crate::model::AwsNodeManagement::auto_repair].
    pub fn set_auto_repair<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_repair = v.into();
        self
    }
}

impl wkt::message::Message for AwsNodeManagement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodeManagement"
    }
}

/// Parameters that describe the nodes in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsNodeConfig {
    /// Optional. The EC2 instance type when creating on-Demand instances.
    ///
    /// If unspecified during node pool creation, a default will be chosen based on
    /// the node pool version, and assigned to this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_type: std::string::String,

    /// Optional. Template for the root volume provisioned for node pool nodes.
    /// Volumes will be provisioned in the availability zone assigned
    /// to the node pool subnet.
    ///
    /// When unspecified, it defaults to 32 GiB with the GP2 volume type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub root_volume: std::option::Option<crate::model::AwsVolumeTemplate>,

    /// Optional. The initial taints assigned to nodes of this node pool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    /// Optional. The initial labels assigned to nodes of this node pool. An object
    /// containing a list of "key": value pairs. Example: { "name": "wrench",
    /// "mass": "1.3kg", "count": "3" }.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Key/value metadata to assign to each underlying AWS resource.
    /// Specify at most 50 pairs containing alphanumerics, spaces, and symbols
    /// (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to
    /// 255 Unicode characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The name or ARN of the AWS IAM instance profile to assign to
    /// nodes in the pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub iam_instance_profile: std::string::String,

    /// Optional. The OS image type to use on node pool instances.
    /// Can be unspecified, or have a value of `ubuntu`.
    ///
    /// When unspecified, it defaults to `ubuntu`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_type: std::string::String,

    /// Optional. The SSH configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssh_config: std::option::Option<crate::model::AwsSshConfig>,

    /// Optional. The IDs of additional security groups to add to nodes in this
    /// pool. The manager will automatically create security groups with minimum
    /// rules needed for a functioning cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub security_group_ids: std::vec::Vec<std::string::String>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AwsProxyConfig>,

    /// Required. Config encryption for user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_encryption: std::option::Option<crate::model::AwsConfigEncryption>,

    /// Optional. Placement related info for this node.
    /// When unspecified, the VPC's default tenancy will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_placement: std::option::Option<crate::model::AwsInstancePlacement>,

    /// Optional. Configuration related to CloudWatch metrics collection on the
    /// Auto Scaling group of the node pool.
    ///
    /// When unspecified, metrics collection is disabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_metrics_collection:
        std::option::Option<crate::model::AwsAutoscalingGroupMetricsCollection>,

    /// Optional. Configuration for provisioning EC2 Spot instances
    ///
    /// When specified, the node pool will provision Spot instances from the set
    /// of spot_config.instance_types.
    /// This field is mutually exclusive with `instance_type`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spot_config: std::option::Option<crate::model::SpotConfig>,
}

impl AwsNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_type][crate::model::AwsNodeConfig::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AwsNodeConfig::root_volume].
    pub fn set_root_volume<
        T: std::convert::Into<std::option::Option<crate::model::AwsVolumeTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.root_volume = v.into();
        self
    }

    /// Sets the value of [iam_instance_profile][crate::model::AwsNodeConfig::iam_instance_profile].
    pub fn set_iam_instance_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.iam_instance_profile = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::AwsNodeConfig::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AwsNodeConfig::ssh_config].
    pub fn set_ssh_config<
        T: std::convert::Into<std::option::Option<crate::model::AwsSshConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssh_config = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::AwsNodeConfig::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AwsProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }

    /// Sets the value of [config_encryption][crate::model::AwsNodeConfig::config_encryption].
    pub fn set_config_encryption<
        T: std::convert::Into<std::option::Option<crate::model::AwsConfigEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_encryption = v.into();
        self
    }

    /// Sets the value of [instance_placement][crate::model::AwsNodeConfig::instance_placement].
    pub fn set_instance_placement<
        T: std::convert::Into<std::option::Option<crate::model::AwsInstancePlacement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_placement = v.into();
        self
    }

    /// Sets the value of [autoscaling_metrics_collection][crate::model::AwsNodeConfig::autoscaling_metrics_collection].
    pub fn set_autoscaling_metrics_collection<
        T: std::convert::Into<std::option::Option<crate::model::AwsAutoscalingGroupMetricsCollection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_metrics_collection = v.into();
        self
    }

    /// Sets the value of [spot_config][crate::model::AwsNodeConfig::spot_config].
    pub fn set_spot_config<T: std::convert::Into<std::option::Option<crate::model::SpotConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spot_config = v.into();
        self
    }

    /// Sets the value of [taints][crate::model::AwsNodeConfig::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_group_ids][crate::model::AwsNodeConfig::security_group_ids].
    pub fn set_security_group_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.security_group_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AwsNodeConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AwsNodeConfig::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AwsNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodeConfig"
    }
}

/// AwsNodePoolAutoscaling contains information required by cluster autoscaler
/// to adjust the size of the node pool to the current cluster usage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsNodePoolAutoscaling {
    /// Required. Minimum number of nodes in the node pool. Must be greater than or
    /// equal to 1 and less than or equal to max_node_count.
    pub min_node_count: i32,

    /// Required. Maximum number of nodes in the node pool. Must be greater than or
    /// equal to min_node_count and less than or equal to 50.
    pub max_node_count: i32,
}

impl AwsNodePoolAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_node_count][crate::model::AwsNodePoolAutoscaling::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::AwsNodePoolAutoscaling::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for AwsNodePoolAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodePoolAutoscaling"
    }
}

/// AwsOpenIdConfig is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsOpenIdConfig {
    /// OIDC Issuer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issuer: std::string::String,

    /// JSON Web Key uri.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub jwks_uri: std::string::String,

    /// Supported response types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub response_types_supported: std::vec::Vec<std::string::String>,

    /// Supported subject types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject_types_supported: std::vec::Vec<std::string::String>,

    /// supported ID Token signing Algorithms.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub id_token_signing_alg_values_supported: std::vec::Vec<std::string::String>,

    /// Supported claims.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub claims_supported: std::vec::Vec<std::string::String>,

    /// Supported grant types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grant_types: std::vec::Vec<std::string::String>,
}

impl AwsOpenIdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer][crate::model::AwsOpenIdConfig::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [jwks_uri][crate::model::AwsOpenIdConfig::jwks_uri].
    pub fn set_jwks_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.jwks_uri = v.into();
        self
    }

    /// Sets the value of [response_types_supported][crate::model::AwsOpenIdConfig::response_types_supported].
    pub fn set_response_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.response_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subject_types_supported][crate::model::AwsOpenIdConfig::subject_types_supported].
    pub fn set_subject_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id_token_signing_alg_values_supported][crate::model::AwsOpenIdConfig::id_token_signing_alg_values_supported].
    pub fn set_id_token_signing_alg_values_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_token_signing_alg_values_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims_supported][crate::model::AwsOpenIdConfig::claims_supported].
    pub fn set_claims_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.claims_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grant_types][crate::model::AwsOpenIdConfig::grant_types].
    pub fn set_grant_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grant_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsOpenIdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsOpenIdConfig"
    }
}

/// AwsJsonWebKeys is a valid JSON Web Key Set as specififed in RFC 7517.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsJsonWebKeys {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub keys: std::vec::Vec<crate::model::Jwk>,
}

impl AwsJsonWebKeys {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::AwsJsonWebKeys::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwk>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsJsonWebKeys {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsJsonWebKeys"
    }
}

/// AwsServerConfig is the configuration of GKE cluster on AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsServerConfig {
    /// The resource name of the config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// List of all released Kubernetes versions, including ones which are end of
    /// life and can no longer be used.  Filter by the `enabled`
    /// property to limit to currently available versions.
    /// Valid versions supported for both create and update operations
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub valid_versions: std::vec::Vec<crate::model::AwsK8sVersionInfo>,

    /// The list of supported AWS regions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_aws_regions: std::vec::Vec<std::string::String>,
}

impl AwsServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AwsServerConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [valid_versions][crate::model::AwsServerConfig::valid_versions].
    pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsK8sVersionInfo>,
    {
        use std::iter::Iterator;
        self.valid_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_aws_regions][crate::model::AwsServerConfig::supported_aws_regions].
    pub fn set_supported_aws_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_aws_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsServerConfig"
    }
}

/// Kubernetes version information of GKE cluster on AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsK8sVersionInfo {
    /// Kubernetes version name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional. True if the version is available for cluster creation. If a
    /// version is enabled for creation, it can be used to create new clusters.
    /// Otherwise, cluster creation will fail. However, cluster upgrade operations
    /// may succeed, even if the version is not enabled.
    pub enabled: bool,

    /// Optional. True if this cluster version belongs to a minor version that has
    /// reached its end of life and is no longer in scope to receive security and
    /// bug fixes.
    pub end_of_life: bool,

    /// Optional. The estimated date (in Pacific Time) when this cluster version
    /// will reach its end of life. Or if this version is no longer supported (the
    /// `end_of_life` field is true), this is the actual date (in Pacific time)
    /// when the version reached its end of life.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_of_life_date: std::option::Option<gtype::model::Date>,

    /// Optional. The date (in Pacific Time) when the cluster version was released.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release_date: std::option::Option<gtype::model::Date>,
}

impl AwsK8sVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AwsK8sVersionInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::AwsK8sVersionInfo::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [end_of_life][crate::model::AwsK8sVersionInfo::end_of_life].
    pub fn set_end_of_life<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.end_of_life = v.into();
        self
    }

    /// Sets the value of [end_of_life_date][crate::model::AwsK8sVersionInfo::end_of_life_date].
    pub fn set_end_of_life_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_of_life_date = v.into();
        self
    }

    /// Sets the value of [release_date][crate::model::AwsK8sVersionInfo::release_date].
    pub fn set_release_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_date = v.into();
        self
    }
}

impl wkt::message::Message for AwsK8sVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsK8sVersionInfo"
    }
}

/// SSH configuration for AWS resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsSshConfig {
    /// Required. The name of the EC2 key pair used to login into cluster machines.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ec2_key_pair: std::string::String,
}

impl AwsSshConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ec2_key_pair][crate::model::AwsSshConfig::ec2_key_pair].
    pub fn set_ec2_key_pair<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ec2_key_pair = v.into();
        self
    }
}

impl wkt::message::Message for AwsSshConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsSshConfig"
    }
}

/// Details of a proxy config stored in AWS Secret Manager.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsProxyConfig {
    /// The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy
    /// configuration.
    ///
    /// The secret must be a JSON encoded proxy configuration
    /// as described in
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/aws/how-to/use-a-proxy#create_a_proxy_configuration_file>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_arn: std::string::String,

    /// The version string of the AWS Secret Manager secret that contains the
    /// HTTP(S) proxy configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_version: std::string::String,
}

impl AwsProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_arn][crate::model::AwsProxyConfig::secret_arn].
    pub fn set_secret_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_arn = v.into();
        self
    }

    /// Sets the value of [secret_version][crate::model::AwsProxyConfig::secret_version].
    pub fn set_secret_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_version = v.into();
        self
    }
}

impl wkt::message::Message for AwsProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsProxyConfig"
    }
}

/// Config encryption for user data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsConfigEncryption {
    /// Required. The ARN of the AWS KMS key used to encrypt user data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_arn: std::string::String,
}

impl AwsConfigEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_arn][crate::model::AwsConfigEncryption::kms_key_arn].
    pub fn set_kms_key_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_arn = v.into();
        self
    }
}

impl wkt::message::Message for AwsConfigEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsConfigEncryption"
    }
}

/// Details of placement information for an instance.
/// Limitations for using the `host` tenancy:
///
/// * T3 instances that use the unlimited CPU credit option don't support host
///   tenancy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsInstancePlacement {
    /// Required. The tenancy for instance.
    pub tenancy: crate::model::aws_instance_placement::Tenancy,
}

impl AwsInstancePlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenancy][crate::model::AwsInstancePlacement::tenancy].
    pub fn set_tenancy<T: std::convert::Into<crate::model::aws_instance_placement::Tenancy>>(
        mut self,
        v: T,
    ) -> Self {
        self.tenancy = v.into();
        self
    }
}

impl wkt::message::Message for AwsInstancePlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsInstancePlacement"
    }
}

/// Defines additional types related to AwsInstancePlacement
pub mod aws_instance_placement {
    #[allow(unused_imports)]
    use super::*;

    /// Tenancy defines how EC2 instances are distributed across physical hardware.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Tenancy(i32);

    impl Tenancy {
        /// Not set.
        pub const TENANCY_UNSPECIFIED: Tenancy = Tenancy::new(0);

        /// Use default VPC tenancy.
        pub const DEFAULT: Tenancy = Tenancy::new(1);

        /// Run a dedicated instance.
        pub const DEDICATED: Tenancy = Tenancy::new(2);

        /// Launch this instance to a dedicated host.
        pub const HOST: Tenancy = Tenancy::new(3);

        /// Creates a new Tenancy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TENANCY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DEFAULT"),
                2 => std::borrow::Cow::Borrowed("DEDICATED"),
                3 => std::borrow::Cow::Borrowed("HOST"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TENANCY_UNSPECIFIED" => std::option::Option::Some(Self::TENANCY_UNSPECIFIED),
                "DEFAULT" => std::option::Option::Some(Self::DEFAULT),
                "DEDICATED" => std::option::Option::Some(Self::DEDICATED),
                "HOST" => std::option::Option::Some(Self::HOST),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Tenancy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Tenancy {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration related to CloudWatch metrics collection in an AWS
/// Auto Scaling group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAutoscalingGroupMetricsCollection {
    /// Required. The frequency at which EC2 Auto Scaling sends aggregated data to
    /// AWS CloudWatch. The only valid value is "1Minute".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub granularity: std::string::String,

    /// Optional. The metrics to enable. For a list of valid metrics, see
    /// <https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_EnableMetricsCollection.html>.
    /// If you specify Granularity and don't specify any metrics, all metrics are
    /// enabled.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<std::string::String>,
}

impl AwsAutoscalingGroupMetricsCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [granularity][crate::model::AwsAutoscalingGroupMetricsCollection::granularity].
    pub fn set_granularity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.granularity = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::AwsAutoscalingGroupMetricsCollection::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsAutoscalingGroupMetricsCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsAutoscalingGroupMetricsCollection"
    }
}

/// SpotConfig has configuration info for Spot node.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpotConfig {
    /// Required. A list of instance types for creating spot node pool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_types: std::vec::Vec<std::string::String>,
}

impl SpotConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_types][crate::model::SpotConfig::instance_types].
    pub fn set_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpotConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.SpotConfig"
    }
}

/// AwsClusterError describes errors found on AWS clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsClusterError {
    /// Human-friendly description of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl AwsClusterError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AwsClusterError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AwsClusterError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsClusterError"
    }
}

/// AwsNodePoolError describes errors found on AWS node pools.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsNodePoolError {
    /// Human-friendly description of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl AwsNodePoolError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AwsNodePoolError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AwsNodePoolError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AwsNodePoolError"
    }
}

/// Request message for `AwsClusters.CreateAwsCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAwsClusterRequest {
    /// Required. The parent location where this
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource will be
    /// created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_cluster: std::option::Option<crate::model::AwsCluster>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_cluster_id: std::string::String,

    /// If set, only validate the request, but do not actually create the cluster.
    pub validate_only: bool,
}

impl CreateAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAwsClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aws_cluster][crate::model::CreateAwsClusterRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::option::Option<crate::model::AwsCluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aws_cluster = v.into();
        self
    }

    /// Sets the value of [aws_cluster_id][crate::model::CreateAwsClusterRequest::aws_cluster_id].
    pub fn set_aws_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAwsClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAwsClusterRequest"
    }
}

/// Request message for `AwsClusters.UpdateAwsCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAwsClusterRequest {
    /// Required. The [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_cluster: std::option::Option<crate::model::AwsCluster>,

    /// If set, only validate the request, but do not actually update the cluster.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster]:
    ///
    /// * `description`.
    /// * `annotations`.
    /// * `control_plane.version`.
    /// * `authorization.admin_users`.
    /// * `authorization.admin_groups`.
    /// * `binary_authorization.evaluation_mode`.
    /// * `control_plane.aws_services_authentication.role_arn`.
    /// * `control_plane.aws_services_authentication.role_session_name`.
    /// * `control_plane.config_encryption.kms_key_arn`.
    /// * `control_plane.instance_type`.
    /// * `control_plane.security_group_ids`.
    /// * `control_plane.proxy_config`.
    /// * `control_plane.proxy_config.secret_arn`.
    /// * `control_plane.proxy_config.secret_version`.
    /// * `control_plane.root_volume.size_gib`.
    /// * `control_plane.root_volume.volume_type`.
    /// * `control_plane.root_volume.iops`.
    /// * `control_plane.root_volume.throughput`.
    /// * `control_plane.root_volume.kms_key_arn`.
    /// * `control_plane.ssh_config`.
    /// * `control_plane.ssh_config.ec2_key_pair`.
    /// * `control_plane.instance_placement.tenancy`.
    /// * `control_plane.iam_instance_profile`.
    /// * `logging_config.component_config.enable_components`.
    /// * `control_plane.tags`.
    /// * `monitoring_config.managed_prometheus_config.enabled`.
    /// * `networking.per_node_pool_sg_rules_disabled`.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::UpdateAwsClusterRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::option::Option<crate::model::AwsCluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aws_cluster = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAwsClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAwsClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAwsClusterRequest"
    }
}

/// Request message for `AwsClusters.GetAwsCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAwsClusterRequest {
    /// Required. The name of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource to
    /// describe.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAwsClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsClusterRequest"
    }
}

/// Request message for `AwsClusters.ListAwsClusters` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAwsClustersRequest {
    /// Required. The parent location which owns this collection of
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAwsClustersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAwsClustersResponse.next_page_token]: crate::model::ListAwsClustersResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [awsClusters.list][google.cloud.gkemulticloud.v1.AwsClusters.ListAwsClusters]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.ListAwsClusters]: crate::client::AwsClusters::list_aws_clusters
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAwsClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAwsClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAwsClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAwsClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAwsClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsClustersRequest"
    }
}

/// Response message for `AwsClusters.ListAwsClusters` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAwsClustersResponse {
    /// A list of [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resources
    /// in the specified Google Cloud Platform project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aws_clusters: std::vec::Vec<crate::model::AwsCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAwsClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAwsClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [aws_clusters][crate::model::ListAwsClustersResponse::aws_clusters].
    pub fn set_aws_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsCluster>,
    {
        use std::iter::Iterator;
        self.aws_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAwsClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsClustersResponse"
    }
}

impl gax::paginator::PageableResponse for ListAwsClustersResponse {
    type PageItem = crate::model::AwsCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.aws_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AwsClusters.DeleteAwsCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAwsClusterRequest {
    /// Required. The resource name the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] to delete.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// Optional. If set to true, the deletion of
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource will
    /// succeed even if errors occur during deleting in cluster resources. Using
    /// this parameter may result in orphaned resources in the cluster.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    pub ignore_errors: bool,

    /// The current etag of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided etag does not match the current etag of the cluster,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteAwsClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAwsClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAwsClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAwsClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAwsClusterRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAwsClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAwsClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAwsClusterRequest"
    }
}

/// Response message for `AwsClusters.CreateAwsNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAwsNodePoolRequest {
    /// Required. The [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster]
    /// resource where this node pool will be created.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_node_pool: std::option::Option<crate::model::AwsNodePool>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_node_pool_id: std::string::String,

    /// If set, only validate the request, but do not actually create the node
    /// pool.
    pub validate_only: bool,
}

impl CreateAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAwsNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aws_node_pool][crate::model::CreateAwsNodePoolRequest::aws_node_pool].
    pub fn set_aws_node_pool<
        T: std::convert::Into<std::option::Option<crate::model::AwsNodePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aws_node_pool = v.into();
        self
    }

    /// Sets the value of [aws_node_pool_id][crate::model::CreateAwsNodePoolRequest::aws_node_pool_id].
    pub fn set_aws_node_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.aws_node_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAwsNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAwsNodePoolRequest"
    }
}

/// Request message for `AwsClusters.UpdateAwsNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAwsNodePoolRequest {
    /// Required. The [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aws_node_pool: std::option::Option<crate::model::AwsNodePool>,

    /// If set, only validate the request, but don't actually update the node pool.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool]:
    ///
    /// * `annotations`.
    /// * `version`.
    /// * `autoscaling.min_node_count`.
    /// * `autoscaling.max_node_count`.
    /// * `config.config_encryption.kms_key_arn`.
    /// * `config.security_group_ids`.
    /// * `config.root_volume.iops`.
    /// * `config.root_volume.throughput`.
    /// * `config.root_volume.kms_key_arn`.
    /// * `config.root_volume.volume_type`.
    /// * `config.root_volume.size_gib`.
    /// * `config.proxy_config`.
    /// * `config.proxy_config.secret_arn`.
    /// * `config.proxy_config.secret_version`.
    /// * `config.ssh_config`.
    /// * `config.ssh_config.ec2_key_pair`.
    /// * `config.instance_placement.tenancy`.
    /// * `config.iam_instance_profile`.
    /// * `config.labels`.
    /// * `config.tags`.
    /// * `config.autoscaling_metrics_collection`.
    /// * `config.autoscaling_metrics_collection.granularity`.
    /// * `config.autoscaling_metrics_collection.metrics`.
    /// * `config.instance_type`.
    /// * `management.auto_repair`.
    /// * `management`.
    /// * `update_settings`.
    /// * `update_settings.surge_settings`.
    /// * `update_settings.surge_settings.max_surge`.
    /// * `update_settings.surge_settings.max_unavailable`.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_node_pool][crate::model::UpdateAwsNodePoolRequest::aws_node_pool].
    pub fn set_aws_node_pool<
        T: std::convert::Into<std::option::Option<crate::model::AwsNodePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aws_node_pool = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAwsNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAwsNodePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAwsNodePoolRequest"
    }
}

/// Request message for `AwsClusters.RollbackAwsNodePoolUpdate` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackAwsNodePoolUpdateRequest {
    /// Required. The name of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource to
    /// rollback.
    ///
    /// `AwsNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Option for rollback to ignore the PodDisruptionBudget when
    /// draining the node pool nodes. Default value is false.
    pub respect_pdb: bool,
}

impl RollbackAwsNodePoolUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackAwsNodePoolUpdateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [respect_pdb][crate::model::RollbackAwsNodePoolUpdateRequest::respect_pdb].
    pub fn set_respect_pdb<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.respect_pdb = v.into();
        self
    }
}

impl wkt::message::Message for RollbackAwsNodePoolUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.RollbackAwsNodePoolUpdateRequest"
    }
}

/// Request message for `AwsClusters.GetAwsNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAwsNodePoolRequest {
    /// Required. The name of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource to
    /// describe.
    ///
    /// `AwsNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAwsNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsNodePoolRequest"
    }
}

/// Request message for `AwsClusters.ListAwsNodePools` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAwsNodePoolsRequest {
    /// Required. The parent `AwsCluster` which owns this collection of
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resources.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAwsNodePoolsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAwsNodePoolsResponse.next_page_token]: crate::model::ListAwsNodePoolsResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [awsNodePools.list][google.cloud.gkemulticloud.v1.AwsClusters.ListAwsNodePools]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsClusters.ListAwsNodePools]: crate::client::AwsClusters::list_aws_node_pools
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAwsNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAwsNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAwsNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAwsNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAwsNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsNodePoolsRequest"
    }
}

/// Response message for `AwsClusters.ListAwsNodePools` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAwsNodePoolsResponse {
    /// A list of [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool]
    /// resources in the specified `AwsCluster`.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aws_node_pools: std::vec::Vec<crate::model::AwsNodePool>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAwsNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAwsNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [aws_node_pools][crate::model::ListAwsNodePoolsResponse::aws_node_pools].
    pub fn set_aws_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsNodePool>,
    {
        use std::iter::Iterator;
        self.aws_node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAwsNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAwsNodePoolsResponse"
    }
}

impl gax::paginator::PageableResponse for ListAwsNodePoolsResponse {
    type PageItem = crate::model::AwsNodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.aws_node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AwsClusters.DeleteAwsNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAwsNodePoolRequest {
    /// Required. The resource name the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] to delete.
    ///
    /// `AwsNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>/awsNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the node
    /// pool.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// Optional. If set to true, the deletion of
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool] resource will
    /// succeed even if errors occur during deleting in node pool resources. Using
    /// this parameter may result in orphaned resources in the node pool.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    pub ignore_errors: bool,

    /// The current ETag of the
    /// [AwsNodePool][google.cloud.gkemulticloud.v1.AwsNodePool].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided ETag does not match the current etag of the node pool,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsNodePool]: crate::model::AwsNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteAwsNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAwsNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAwsNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAwsNodePoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAwsNodePoolRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAwsNodePoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAwsNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAwsNodePoolRequest"
    }
}

/// GetAwsOpenIdConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAwsOpenIdConfigRequest {
    /// Required. The AwsCluster, which owns the OIDC discovery document.
    /// Format:
    /// projects/{project}/locations/{location}/awsClusters/{cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_cluster: std::string::String,
}

impl GetAwsOpenIdConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GetAwsOpenIdConfigRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsOpenIdConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsOpenIdConfigRequest"
    }
}

/// GetAwsJsonWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAwsJsonWebKeysRequest {
    /// Required. The AwsCluster, which owns the JsonWebKeys.
    /// Format:
    /// projects/{project}/locations/{location}/awsClusters/{cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_cluster: std::string::String,
}

impl GetAwsJsonWebKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GetAwsJsonWebKeysRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsJsonWebKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsJsonWebKeysRequest"
    }
}

/// GetAwsServerConfigRequest gets the server config of GKE cluster on AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAwsServerConfigRequest {
    /// Required. The name of the
    /// [AwsServerConfig][google.cloud.gkemulticloud.v1.AwsServerConfig] resource
    /// to describe.
    ///
    /// `AwsServerConfig` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsServerConfig]: crate::model::AwsServerConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAwsServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAwsServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAwsServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAwsServerConfigRequest"
    }
}

/// Request message for `AwsClusters.GenerateAwsAccessToken` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAwsAccessTokenRequest {
    /// Required. The name of the
    /// [AwsCluster][google.cloud.gkemulticloud.v1.AwsCluster] resource to
    /// authenticate to.
    ///
    /// `AwsCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/awsClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AwsCluster]: crate::model::AwsCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_cluster: std::string::String,
}

impl GenerateAwsAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GenerateAwsAccessTokenRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsAccessTokenRequest"
    }
}

/// Response message for `AwsClusters.GenerateAwsAccessToken` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAwsAccessTokenResponse {
    /// Output only. Access token to authenticate to k8s api-server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,
}

impl GenerateAwsAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAwsAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::GenerateAwsAccessTokenResponse::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsAccessTokenResponse"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAwsClusterAgentTokenRequest {
    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_cluster: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_token: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_token_type: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_pool_id: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub grant_type: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audience: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scope: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub requested_token_type: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub options: std::string::String,
}

impl GenerateAwsClusterAgentTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_cluster][crate::model::GenerateAwsClusterAgentTokenRequest::aws_cluster].
    pub fn set_aws_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_cluster = v.into();
        self
    }

    /// Sets the value of [subject_token][crate::model::GenerateAwsClusterAgentTokenRequest::subject_token].
    pub fn set_subject_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_token = v.into();
        self
    }

    /// Sets the value of [subject_token_type][crate::model::GenerateAwsClusterAgentTokenRequest::subject_token_type].
    pub fn set_subject_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_token_type = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenerateAwsClusterAgentTokenRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::GenerateAwsClusterAgentTokenRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [grant_type][crate::model::GenerateAwsClusterAgentTokenRequest::grant_type].
    pub fn set_grant_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grant_type = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::GenerateAwsClusterAgentTokenRequest::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::GenerateAwsClusterAgentTokenRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [requested_token_type][crate::model::GenerateAwsClusterAgentTokenRequest::requested_token_type].
    pub fn set_requested_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_token_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::GenerateAwsClusterAgentTokenRequest::options].
    pub fn set_options<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.options = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsClusterAgentTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsClusterAgentTokenRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAwsClusterAgentTokenResponse {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    pub expires_in: i32,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token_type: std::string::String,
}

impl GenerateAwsClusterAgentTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAwsClusterAgentTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expires_in][crate::model::GenerateAwsClusterAgentTokenResponse::expires_in].
    pub fn set_expires_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expires_in = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::GenerateAwsClusterAgentTokenResponse::token_type].
    pub fn set_token_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAwsClusterAgentTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAwsClusterAgentTokenResponse"
    }
}

/// An Anthos cluster running on Azure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureCluster {
    /// The name of this resource.
    ///
    /// Cluster names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human readable description of this cluster.
    /// Cannot be longer than 255 UTF-8 encoded bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. The Azure region where the cluster runs.
    ///
    /// Each Google Cloud region supports a subset of nearby Azure regions.
    /// You can call
    /// [GetAzureServerConfig][google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig]
    /// to list all supported Azure regions within a given Google Cloud region.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig]: crate::client::AzureClusters::get_azure_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_region: std::string::String,

    /// Required. The ARM ID of the resource group where the cluster resources are
    /// deployed. For example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-name>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_group_id: std::string::String,

    /// Optional. Name of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] that contains
    /// authentication configuration for how the Anthos Multi-Cloud API connects to
    /// Azure APIs.
    ///
    /// Either azure_client or azure_services_authentication should be provided.
    ///
    /// The `AzureClient` resource must reside on the same Google Cloud Platform
    /// project and region as the `AzureCluster`.
    ///
    /// `AzureClient` names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_client: std::string::String,

    /// Required. Cluster-wide networking configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub networking: std::option::Option<crate::model::AzureClusterNetworking>,

    /// Required. Configuration related to the cluster control plane.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control_plane: std::option::Option<crate::model::AzureControlPlane>,

    /// Required. Configuration related to the cluster RBAC settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization: std::option::Option<crate::model::AzureAuthorization>,

    /// Optional. Authentication configuration for management of Azure resources.
    ///
    /// Either azure_client or azure_services_authentication should be provided.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_services_authentication:
        std::option::Option<crate::model::AzureServicesAuthentication>,

    /// Output only. The current state of the cluster.
    pub state: crate::model::azure_cluster::State,

    /// Output only. The endpoint of the cluster's API server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Output only. A globally unique identifier for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. If set, there are currently changes in flight to the cluster.
    pub reconciling: bool,

    /// Output only. The time at which this cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this cluster was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Annotations on the cluster.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Keys can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workload Identity settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Output only. PEM encoded x509 certificate of the cluster root of trust.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ca_certificate: std::string::String,

    /// Required. Fleet configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Output only. Managed Azure resources for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub managed_resources: std::option::Option<crate::model::AzureClusterResources>,

    /// Optional. Logging configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Output only. A set of errors found in the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::AzureClusterError>,

    /// Optional. Monitoring configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,
}

impl AzureCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AzureCluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [azure_region][crate::model::AzureCluster::azure_region].
    pub fn set_azure_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_region = v.into();
        self
    }

    /// Sets the value of [resource_group_id][crate::model::AzureCluster::resource_group_id].
    pub fn set_resource_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_group_id = v.into();
        self
    }

    /// Sets the value of [azure_client][crate::model::AzureCluster::azure_client].
    pub fn set_azure_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_client = v.into();
        self
    }

    /// Sets the value of [networking][crate::model::AzureCluster::networking].
    pub fn set_networking<
        T: std::convert::Into<std::option::Option<crate::model::AzureClusterNetworking>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.networking = v.into();
        self
    }

    /// Sets the value of [control_plane][crate::model::AzureCluster::control_plane].
    pub fn set_control_plane<
        T: std::convert::Into<std::option::Option<crate::model::AzureControlPlane>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane = v.into();
        self
    }

    /// Sets the value of [authorization][crate::model::AzureCluster::authorization].
    pub fn set_authorization<
        T: std::convert::Into<std::option::Option<crate::model::AzureAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization = v.into();
        self
    }

    /// Sets the value of [azure_services_authentication][crate::model::AzureCluster::azure_services_authentication].
    pub fn set_azure_services_authentication<
        T: std::convert::Into<std::option::Option<crate::model::AzureServicesAuthentication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.azure_services_authentication = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AzureCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::azure_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::AzureCluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AzureCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AzureCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AzureCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AzureCluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AzureCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::AzureCluster::workload_identity_config].
    pub fn set_workload_identity_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadIdentityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_identity_config = v.into();
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::AzureCluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::AzureCluster::fleet].
    pub fn set_fleet<T: std::convert::Into<std::option::Option<crate::model::Fleet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet = v.into();
        self
    }

    /// Sets the value of [managed_resources][crate::model::AzureCluster::managed_resources].
    pub fn set_managed_resources<
        T: std::convert::Into<std::option::Option<crate::model::AzureClusterResources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.managed_resources = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::AzureCluster::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::AzureCluster::monitoring_config].
    pub fn set_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::MonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_config = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::AzureCluster::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClusterError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::AzureCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AzureCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureCluster"
    }
}

/// Defines additional types related to AzureCluster
pub mod azure_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The PROVISIONING state indicates the cluster is being created.
        pub const PROVISIONING: State = State::new(1);

        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        pub const RUNNING: State = State::new(2);

        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the control plane replicas.
        pub const RECONCILING: State = State::new(3);

        /// The STOPPING state indicates the cluster is being deleted.
        pub const STOPPING: State = State::new(4);

        /// The ERROR state indicates the cluster is in a broken unrecoverable
        /// state.
        pub const ERROR: State = State::new(5);

        /// The DEGRADED state indicates the cluster requires user action to
        /// restore full functionality.
        pub const DEGRADED: State = State::new(6);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("RECONCILING"),
                4 => std::borrow::Cow::Borrowed("STOPPING"),
                5 => std::borrow::Cow::Borrowed("ERROR"),
                6 => std::borrow::Cow::Borrowed("DEGRADED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "RECONCILING" => std::option::Option::Some(Self::RECONCILING),
                "STOPPING" => std::option::Option::Some(Self::STOPPING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "DEGRADED" => std::option::Option::Some(Self::DEGRADED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ClusterNetworking contains cluster-wide networking configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureClusterNetworking {
    /// Required. The Azure Resource Manager (ARM) ID of the VNet associated with
    /// your cluster.
    ///
    /// All components in the cluster (i.e. control plane and node pools) run on a
    /// single VNet.
    ///
    /// Example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.Network/virtualNetworks/<vnet-id>`
    ///
    /// This field cannot be changed after creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub virtual_network_id: std::string::String,

    /// Required. The IP address range of the pods in this cluster, in CIDR
    /// notation (e.g. `10.96.0.0/14`).
    ///
    /// All pods in the cluster get assigned a unique IPv4 address from these
    /// ranges. Only a single range is supported.
    ///
    /// This field cannot be changed after creation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pod_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. The IP address range for services in this cluster, in CIDR
    /// notation (e.g. `10.96.0.0/14`).
    ///
    /// All services in the cluster get assigned a unique IPv4 address from these
    /// ranges. Only a single range is supported.
    ///
    /// This field cannot be changed after creating a cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_address_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Optional. The ARM ID of the subnet where Kubernetes private service type
    /// load balancers are deployed. When unspecified, it defaults to
    /// AzureControlPlane.subnet_id.
    ///
    /// Example:
    /// "/subscriptions/d00494d6-6f3c-4280-bbb2-899e163d1d30/resourceGroups/anthos_cluster_gkeust4/providers/Microsoft.Network/virtualNetworks/gke-vnet-gkeust4/subnets/subnetid456"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_load_balancer_subnet_id: std::string::String,
}

impl AzureClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [virtual_network_id][crate::model::AzureClusterNetworking::virtual_network_id].
    pub fn set_virtual_network_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.virtual_network_id = v.into();
        self
    }

    /// Sets the value of [service_load_balancer_subnet_id][crate::model::AzureClusterNetworking::service_load_balancer_subnet_id].
    pub fn set_service_load_balancer_subnet_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_load_balancer_subnet_id = v.into();
        self
    }

    /// Sets the value of [pod_address_cidr_blocks][crate::model::AzureClusterNetworking::pod_address_cidr_blocks].
    pub fn set_pod_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_address_cidr_blocks][crate::model::AzureClusterNetworking::service_address_cidr_blocks].
    pub fn set_service_address_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_address_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterNetworking"
    }
}

/// AzureControlPlane represents the control plane configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureControlPlane {
    /// Required. The Kubernetes version to run on control plane replicas
    /// (e.g. `1.19.10-gke.1000`).
    ///
    /// You can list all supported versions on a given Google Cloud region by
    /// calling
    /// [GetAzureServerConfig][google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig].
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.GetAzureServerConfig]: crate::client::AzureClusters::get_azure_server_config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional. The ARM ID of the default subnet for the control plane. The
    /// control plane VMs are deployed in this subnet, unless
    /// `AzureControlPlane.replica_placements` is specified. This subnet will also
    /// be used as default for `AzureControlPlane.endpoint_subnet_id` if
    /// `AzureControlPlane.endpoint_subnet_id` is not specified. Similarly it will
    /// be used as default for
    /// `AzureClusterNetworking.service_load_balancer_subnet_id`.
    ///
    /// Example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.Network/virtualNetworks/<vnet-id>/subnets/default`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_id: std::string::String,

    /// Optional. The Azure VM size name. Example: `Standard_DS2_v2`.
    ///
    /// For available VM sizes, see
    /// <https://docs.microsoft.com/en-us/azure/virtual-machines/vm-naming-conventions>.
    ///
    /// When unspecified, it defaults to `Standard_DS2_v2`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_size: std::string::String,

    /// Required. SSH configuration for how to access the underlying control plane
    /// machines.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssh_config: std::option::Option<crate::model::AzureSshConfig>,

    /// Optional. Configuration related to the root volume provisioned for each
    /// control plane replica.
    ///
    /// When unspecified, it defaults to 32-GiB Azure Disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub root_volume: std::option::Option<crate::model::AzureDiskTemplate>,

    /// Optional. Configuration related to the main volume provisioned for each
    /// control plane replica.
    /// The main volume is in charge of storing all of the cluster's etcd state.
    ///
    /// When unspecified, it defaults to a 8-GiB Azure Disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub main_volume: std::option::Option<crate::model::AzureDiskTemplate>,

    /// Optional. Configuration related to application-layer secrets encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_encryption: std::option::Option<crate::model::AzureDatabaseEncryption>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AzureProxyConfig>,

    /// Optional. Configuration related to vm config encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_encryption: std::option::Option<crate::model::AzureConfigEncryption>,

    /// Optional. A set of tags to apply to all underlying control plane Azure
    /// resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Configuration for where to place the control plane replicas.
    ///
    /// Up to three replica placement instances can be specified. If
    /// replica_placements is set, the replica placement instances will be applied
    /// to the three control plane replicas as evenly as possible.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replica_placements: std::vec::Vec<crate::model::ReplicaPlacement>,

    /// Optional. The ARM ID of the subnet where the control plane load balancer is
    /// deployed. When unspecified, it defaults to AzureControlPlane.subnet_id.
    ///
    /// Example:
    /// "/subscriptions/d00494d6-6f3c-4280-bbb2-899e163d1d30/resourceGroups/anthos_cluster_gkeust4/providers/Microsoft.Network/virtualNetworks/gke-vnet-gkeust4/subnets/subnetid123"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint_subnet_id: std::string::String,
}

impl AzureControlPlane {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AzureControlPlane::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [subnet_id][crate::model::AzureControlPlane::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [vm_size][crate::model::AzureControlPlane::vm_size].
    pub fn set_vm_size<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_size = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AzureControlPlane::ssh_config].
    pub fn set_ssh_config<
        T: std::convert::Into<std::option::Option<crate::model::AzureSshConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssh_config = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AzureControlPlane::root_volume].
    pub fn set_root_volume<
        T: std::convert::Into<std::option::Option<crate::model::AzureDiskTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.root_volume = v.into();
        self
    }

    /// Sets the value of [main_volume][crate::model::AzureControlPlane::main_volume].
    pub fn set_main_volume<
        T: std::convert::Into<std::option::Option<crate::model::AzureDiskTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.main_volume = v.into();
        self
    }

    /// Sets the value of [database_encryption][crate::model::AzureControlPlane::database_encryption].
    pub fn set_database_encryption<
        T: std::convert::Into<std::option::Option<crate::model::AzureDatabaseEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_encryption = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::AzureControlPlane::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AzureProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }

    /// Sets the value of [config_encryption][crate::model::AzureControlPlane::config_encryption].
    pub fn set_config_encryption<
        T: std::convert::Into<std::option::Option<crate::model::AzureConfigEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_encryption = v.into();
        self
    }

    /// Sets the value of [endpoint_subnet_id][crate::model::AzureControlPlane::endpoint_subnet_id].
    pub fn set_endpoint_subnet_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_subnet_id = v.into();
        self
    }

    /// Sets the value of [replica_placements][crate::model::AzureControlPlane::replica_placements].
    pub fn set_replica_placements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaPlacement>,
    {
        use std::iter::Iterator;
        self.replica_placements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AzureControlPlane::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AzureControlPlane {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureControlPlane"
    }
}

/// Configuration for the placement of a control plane replica.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaPlacement {
    /// Required. For a given replica, the ARM ID of the subnet where the control
    /// plane VM is deployed. Make sure it's a subnet under the virtual network in
    /// the cluster configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_id: std::string::String,

    /// Required. For a given replica, the Azure availability zone where to
    /// provision the control plane VM and the ETCD disk.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_availability_zone: std::string::String,
}

impl ReplicaPlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnet_id][crate::model::ReplicaPlacement::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [azure_availability_zone][crate::model::ReplicaPlacement::azure_availability_zone].
    pub fn set_azure_availability_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_availability_zone = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaPlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ReplicaPlacement"
    }
}

/// Details of a proxy config stored in Azure Key Vault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureProxyConfig {
    /// The ARM ID the of the resource group containing proxy keyvault.
    ///
    /// Resource group ids are formatted as
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-name>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_group_id: std::string::String,

    /// The URL the of the proxy setting secret with its version.
    ///
    /// The secret must be a JSON encoded proxy configuration
    /// as described in
    /// <https://cloud.google.com/kubernetes-engine/multi-cloud/docs/azure/how-to/use-a-proxy#create_a_proxy_configuration_file>
    ///
    /// Secret ids are formatted as
    /// `https://<key-vault-name>.vault.azure.net/secrets/<secret-name>/<secret-version>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_id: std::string::String,
}

impl AzureProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_group_id][crate::model::AzureProxyConfig::resource_group_id].
    pub fn set_resource_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_group_id = v.into();
        self
    }

    /// Sets the value of [secret_id][crate::model::AzureProxyConfig::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureProxyConfig"
    }
}

/// Configuration related to application-layer secrets encryption.
///
/// Anthos clusters on Azure encrypts your Kubernetes data at rest
/// in etcd using Azure Key Vault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureDatabaseEncryption {
    /// Required. The ARM ID of the Azure Key Vault key to encrypt / decrypt data.
    ///
    /// For example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.KeyVault/vaults/<key-vault-id>/keys/<key-name>`
    /// Encryption will always take the latest version of the key and hence
    /// specific version is not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_id: std::string::String,
}

impl AzureDatabaseEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_id][crate::model::AzureDatabaseEncryption::key_id].
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureDatabaseEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureDatabaseEncryption"
    }
}

/// Configuration related to config data encryption.
///
/// Azure VM bootstrap secret is envelope encrypted with the provided key vault
/// key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureConfigEncryption {
    /// Required. The ARM ID of the Azure Key Vault key to encrypt / decrypt config
    /// data.
    ///
    /// For example:
    /// `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.KeyVault/vaults/<key-vault-id>/keys/<key-name>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_id: std::string::String,

    /// Optional. RSA key of the Azure Key Vault public key to use for encrypting
    /// the data.
    ///
    /// This key must be formatted as a PEM-encoded SubjectPublicKeyInfo (RFC 5280)
    /// in ASN.1 DER form. The string must be comprised of a single PEM block of
    /// type "PUBLIC KEY".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,
}

impl AzureConfigEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_id][crate::model::AzureConfigEncryption::key_id].
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::AzureConfigEncryption::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }
}

impl wkt::message::Message for AzureConfigEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureConfigEncryption"
    }
}

/// Configuration for Azure Disks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureDiskTemplate {
    /// Optional. The size of the disk, in GiBs.
    ///
    /// When unspecified, a default value is provided. See the specific reference
    /// in the parent resource.
    pub size_gib: i32,
}

impl AzureDiskTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_gib][crate::model::AzureDiskTemplate::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }
}

impl wkt::message::Message for AzureDiskTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureDiskTemplate"
    }
}

/// `AzureClient` resources hold client authentication information needed by the
/// Anthos Multi-Cloud API to manage Azure resources on your Azure subscription.
///
/// When an [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] is
/// created, an `AzureClient` resource needs to be provided and all operations on
/// Azure resources associated to that cluster will authenticate to Azure
/// services using the given client.
///
/// `AzureClient` resources are immutable and cannot be modified upon creation.
///
/// Each `AzureClient` resource is bound to a single Azure Active Directory
/// Application and tenant.
///
/// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureClient {
    /// The name of this resource.
    ///
    /// `AzureClient` resource names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The Azure Active Directory Tenant ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tenant_id: std::string::String,

    /// Required. The Azure Active Directory Application ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub application_id: std::string::String,

    /// Output only. If set, there are currently pending changes to the client.
    pub reconciling: bool,

    /// Optional. Annotations on the resource.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Keys can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The PEM encoded x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pem_certificate: std::string::String,

    /// Output only. A globally unique identifier for the client.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time at which this resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this client was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl AzureClient {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureClient::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tenant_id][crate::model::AzureClient::tenant_id].
    pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant_id = v.into();
        self
    }

    /// Sets the value of [application_id][crate::model::AzureClient::application_id].
    pub fn set_application_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.application_id = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AzureClient::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [pem_certificate][crate::model::AzureClient::pem_certificate].
    pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem_certificate = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AzureClient::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AzureClient::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AzureClient::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::AzureClient::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AzureClient {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClient"
    }
}

/// Configuration related to the cluster RBAC settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureAuthorization {
    /// Optional. Users that can perform operations as a cluster admin. A managed
    /// ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
    /// to the users. Up to ten admin users can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admin_users: std::vec::Vec<crate::model::AzureClusterUser>,

    /// Optional. Groups of users that can perform operations as a cluster admin. A
    /// managed ClusterRoleBinding will be created to grant the `cluster-admin`
    /// ClusterRole to the groups. Up to ten admin groups can be provided.
    ///
    /// For more info on RBAC, see
    /// <https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admin_groups: std::vec::Vec<crate::model::AzureClusterGroup>,
}

impl AzureAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::AzureAuthorization::admin_users].
    pub fn set_admin_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClusterUser>,
    {
        use std::iter::Iterator;
        self.admin_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin_groups][crate::model::AzureAuthorization::admin_groups].
    pub fn set_admin_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClusterGroup>,
    {
        use std::iter::Iterator;
        self.admin_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureAuthorization"
    }
}

/// Authentication configuration for the management of Azure resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureServicesAuthentication {
    /// Required. The Azure Active Directory Tenant ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tenant_id: std::string::String,

    /// Required. The Azure Active Directory Application ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub application_id: std::string::String,
}

impl AzureServicesAuthentication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenant_id][crate::model::AzureServicesAuthentication::tenant_id].
    pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant_id = v.into();
        self
    }

    /// Sets the value of [application_id][crate::model::AzureServicesAuthentication::application_id].
    pub fn set_application_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.application_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureServicesAuthentication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureServicesAuthentication"
    }
}

/// Identities of a user-type subject for Azure clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureClusterUser {
    /// Required. The name of the user, e.g. `my-gcp-id@gmail.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,
}

impl AzureClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::AzureClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterUser"
    }
}

/// Identities of a group-type subject for Azure clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureClusterGroup {
    /// Required. The name of the group, e.g. `my-group@domain.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,
}

impl AzureClusterGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AzureClusterGroup::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterGroup"
    }
}

/// An Anthos node pool running on Azure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureNodePool {
    /// The name of this resource.
    ///
    /// Node pool names are formatted as
    /// `projects/<project-number>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// For more details on Google Cloud resource names,
    /// see [Resource Names](https://cloud.google.com/apis/design/resource_names)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The Kubernetes version (e.g. `1.19.10-gke.1000`) running on this
    /// node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Required. The node configuration of the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::AzureNodeConfig>,

    /// Required. The ARM ID of the subnet where the node pool VMs run. Make sure
    /// it's a subnet under the virtual network in the cluster configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_id: std::string::String,

    /// Required. Autoscaler configuration for this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling: std::option::Option<crate::model::AzureNodePoolAutoscaling>,

    /// Output only. The current state of the node pool.
    pub state: crate::model::azure_node_pool::State,

    /// Output only. A globally unique identifier for the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. If set, there are currently pending changes to the node
    /// pool.
    pub reconciling: bool,

    /// Output only. The time at which this node pool was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this node pool was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Allows clients to perform consistent read-modify-writes
    /// through optimistic concurrency control.
    ///
    /// Can be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Annotations on the node pool.
    ///
    /// This field has the same restrictions as Kubernetes annotations.
    /// The total size of all keys and values combined is limited to 256k.
    /// Keys can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Optional. The Azure availability zone of the nodes in this nodepool.
    ///
    /// When unspecified, it defaults to `1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_availability_zone: std::string::String,

    /// Output only. A set of errors found in the node pool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::AzureNodePoolError>,

    /// Optional. The Management configuration for this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management: std::option::Option<crate::model::AzureNodeManagement>,
}

impl AzureNodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureNodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AzureNodePool::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [config][crate::model::AzureNodePool::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::AzureNodeConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [subnet_id][crate::model::AzureNodePool::subnet_id].
    pub fn set_subnet_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_id = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::AzureNodePool::autoscaling].
    pub fn set_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::AzureNodePoolAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AzureNodePool::state].
    pub fn set_state<T: std::convert::Into<crate::model::azure_node_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AzureNodePool::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::AzureNodePool::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AzureNodePool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AzureNodePool::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AzureNodePool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [max_pods_constraint][crate::model::AzureNodePool::max_pods_constraint].
    pub fn set_max_pods_constraint<
        T: std::convert::Into<std::option::Option<crate::model::MaxPodsConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.max_pods_constraint = v.into();
        self
    }

    /// Sets the value of [azure_availability_zone][crate::model::AzureNodePool::azure_availability_zone].
    pub fn set_azure_availability_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_availability_zone = v.into();
        self
    }

    /// Sets the value of [management][crate::model::AzureNodePool::management].
    pub fn set_management<
        T: std::convert::Into<std::option::Option<crate::model::AzureNodeManagement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::AzureNodePool::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureNodePoolError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::AzureNodePool::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AzureNodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodePool"
    }
}

/// Defines additional types related to AzureNodePool
pub mod azure_node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The lifecycle state of the node pool.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The PROVISIONING state indicates the node pool is being created.
        pub const PROVISIONING: State = State::new(1);

        /// The RUNNING state indicates the node pool has been created and is fully
        /// usable.
        pub const RUNNING: State = State::new(2);

        /// The RECONCILING state indicates that the node pool is being reconciled.
        pub const RECONCILING: State = State::new(3);

        /// The STOPPING state indicates the node pool is being deleted.
        pub const STOPPING: State = State::new(4);

        /// The ERROR state indicates the node pool is in a broken unrecoverable
        /// state.
        pub const ERROR: State = State::new(5);

        /// The DEGRADED state indicates the node pool requires user action to
        /// restore full functionality.
        pub const DEGRADED: State = State::new(6);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("RECONCILING"),
                4 => std::borrow::Cow::Borrowed("STOPPING"),
                5 => std::borrow::Cow::Borrowed("ERROR"),
                6 => std::borrow::Cow::Borrowed("DEGRADED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "RECONCILING" => std::option::Option::Some(Self::RECONCILING),
                "STOPPING" => std::option::Option::Some(Self::STOPPING),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "DEGRADED" => std::option::Option::Some(Self::DEGRADED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// AzureNodeManagement defines the set of node management features turned on for
/// an Azure node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureNodeManagement {
    /// Optional. Whether or not the nodes will be automatically repaired. When set
    /// to true, the nodes in this node pool will be monitored and if they fail
    /// health checks consistently over a period of time, an automatic repair
    /// action will be triggered to replace them with new nodes.
    pub auto_repair: bool,
}

impl AzureNodeManagement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_repair][crate::model::AzureNodeManagement::auto_repair].
    pub fn set_auto_repair<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_repair = v.into();
        self
    }
}

impl wkt::message::Message for AzureNodeManagement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodeManagement"
    }
}

/// Parameters that describe the configuration of all node machines
/// on a given node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureNodeConfig {
    /// Optional. The Azure VM size name. Example: `Standard_DS2_v2`.
    ///
    /// See [Supported VM
    /// sizes](/anthos/clusters/docs/azure/reference/supported-vms) for options.
    ///
    /// When unspecified, it defaults to `Standard_DS2_v2`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_size: std::string::String,

    /// Optional. Configuration related to the root volume provisioned for each
    /// node pool machine.
    ///
    /// When unspecified, it defaults to a 32-GiB Azure Disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub root_volume: std::option::Option<crate::model::AzureDiskTemplate>,

    /// Optional. A set of tags to apply to all underlying Azure resources for this
    /// node pool. This currently only includes Virtual Machine Scale Sets.
    ///
    /// Specify at most 50 pairs containing alphanumerics, spaces, and symbols
    /// (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to
    /// 255 Unicode characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The OS image type to use on node pool instances.
    /// Can be unspecified, or have a value of `ubuntu`.
    ///
    /// When unspecified, it defaults to `ubuntu`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_type: std::string::String,

    /// Required. SSH configuration for how to access the node pool machines.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssh_config: std::option::Option<crate::model::AzureSshConfig>,

    /// Optional. Proxy configuration for outbound HTTP(S) traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub proxy_config: std::option::Option<crate::model::AzureProxyConfig>,

    /// Optional. Configuration related to vm config encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_encryption: std::option::Option<crate::model::AzureConfigEncryption>,

    /// Optional. The initial taints assigned to nodes of this node pool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    /// Optional. The initial labels assigned to nodes of this node pool. An object
    /// containing a list of "key": value pairs. Example: { "name": "wrench",
    /// "mass": "1.3kg", "count": "3" }.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl AzureNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_size][crate::model::AzureNodeConfig::vm_size].
    pub fn set_vm_size<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_size = v.into();
        self
    }

    /// Sets the value of [root_volume][crate::model::AzureNodeConfig::root_volume].
    pub fn set_root_volume<
        T: std::convert::Into<std::option::Option<crate::model::AzureDiskTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.root_volume = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::AzureNodeConfig::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [ssh_config][crate::model::AzureNodeConfig::ssh_config].
    pub fn set_ssh_config<
        T: std::convert::Into<std::option::Option<crate::model::AzureSshConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ssh_config = v.into();
        self
    }

    /// Sets the value of [proxy_config][crate::model::AzureNodeConfig::proxy_config].
    pub fn set_proxy_config<
        T: std::convert::Into<std::option::Option<crate::model::AzureProxyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.proxy_config = v.into();
        self
    }

    /// Sets the value of [config_encryption][crate::model::AzureNodeConfig::config_encryption].
    pub fn set_config_encryption<
        T: std::convert::Into<std::option::Option<crate::model::AzureConfigEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_encryption = v.into();
        self
    }

    /// Sets the value of [taints][crate::model::AzureNodeConfig::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AzureNodeConfig::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AzureNodeConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AzureNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodeConfig"
    }
}

/// Configuration related to Kubernetes cluster autoscaler.
///
/// The Kubernetes cluster autoscaler will automatically adjust the
/// size of the node pool based on the cluster load.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureNodePoolAutoscaling {
    /// Required. Minimum number of nodes in the node pool. Must be greater than or
    /// equal to 1 and less than or equal to max_node_count.
    pub min_node_count: i32,

    /// Required. Maximum number of nodes in the node pool. Must be greater than or
    /// equal to min_node_count and less than or equal to 50.
    pub max_node_count: i32,
}

impl AzureNodePoolAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_node_count][crate::model::AzureNodePoolAutoscaling::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::AzureNodePoolAutoscaling::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for AzureNodePoolAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodePoolAutoscaling"
    }
}

/// AzureOpenIdConfig is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureOpenIdConfig {
    /// OIDC Issuer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issuer: std::string::String,

    /// JSON Web Key uri.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub jwks_uri: std::string::String,

    /// Supported response types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub response_types_supported: std::vec::Vec<std::string::String>,

    /// Supported subject types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject_types_supported: std::vec::Vec<std::string::String>,

    /// supported ID Token signing Algorithms.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub id_token_signing_alg_values_supported: std::vec::Vec<std::string::String>,

    /// Supported claims.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub claims_supported: std::vec::Vec<std::string::String>,

    /// Supported grant types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grant_types: std::vec::Vec<std::string::String>,
}

impl AzureOpenIdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer][crate::model::AzureOpenIdConfig::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [jwks_uri][crate::model::AzureOpenIdConfig::jwks_uri].
    pub fn set_jwks_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.jwks_uri = v.into();
        self
    }

    /// Sets the value of [response_types_supported][crate::model::AzureOpenIdConfig::response_types_supported].
    pub fn set_response_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.response_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subject_types_supported][crate::model::AzureOpenIdConfig::subject_types_supported].
    pub fn set_subject_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id_token_signing_alg_values_supported][crate::model::AzureOpenIdConfig::id_token_signing_alg_values_supported].
    pub fn set_id_token_signing_alg_values_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_token_signing_alg_values_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims_supported][crate::model::AzureOpenIdConfig::claims_supported].
    pub fn set_claims_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.claims_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grant_types][crate::model::AzureOpenIdConfig::grant_types].
    pub fn set_grant_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grant_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureOpenIdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureOpenIdConfig"
    }
}

/// AzureJsonWebKeys is a valid JSON Web Key Set as specififed in RFC 7517.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureJsonWebKeys {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub keys: std::vec::Vec<crate::model::Jwk>,
}

impl AzureJsonWebKeys {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::AzureJsonWebKeys::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwk>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureJsonWebKeys {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureJsonWebKeys"
    }
}

/// AzureServerConfig contains information about a Google Cloud location, such as
/// supported Azure regions and Kubernetes versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureServerConfig {
    /// The `AzureServerConfig` resource name.
    ///
    /// `AzureServerConfig` names are formatted as
    /// `projects/<project-number>/locations/<region>/azureServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// List of all released Kubernetes versions, including ones which are end of
    /// life and can no longer be used.  Filter by the `enabled`
    /// property to limit to currently available versions.
    /// Valid versions supported for both create and update operations
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub valid_versions: std::vec::Vec<crate::model::AzureK8sVersionInfo>,

    /// The list of supported Azure regions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_azure_regions: std::vec::Vec<std::string::String>,
}

impl AzureServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AzureServerConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [valid_versions][crate::model::AzureServerConfig::valid_versions].
    pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureK8sVersionInfo>,
    {
        use std::iter::Iterator;
        self.valid_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_azure_regions][crate::model::AzureServerConfig::supported_azure_regions].
    pub fn set_supported_azure_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_azure_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureServerConfig"
    }
}

/// Kubernetes version information of GKE cluster on Azure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureK8sVersionInfo {
    /// Kubernetes version name (for example, `1.19.10-gke.1000`)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional. True if the version is available for cluster creation. If a
    /// version is enabled for creation, it can be used to create new clusters.
    /// Otherwise, cluster creation will fail. However, cluster upgrade operations
    /// may succeed, even if the version is not enabled.
    pub enabled: bool,

    /// Optional. True if this cluster version belongs to a minor version that has
    /// reached its end of life and is no longer in scope to receive security and
    /// bug fixes.
    pub end_of_life: bool,

    /// Optional. The estimated date (in Pacific Time) when this cluster version
    /// will reach its end of life. Or if this version is no longer supported (the
    /// `end_of_life` field is true), this is the actual date (in Pacific time)
    /// when the version reached its end of life.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_of_life_date: std::option::Option<gtype::model::Date>,

    /// Optional. The date (in Pacific Time) when the cluster version was released.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release_date: std::option::Option<gtype::model::Date>,
}

impl AzureK8sVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::AzureK8sVersionInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::AzureK8sVersionInfo::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [end_of_life][crate::model::AzureK8sVersionInfo::end_of_life].
    pub fn set_end_of_life<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.end_of_life = v.into();
        self
    }

    /// Sets the value of [end_of_life_date][crate::model::AzureK8sVersionInfo::end_of_life_date].
    pub fn set_end_of_life_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_of_life_date = v.into();
        self
    }

    /// Sets the value of [release_date][crate::model::AzureK8sVersionInfo::release_date].
    pub fn set_release_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_date = v.into();
        self
    }
}

impl wkt::message::Message for AzureK8sVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureK8sVersionInfo"
    }
}

/// SSH configuration for Azure resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureSshConfig {
    /// Required. The SSH public key data for VMs managed by Anthos. This accepts
    /// the authorized_keys file format used in OpenSSH according to the sshd(8)
    /// manual page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub authorized_key: std::string::String,
}

impl AzureSshConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authorized_key][crate::model::AzureSshConfig::authorized_key].
    pub fn set_authorized_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authorized_key = v.into();
        self
    }
}

impl wkt::message::Message for AzureSshConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureSshConfig"
    }
}

/// Managed Azure resources for the cluster.
///
/// The values could change and be empty, depending on the state of the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureClusterResources {
    /// Output only. The ARM ID of the cluster network security group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_security_group_id: std::string::String,

    /// Output only. The ARM ID of the control plane application security group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub control_plane_application_security_group_id: std::string::String,
}

impl AzureClusterResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_security_group_id][crate::model::AzureClusterResources::network_security_group_id].
    pub fn set_network_security_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_security_group_id = v.into();
        self
    }

    /// Sets the value of [control_plane_application_security_group_id][crate::model::AzureClusterResources::control_plane_application_security_group_id].
    pub fn set_control_plane_application_security_group_id<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_application_security_group_id = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterResources"
    }
}

/// AzureClusterError describes errors found on Azure clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureClusterError {
    /// Human-friendly description of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl AzureClusterError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AzureClusterError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AzureClusterError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureClusterError"
    }
}

/// AzureNodePoolError describes errors found on Azure node pools.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureNodePoolError {
    /// Human-friendly description of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl AzureNodePoolError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AzureNodePoolError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for AzureNodePoolError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.AzureNodePoolError"
    }
}

/// Request message for `AzureClusters.CreateAzureCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAzureClusterRequest {
    /// Required. The parent location where this
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource will be
    /// created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_cluster: std::option::Option<crate::model::AzureCluster>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_cluster_id: std::string::String,

    /// If set, only validate the request, but do not actually create the cluster.
    pub validate_only: bool,
}

impl CreateAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAzureClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [azure_cluster][crate::model::CreateAzureClusterRequest::azure_cluster].
    pub fn set_azure_cluster<
        T: std::convert::Into<std::option::Option<crate::model::AzureCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.azure_cluster = v.into();
        self
    }

    /// Sets the value of [azure_cluster_id][crate::model::CreateAzureClusterRequest::azure_cluster_id].
    pub fn set_azure_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_cluster_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAzureClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAzureClusterRequest"
    }
}

/// Request message for `AzureClusters.UpdateAzureCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAzureClusterRequest {
    /// Required. The [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_cluster: std::option::Option<crate::model::AzureCluster>,

    /// If set, only validate the request, but do not actually update the cluster.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]:
    ///
    /// * `description`.
    /// * `azureClient`.
    /// * `control_plane.version`.
    /// * `control_plane.vm_size`.
    /// * `annotations`.
    /// * `authorization.admin_users`.
    /// * `authorization.admin_groups`.
    /// * `control_plane.root_volume.size_gib`.
    /// * `azure_services_authentication`.
    /// * `azure_services_authentication.tenant_id`.
    /// * `azure_services_authentication.application_id`.
    /// * `control_plane.proxy_config`.
    /// * `control_plane.proxy_config.resource_group_id`.
    /// * `control_plane.proxy_config.secret_id`.
    /// * `control_plane.ssh_config.authorized_key`.
    /// * `logging_config.component_config.enable_components`
    /// * `monitoring_config.managed_prometheus_config.enabled`.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::UpdateAzureClusterRequest::azure_cluster].
    pub fn set_azure_cluster<
        T: std::convert::Into<std::option::Option<crate::model::AzureCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.azure_cluster = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAzureClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAzureClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAzureClusterRequest"
    }
}

/// Request message for `AzureClusters.GetAzureCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAzureClusterRequest {
    /// Required. The name of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource to
    /// describe.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureClusterRequest"
    }
}

/// Request message for `AzureClusters.ListAzureClusters` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAzureClustersRequest {
    /// Required. The parent location which owns this collection of
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAzureClustersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAzureClustersResponse.next_page_token]: crate::model::ListAzureClustersResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [azureClusters.list][google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClusters]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClusters]: crate::client::AzureClusters::list_azure_clusters
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAzureClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAzureClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAzureClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAzureClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClustersRequest"
    }
}

/// Response message for `AzureClusters.ListAzureClusters` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAzureClustersResponse {
    /// A list of [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]
    /// resources in the specified Google Cloud Platform project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub azure_clusters: std::vec::Vec<crate::model::AzureCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAzureClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAzureClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [azure_clusters][crate::model::ListAzureClustersResponse::azure_clusters].
    pub fn set_azure_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureCluster>,
    {
        use std::iter::Iterator;
        self.azure_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAzureClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClustersResponse"
    }
}

impl gax::paginator::PageableResponse for ListAzureClustersResponse {
    type PageItem = crate::model::AzureCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.azure_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AzureClusters.DeleteAzureCluster` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAzureClusterRequest {
    /// Required. The resource name the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] to delete.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, and the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,

    /// The current etag of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided etag does not match the current etag of the cluster,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set to true, the deletion of
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource will
    /// succeed even if errors occur during deleting in cluster resources. Using
    /// this parameter may result in orphaned resources in the cluster.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    pub ignore_errors: bool,
}

impl DeleteAzureClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAzureClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAzureClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAzureClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAzureClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAzureClusterRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAzureClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAzureClusterRequest"
    }
}

/// Response message for `AzureClusters.CreateAzureNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAzureNodePoolRequest {
    /// Required. The [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster]
    /// resource where this node pool will be created.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_node_pool: std::option::Option<crate::model::AzureNodePool>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_node_pool_id: std::string::String,

    /// If set, only validate the request, but do not actually create the node
    /// pool.
    pub validate_only: bool,
}

impl CreateAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAzureNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [azure_node_pool][crate::model::CreateAzureNodePoolRequest::azure_node_pool].
    pub fn set_azure_node_pool<
        T: std::convert::Into<std::option::Option<crate::model::AzureNodePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.azure_node_pool = v.into();
        self
    }

    /// Sets the value of [azure_node_pool_id][crate::model::CreateAzureNodePoolRequest::azure_node_pool_id].
    pub fn set_azure_node_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.azure_node_pool_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAzureNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAzureNodePoolRequest"
    }
}

/// Request message for `AzureClusters.UpdateAzureNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAzureNodePoolRequest {
    /// Required. The [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool]
    /// resource to update.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_node_pool: std::option::Option<crate::model::AzureNodePool>,

    /// If set, only validate the request, but don't actually update the node pool.
    pub validate_only: bool,

    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field can only include these
    /// fields from [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool]:
    ///
    /// *.  `annotations`.
    ///
    /// * `version`.
    /// * `autoscaling.min_node_count`.
    /// * `autoscaling.max_node_count`.
    /// * `config.ssh_config.authorized_key`.
    /// * `management.auto_repair`.
    /// * `management`.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_node_pool][crate::model::UpdateAzureNodePoolRequest::azure_node_pool].
    pub fn set_azure_node_pool<
        T: std::convert::Into<std::option::Option<crate::model::AzureNodePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.azure_node_pool = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAzureNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAzureNodePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.UpdateAzureNodePoolRequest"
    }
}

/// Request message for `AzureClusters.GetAzureNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAzureNodePoolRequest {
    /// Required. The name of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource to
    /// describe.
    ///
    /// `AzureNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureNodePoolRequest"
    }
}

/// Request message for `AzureClusters.ListAzureNodePools` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAzureNodePoolsRequest {
    /// Required. The parent `AzureCluster` which owns this collection of
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resources.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAzureNodePoolsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAzureNodePoolsResponse.next_page_token]: crate::model::ListAzureNodePoolsResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [azureNodePools.list][google.cloud.gkemulticloud.v1.AzureClusters.ListAzureNodePools]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.ListAzureNodePools]: crate::client::AzureClusters::list_azure_node_pools
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAzureNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAzureNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAzureNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAzureNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureNodePoolsRequest"
    }
}

/// Response message for `AzureClusters.ListAzureNodePools` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAzureNodePoolsResponse {
    /// A list of [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool]
    /// resources in the specified `AzureCluster`.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub azure_node_pools: std::vec::Vec<crate::model::AzureNodePool>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAzureNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAzureNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [azure_node_pools][crate::model::ListAzureNodePoolsResponse::azure_node_pools].
    pub fn set_azure_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureNodePool>,
    {
        use std::iter::Iterator;
        self.azure_node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAzureNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureNodePoolsResponse"
    }
}

impl gax::paginator::PageableResponse for ListAzureNodePoolsResponse {
    type PageItem = crate::model::AzureNodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.azure_node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AzureClusters.DeleteAzureNodePool` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAzureNodePoolRequest {
    /// Required. The resource name the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] to delete.
    ///
    /// `AzureNodePool` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>/azureNodePools/<node-pool-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, only validate the request, but do not actually delete the node
    /// pool.
    pub validate_only: bool,

    /// If set to true, and the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource is
    /// not found, the request will succeed but no action will be taken on the
    /// server and a completed [Operation][google.longrunning.Operation] will be
    /// returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// The current ETag of the
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool].
    ///
    /// Allows clients to perform deletions through optimistic concurrency control.
    ///
    /// If the provided ETag does not match the current etag of the node pool,
    /// the request will fail and an ABORTED error will be returned.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set to true, the deletion of
    /// [AzureNodePool][google.cloud.gkemulticloud.v1.AzureNodePool] resource will
    /// succeed even if errors occur during deleting in node pool resources. Using
    /// this parameter may result in orphaned resources in the node pool.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureNodePool]: crate::model::AzureNodePool
    pub ignore_errors: bool,
}

impl DeleteAzureNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAzureNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAzureNodePoolRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAzureNodePoolRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAzureNodePoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [ignore_errors][crate::model::DeleteAzureNodePoolRequest::ignore_errors].
    pub fn set_ignore_errors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_errors = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAzureNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAzureNodePoolRequest"
    }
}

/// GetAzureOpenIdConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAzureOpenIdConfigRequest {
    /// Required. The AzureCluster, which owns the OIDC discovery document.
    /// Format:
    /// projects/\<project-id\>/locations/\<region\>/azureClusters/\<cluster-id\>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_cluster: std::string::String,
}

impl GetAzureOpenIdConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GetAzureOpenIdConfigRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureOpenIdConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureOpenIdConfigRequest"
    }
}

/// GetAzureJsonWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAzureJsonWebKeysRequest {
    /// Required. The AzureCluster, which owns the JsonWebKeys.
    /// Format:
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_cluster: std::string::String,
}

impl GetAzureJsonWebKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GetAzureJsonWebKeysRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureJsonWebKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureJsonWebKeysRequest"
    }
}

/// GetAzureServerConfigRequest gets the server config of GKE cluster on Azure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAzureServerConfigRequest {
    /// Required. The name of the
    /// [AzureServerConfig][google.cloud.gkemulticloud.v1.AzureServerConfig]
    /// resource to describe.
    ///
    /// `AzureServerConfig` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureServerConfig`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureServerConfig]: crate::model::AzureServerConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAzureServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureServerConfigRequest"
    }
}

/// Request message for `AzureClusters.CreateAzureClient` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAzureClientRequest {
    /// Required. The parent location where this
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource will be
    /// created.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The specification of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] to create.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub azure_client: std::option::Option<crate::model::AzureClient>,

    /// Required. A client provided ID the resource. Must be unique within the
    /// parent resource.
    ///
    /// The provided ID will be part of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource name
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClients/<client-id>`.
    ///
    /// Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_client_id: std::string::String,

    /// If set, only validate the request, but do not actually create the client.
    pub validate_only: bool,
}

impl CreateAzureClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAzureClientRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [azure_client][crate::model::CreateAzureClientRequest::azure_client].
    pub fn set_azure_client<
        T: std::convert::Into<std::option::Option<crate::model::AzureClient>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.azure_client = v.into();
        self
    }

    /// Sets the value of [azure_client_id][crate::model::CreateAzureClientRequest::azure_client_id].
    pub fn set_azure_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_client_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAzureClientRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAzureClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CreateAzureClientRequest"
    }
}

/// Request message for `AzureClusters.GetAzureClient` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAzureClientRequest {
    /// Required. The name of the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource to
    /// describe.
    ///
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] names are
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAzureClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAzureClientRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAzureClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GetAzureClientRequest"
    }
}

/// Request message for `AzureClusters.ListAzureClients` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAzureClientsRequest {
    /// Required. The parent location which owns this collection of
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resources.
    ///
    /// Location names are formatted as `projects/<project-id>/locations/<region>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud Platform resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 50 will be used by the service.
    /// Regardless of the pageSize value, the response can include a partial list
    /// and a caller should only rely on response's
    /// [nextPageToken][google.cloud.gkemulticloud.v1.ListAzureClientsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkemulticloud.v1.ListAzureClientsResponse.next_page_token]: crate::model::ListAzureClientsResponse::next_page_token
    pub page_size: i32,

    /// The `nextPageToken` value returned from a previous
    /// [azureClients.list][google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClients]
    /// request, if any.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClusters.ListAzureClients]: crate::client::AzureClusters::list_azure_clients
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAzureClientsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAzureClientsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAzureClientsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAzureClientsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAzureClientsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClientsRequest"
    }
}

/// Response message for `AzureClusters.ListAzureClients` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAzureClientsResponse {
    /// A list of [AzureClient][google.cloud.gkemulticloud.v1.AzureClient]
    /// resources in the specified Google Cloud project and region region.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub azure_clients: std::vec::Vec<crate::model::AzureClient>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAzureClientsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAzureClientsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [azure_clients][crate::model::ListAzureClientsResponse::azure_clients].
    pub fn set_azure_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureClient>,
    {
        use std::iter::Iterator;
        self.azure_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAzureClientsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ListAzureClientsResponse"
    }
}

impl gax::paginator::PageableResponse for ListAzureClientsResponse {
    type PageItem = crate::model::AzureClient;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.azure_clients
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `AzureClusters.DeleteAzureClient` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAzureClientRequest {
    /// Required. The resource name the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] to delete.
    ///
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] names are
    /// formatted as
    /// `projects/<project-id>/locations/<region>/azureClients/<client-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, and the
    /// [AzureClient][google.cloud.gkemulticloud.v1.AzureClient] resource is not
    /// found, the request will succeed but no action will be taken on the server
    /// and a completed [Operation][google.longrunning.Operation] will be returned.
    ///
    /// Useful for idempotent deletion.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureClient]: crate::model::AzureClient
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub allow_missing: bool,

    /// If set, only validate the request, but do not actually delete the resource.
    pub validate_only: bool,
}

impl DeleteAzureClientRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAzureClientRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAzureClientRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAzureClientRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAzureClientRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.DeleteAzureClientRequest"
    }
}

/// Request message for `AzureClusters.GenerateAzureAccessToken` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAzureAccessTokenRequest {
    /// Required. The name of the
    /// [AzureCluster][google.cloud.gkemulticloud.v1.AzureCluster] resource to
    /// authenticate to.
    ///
    /// `AzureCluster` names are formatted as
    /// `projects/<project-id>/locations/<region>/azureClusters/<cluster-id>`.
    ///
    /// See [Resource Names](https://cloud.google.com/apis/design/resource_names)
    /// for more details on Google Cloud resource names.
    ///
    /// [google.cloud.gkemulticloud.v1.AzureCluster]: crate::model::AzureCluster
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_cluster: std::string::String,
}

impl GenerateAzureAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GenerateAzureAccessTokenRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureAccessTokenRequest"
    }
}

/// Response message for `AzureClusters.GenerateAzureAccessToken` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAzureAccessTokenResponse {
    /// Output only. Access token to authenticate to k8s api-server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,
}

impl GenerateAzureAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAzureAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::GenerateAzureAccessTokenResponse::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureAccessTokenResponse"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAzureClusterAgentTokenRequest {
    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub azure_cluster: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_token: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject_token_type: std::string::String,

    /// Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_pool_id: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub grant_type: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audience: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scope: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub requested_token_type: std::string::String,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub options: std::string::String,
}

impl GenerateAzureClusterAgentTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [azure_cluster][crate::model::GenerateAzureClusterAgentTokenRequest::azure_cluster].
    pub fn set_azure_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_cluster = v.into();
        self
    }

    /// Sets the value of [subject_token][crate::model::GenerateAzureClusterAgentTokenRequest::subject_token].
    pub fn set_subject_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject_token = v.into();
        self
    }

    /// Sets the value of [subject_token_type][crate::model::GenerateAzureClusterAgentTokenRequest::subject_token_type].
    pub fn set_subject_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_token_type = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GenerateAzureClusterAgentTokenRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::GenerateAzureClusterAgentTokenRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [grant_type][crate::model::GenerateAzureClusterAgentTokenRequest::grant_type].
    pub fn set_grant_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.grant_type = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::GenerateAzureClusterAgentTokenRequest::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::GenerateAzureClusterAgentTokenRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [requested_token_type][crate::model::GenerateAzureClusterAgentTokenRequest::requested_token_type].
    pub fn set_requested_token_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_token_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::GenerateAzureClusterAgentTokenRequest::options].
    pub fn set_options<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.options = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureClusterAgentTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureClusterAgentTokenRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAzureClusterAgentTokenResponse {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    pub expires_in: i32,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token_type: std::string::String,
}

impl GenerateAzureClusterAgentTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAzureClusterAgentTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expires_in][crate::model::GenerateAzureClusterAgentTokenResponse::expires_in].
    pub fn set_expires_in<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expires_in = v.into();
        self
    }

    /// Sets the value of [token_type][crate::model::GenerateAzureClusterAgentTokenResponse::token_type].
    pub fn set_token_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token_type = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAzureClusterAgentTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.GenerateAzureClusterAgentTokenResponse"
    }
}

/// Jwk is a JSON Web Key as specified in RFC 7517.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Jwk {
    /// Key Type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kty: std::string::String,

    /// Algorithm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub alg: std::string::String,

    /// Permitted uses for the public keys.
    #[serde(rename = "use")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#use: std::string::String,

    /// Key ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kid: std::string::String,

    /// Used for RSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub n: std::string::String,

    /// Used for RSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub e: std::string::String,

    /// Used for ECDSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub x: std::string::String,

    /// Used for ECDSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub y: std::string::String,

    /// Used for ECDSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crv: std::string::String,
}

impl Jwk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kty][crate::model::Jwk::kty].
    pub fn set_kty<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kty = v.into();
        self
    }

    /// Sets the value of [alg][crate::model::Jwk::alg].
    pub fn set_alg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alg = v.into();
        self
    }

    /// Sets the value of [r#use][crate::model::Jwk::use].
    pub fn set_use<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#use = v.into();
        self
    }

    /// Sets the value of [kid][crate::model::Jwk::kid].
    pub fn set_kid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kid = v.into();
        self
    }

    /// Sets the value of [n][crate::model::Jwk::n].
    pub fn set_n<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n = v.into();
        self
    }

    /// Sets the value of [e][crate::model::Jwk::e].
    pub fn set_e<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.e = v.into();
        self
    }

    /// Sets the value of [x][crate::model::Jwk::x].
    pub fn set_x<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Jwk::y].
    pub fn set_y<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [crv][crate::model::Jwk::crv].
    pub fn set_crv<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crv = v.into();
        self
    }
}

impl wkt::message::Message for Jwk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.Jwk"
    }
}

/// Workload Identity settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadIdentityConfig {
    /// The OIDC issuer URL for this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issuer_uri: std::string::String,

    /// The Workload Identity Pool associated to the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_pool: std::string::String,

    /// The ID of the OIDC Identity Provider (IdP) associated to the Workload
    /// Identity Pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub identity_provider: std::string::String,
}

impl WorkloadIdentityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer_uri][crate::model::WorkloadIdentityConfig::issuer_uri].
    pub fn set_issuer_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer_uri = v.into();
        self
    }

    /// Sets the value of [workload_pool][crate::model::WorkloadIdentityConfig::workload_pool].
    pub fn set_workload_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_pool = v.into();
        self
    }

    /// Sets the value of [identity_provider][crate::model::WorkloadIdentityConfig::identity_provider].
    pub fn set_identity_provider<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.identity_provider = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadIdentityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.WorkloadIdentityConfig"
    }
}

/// Constraints applied to pods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaxPodsConstraint {
    /// Required. The maximum number of pods to schedule on a single node.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_pods_per_node: i64,
}

impl MaxPodsConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_pods_per_node][crate::model::MaxPodsConstraint::max_pods_per_node].
    pub fn set_max_pods_per_node<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_pods_per_node = v.into();
        self
    }
}

impl wkt::message::Message for MaxPodsConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.MaxPodsConstraint"
    }
}

/// Metadata about a long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time at which this operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this operation was completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the resource associated to this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_detail: std::string::String,

    /// Output only. Human-readable status of any error that occurred during the
    /// operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_detail: std::string::String,

    /// Output only. The verb associated with the API method which triggered this
    /// operation. Possible values are "create", "delete", "update" and "import".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Identifies whether it has been requested cancellation
    /// for the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::OperationMetadata::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [error_detail][crate::model::OperationMetadata::error_detail].
    pub fn set_error_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_detail = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.OperationMetadata"
    }
}

/// The taint content for the node taint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeTaint {
    /// Required. Key for the taint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Required. Value for the taint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// Required. The taint effect.
    pub effect: crate::model::node_taint::Effect,
}

impl NodeTaint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::NodeTaint::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::NodeTaint::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [effect][crate::model::NodeTaint::effect].
    pub fn set_effect<T: std::convert::Into<crate::model::node_taint::Effect>>(
        mut self,
        v: T,
    ) -> Self {
        self.effect = v.into();
        self
    }
}

impl wkt::message::Message for NodeTaint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.NodeTaint"
    }
}

/// Defines additional types related to NodeTaint
pub mod node_taint {
    #[allow(unused_imports)]
    use super::*;

    /// The taint effect.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Effect(i32);

    impl Effect {
        /// Not set.
        pub const EFFECT_UNSPECIFIED: Effect = Effect::new(0);

        /// Do not allow new pods to schedule onto the node unless they tolerate the
        /// taint, but allow all pods submitted to Kubelet without going through the
        /// scheduler to start, and allow all already-running pods to continue
        /// running. Enforced by the scheduler.
        pub const NO_SCHEDULE: Effect = Effect::new(1);

        /// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
        /// new pods onto the node, rather than prohibiting new pods from scheduling
        /// onto the node entirely. Enforced by the scheduler.
        pub const PREFER_NO_SCHEDULE: Effect = Effect::new(2);

        /// Evict any already-running pods that do not tolerate the taint.
        /// Currently enforced by NodeController.
        pub const NO_EXECUTE: Effect = Effect::new(3);

        /// Creates a new Effect instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EFFECT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NO_SCHEDULE"),
                2 => std::borrow::Cow::Borrowed("PREFER_NO_SCHEDULE"),
                3 => std::borrow::Cow::Borrowed("NO_EXECUTE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EFFECT_UNSPECIFIED" => std::option::Option::Some(Self::EFFECT_UNSPECIFIED),
                "NO_SCHEDULE" => std::option::Option::Some(Self::NO_SCHEDULE),
                "PREFER_NO_SCHEDULE" => std::option::Option::Some(Self::PREFER_NO_SCHEDULE),
                "NO_EXECUTE" => std::option::Option::Some(Self::NO_EXECUTE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Effect {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Effect {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration for node pool kubelet options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeKubeletConfig {
    /// Optional. Enable the insecure kubelet read only port.
    pub insecure_kubelet_readonly_port_enabled: bool,

    /// Optional. Control the CPU management policy on the node.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/>
    ///
    /// The following values are allowed.
    ///
    /// * "none": the default, which represents the existing scheduling behavior.
    /// * "static": allows pods with certain resource characteristics to be granted
    ///   increased CPU affinity and exclusivity on the node.
    ///   The default value is 'none' if unspecified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu_manager_policy: std::option::Option<std::string::String>,

    /// Optional. Enable CPU CFS quota enforcement for containers that specify CPU
    /// limits.
    ///
    /// This option is enabled by default which makes kubelet use CFS quota
    /// (<https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt>) to
    /// enforce container CPU limits. Otherwise, CPU limits will not be enforced at
    /// all.
    ///
    /// Disable this option to mitigate CPU throttling problems while still having
    /// your pods to be in Guaranteed QoS class by specifying the CPU limits.
    ///
    /// The default value is 'true' if unspecified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu_cfs_quota: std::option::Option<bool>,

    /// Optional. Set the CPU CFS quota period value 'cpu.cfs_period_us'.
    ///
    /// The string must be a sequence of decimal numbers, each with optional
    /// fraction and a unit suffix, such as "300ms".
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// The value must be a positive duration.
    ///
    /// The default value is '100ms' if unspecified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu_cfs_quota_period: std::option::Option<std::string::String>,

    /// Optional. Set the Pod PID limits. See
    /// <https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits>
    ///
    /// Controls the maximum number of processes allowed to run in a pod. The value
    /// must be greater than or equal to 1024 and less than 4194304.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub pod_pids_limit: std::option::Option<i64>,
}

impl NodeKubeletConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insecure_kubelet_readonly_port_enabled][crate::model::NodeKubeletConfig::insecure_kubelet_readonly_port_enabled].
    pub fn set_insecure_kubelet_readonly_port_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.insecure_kubelet_readonly_port_enabled = v.into();
        self
    }

    /// Sets the value of [cpu_manager_policy][crate::model::NodeKubeletConfig::cpu_manager_policy].
    pub fn set_cpu_manager_policy<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_manager_policy = v.into();
        self
    }

    /// Sets the value of [cpu_cfs_quota][crate::model::NodeKubeletConfig::cpu_cfs_quota].
    pub fn set_cpu_cfs_quota<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_cfs_quota = v.into();
        self
    }

    /// Sets the value of [cpu_cfs_quota_period][crate::model::NodeKubeletConfig::cpu_cfs_quota_period].
    pub fn set_cpu_cfs_quota_period<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_cfs_quota_period = v.into();
        self
    }

    /// Sets the value of [pod_pids_limit][crate::model::NodeKubeletConfig::pod_pids_limit].
    pub fn set_pod_pids_limit<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pod_pids_limit = v.into();
        self
    }
}

impl wkt::message::Message for NodeKubeletConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.NodeKubeletConfig"
    }
}

/// Fleet related configuration.
///
/// Fleets are a Google Cloud concept for logically organizing clusters,
/// letting you use and manage multi-cluster capabilities and apply
/// consistent policies across your systems.
///
/// See [Anthos
/// Fleets](https://cloud.google.com/anthos/multicluster-management/fleets) for
/// more details on Anthos multi-cluster capabilities using Fleets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Fleet {
    /// Required. The name of the Fleet host project where this cluster will be
    /// registered.
    ///
    /// Project names are formatted as
    /// `projects/<project-number>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Output only. The name of the managed Hub Membership resource associated to
    /// this cluster.
    ///
    /// Membership names are formatted as
    /// `projects/<project-number>/locations/global/membership/<cluster-id>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub membership: std::string::String,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.Fleet"
    }
}

/// Parameters that describe the Logging configuration in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingConfig {
    /// The configuration of the logging components;
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub component_config: std::option::Option<crate::model::LoggingComponentConfig>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_config][crate::model::LoggingConfig::component_config].
    pub fn set_component_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingComponentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.component_config = v.into();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.LoggingConfig"
    }
}

/// Parameters that describe the Logging component configuration in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingComponentConfig {
    /// The components to be enabled.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub enable_components: std::vec::Vec<crate::model::logging_component_config::Component>,
}

impl LoggingComponentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_components][crate::model::LoggingComponentConfig::enable_components].
    pub fn set_enable_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_component_config::Component>,
    {
        use std::iter::Iterator;
        self.enable_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoggingComponentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.LoggingComponentConfig"
    }
}

/// Defines additional types related to LoggingComponentConfig
pub mod logging_component_config {
    #[allow(unused_imports)]
    use super::*;

    /// The components of the logging configuration;
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Component(i32);

    impl Component {
        /// No component is specified
        pub const COMPONENT_UNSPECIFIED: Component = Component::new(0);

        /// This indicates that system logging components is enabled.
        pub const SYSTEM_COMPONENTS: Component = Component::new(1);

        /// This indicates that user workload logging component is enabled.
        pub const WORKLOADS: Component = Component::new(2);

        /// Creates a new Component instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMPONENT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SYSTEM_COMPONENTS"),
                2 => std::borrow::Cow::Borrowed("WORKLOADS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMPONENT_UNSPECIFIED" => std::option::Option::Some(Self::COMPONENT_UNSPECIFIED),
                "SYSTEM_COMPONENTS" => std::option::Option::Some(Self::SYSTEM_COMPONENTS),
                "WORKLOADS" => std::option::Option::Some(Self::WORKLOADS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Component {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Component {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Parameters that describe the Monitoring configuration in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MonitoringConfig {
    /// Enable Google Cloud Managed Service for Prometheus in the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub managed_prometheus_config: std::option::Option<crate::model::ManagedPrometheusConfig>,

    /// Optionally enable GKE metrics.
    /// Only for Attached Clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_monitoring_config: std::option::Option<crate::model::CloudMonitoringConfig>,
}

impl MonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [managed_prometheus_config][crate::model::MonitoringConfig::managed_prometheus_config].
    pub fn set_managed_prometheus_config<
        T: std::convert::Into<std::option::Option<crate::model::ManagedPrometheusConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.managed_prometheus_config = v.into();
        self
    }

    /// Sets the value of [cloud_monitoring_config][crate::model::MonitoringConfig::cloud_monitoring_config].
    pub fn set_cloud_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::CloudMonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_monitoring_config = v.into();
        self
    }
}

impl wkt::message::Message for MonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.MonitoringConfig"
    }
}

/// ManagedPrometheusConfig defines the configuration for
/// Google Cloud Managed Service for Prometheus.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedPrometheusConfig {
    /// Enable Managed Collection.
    pub enabled: bool,
}

impl ManagedPrometheusConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ManagedPrometheusConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ManagedPrometheusConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.ManagedPrometheusConfig"
    }
}

/// CloudMonitoringConfig defines the configuration for
/// built-in Cloud Logging and Monitoring.
/// Only for Attached Clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudMonitoringConfig {
    /// Enable GKE-native logging and metrics.
    /// Only for Attached Clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,
}

impl CloudMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::CloudMonitoringConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for CloudMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.CloudMonitoringConfig"
    }
}

/// Configuration for Binary Authorization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BinaryAuthorization {
    /// Mode of operation for binauthz policy evaluation. If unspecified, defaults
    /// to DISABLED.
    pub evaluation_mode: crate::model::binary_authorization::EvaluationMode,
}

impl BinaryAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation_mode][crate::model::BinaryAuthorization::evaluation_mode].
    pub fn set_evaluation_mode<
        T: std::convert::Into<crate::model::binary_authorization::EvaluationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_mode = v.into();
        self
    }
}

impl wkt::message::Message for BinaryAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.BinaryAuthorization"
    }
}

/// Defines additional types related to BinaryAuthorization
pub mod binary_authorization {
    #[allow(unused_imports)]
    use super::*;

    /// Binary Authorization mode of operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EvaluationMode(i32);

    impl EvaluationMode {
        /// Default value
        pub const EVALUATION_MODE_UNSPECIFIED: EvaluationMode = EvaluationMode::new(0);

        /// Disable BinaryAuthorization
        pub const DISABLED: EvaluationMode = EvaluationMode::new(1);

        /// Enforce Kubernetes admission requests with BinaryAuthorization using the
        /// project's singleton policy.
        pub const PROJECT_SINGLETON_POLICY_ENFORCE: EvaluationMode = EvaluationMode::new(2);

        /// Creates a new EvaluationMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EVALUATION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("PROJECT_SINGLETON_POLICY_ENFORCE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EVALUATION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EVALUATION_MODE_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "PROJECT_SINGLETON_POLICY_ENFORCE" => {
                    std::option::Option::Some(Self::PROJECT_SINGLETON_POLICY_ENFORCE)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EvaluationMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EvaluationMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// SecurityPostureConfig defines the flags needed to enable/disable features for
/// the Security Posture API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecurityPostureConfig {
    /// Sets which mode to use for vulnerability scanning.
    pub vulnerability_mode: crate::model::security_posture_config::VulnerabilityMode,
}

impl SecurityPostureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vulnerability_mode][crate::model::SecurityPostureConfig::vulnerability_mode].
    pub fn set_vulnerability_mode<
        T: std::convert::Into<crate::model::security_posture_config::VulnerabilityMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerability_mode = v.into();
        self
    }
}

impl wkt::message::Message for SecurityPostureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkemulticloud.v1.SecurityPostureConfig"
    }
}

/// Defines additional types related to SecurityPostureConfig
pub mod security_posture_config {
    #[allow(unused_imports)]
    use super::*;

    /// VulnerabilityMode defines enablement mode for vulnerability scanning.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct VulnerabilityMode(i32);

    impl VulnerabilityMode {
        /// Default value not specified.
        pub const VULNERABILITY_MODE_UNSPECIFIED: VulnerabilityMode = VulnerabilityMode::new(0);

        /// Disables vulnerability scanning on the cluster.
        pub const VULNERABILITY_DISABLED: VulnerabilityMode = VulnerabilityMode::new(1);

        /// Applies the Security Posture's vulnerability on cluster Enterprise level
        /// features.
        pub const VULNERABILITY_ENTERPRISE: VulnerabilityMode = VulnerabilityMode::new(2);

        /// Creates a new VulnerabilityMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VULNERABILITY_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("VULNERABILITY_DISABLED"),
                2 => std::borrow::Cow::Borrowed("VULNERABILITY_ENTERPRISE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VULNERABILITY_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::VULNERABILITY_MODE_UNSPECIFIED)
                }
                "VULNERABILITY_DISABLED" => std::option::Option::Some(Self::VULNERABILITY_DISABLED),
                "VULNERABILITY_ENTERPRISE" => {
                    std::option::Option::Some(Self::VULNERABILITY_ENTERPRISE)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for VulnerabilityMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for VulnerabilityMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}
