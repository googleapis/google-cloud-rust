// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Connectivity Test for a network reachability analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectivityTest {
    /// Identifier. Unique name of the resource using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The user-supplied description of the Connectivity Test.
    /// Maximum of 512 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Source specification of the Connectivity Test.
    ///
    /// You can use a combination of source IP address, virtual machine
    /// (VM) instance, or Compute Engine network to uniquely identify
    /// the source location.
    ///
    /// Examples:
    /// If the source IP address is an internal IP address within a Google Cloud
    /// Virtual Private Cloud (VPC) network, then you must also specify the VPC
    /// network. Otherwise, specify the VM instance, which already contains its
    /// internal IP address and VPC network information.
    ///
    /// If the source of the test is within an on-premises network, then you must
    /// provide the destination VPC network.
    ///
    /// If the source endpoint is a Compute Engine VM instance with multiple
    /// network interfaces, the instance itself is not sufficient to identify the
    /// endpoint. So, you must also specify the source IP address or VPC network.
    ///
    /// A reachability analysis proceeds even if the source location is
    /// ambiguous. However, the test result may include endpoints that you don't
    /// intend to test.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Endpoint>,

    /// Required. Destination specification of the Connectivity Test.
    ///
    /// You can use a combination of destination IP address, Compute Engine
    /// VM instance, or VPC network to uniquely identify the destination
    /// location.
    ///
    /// Even if the destination IP address is not unique, the source IP
    /// location is unique. Usually, the analysis can infer the destination
    /// endpoint from route information.
    ///
    /// If the destination you specify is a VM instance and the instance has
    /// multiple network interfaces, then you must also specify either
    /// a destination IP address  or VPC network to identify the destination
    /// interface.
    ///
    /// A reachability analysis proceeds even if the destination location is
    /// ambiguous. However, the result can include endpoints that you don't
    /// intend to test.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::Endpoint>,

    /// IP Protocol of the test. When not provided, "TCP" is assumed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protocol: std::string::String,

    /// Other projects that may be relevant for reachability analysis.
    /// This is applicable to scenarios where a test can cross project boundaries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_projects: std::vec::Vec<std::string::String>,

    /// Output only. The display name of a Connectivity Test.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Resource labels to represent user-provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time the test was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the test's configuration was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The reachability details of this test from the latest run.
    /// The details are updated when creating a new test, updating an
    /// existing test, or triggering a one-time rerun of an existing test.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reachability_details: std::option::Option<crate::model::ReachabilityDetails>,

    /// Output only. The probing details of this test from the latest run, present
    /// for applicable tests only. The details are updated when creating a new
    /// test, updating an existing test, or triggering a one-time rerun of an
    /// existing test.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub probing_details: std::option::Option<crate::model::ProbingDetails>,

    /// Whether run analysis for the return path from destination to source.
    /// Default value is false.
    pub round_trip: bool,

    /// Output only. The reachability details of this test from the latest run for
    /// the return path. The details are updated when creating a new test,
    /// updating an existing test, or triggering a one-time rerun of an existing
    /// test.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub return_reachability_details: std::option::Option<crate::model::ReachabilityDetails>,

    /// Whether the test should skip firewall checking.
    /// If not provided, we assume false.
    pub bypass_firewall_checks: bool,
}

impl ConnectivityTest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectivityTest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConnectivityTest::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ConnectivityTest::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ConnectivityTest::destination].
    pub fn set_destination<T: std::convert::Into<std::option::Option<crate::model::Endpoint>>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::ConnectivityTest::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectivityTest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectivityTest::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectivityTest::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [reachability_details][crate::model::ConnectivityTest::reachability_details].
    pub fn set_reachability_details<
        T: std::convert::Into<std::option::Option<crate::model::ReachabilityDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reachability_details = v.into();
        self
    }

    /// Sets the value of [probing_details][crate::model::ConnectivityTest::probing_details].
    pub fn set_probing_details<
        T: std::convert::Into<std::option::Option<crate::model::ProbingDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probing_details = v.into();
        self
    }

    /// Sets the value of [round_trip][crate::model::ConnectivityTest::round_trip].
    pub fn set_round_trip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.round_trip = v.into();
        self
    }

    /// Sets the value of [return_reachability_details][crate::model::ConnectivityTest::return_reachability_details].
    pub fn set_return_reachability_details<
        T: std::convert::Into<std::option::Option<crate::model::ReachabilityDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.return_reachability_details = v.into();
        self
    }

    /// Sets the value of [bypass_firewall_checks][crate::model::ConnectivityTest::bypass_firewall_checks].
    pub fn set_bypass_firewall_checks<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.bypass_firewall_checks = v.into();
        self
    }

    /// Sets the value of [related_projects][crate::model::ConnectivityTest::related_projects].
    pub fn set_related_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::ConnectivityTest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ConnectivityTest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ConnectivityTest"
    }
}

/// Source or destination of the Connectivity Test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Endpoint {
    /// The IP address of the endpoint, which can be an external or internal IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// The IP protocol port of the endpoint.
    /// Only applicable when protocol is TCP or UDP.
    pub port: i32,

    /// A Compute Engine instance URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// A forwarding rule and its corresponding IP address represent the frontend
    /// configuration of a Google Cloud load balancer. Forwarding rules are also
    /// used for protocol forwarding, Private Service Connect and other network
    /// services to provide forwarding information in the control plane. Format:
    /// projects/{project}/global/forwardingRules/{id} or
    /// projects/{project}/regions/{region}/forwardingRules/{id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Output only. Specifies the type of the target of the forwarding rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub forwarding_rule_target: std::option::Option<crate::model::endpoint::ForwardingRuleTarget>,

    /// Output only. ID of the load balancer the forwarding rule points to. Empty
    /// for forwarding rules not related to load balancers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub load_balancer_id: std::option::Option<std::string::String>,

    /// Output only. Type of the load balancer the forwarding rule points to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub load_balancer_type: std::option::Option<crate::model::LoadBalancerType>,

    /// A cluster URI for [Google Kubernetes Engine cluster control
    /// plane](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gke_master_cluster: std::string::String,

    /// DNS endpoint of [Google Kubernetes Engine cluster control
    /// plane](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
    /// Requires gke_master_cluster to be set, can't be used simultaneoulsly with
    /// ip_address or network. Applicable only to destination endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    /// A [Cloud SQL](https://cloud.google.com/sql) instance URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_instance: std::string::String,

    /// A [Redis Instance](https://cloud.google.com/memorystore/docs/redis)
    /// URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub redis_instance: std::string::String,

    /// A [Redis Cluster](https://cloud.google.com/memorystore/docs/cluster)
    /// URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub redis_cluster: std::string::String,

    /// A [Cloud Function](https://cloud.google.com/functions).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_function: std::option::Option<crate::model::endpoint::CloudFunctionEndpoint>,

    /// An [App Engine](https://cloud.google.com/appengine) [service
    /// version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_engine_version: std::option::Option<crate::model::endpoint::AppEngineVersionEndpoint>,

    /// A [Cloud Run](https://cloud.google.com/run)
    /// [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_run_revision: std::option::Option<crate::model::endpoint::CloudRunRevisionEndpoint>,

    /// A Compute Engine network URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Type of the network where the endpoint is located.
    /// Applicable only to source endpoint, as destination network type can be
    /// inferred from the source.
    pub network_type: crate::model::endpoint::NetworkType,

    /// Project ID where the endpoint is located.
    /// The Project ID can be derived from the URI if you provide a VM instance or
    /// network URI.
    /// The following are two cases where you must provide the project ID:
    ///
    /// . Only the IP address is specified, and the IP address is within a Google
    ///   Cloud project.
    /// . When you are using Shared VPC and the IP address that you provide is
    ///   from the service project. In this case, the network that the IP address
    ///   resides in is defined in the host project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,
}

impl Endpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_address][crate::model::Endpoint::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::Endpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::Endpoint::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::Endpoint::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [forwarding_rule_target][crate::model::Endpoint::forwarding_rule_target].
    pub fn set_forwarding_rule_target<
        T: std::convert::Into<std::option::Option<crate::model::endpoint::ForwardingRuleTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.forwarding_rule_target = v.into();
        self
    }

    /// Sets the value of [load_balancer_id][crate::model::Endpoint::load_balancer_id].
    pub fn set_load_balancer_id<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_id = v.into();
        self
    }

    /// Sets the value of [load_balancer_type][crate::model::Endpoint::load_balancer_type].
    pub fn set_load_balancer_type<
        T: std::convert::Into<std::option::Option<crate::model::LoadBalancerType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_type = v.into();
        self
    }

    /// Sets the value of [gke_master_cluster][crate::model::Endpoint::gke_master_cluster].
    pub fn set_gke_master_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gke_master_cluster = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Endpoint::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [cloud_sql_instance][crate::model::Endpoint::cloud_sql_instance].
    pub fn set_cloud_sql_instance<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_sql_instance = v.into();
        self
    }

    /// Sets the value of [redis_instance][crate::model::Endpoint::redis_instance].
    pub fn set_redis_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redis_instance = v.into();
        self
    }

    /// Sets the value of [redis_cluster][crate::model::Endpoint::redis_cluster].
    pub fn set_redis_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redis_cluster = v.into();
        self
    }

    /// Sets the value of [cloud_function][crate::model::Endpoint::cloud_function].
    pub fn set_cloud_function<
        T: std::convert::Into<std::option::Option<crate::model::endpoint::CloudFunctionEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_function = v.into();
        self
    }

    /// Sets the value of [app_engine_version][crate::model::Endpoint::app_engine_version].
    pub fn set_app_engine_version<
        T: std::convert::Into<std::option::Option<crate::model::endpoint::AppEngineVersionEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_version = v.into();
        self
    }

    /// Sets the value of [cloud_run_revision][crate::model::Endpoint::cloud_run_revision].
    pub fn set_cloud_run_revision<
        T: std::convert::Into<std::option::Option<crate::model::endpoint::CloudRunRevisionEndpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_run_revision = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Endpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [network_type][crate::model::Endpoint::network_type].
    pub fn set_network_type<T: std::convert::Into<crate::model::endpoint::NetworkType>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_type = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Endpoint::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for Endpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint"
    }
}

/// Defines additional types related to Endpoint
pub mod endpoint {
    #[allow(unused_imports)]
    use super::*;

    /// Wrapper for Cloud Function attributes.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CloudFunctionEndpoint {
        /// A [Cloud Function](https://cloud.google.com/functions) name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,
    }

    impl CloudFunctionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::endpoint::CloudFunctionEndpoint::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudFunctionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint.CloudFunctionEndpoint"
        }
    }

    /// Wrapper for the App Engine service version attributes.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AppEngineVersionEndpoint {
        /// An [App Engine](https://cloud.google.com/appengine) [service
        /// version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions)
        /// name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,
    }

    impl AppEngineVersionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::endpoint::AppEngineVersionEndpoint::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for AppEngineVersionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint.AppEngineVersionEndpoint"
        }
    }

    /// Wrapper for Cloud Run revision attributes.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CloudRunRevisionEndpoint {
        /// A [Cloud Run](https://cloud.google.com/run)
        /// [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
        /// URI. The format is:
        /// projects/{project}/locations/{location}/revisions/{revision}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,
    }

    impl CloudRunRevisionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::endpoint::CloudRunRevisionEndpoint::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudRunRevisionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint.CloudRunRevisionEndpoint"
        }
    }

    /// The type definition of an endpoint's network. Use one of the
    /// following choices:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct NetworkType(i32);

    impl NetworkType {
        /// Default type if unspecified.
        pub const NETWORK_TYPE_UNSPECIFIED: NetworkType = NetworkType::new(0);

        /// A network hosted within Google Cloud.
        /// To receive more detailed output, specify the URI for the source or
        /// destination network.
        pub const GCP_NETWORK: NetworkType = NetworkType::new(1);

        /// A network hosted outside of Google Cloud.
        /// This can be an on-premises network, or a network hosted by another cloud
        /// provider.
        pub const NON_GCP_NETWORK: NetworkType = NetworkType::new(2);

        /// Creates a new NetworkType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("NETWORK_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GCP_NETWORK"),
                2 => std::borrow::Cow::Borrowed("NON_GCP_NETWORK"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "NETWORK_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::NETWORK_TYPE_UNSPECIFIED)
                }
                "GCP_NETWORK" => std::option::Option::Some(Self::GCP_NETWORK),
                "NON_GCP_NETWORK" => std::option::Option::Some(Self::NON_GCP_NETWORK),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for NetworkType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for NetworkType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of the target of a forwarding rule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ForwardingRuleTarget(i32);

    impl ForwardingRuleTarget {
        /// Forwarding rule target is unknown.
        pub const FORWARDING_RULE_TARGET_UNSPECIFIED: ForwardingRuleTarget =
            ForwardingRuleTarget::new(0);

        /// Compute Engine instance for protocol forwarding.
        pub const INSTANCE: ForwardingRuleTarget = ForwardingRuleTarget::new(1);

        /// Load Balancer. The specific type can be found from [load_balancer_type]
        /// [google.cloud.networkmanagement.v1.Endpoint.load_balancer_type].
        pub const LOAD_BALANCER: ForwardingRuleTarget = ForwardingRuleTarget::new(2);

        /// Classic Cloud VPN Gateway.
        pub const VPN_GATEWAY: ForwardingRuleTarget = ForwardingRuleTarget::new(3);

        /// Forwarding Rule is a Private Service Connect endpoint.
        pub const PSC: ForwardingRuleTarget = ForwardingRuleTarget::new(4);

        /// Creates a new ForwardingRuleTarget instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FORWARDING_RULE_TARGET_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INSTANCE"),
                2 => std::borrow::Cow::Borrowed("LOAD_BALANCER"),
                3 => std::borrow::Cow::Borrowed("VPN_GATEWAY"),
                4 => std::borrow::Cow::Borrowed("PSC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FORWARDING_RULE_TARGET_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FORWARDING_RULE_TARGET_UNSPECIFIED)
                }
                "INSTANCE" => std::option::Option::Some(Self::INSTANCE),
                "LOAD_BALANCER" => std::option::Option::Some(Self::LOAD_BALANCER),
                "VPN_GATEWAY" => std::option::Option::Some(Self::VPN_GATEWAY),
                "PSC" => std::option::Option::Some(Self::PSC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ForwardingRuleTarget {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ForwardingRuleTarget {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Results of the configuration analysis from the last run of the test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReachabilityDetails {
    /// The overall result of the test's configuration analysis.
    pub result: crate::model::reachability_details::Result,

    /// The time of the configuration analysis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_time: std::option::Option<wkt::Timestamp>,

    /// The details of a failure or a cancellation of reachability analysis.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Result may contain a list of traces if a test has multiple possible
    /// paths in the network, such as when destination endpoint is a load balancer
    /// with multiple backends.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub traces: std::vec::Vec<crate::model::Trace>,
}

impl ReachabilityDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ReachabilityDetails::result].
    pub fn set_result<T: std::convert::Into<crate::model::reachability_details::Result>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [verify_time][crate::model::ReachabilityDetails::verify_time].
    pub fn set_verify_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.verify_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ReachabilityDetails::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [traces][crate::model::ReachabilityDetails::traces].
    pub fn set_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trace>,
    {
        use std::iter::Iterator;
        self.traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReachabilityDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ReachabilityDetails"
    }
}

/// Defines additional types related to ReachabilityDetails
pub mod reachability_details {
    #[allow(unused_imports)]
    use super::*;

    /// The overall result of the test's configuration analysis.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Result(i32);

    impl Result {
        /// No result was specified.
        pub const RESULT_UNSPECIFIED: Result = Result::new(0);

        /// Possible scenarios are:
        ///
        /// * The configuration analysis determined that a packet originating from
        ///   the source is expected to reach the destination.
        /// * The analysis didn't complete because the user lacks permission for
        ///   some of the resources in the trace. However, at the time the user's
        ///   permission became insufficient, the trace had been successful so far.
        pub const REACHABLE: Result = Result::new(1);

        /// A packet originating from the source is expected to be dropped before
        /// reaching the destination.
        pub const UNREACHABLE: Result = Result::new(2);

        /// The source and destination endpoints do not uniquely identify
        /// the test location in the network, and the reachability result contains
        /// multiple traces. For some traces, a packet could be delivered, and for
        /// others, it would not be. This result is also assigned to
        /// configuration analysis of return path if on its own it should be
        /// REACHABLE, but configuration analysis of forward path is AMBIGUOUS.
        pub const AMBIGUOUS: Result = Result::new(4);

        /// The configuration analysis did not complete. Possible reasons are:
        ///
        /// * A permissions error occurred--for example, the user might not have
        ///   read permission for all of the resources named in the test.
        /// * An internal error occurred.
        /// * The analyzer received an invalid or unsupported argument or was unable
        ///   to identify a known endpoint.
        pub const UNDETERMINED: Result = Result::new(5);

        /// Creates a new Result instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESULT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REACHABLE"),
                2 => std::borrow::Cow::Borrowed("UNREACHABLE"),
                4 => std::borrow::Cow::Borrowed("AMBIGUOUS"),
                5 => std::borrow::Cow::Borrowed("UNDETERMINED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESULT_UNSPECIFIED" => std::option::Option::Some(Self::RESULT_UNSPECIFIED),
                "REACHABLE" => std::option::Option::Some(Self::REACHABLE),
                "UNREACHABLE" => std::option::Option::Some(Self::UNREACHABLE),
                "AMBIGUOUS" => std::option::Option::Some(Self::AMBIGUOUS),
                "UNDETERMINED" => std::option::Option::Some(Self::UNDETERMINED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Latency percentile rank and value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LatencyPercentile {
    /// Percentage of samples this data point applies to.
    pub percent: i32,

    /// percent-th percentile of latency observed, in microseconds.
    /// Fraction of percent/100 of samples have latency lower or
    /// equal to the value of this field.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub latency_micros: i64,
}

impl LatencyPercentile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [percent][crate::model::LatencyPercentile::percent].
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.percent = v.into();
        self
    }

    /// Sets the value of [latency_micros][crate::model::LatencyPercentile::latency_micros].
    pub fn set_latency_micros<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.latency_micros = v.into();
        self
    }
}

impl wkt::message::Message for LatencyPercentile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LatencyPercentile"
    }
}

/// Describes measured latency distribution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LatencyDistribution {
    /// Representative latency percentiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub latency_percentiles: std::vec::Vec<crate::model::LatencyPercentile>,
}

impl LatencyDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [latency_percentiles][crate::model::LatencyDistribution::latency_percentiles].
    pub fn set_latency_percentiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LatencyPercentile>,
    {
        use std::iter::Iterator;
        self.latency_percentiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LatencyDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LatencyDistribution"
    }
}

/// Results of active probing from the last run of the test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProbingDetails {
    /// The overall result of active probing.
    pub result: crate::model::probing_details::ProbingResult,

    /// The time that reachability was assessed through active probing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_time: std::option::Option<wkt::Timestamp>,

    /// Details about an internal failure or the cancellation of active probing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The reason probing was aborted.
    pub abort_cause: crate::model::probing_details::ProbingAbortCause,

    /// Number of probes sent.
    pub sent_probe_count: i32,

    /// Number of probes that reached the destination.
    pub successful_probe_count: i32,

    /// The source and destination endpoints derived from the test input and used
    /// for active probing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint_info: std::option::Option<crate::model::EndpointInfo>,

    /// Latency as measured by active probing in one direction:
    /// from the source to the destination endpoint.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub probing_latency: std::option::Option<crate::model::LatencyDistribution>,

    /// The EdgeLocation from which a packet destined for/originating from the
    /// internet will egress/ingress the Google network.
    /// This will only be populated for a connectivity test which has an internet
    /// destination/source address.
    /// The absence of this field *must not* be used as an indication that the
    /// destination/source is part of the Google network.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_egress_location:
        std::option::Option<crate::model::probing_details::EdgeLocation>,
}

impl ProbingDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ProbingDetails::result].
    pub fn set_result<T: std::convert::Into<crate::model::probing_details::ProbingResult>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [verify_time][crate::model::ProbingDetails::verify_time].
    pub fn set_verify_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.verify_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ProbingDetails::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [abort_cause][crate::model::ProbingDetails::abort_cause].
    pub fn set_abort_cause<
        T: std::convert::Into<crate::model::probing_details::ProbingAbortCause>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.abort_cause = v.into();
        self
    }

    /// Sets the value of [sent_probe_count][crate::model::ProbingDetails::sent_probe_count].
    pub fn set_sent_probe_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sent_probe_count = v.into();
        self
    }

    /// Sets the value of [successful_probe_count][crate::model::ProbingDetails::successful_probe_count].
    pub fn set_successful_probe_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.successful_probe_count = v.into();
        self
    }

    /// Sets the value of [endpoint_info][crate::model::ProbingDetails::endpoint_info].
    pub fn set_endpoint_info<
        T: std::convert::Into<std::option::Option<crate::model::EndpointInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_info = v.into();
        self
    }

    /// Sets the value of [probing_latency][crate::model::ProbingDetails::probing_latency].
    pub fn set_probing_latency<
        T: std::convert::Into<std::option::Option<crate::model::LatencyDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probing_latency = v.into();
        self
    }

    /// Sets the value of [destination_egress_location][crate::model::ProbingDetails::destination_egress_location].
    pub fn set_destination_egress_location<
        T: std::convert::Into<std::option::Option<crate::model::probing_details::EdgeLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_egress_location = v.into();
        self
    }
}

impl wkt::message::Message for ProbingDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ProbingDetails"
    }
}

/// Defines additional types related to ProbingDetails
pub mod probing_details {
    #[allow(unused_imports)]
    use super::*;

    /// Representation of a network edge location as per
    /// <https://cloud.google.com/vpc/docs/edge-locations>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EdgeLocation {
        /// Name of the metropolitan area.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metropolitan_area: std::string::String,
    }

    impl EdgeLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metropolitan_area][crate::model::probing_details::EdgeLocation::metropolitan_area].
        pub fn set_metropolitan_area<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.metropolitan_area = v.into();
            self
        }
    }

    impl wkt::message::Message for EdgeLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.ProbingDetails.EdgeLocation"
        }
    }

    /// Overall probing result of the test.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ProbingResult(i32);

    impl ProbingResult {
        /// No result was specified.
        pub const PROBING_RESULT_UNSPECIFIED: ProbingResult = ProbingResult::new(0);

        /// At least 95% of packets reached the destination.
        pub const REACHABLE: ProbingResult = ProbingResult::new(1);

        /// No packets reached the destination.
        pub const UNREACHABLE: ProbingResult = ProbingResult::new(2);

        /// Less than 95% of packets reached the destination.
        pub const REACHABILITY_INCONSISTENT: ProbingResult = ProbingResult::new(3);

        /// Reachability could not be determined. Possible reasons are:
        ///
        /// * The user lacks permission to access some of the network resources
        ///   required to run the test.
        /// * No valid source endpoint could be derived from the request.
        /// * An internal error occurred.
        pub const UNDETERMINED: ProbingResult = ProbingResult::new(4);

        /// Creates a new ProbingResult instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PROBING_RESULT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REACHABLE"),
                2 => std::borrow::Cow::Borrowed("UNREACHABLE"),
                3 => std::borrow::Cow::Borrowed("REACHABILITY_INCONSISTENT"),
                4 => std::borrow::Cow::Borrowed("UNDETERMINED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PROBING_RESULT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PROBING_RESULT_UNSPECIFIED)
                }
                "REACHABLE" => std::option::Option::Some(Self::REACHABLE),
                "UNREACHABLE" => std::option::Option::Some(Self::UNREACHABLE),
                "REACHABILITY_INCONSISTENT" => {
                    std::option::Option::Some(Self::REACHABILITY_INCONSISTENT)
                }
                "UNDETERMINED" => std::option::Option::Some(Self::UNDETERMINED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ProbingResult {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ProbingResult {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Abort cause types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ProbingAbortCause(i32);

    impl ProbingAbortCause {
        /// No reason was specified.
        pub const PROBING_ABORT_CAUSE_UNSPECIFIED: ProbingAbortCause = ProbingAbortCause::new(0);

        /// The user lacks permission to access some of the
        /// network resources required to run the test.
        pub const PERMISSION_DENIED: ProbingAbortCause = ProbingAbortCause::new(1);

        /// No valid source endpoint could be derived from the request.
        pub const NO_SOURCE_LOCATION: ProbingAbortCause = ProbingAbortCause::new(2);

        /// Creates a new ProbingAbortCause instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PROBING_ABORT_CAUSE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PERMISSION_DENIED"),
                2 => std::borrow::Cow::Borrowed("NO_SOURCE_LOCATION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PROBING_ABORT_CAUSE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PROBING_ABORT_CAUSE_UNSPECIFIED)
                }
                "PERMISSION_DENIED" => std::option::Option::Some(Self::PERMISSION_DENIED),
                "NO_SOURCE_LOCATION" => std::option::Option::Some(Self::NO_SOURCE_LOCATION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ProbingAbortCause {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ProbingAbortCause {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for the `ListConnectivityTests` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectivityTestsRequest {
    /// Required. The parent resource of the Connectivity Tests:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of `ConnectivityTests` to return.
    pub page_size: i32,

    /// Page token from an earlier query, as returned in `next_page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Lists the `ConnectivityTests` that match the filter expression. A filter
    /// expression filters the resources listed in the response. The expression
    /// must be of the form `<field> <operator> <value>` where operators: `<`, `>`,
    /// `<=`,
    /// `>=`,
    /// `!=`, `=`, `:` are supported (colon `:` represents a HAS operator which is
    /// roughly synonymous with equality). \<field\> can refer to a proto or JSON
    /// field, or a synthetic field. Field names can be camelCase or snake_case.
    ///
    /// Examples:
    ///
    /// - Filter by name:
    ///   name = "projects/proj-1/locations/global/connectivityTests/test-1
    ///
    /// - Filter by labels:
    ///
    ///   - Resources that have a key called `foo`
    ///     labels.foo:*
    ///   - Resources that have a key called `foo` whose value is `bar`
    ///     labels.foo = bar
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListConnectivityTestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectivityTestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectivityTestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectivityTestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectivityTestsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectivityTestsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectivityTestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListConnectivityTestsRequest"
    }
}

/// Response for the `ListConnectivityTests` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectivityTestsResponse {
    /// List of Connectivity Tests.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resources: std::vec::Vec<crate::model::ConnectivityTest>,

    /// Page token to fetch the next set of Connectivity Tests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached (when querying all locations with `-`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListConnectivityTestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectivityTestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [resources][crate::model::ListConnectivityTestsResponse::resources].
    pub fn set_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectivityTest>,
    {
        use std::iter::Iterator;
        self.resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectivityTestsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectivityTestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListConnectivityTestsResponse"
    }
}

impl gax::paginator::PageableResponse for ListConnectivityTestsResponse {
    type PageItem = crate::model::ConnectivityTest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resources
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for the `GetConnectivityTest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectivityTestRequest {
    /// Required. `ConnectivityTest` resource name using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectivityTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GetConnectivityTestRequest"
    }
}

/// Request for the `CreateConnectivityTest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectivityTestRequest {
    /// Required. The parent resource of the Connectivity Test to create:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The logical name of the Connectivity Test in your project
    /// with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-40 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the customer project
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub test_id: std::string::String,

    /// Required. A `ConnectivityTest` resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::ConnectivityTest>,
}

impl CreateConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectivityTestRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [test_id][crate::model::CreateConnectivityTestRequest::test_id].
    pub fn set_test_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_id = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::CreateConnectivityTestRequest::resource].
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::ConnectivityTest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CreateConnectivityTestRequest"
    }
}

/// Request for the `UpdateConnectivityTest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectivityTestRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::ConnectivityTest>,
}

impl UpdateConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectivityTestRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::UpdateConnectivityTestRequest::resource].
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::ConnectivityTest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.UpdateConnectivityTestRequest"
    }
}

/// Request for the `DeleteConnectivityTest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectivityTestRequest {
    /// Required. Connectivity Test resource name using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectivityTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DeleteConnectivityTestRequest"
    }
}

/// Request for the `RerunConnectivityTest` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RerunConnectivityTestRequest {
    /// Required. Connectivity Test resource name using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RerunConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RerunConnectivityTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RerunConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RerunConnectivityTestRequest"
    }
}

/// Metadata describing an [Operation][google.longrunning.Operation]
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Target of the operation - for example
    /// projects/project-1/locations/global/connectivityTests/test-1
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_detail: std::string::String,

    /// Specifies if cancellation was requested for the operation.
    pub cancel_requested: bool,

    /// API version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::OperationMetadata::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [cancel_requested][crate::model::OperationMetadata::cancel_requested].
    pub fn set_cancel_requested<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancel_requested = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.OperationMetadata"
    }
}

/// Trace represents one simulated packet forwarding path.
///
/// * Each trace contains multiple ordered steps.
/// * Each step is in a particular state with associated configuration.
/// * State is categorized as final or non-final states.
/// * Each final state has a reason associated.
/// * Each trace must end with a final state (the last step).
///
/// ```norust
///   |---------------------Trace----------------------|
///   Step1(State) Step2(State) ---  StepN(State(final))
/// ```
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trace {
    /// Derived from the source and destination endpoints definition specified by
    /// user request, and validated by the data plane model.
    /// If there are multiple traces starting from different source locations, then
    /// the endpoint_info may be different between traces.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint_info: std::option::Option<crate::model::EndpointInfo>,

    /// A trace of a test contains multiple steps from the initial state to the
    /// final state (delivered, dropped, forwarded, or aborted).
    ///
    /// The steps are ordered by the processing sequence within the simulated
    /// network state machine. It is critical to preserve the order of the steps
    /// and avoid reordering or sorting them.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::Step>,

    /// ID of trace. For forward traces, this ID is unique for each trace. For
    /// return traces, it matches ID of associated forward trace. A single forward
    /// trace can be associated with none, one or more than one return trace.
    pub forward_trace_id: i32,
}

impl Trace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint_info][crate::model::Trace::endpoint_info].
    pub fn set_endpoint_info<
        T: std::convert::Into<std::option::Option<crate::model::EndpointInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_info = v.into();
        self
    }

    /// Sets the value of [forward_trace_id][crate::model::Trace::forward_trace_id].
    pub fn set_forward_trace_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.forward_trace_id = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::Trace::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Trace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.Trace"
    }
}

/// A simulated forwarding path is composed of multiple steps.
/// Each step has a well-defined state and an associated configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Step {
    /// A description of the step. Usually this is a summary of the state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Each step is in one of the pre-defined states.
    pub state: crate::model::step::State,

    /// This is a step that leads to the final state Drop.
    pub causes_drop: bool,

    /// Project ID that contains the configuration this step is validating.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Configuration or metadata associated with each step.
    /// The configuration is filtered based on viewer's permission. If a viewer
    /// has no permission to view the configuration in this step, for non-final
    /// states a special state is populated (VIEWER_PERMISSION_MISSING), and for
    /// final state the configuration is cleared.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub step_info: std::option::Option<crate::model::step::StepInfo>,
}

impl Step {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Step::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Step::state].
    pub fn set_state<T: std::convert::Into<crate::model::step::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [causes_drop][crate::model::Step::causes_drop].
    pub fn set_causes_drop<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.causes_drop = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Step::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of `step_info`.
    pub fn set_step_info<
        T: std::convert::Into<std::option::Option<crate::model::step::StepInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = v.into();
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Instance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstanceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Instance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Firewall`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_firewall(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FirewallInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Firewall(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Route`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_route(&self) -> std::option::Option<&std::boxed::Box<crate::model::RouteInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Route(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Endpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_endpoint(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EndpointInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Endpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `GoogleService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_google_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleServiceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::GoogleService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ForwardingRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_forwarding_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardingRuleInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ForwardingRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `VpnGateway`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vpn_gateway(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpnGatewayInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::VpnGateway(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `VpnTunnel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vpn_tunnel(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpnTunnelInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::VpnTunnel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `VpcConnector`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vpc_connector(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcConnectorInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::VpcConnector(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Deliver`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_deliver(&self) -> std::option::Option<&std::boxed::Box<crate::model::DeliverInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Deliver(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Forward`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_forward(&self) -> std::option::Option<&std::boxed::Box<crate::model::ForwardInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Forward(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Abort`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_abort(&self) -> std::option::Option<&std::boxed::Box<crate::model::AbortInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Abort(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Drop`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_drop(&self) -> std::option::Option<&std::boxed::Box<crate::model::DropInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Drop(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `LoadBalancer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_load_balancer(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LoadBalancerInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::LoadBalancer(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Network`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_network(&self) -> std::option::Option<&std::boxed::Box<crate::model::NetworkInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Network(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `GkeMaster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gke_master(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GKEMasterInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::GkeMaster(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `CloudSqlInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_sql_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSQLInstanceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::CloudSqlInstance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `RedisInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_redis_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedisInstanceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::RedisInstance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `RedisCluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_redis_cluster(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedisClusterInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::RedisCluster(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `CloudFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_function(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudFunctionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::CloudFunction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `AppEngineVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_app_engine_version(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppEngineVersionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::AppEngineVersion(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `CloudRunRevision`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloud_run_revision(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudRunRevisionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::CloudRunRevision(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Nat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_nat(&self) -> std::option::Option<&std::boxed::Box<crate::model::NatInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Nat(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ProxyConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_proxy_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProxyConnectionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ProxyConnection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `LoadBalancerBackendInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_load_balancer_backend_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LoadBalancerBackendInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::LoadBalancerBackendInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `StorageBucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_storage_bucket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageBucketInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::StorageBucket(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ServerlessNeg`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_serverless_neg(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ServerlessNegInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ServerlessNeg(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Instance`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_instance<T: std::convert::Into<std::boxed::Box<crate::model::InstanceInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::Instance(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Firewall`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_firewall<T: std::convert::Into<std::boxed::Box<crate::model::FirewallInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::Firewall(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Route`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_route<T: std::convert::Into<std::boxed::Box<crate::model::RouteInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Route(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Endpoint`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_endpoint<T: std::convert::Into<std::boxed::Box<crate::model::EndpointInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::Endpoint(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `GoogleService`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_google_service<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleServiceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::GoogleService(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ForwardingRule`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_forwarding_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardingRuleInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::ForwardingRule(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `VpnGateway`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_vpn_gateway<T: std::convert::Into<std::boxed::Box<crate::model::VpnGatewayInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::VpnGateway(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `VpnTunnel`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_vpn_tunnel<T: std::convert::Into<std::boxed::Box<crate::model::VpnTunnelInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::VpnTunnel(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `VpcConnector`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_vpc_connector<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcConnectorInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::VpcConnector(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Deliver`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_deliver<T: std::convert::Into<std::boxed::Box<crate::model::DeliverInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Deliver(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Forward`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_forward<T: std::convert::Into<std::boxed::Box<crate::model::ForwardInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Forward(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Abort`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_abort<T: std::convert::Into<std::boxed::Box<crate::model::AbortInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Abort(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Drop`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_drop<T: std::convert::Into<std::boxed::Box<crate::model::DropInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Drop(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `LoadBalancer`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_load_balancer<
        T: std::convert::Into<std::boxed::Box<crate::model::LoadBalancerInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::LoadBalancer(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Network`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_network<T: std::convert::Into<std::boxed::Box<crate::model::NetworkInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Network(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `GkeMaster`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_gke_master<T: std::convert::Into<std::boxed::Box<crate::model::GKEMasterInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::GkeMaster(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `CloudSqlInstance`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_cloud_sql_instance<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLInstanceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::CloudSqlInstance(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `RedisInstance`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_redis_instance<
        T: std::convert::Into<std::boxed::Box<crate::model::RedisInstanceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::RedisInstance(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `RedisCluster`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_redis_cluster<
        T: std::convert::Into<std::boxed::Box<crate::model::RedisClusterInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::RedisCluster(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `CloudFunction`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_cloud_function<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudFunctionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::CloudFunction(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `AppEngineVersion`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_app_engine_version<
        T: std::convert::Into<std::boxed::Box<crate::model::AppEngineVersionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::AppEngineVersion(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `CloudRunRevision`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_cloud_run_revision<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudRunRevisionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::CloudRunRevision(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Nat`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_nat<T: std::convert::Into<std::boxed::Box<crate::model::NatInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Nat(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ProxyConnection`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_proxy_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::ProxyConnectionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::ProxyConnection(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `LoadBalancerBackendInfo`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_load_balancer_backend_info<
        T: std::convert::Into<std::boxed::Box<crate::model::LoadBalancerBackendInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(
            crate::model::step::StepInfo::LoadBalancerBackendInfo(v.into()),
        );
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `StorageBucket`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_storage_bucket<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageBucketInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::StorageBucket(v.into()));
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ServerlessNeg`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_serverless_neg<
        T: std::convert::Into<std::boxed::Box<crate::model::ServerlessNegInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::ServerlessNeg(v.into()));
        self
    }
}

impl wkt::message::Message for Step {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.Step"
    }
}

/// Defines additional types related to Step
pub mod step {
    #[allow(unused_imports)]
    use super::*;

    /// Type of states that are defined in the network state machine.
    /// Each step in the packet trace is in a specific state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Initial state: packet originating from a Compute Engine instance.
        /// An InstanceInfo is populated with starting instance information.
        pub const START_FROM_INSTANCE: State = State::new(1);

        /// Initial state: packet originating from the internet.
        /// The endpoint information is populated.
        pub const START_FROM_INTERNET: State = State::new(2);

        /// Initial state: packet originating from a Google service.
        /// The google_service information is populated.
        pub const START_FROM_GOOGLE_SERVICE: State = State::new(27);

        /// Initial state: packet originating from a VPC or on-premises network
        /// with internal source IP.
        /// If the source is a VPC network visible to the user, a NetworkInfo
        /// is populated with details of the network.
        pub const START_FROM_PRIVATE_NETWORK: State = State::new(3);

        /// Initial state: packet originating from a Google Kubernetes Engine cluster
        /// master. A GKEMasterInfo is populated with starting instance information.
        pub const START_FROM_GKE_MASTER: State = State::new(21);

        /// Initial state: packet originating from a Cloud SQL instance.
        /// A CloudSQLInstanceInfo is populated with starting instance information.
        pub const START_FROM_CLOUD_SQL_INSTANCE: State = State::new(22);

        /// Initial state: packet originating from a Redis instance.
        /// A RedisInstanceInfo is populated with starting instance information.
        pub const START_FROM_REDIS_INSTANCE: State = State::new(32);

        /// Initial state: packet originating from a Redis Cluster.
        /// A RedisClusterInfo is populated with starting Cluster information.
        pub const START_FROM_REDIS_CLUSTER: State = State::new(33);

        /// Initial state: packet originating from a Cloud Function.
        /// A CloudFunctionInfo is populated with starting function information.
        pub const START_FROM_CLOUD_FUNCTION: State = State::new(23);

        /// Initial state: packet originating from an App Engine service version.
        /// An AppEngineVersionInfo is populated with starting version information.
        pub const START_FROM_APP_ENGINE_VERSION: State = State::new(25);

        /// Initial state: packet originating from a Cloud Run revision.
        /// A CloudRunRevisionInfo is populated with starting revision information.
        pub const START_FROM_CLOUD_RUN_REVISION: State = State::new(26);

        /// Initial state: packet originating from a Storage Bucket. Used only for
        /// return traces.
        /// The storage_bucket information is populated.
        pub const START_FROM_STORAGE_BUCKET: State = State::new(29);

        /// Initial state: packet originating from a published service that uses
        /// Private Service Connect. Used only for return traces.
        pub const START_FROM_PSC_PUBLISHED_SERVICE: State = State::new(30);

        /// Initial state: packet originating from a serverless network endpoint
        /// group backend. Used only for return traces.
        /// The serverless_neg information is populated.
        pub const START_FROM_SERVERLESS_NEG: State = State::new(31);

        /// Config checking state: verify ingress firewall rule.
        pub const APPLY_INGRESS_FIREWALL_RULE: State = State::new(4);

        /// Config checking state: verify egress firewall rule.
        pub const APPLY_EGRESS_FIREWALL_RULE: State = State::new(5);

        /// Config checking state: verify route.
        pub const APPLY_ROUTE: State = State::new(6);

        /// Config checking state: match forwarding rule.
        pub const APPLY_FORWARDING_RULE: State = State::new(7);

        /// Config checking state: verify load balancer backend configuration.
        pub const ANALYZE_LOAD_BALANCER_BACKEND: State = State::new(28);

        /// Config checking state: packet sent or received under foreign IP
        /// address and allowed.
        pub const SPOOFING_APPROVED: State = State::new(8);

        /// Forwarding state: arriving at a Compute Engine instance.
        pub const ARRIVE_AT_INSTANCE: State = State::new(9);

        /// Forwarding state: arriving at a Compute Engine internal load balancer.
        pub const ARRIVE_AT_INTERNAL_LOAD_BALANCER: State = State::new(10);

        /// Forwarding state: arriving at a Compute Engine external load balancer.
        pub const ARRIVE_AT_EXTERNAL_LOAD_BALANCER: State = State::new(11);

        /// Forwarding state: arriving at a Cloud VPN gateway.
        pub const ARRIVE_AT_VPN_GATEWAY: State = State::new(12);

        /// Forwarding state: arriving at a Cloud VPN tunnel.
        pub const ARRIVE_AT_VPN_TUNNEL: State = State::new(13);

        /// Forwarding state: arriving at a VPC connector.
        pub const ARRIVE_AT_VPC_CONNECTOR: State = State::new(24);

        /// Transition state: packet header translated.
        pub const NAT: State = State::new(14);

        /// Transition state: original connection is terminated and a new proxied
        /// connection is initiated.
        pub const PROXY_CONNECTION: State = State::new(15);

        /// Final state: packet could be delivered.
        pub const DELIVER: State = State::new(16);

        /// Final state: packet could be dropped.
        pub const DROP: State = State::new(17);

        /// Final state: packet could be forwarded to a network with an unknown
        /// configuration.
        pub const FORWARD: State = State::new(18);

        /// Final state: analysis is aborted.
        pub const ABORT: State = State::new(19);

        /// Special state: viewer of the test result does not have permission to
        /// see the configuration in this step.
        pub const VIEWER_PERMISSION_MISSING: State = State::new(20);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("START_FROM_INSTANCE"),
                2 => std::borrow::Cow::Borrowed("START_FROM_INTERNET"),
                3 => std::borrow::Cow::Borrowed("START_FROM_PRIVATE_NETWORK"),
                4 => std::borrow::Cow::Borrowed("APPLY_INGRESS_FIREWALL_RULE"),
                5 => std::borrow::Cow::Borrowed("APPLY_EGRESS_FIREWALL_RULE"),
                6 => std::borrow::Cow::Borrowed("APPLY_ROUTE"),
                7 => std::borrow::Cow::Borrowed("APPLY_FORWARDING_RULE"),
                8 => std::borrow::Cow::Borrowed("SPOOFING_APPROVED"),
                9 => std::borrow::Cow::Borrowed("ARRIVE_AT_INSTANCE"),
                10 => std::borrow::Cow::Borrowed("ARRIVE_AT_INTERNAL_LOAD_BALANCER"),
                11 => std::borrow::Cow::Borrowed("ARRIVE_AT_EXTERNAL_LOAD_BALANCER"),
                12 => std::borrow::Cow::Borrowed("ARRIVE_AT_VPN_GATEWAY"),
                13 => std::borrow::Cow::Borrowed("ARRIVE_AT_VPN_TUNNEL"),
                14 => std::borrow::Cow::Borrowed("NAT"),
                15 => std::borrow::Cow::Borrowed("PROXY_CONNECTION"),
                16 => std::borrow::Cow::Borrowed("DELIVER"),
                17 => std::borrow::Cow::Borrowed("DROP"),
                18 => std::borrow::Cow::Borrowed("FORWARD"),
                19 => std::borrow::Cow::Borrowed("ABORT"),
                20 => std::borrow::Cow::Borrowed("VIEWER_PERMISSION_MISSING"),
                21 => std::borrow::Cow::Borrowed("START_FROM_GKE_MASTER"),
                22 => std::borrow::Cow::Borrowed("START_FROM_CLOUD_SQL_INSTANCE"),
                23 => std::borrow::Cow::Borrowed("START_FROM_CLOUD_FUNCTION"),
                24 => std::borrow::Cow::Borrowed("ARRIVE_AT_VPC_CONNECTOR"),
                25 => std::borrow::Cow::Borrowed("START_FROM_APP_ENGINE_VERSION"),
                26 => std::borrow::Cow::Borrowed("START_FROM_CLOUD_RUN_REVISION"),
                27 => std::borrow::Cow::Borrowed("START_FROM_GOOGLE_SERVICE"),
                28 => std::borrow::Cow::Borrowed("ANALYZE_LOAD_BALANCER_BACKEND"),
                29 => std::borrow::Cow::Borrowed("START_FROM_STORAGE_BUCKET"),
                30 => std::borrow::Cow::Borrowed("START_FROM_PSC_PUBLISHED_SERVICE"),
                31 => std::borrow::Cow::Borrowed("START_FROM_SERVERLESS_NEG"),
                32 => std::borrow::Cow::Borrowed("START_FROM_REDIS_INSTANCE"),
                33 => std::borrow::Cow::Borrowed("START_FROM_REDIS_CLUSTER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "START_FROM_INSTANCE" => std::option::Option::Some(Self::START_FROM_INSTANCE),
                "START_FROM_INTERNET" => std::option::Option::Some(Self::START_FROM_INTERNET),
                "START_FROM_GOOGLE_SERVICE" => {
                    std::option::Option::Some(Self::START_FROM_GOOGLE_SERVICE)
                }
                "START_FROM_PRIVATE_NETWORK" => {
                    std::option::Option::Some(Self::START_FROM_PRIVATE_NETWORK)
                }
                "START_FROM_GKE_MASTER" => std::option::Option::Some(Self::START_FROM_GKE_MASTER),
                "START_FROM_CLOUD_SQL_INSTANCE" => {
                    std::option::Option::Some(Self::START_FROM_CLOUD_SQL_INSTANCE)
                }
                "START_FROM_REDIS_INSTANCE" => {
                    std::option::Option::Some(Self::START_FROM_REDIS_INSTANCE)
                }
                "START_FROM_REDIS_CLUSTER" => {
                    std::option::Option::Some(Self::START_FROM_REDIS_CLUSTER)
                }
                "START_FROM_CLOUD_FUNCTION" => {
                    std::option::Option::Some(Self::START_FROM_CLOUD_FUNCTION)
                }
                "START_FROM_APP_ENGINE_VERSION" => {
                    std::option::Option::Some(Self::START_FROM_APP_ENGINE_VERSION)
                }
                "START_FROM_CLOUD_RUN_REVISION" => {
                    std::option::Option::Some(Self::START_FROM_CLOUD_RUN_REVISION)
                }
                "START_FROM_STORAGE_BUCKET" => {
                    std::option::Option::Some(Self::START_FROM_STORAGE_BUCKET)
                }
                "START_FROM_PSC_PUBLISHED_SERVICE" => {
                    std::option::Option::Some(Self::START_FROM_PSC_PUBLISHED_SERVICE)
                }
                "START_FROM_SERVERLESS_NEG" => {
                    std::option::Option::Some(Self::START_FROM_SERVERLESS_NEG)
                }
                "APPLY_INGRESS_FIREWALL_RULE" => {
                    std::option::Option::Some(Self::APPLY_INGRESS_FIREWALL_RULE)
                }
                "APPLY_EGRESS_FIREWALL_RULE" => {
                    std::option::Option::Some(Self::APPLY_EGRESS_FIREWALL_RULE)
                }
                "APPLY_ROUTE" => std::option::Option::Some(Self::APPLY_ROUTE),
                "APPLY_FORWARDING_RULE" => std::option::Option::Some(Self::APPLY_FORWARDING_RULE),
                "ANALYZE_LOAD_BALANCER_BACKEND" => {
                    std::option::Option::Some(Self::ANALYZE_LOAD_BALANCER_BACKEND)
                }
                "SPOOFING_APPROVED" => std::option::Option::Some(Self::SPOOFING_APPROVED),
                "ARRIVE_AT_INSTANCE" => std::option::Option::Some(Self::ARRIVE_AT_INSTANCE),
                "ARRIVE_AT_INTERNAL_LOAD_BALANCER" => {
                    std::option::Option::Some(Self::ARRIVE_AT_INTERNAL_LOAD_BALANCER)
                }
                "ARRIVE_AT_EXTERNAL_LOAD_BALANCER" => {
                    std::option::Option::Some(Self::ARRIVE_AT_EXTERNAL_LOAD_BALANCER)
                }
                "ARRIVE_AT_VPN_GATEWAY" => std::option::Option::Some(Self::ARRIVE_AT_VPN_GATEWAY),
                "ARRIVE_AT_VPN_TUNNEL" => std::option::Option::Some(Self::ARRIVE_AT_VPN_TUNNEL),
                "ARRIVE_AT_VPC_CONNECTOR" => {
                    std::option::Option::Some(Self::ARRIVE_AT_VPC_CONNECTOR)
                }
                "NAT" => std::option::Option::Some(Self::NAT),
                "PROXY_CONNECTION" => std::option::Option::Some(Self::PROXY_CONNECTION),
                "DELIVER" => std::option::Option::Some(Self::DELIVER),
                "DROP" => std::option::Option::Some(Self::DROP),
                "FORWARD" => std::option::Option::Some(Self::FORWARD),
                "ABORT" => std::option::Option::Some(Self::ABORT),
                "VIEWER_PERMISSION_MISSING" => {
                    std::option::Option::Some(Self::VIEWER_PERMISSION_MISSING)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Configuration or metadata associated with each step.
    /// The configuration is filtered based on viewer's permission. If a viewer
    /// has no permission to view the configuration in this step, for non-final
    /// states a special state is populated (VIEWER_PERMISSION_MISSING), and for
    /// final state the configuration is cleared.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StepInfo {
        /// Display information of a Compute Engine instance.
        Instance(std::boxed::Box<crate::model::InstanceInfo>),
        /// Display information of a Compute Engine firewall rule.
        Firewall(std::boxed::Box<crate::model::FirewallInfo>),
        /// Display information of a Compute Engine route.
        Route(std::boxed::Box<crate::model::RouteInfo>),
        /// Display information of the source and destination under analysis.
        /// The endpoint information in an intermediate state may differ with the
        /// initial input, as it might be modified by state like NAT,
        /// or Connection Proxy.
        Endpoint(std::boxed::Box<crate::model::EndpointInfo>),
        /// Display information of a Google service
        GoogleService(std::boxed::Box<crate::model::GoogleServiceInfo>),
        /// Display information of a Compute Engine forwarding rule.
        ForwardingRule(std::boxed::Box<crate::model::ForwardingRuleInfo>),
        /// Display information of a Compute Engine VPN gateway.
        VpnGateway(std::boxed::Box<crate::model::VpnGatewayInfo>),
        /// Display information of a Compute Engine VPN tunnel.
        VpnTunnel(std::boxed::Box<crate::model::VpnTunnelInfo>),
        /// Display information of a VPC connector.
        VpcConnector(std::boxed::Box<crate::model::VpcConnectorInfo>),
        /// Display information of the final state "deliver" and reason.
        Deliver(std::boxed::Box<crate::model::DeliverInfo>),
        /// Display information of the final state "forward" and reason.
        Forward(std::boxed::Box<crate::model::ForwardInfo>),
        /// Display information of the final state "abort" and reason.
        Abort(std::boxed::Box<crate::model::AbortInfo>),
        /// Display information of the final state "drop" and reason.
        Drop(std::boxed::Box<crate::model::DropInfo>),
        /// Display information of the load balancers. Deprecated in favor of the
        /// `load_balancer_backend_info` field, not used in new tests.
        LoadBalancer(std::boxed::Box<crate::model::LoadBalancerInfo>),
        /// Display information of a Google Cloud network.
        Network(std::boxed::Box<crate::model::NetworkInfo>),
        /// Display information of a Google Kubernetes Engine cluster master.
        GkeMaster(std::boxed::Box<crate::model::GKEMasterInfo>),
        /// Display information of a Cloud SQL instance.
        CloudSqlInstance(std::boxed::Box<crate::model::CloudSQLInstanceInfo>),
        /// Display information of a Redis Instance.
        RedisInstance(std::boxed::Box<crate::model::RedisInstanceInfo>),
        /// Display information of a Redis Cluster.
        RedisCluster(std::boxed::Box<crate::model::RedisClusterInfo>),
        /// Display information of a Cloud Function.
        CloudFunction(std::boxed::Box<crate::model::CloudFunctionInfo>),
        /// Display information of an App Engine service version.
        AppEngineVersion(std::boxed::Box<crate::model::AppEngineVersionInfo>),
        /// Display information of a Cloud Run revision.
        CloudRunRevision(std::boxed::Box<crate::model::CloudRunRevisionInfo>),
        /// Display information of a NAT.
        Nat(std::boxed::Box<crate::model::NatInfo>),
        /// Display information of a ProxyConnection.
        ProxyConnection(std::boxed::Box<crate::model::ProxyConnectionInfo>),
        /// Display information of a specific load balancer backend.
        LoadBalancerBackendInfo(std::boxed::Box<crate::model::LoadBalancerBackendInfo>),
        /// Display information of a Storage Bucket. Used only for return traces.
        StorageBucket(std::boxed::Box<crate::model::StorageBucketInfo>),
        /// Display information of a Serverless network endpoint group backend. Used
        /// only for return traces.
        ServerlessNeg(std::boxed::Box<crate::model::ServerlessNegInfo>),
    }
}

/// For display only. Metadata associated with a Compute Engine instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceInfo {
    /// Name of a Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Name of the network interface of a Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub interface: std::string::String,

    /// URI of a Compute Engine network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Internal IP address of the network interface.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// External IP address of the network interface.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_ip: std::string::String,

    /// Network tags configured on the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Service account authorized for the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// URI of the PSC network attachment the NIC is attached to (if relevant).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_network_attachment_uri: std::string::String,
}

impl InstanceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::InstanceInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::InstanceInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [interface][crate::model::InstanceInfo::interface].
    pub fn set_interface<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.interface = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::InstanceInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::InstanceInfo::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::InstanceInfo::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::InstanceInfo::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [psc_network_attachment_uri][crate::model::InstanceInfo::psc_network_attachment_uri].
    pub fn set_psc_network_attachment_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_network_attachment_uri = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::InstanceInfo::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstanceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.InstanceInfo"
    }
}

/// For display only. Metadata associated with a Compute Engine network.
/// Next ID: 7
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkInfo {
    /// Name of a Compute Engine network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Compute Engine network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// URI of the subnet matching the source IP address of the test.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub matched_subnet_uri: std::string::String,

    /// The IP range of the subnet matching the source IP address of the test.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub matched_ip_range: std::string::String,

    /// The region of the subnet matching the source IP address of the test.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl NetworkInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::NetworkInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::NetworkInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [matched_subnet_uri][crate::model::NetworkInfo::matched_subnet_uri].
    pub fn set_matched_subnet_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_subnet_uri = v.into();
        self
    }

    /// Sets the value of [matched_ip_range][crate::model::NetworkInfo::matched_ip_range].
    pub fn set_matched_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_ip_range = v.into();
        self
    }

    /// Sets the value of [region][crate::model::NetworkInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.NetworkInfo"
    }
}

/// For display only. Metadata associated with a VPC firewall rule, an implied
/// VPC firewall rule, or a firewall policy rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirewallInfo {
    /// The display name of the firewall rule. This field might be empty for
    /// firewall policy rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The URI of the firewall rule. This field is not applicable to implied
    /// VPC firewall rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Possible values: INGRESS, EGRESS
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub direction: std::string::String,

    /// Possible values: ALLOW, DENY, APPLY_SECURITY_PROFILE_GROUP
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action: std::string::String,

    /// The priority of the firewall rule.
    pub priority: i32,

    /// The URI of the VPC network that the firewall rule is associated with.
    /// This field is not applicable to hierarchical firewall policy rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// The target tags defined by the VPC firewall rule. This field is not
    /// applicable to firewall policy rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_tags: std::vec::Vec<std::string::String>,

    /// The target service accounts specified by the firewall rule.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_service_accounts: std::vec::Vec<std::string::String>,

    /// The name of the firewall policy that this rule is associated with.
    /// This field is not applicable to VPC firewall rules and implied VPC firewall
    /// rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy: std::string::String,

    /// The URI of the firewall policy that this rule is associated with.
    /// This field is not applicable to VPC firewall rules and implied VPC firewall
    /// rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_uri: std::string::String,

    /// The firewall rule's type.
    pub firewall_rule_type: crate::model::firewall_info::FirewallRuleType,
}

impl FirewallInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::FirewallInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::FirewallInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::FirewallInfo::direction].
    pub fn set_direction<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [action][crate::model::FirewallInfo::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::FirewallInfo::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::FirewallInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::FirewallInfo::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [policy_uri][crate::model::FirewallInfo::policy_uri].
    pub fn set_policy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_uri = v.into();
        self
    }

    /// Sets the value of [firewall_rule_type][crate::model::FirewallInfo::firewall_rule_type].
    pub fn set_firewall_rule_type<
        T: std::convert::Into<crate::model::firewall_info::FirewallRuleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_rule_type = v.into();
        self
    }

    /// Sets the value of [target_tags][crate::model::FirewallInfo::target_tags].
    pub fn set_target_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_service_accounts][crate::model::FirewallInfo::target_service_accounts].
    pub fn set_target_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FirewallInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.FirewallInfo"
    }
}

/// Defines additional types related to FirewallInfo
pub mod firewall_info {
    #[allow(unused_imports)]
    use super::*;

    /// The firewall rule's type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FirewallRuleType(i32);

    impl FirewallRuleType {
        /// Unspecified type.
        pub const FIREWALL_RULE_TYPE_UNSPECIFIED: FirewallRuleType = FirewallRuleType::new(0);

        /// Hierarchical firewall policy rule. For details, see
        /// [Hierarchical firewall policies
        /// overview](https://cloud.google.com/vpc/docs/firewall-policies).
        pub const HIERARCHICAL_FIREWALL_POLICY_RULE: FirewallRuleType = FirewallRuleType::new(1);

        /// VPC firewall rule. For details, see
        /// [VPC firewall rules
        /// overview](https://cloud.google.com/vpc/docs/firewalls).
        pub const VPC_FIREWALL_RULE: FirewallRuleType = FirewallRuleType::new(2);

        /// Implied VPC firewall rule. For details, see
        /// [Implied
        /// rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
        pub const IMPLIED_VPC_FIREWALL_RULE: FirewallRuleType = FirewallRuleType::new(3);

        /// Implicit firewall rules that are managed by serverless VPC access to
        /// allow ingress access. They are not visible in the Google Cloud console.
        /// For details, see [VPC connector's implicit
        /// rules](https://cloud.google.com/functions/docs/networking/connecting-vpc#restrict-access).
        pub const SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE: FirewallRuleType =
            FirewallRuleType::new(4);

        /// Global network firewall policy rule.
        /// For details, see [Network firewall
        /// policies](https://cloud.google.com/vpc/docs/network-firewall-policies).
        pub const NETWORK_FIREWALL_POLICY_RULE: FirewallRuleType = FirewallRuleType::new(5);

        /// Regional network firewall policy rule.
        /// For details, see [Regional network firewall
        /// policies](https://cloud.google.com/firewall/docs/regional-firewall-policies).
        pub const NETWORK_REGIONAL_FIREWALL_POLICY_RULE: FirewallRuleType =
            FirewallRuleType::new(6);

        /// Firewall policy rule containing attributes not yet supported in
        /// Connectivity tests. Firewall analysis is skipped if such a rule can
        /// potentially be matched. Please see the [list of unsupported
        /// configurations](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs).
        pub const UNSUPPORTED_FIREWALL_POLICY_RULE: FirewallRuleType = FirewallRuleType::new(100);

        /// Tracking state for response traffic created when request traffic goes
        /// through allow firewall rule.
        /// For details, see [firewall rules
        /// specifications](https://cloud.google.com/firewall/docs/firewalls#specifications)
        pub const TRACKING_STATE: FirewallRuleType = FirewallRuleType::new(101);

        /// Creates a new FirewallRuleType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FIREWALL_RULE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("HIERARCHICAL_FIREWALL_POLICY_RULE"),
                2 => std::borrow::Cow::Borrowed("VPC_FIREWALL_RULE"),
                3 => std::borrow::Cow::Borrowed("IMPLIED_VPC_FIREWALL_RULE"),
                4 => std::borrow::Cow::Borrowed("SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE"),
                5 => std::borrow::Cow::Borrowed("NETWORK_FIREWALL_POLICY_RULE"),
                6 => std::borrow::Cow::Borrowed("NETWORK_REGIONAL_FIREWALL_POLICY_RULE"),
                100 => std::borrow::Cow::Borrowed("UNSUPPORTED_FIREWALL_POLICY_RULE"),
                101 => std::borrow::Cow::Borrowed("TRACKING_STATE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FIREWALL_RULE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FIREWALL_RULE_TYPE_UNSPECIFIED)
                }
                "HIERARCHICAL_FIREWALL_POLICY_RULE" => {
                    std::option::Option::Some(Self::HIERARCHICAL_FIREWALL_POLICY_RULE)
                }
                "VPC_FIREWALL_RULE" => std::option::Option::Some(Self::VPC_FIREWALL_RULE),
                "IMPLIED_VPC_FIREWALL_RULE" => {
                    std::option::Option::Some(Self::IMPLIED_VPC_FIREWALL_RULE)
                }
                "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE" => {
                    std::option::Option::Some(Self::SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE)
                }
                "NETWORK_FIREWALL_POLICY_RULE" => {
                    std::option::Option::Some(Self::NETWORK_FIREWALL_POLICY_RULE)
                }
                "NETWORK_REGIONAL_FIREWALL_POLICY_RULE" => {
                    std::option::Option::Some(Self::NETWORK_REGIONAL_FIREWALL_POLICY_RULE)
                }
                "UNSUPPORTED_FIREWALL_POLICY_RULE" => {
                    std::option::Option::Some(Self::UNSUPPORTED_FIREWALL_POLICY_RULE)
                }
                "TRACKING_STATE" => std::option::Option::Some(Self::TRACKING_STATE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FirewallRuleType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FirewallRuleType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with a Compute Engine route.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RouteInfo {
    /// Type of route.
    pub route_type: crate::model::route_info::RouteType,

    /// Type of next hop.
    pub next_hop_type: crate::model::route_info::NextHopType,

    /// Indicates where route is applicable.
    pub route_scope: crate::model::route_info::RouteScope,

    /// Name of a route.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a route (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Region of the route (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Destination IP range of the route.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dest_ip_range: std::string::String,

    /// Next hop of the route.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_hop: std::string::String,

    /// URI of a Compute Engine network. NETWORK routes only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Priority of the route.
    pub priority: i32,

    /// Instance tags of the route.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_tags: std::vec::Vec<std::string::String>,

    /// Source IP address range of the route. Policy based routes only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub src_ip_range: std::string::String,

    /// Destination port ranges of the route. Policy based routes only.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dest_port_ranges: std::vec::Vec<std::string::String>,

    /// Source port ranges of the route. Policy based routes only.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub src_port_ranges: std::vec::Vec<std::string::String>,

    /// Protocols of the route. Policy based routes only.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub protocols: std::vec::Vec<std::string::String>,

    /// URI of a NCC Hub. NCC_HUB routes only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ncc_hub_uri: std::option::Option<std::string::String>,

    /// URI of a NCC Spoke. NCC_HUB routes only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ncc_spoke_uri: std::option::Option<std::string::String>,

    /// For advertised dynamic routes, the URI of the Cloud Router that advertised
    /// the corresponding IP prefix.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advertised_route_source_router_uri: std::option::Option<std::string::String>,

    /// For advertised routes, the URI of their next hop, i.e. the URI of the
    /// hybrid endpoint (VPN tunnel, Interconnect attachment, NCC router appliance)
    /// the advertised prefix is advertised through, or URI of the source peered
    /// network.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advertised_route_next_hop_uri: std::option::Option<std::string::String>,
}

impl RouteInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [route_type][crate::model::RouteInfo::route_type].
    pub fn set_route_type<T: std::convert::Into<crate::model::route_info::RouteType>>(
        mut self,
        v: T,
    ) -> Self {
        self.route_type = v.into();
        self
    }

    /// Sets the value of [next_hop_type][crate::model::RouteInfo::next_hop_type].
    pub fn set_next_hop_type<T: std::convert::Into<crate::model::route_info::NextHopType>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_hop_type = v.into();
        self
    }

    /// Sets the value of [route_scope][crate::model::RouteInfo::route_scope].
    pub fn set_route_scope<T: std::convert::Into<crate::model::route_info::RouteScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.route_scope = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RouteInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::RouteInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::RouteInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [dest_ip_range][crate::model::RouteInfo::dest_ip_range].
    pub fn set_dest_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dest_ip_range = v.into();
        self
    }

    /// Sets the value of [next_hop][crate::model::RouteInfo::next_hop].
    pub fn set_next_hop<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_hop = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::RouteInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::RouteInfo::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [src_ip_range][crate::model::RouteInfo::src_ip_range].
    pub fn set_src_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.src_ip_range = v.into();
        self
    }

    /// Sets the value of [ncc_hub_uri][crate::model::RouteInfo::ncc_hub_uri].
    pub fn set_ncc_hub_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ncc_hub_uri = v.into();
        self
    }

    /// Sets the value of [ncc_spoke_uri][crate::model::RouteInfo::ncc_spoke_uri].
    pub fn set_ncc_spoke_uri<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ncc_spoke_uri = v.into();
        self
    }

    /// Sets the value of [advertised_route_source_router_uri][crate::model::RouteInfo::advertised_route_source_router_uri].
    pub fn set_advertised_route_source_router_uri<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.advertised_route_source_router_uri = v.into();
        self
    }

    /// Sets the value of [advertised_route_next_hop_uri][crate::model::RouteInfo::advertised_route_next_hop_uri].
    pub fn set_advertised_route_next_hop_uri<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.advertised_route_next_hop_uri = v.into();
        self
    }

    /// Sets the value of [instance_tags][crate::model::RouteInfo::instance_tags].
    pub fn set_instance_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_port_ranges][crate::model::RouteInfo::dest_port_ranges].
    pub fn set_dest_port_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_port_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_port_ranges][crate::model::RouteInfo::src_port_ranges].
    pub fn set_src_port_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_port_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [protocols][crate::model::RouteInfo::protocols].
    pub fn set_protocols<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.protocols = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RouteInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RouteInfo"
    }
}

/// Defines additional types related to RouteInfo
pub mod route_info {
    #[allow(unused_imports)]
    use super::*;

    /// Type of route:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RouteType(i32);

    impl RouteType {
        /// Unspecified type. Default value.
        pub const ROUTE_TYPE_UNSPECIFIED: RouteType = RouteType::new(0);

        /// Route is a subnet route automatically created by the system.
        pub const SUBNET: RouteType = RouteType::new(1);

        /// Static route created by the user, including the default route to the
        /// internet.
        pub const STATIC: RouteType = RouteType::new(2);

        /// Dynamic route exchanged between BGP peers.
        pub const DYNAMIC: RouteType = RouteType::new(3);

        /// A subnet route received from peering network.
        pub const PEERING_SUBNET: RouteType = RouteType::new(4);

        /// A static route received from peering network.
        pub const PEERING_STATIC: RouteType = RouteType::new(5);

        /// A dynamic route received from peering network.
        pub const PEERING_DYNAMIC: RouteType = RouteType::new(6);

        /// Policy based route.
        pub const POLICY_BASED: RouteType = RouteType::new(7);

        /// Advertised route. Synthetic route which is used to transition from the
        /// StartFromPrivateNetwork state in Connectivity tests.
        pub const ADVERTISED: RouteType = RouteType::new(101);

        /// Creates a new RouteType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROUTE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SUBNET"),
                2 => std::borrow::Cow::Borrowed("STATIC"),
                3 => std::borrow::Cow::Borrowed("DYNAMIC"),
                4 => std::borrow::Cow::Borrowed("PEERING_SUBNET"),
                5 => std::borrow::Cow::Borrowed("PEERING_STATIC"),
                6 => std::borrow::Cow::Borrowed("PEERING_DYNAMIC"),
                7 => std::borrow::Cow::Borrowed("POLICY_BASED"),
                101 => std::borrow::Cow::Borrowed("ADVERTISED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROUTE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::ROUTE_TYPE_UNSPECIFIED),
                "SUBNET" => std::option::Option::Some(Self::SUBNET),
                "STATIC" => std::option::Option::Some(Self::STATIC),
                "DYNAMIC" => std::option::Option::Some(Self::DYNAMIC),
                "PEERING_SUBNET" => std::option::Option::Some(Self::PEERING_SUBNET),
                "PEERING_STATIC" => std::option::Option::Some(Self::PEERING_STATIC),
                "PEERING_DYNAMIC" => std::option::Option::Some(Self::PEERING_DYNAMIC),
                "POLICY_BASED" => std::option::Option::Some(Self::POLICY_BASED),
                "ADVERTISED" => std::option::Option::Some(Self::ADVERTISED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RouteType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RouteType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of next hop:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct NextHopType(i32);

    impl NextHopType {
        /// Unspecified type. Default value.
        pub const NEXT_HOP_TYPE_UNSPECIFIED: NextHopType = NextHopType::new(0);

        /// Next hop is an IP address.
        pub const NEXT_HOP_IP: NextHopType = NextHopType::new(1);

        /// Next hop is a Compute Engine instance.
        pub const NEXT_HOP_INSTANCE: NextHopType = NextHopType::new(2);

        /// Next hop is a VPC network gateway.
        pub const NEXT_HOP_NETWORK: NextHopType = NextHopType::new(3);

        /// Next hop is a peering VPC.
        pub const NEXT_HOP_PEERING: NextHopType = NextHopType::new(4);

        /// Next hop is an interconnect.
        pub const NEXT_HOP_INTERCONNECT: NextHopType = NextHopType::new(5);

        /// Next hop is a VPN tunnel.
        pub const NEXT_HOP_VPN_TUNNEL: NextHopType = NextHopType::new(6);

        /// Next hop is a VPN gateway. This scenario only happens when tracing
        /// connectivity from an on-premises network to Google Cloud through a VPN.
        /// The analysis simulates a packet departing from the on-premises network
        /// through a VPN tunnel and arriving at a Cloud VPN gateway.
        pub const NEXT_HOP_VPN_GATEWAY: NextHopType = NextHopType::new(7);

        /// Next hop is an internet gateway.
        pub const NEXT_HOP_INTERNET_GATEWAY: NextHopType = NextHopType::new(8);

        /// Next hop is blackhole; that is, the next hop either does not exist or is
        /// not running.
        pub const NEXT_HOP_BLACKHOLE: NextHopType = NextHopType::new(9);

        /// Next hop is the forwarding rule of an Internal Load Balancer.
        pub const NEXT_HOP_ILB: NextHopType = NextHopType::new(10);

        /// Next hop is a
        /// [router appliance
        /// instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
        pub const NEXT_HOP_ROUTER_APPLIANCE: NextHopType = NextHopType::new(11);

        /// Next hop is an NCC hub.
        pub const NEXT_HOP_NCC_HUB: NextHopType = NextHopType::new(12);

        /// Creates a new NextHopType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("NEXT_HOP_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NEXT_HOP_IP"),
                2 => std::borrow::Cow::Borrowed("NEXT_HOP_INSTANCE"),
                3 => std::borrow::Cow::Borrowed("NEXT_HOP_NETWORK"),
                4 => std::borrow::Cow::Borrowed("NEXT_HOP_PEERING"),
                5 => std::borrow::Cow::Borrowed("NEXT_HOP_INTERCONNECT"),
                6 => std::borrow::Cow::Borrowed("NEXT_HOP_VPN_TUNNEL"),
                7 => std::borrow::Cow::Borrowed("NEXT_HOP_VPN_GATEWAY"),
                8 => std::borrow::Cow::Borrowed("NEXT_HOP_INTERNET_GATEWAY"),
                9 => std::borrow::Cow::Borrowed("NEXT_HOP_BLACKHOLE"),
                10 => std::borrow::Cow::Borrowed("NEXT_HOP_ILB"),
                11 => std::borrow::Cow::Borrowed("NEXT_HOP_ROUTER_APPLIANCE"),
                12 => std::borrow::Cow::Borrowed("NEXT_HOP_NCC_HUB"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "NEXT_HOP_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::NEXT_HOP_TYPE_UNSPECIFIED)
                }
                "NEXT_HOP_IP" => std::option::Option::Some(Self::NEXT_HOP_IP),
                "NEXT_HOP_INSTANCE" => std::option::Option::Some(Self::NEXT_HOP_INSTANCE),
                "NEXT_HOP_NETWORK" => std::option::Option::Some(Self::NEXT_HOP_NETWORK),
                "NEXT_HOP_PEERING" => std::option::Option::Some(Self::NEXT_HOP_PEERING),
                "NEXT_HOP_INTERCONNECT" => std::option::Option::Some(Self::NEXT_HOP_INTERCONNECT),
                "NEXT_HOP_VPN_TUNNEL" => std::option::Option::Some(Self::NEXT_HOP_VPN_TUNNEL),
                "NEXT_HOP_VPN_GATEWAY" => std::option::Option::Some(Self::NEXT_HOP_VPN_GATEWAY),
                "NEXT_HOP_INTERNET_GATEWAY" => {
                    std::option::Option::Some(Self::NEXT_HOP_INTERNET_GATEWAY)
                }
                "NEXT_HOP_BLACKHOLE" => std::option::Option::Some(Self::NEXT_HOP_BLACKHOLE),
                "NEXT_HOP_ILB" => std::option::Option::Some(Self::NEXT_HOP_ILB),
                "NEXT_HOP_ROUTER_APPLIANCE" => {
                    std::option::Option::Some(Self::NEXT_HOP_ROUTER_APPLIANCE)
                }
                "NEXT_HOP_NCC_HUB" => std::option::Option::Some(Self::NEXT_HOP_NCC_HUB),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for NextHopType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for NextHopType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates where routes are applicable.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RouteScope(i32);

    impl RouteScope {
        /// Unspecified scope. Default value.
        pub const ROUTE_SCOPE_UNSPECIFIED: RouteScope = RouteScope::new(0);

        /// Route is applicable to packets in Network.
        pub const NETWORK: RouteScope = RouteScope::new(1);

        /// Route is applicable to packets using NCC Hub's routing table.
        pub const NCC_HUB: RouteScope = RouteScope::new(2);

        /// Creates a new RouteScope instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROUTE_SCOPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NETWORK"),
                2 => std::borrow::Cow::Borrowed("NCC_HUB"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROUTE_SCOPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ROUTE_SCOPE_UNSPECIFIED)
                }
                "NETWORK" => std::option::Option::Some(Self::NETWORK),
                "NCC_HUB" => std::option::Option::Some(Self::NCC_HUB),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RouteScope {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RouteScope {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Details of a Google Service sending packets to a
/// VPC network. Although the source IP might be a publicly routable address,
/// some Google Services use special routes within Google production
/// infrastructure to reach Compute Engine Instances.
/// <https://cloud.google.com/vpc/docs/routes#special_return_paths>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleServiceInfo {
    /// Source IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_ip: std::string::String,

    /// Recognized type of a Google Service.
    pub google_service_type: crate::model::google_service_info::GoogleServiceType,
}

impl GoogleServiceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_ip][crate::model::GoogleServiceInfo::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [google_service_type][crate::model::GoogleServiceInfo::google_service_type].
    pub fn set_google_service_type<
        T: std::convert::Into<crate::model::google_service_info::GoogleServiceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_service_type = v.into();
        self
    }
}

impl wkt::message::Message for GoogleServiceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GoogleServiceInfo"
    }
}

/// Defines additional types related to GoogleServiceInfo
pub mod google_service_info {
    #[allow(unused_imports)]
    use super::*;

    /// Recognized type of a Google Service.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct GoogleServiceType(i32);

    impl GoogleServiceType {
        /// Unspecified Google Service.
        pub const GOOGLE_SERVICE_TYPE_UNSPECIFIED: GoogleServiceType = GoogleServiceType::new(0);

        /// Identity aware proxy.
        /// <https://cloud.google.com/iap/docs/using-tcp-forwarding>
        pub const IAP: GoogleServiceType = GoogleServiceType::new(1);

        /// One of two services sharing IP ranges:
        ///
        /// * Load Balancer proxy
        /// * Centralized Health Check prober
        ///   <https://cloud.google.com/load-balancing/docs/firewall-rules>
        pub const GFE_PROXY_OR_HEALTH_CHECK_PROBER: GoogleServiceType = GoogleServiceType::new(2);

        /// Connectivity from Cloud DNS to forwarding targets or alternate name
        /// servers that use private routing.
        /// <https://cloud.google.com/dns/docs/zones/forwarding-zones#firewall-rules>
        /// <https://cloud.google.com/dns/docs/policies#firewall-rules>
        pub const CLOUD_DNS: GoogleServiceType = GoogleServiceType::new(3);

        /// private.googleapis.com and restricted.googleapis.com
        pub const GOOGLE_API: GoogleServiceType = GoogleServiceType::new(4);

        /// Google API via Private Service Connect.
        /// <https://cloud.google.com/vpc/docs/configure-private-service-connect-apis>
        pub const GOOGLE_API_PSC: GoogleServiceType = GoogleServiceType::new(5);

        /// Google API via VPC Service Controls.
        /// <https://cloud.google.com/vpc/docs/configure-private-service-connect-apis>
        pub const GOOGLE_API_VPC_SC: GoogleServiceType = GoogleServiceType::new(6);

        /// Creates a new GoogleServiceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("GOOGLE_SERVICE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IAP"),
                2 => std::borrow::Cow::Borrowed("GFE_PROXY_OR_HEALTH_CHECK_PROBER"),
                3 => std::borrow::Cow::Borrowed("CLOUD_DNS"),
                4 => std::borrow::Cow::Borrowed("GOOGLE_API"),
                5 => std::borrow::Cow::Borrowed("GOOGLE_API_PSC"),
                6 => std::borrow::Cow::Borrowed("GOOGLE_API_VPC_SC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "GOOGLE_SERVICE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::GOOGLE_SERVICE_TYPE_UNSPECIFIED)
                }
                "IAP" => std::option::Option::Some(Self::IAP),
                "GFE_PROXY_OR_HEALTH_CHECK_PROBER" => {
                    std::option::Option::Some(Self::GFE_PROXY_OR_HEALTH_CHECK_PROBER)
                }
                "CLOUD_DNS" => std::option::Option::Some(Self::CLOUD_DNS),
                "GOOGLE_API" => std::option::Option::Some(Self::GOOGLE_API),
                "GOOGLE_API_PSC" => std::option::Option::Some(Self::GOOGLE_API_PSC),
                "GOOGLE_API_VPC_SC" => std::option::Option::Some(Self::GOOGLE_API_VPC_SC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for GoogleServiceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for GoogleServiceType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with a Compute Engine forwarding rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForwardingRuleInfo {
    /// Name of the forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of the forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Protocol defined in the forwarding rule that matches the packet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub matched_protocol: std::string::String,

    /// Port range defined in the forwarding rule that matches the packet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub matched_port_range: std::string::String,

    /// VIP of the forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vip: std::string::String,

    /// Target type of the forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Network URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Region of the forwarding rule. Set only for regional forwarding rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Name of the load balancer the forwarding rule belongs to. Empty for
    /// forwarding rules not related to load balancers (like PSC forwarding rules).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub load_balancer_name: std::string::String,

    /// URI of the PSC service attachment this forwarding rule targets (if
    /// applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_service_attachment_uri: std::string::String,

    /// PSC Google API target this forwarding rule targets (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_google_api_target: std::string::String,
}

impl ForwardingRuleInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::ForwardingRuleInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ForwardingRuleInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [matched_protocol][crate::model::ForwardingRuleInfo::matched_protocol].
    pub fn set_matched_protocol<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_protocol = v.into();
        self
    }

    /// Sets the value of [matched_port_range][crate::model::ForwardingRuleInfo::matched_port_range].
    pub fn set_matched_port_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_port_range = v.into();
        self
    }

    /// Sets the value of [vip][crate::model::ForwardingRuleInfo::vip].
    pub fn set_vip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vip = v.into();
        self
    }

    /// Sets the value of [target][crate::model::ForwardingRuleInfo::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::ForwardingRuleInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ForwardingRuleInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [load_balancer_name][crate::model::ForwardingRuleInfo::load_balancer_name].
    pub fn set_load_balancer_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_name = v.into();
        self
    }

    /// Sets the value of [psc_service_attachment_uri][crate::model::ForwardingRuleInfo::psc_service_attachment_uri].
    pub fn set_psc_service_attachment_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_service_attachment_uri = v.into();
        self
    }

    /// Sets the value of [psc_google_api_target][crate::model::ForwardingRuleInfo::psc_google_api_target].
    pub fn set_psc_google_api_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_google_api_target = v.into();
        self
    }
}

impl wkt::message::Message for ForwardingRuleInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ForwardingRuleInfo"
    }
}

/// For display only. Metadata associated with a load balancer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoadBalancerInfo {
    /// Type of the load balancer.
    pub load_balancer_type: crate::model::load_balancer_info::LoadBalancerType,

    /// URI of the health check for the load balancer. Deprecated and no longer
    /// populated as different load balancer backends might have different health
    /// checks.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_check_uri: std::string::String,

    /// Information for the loadbalancer backends.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backends: std::vec::Vec<crate::model::LoadBalancerBackend>,

    /// Type of load balancer's backend configuration.
    pub backend_type: crate::model::load_balancer_info::BackendType,

    /// Backend configuration URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backend_uri: std::string::String,
}

impl LoadBalancerInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [load_balancer_type][crate::model::LoadBalancerInfo::load_balancer_type].
    pub fn set_load_balancer_type<
        T: std::convert::Into<crate::model::load_balancer_info::LoadBalancerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_type = v.into();
        self
    }

    /// Sets the value of [health_check_uri][crate::model::LoadBalancerInfo::health_check_uri].
    pub fn set_health_check_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_uri = v.into();
        self
    }

    /// Sets the value of [backend_type][crate::model::LoadBalancerInfo::backend_type].
    pub fn set_backend_type<
        T: std::convert::Into<crate::model::load_balancer_info::BackendType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [backend_uri][crate::model::LoadBalancerInfo::backend_uri].
    pub fn set_backend_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backend_uri = v.into();
        self
    }

    /// Sets the value of [backends][crate::model::LoadBalancerInfo::backends].
    pub fn set_backends<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LoadBalancerBackend>,
    {
        use std::iter::Iterator;
        self.backends = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoadBalancerInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LoadBalancerInfo"
    }
}

/// Defines additional types related to LoadBalancerInfo
pub mod load_balancer_info {
    #[allow(unused_imports)]
    use super::*;

    /// The type definition for a load balancer:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LoadBalancerType(i32);

    impl LoadBalancerType {
        /// Type is unspecified.
        pub const LOAD_BALANCER_TYPE_UNSPECIFIED: LoadBalancerType = LoadBalancerType::new(0);

        /// Internal TCP/UDP load balancer.
        pub const INTERNAL_TCP_UDP: LoadBalancerType = LoadBalancerType::new(1);

        /// Network TCP/UDP load balancer.
        pub const NETWORK_TCP_UDP: LoadBalancerType = LoadBalancerType::new(2);

        /// HTTP(S) proxy load balancer.
        pub const HTTP_PROXY: LoadBalancerType = LoadBalancerType::new(3);

        /// TCP proxy load balancer.
        pub const TCP_PROXY: LoadBalancerType = LoadBalancerType::new(4);

        /// SSL proxy load balancer.
        pub const SSL_PROXY: LoadBalancerType = LoadBalancerType::new(5);

        /// Creates a new LoadBalancerType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LOAD_BALANCER_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INTERNAL_TCP_UDP"),
                2 => std::borrow::Cow::Borrowed("NETWORK_TCP_UDP"),
                3 => std::borrow::Cow::Borrowed("HTTP_PROXY"),
                4 => std::borrow::Cow::Borrowed("TCP_PROXY"),
                5 => std::borrow::Cow::Borrowed("SSL_PROXY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LOAD_BALANCER_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::LOAD_BALANCER_TYPE_UNSPECIFIED)
                }
                "INTERNAL_TCP_UDP" => std::option::Option::Some(Self::INTERNAL_TCP_UDP),
                "NETWORK_TCP_UDP" => std::option::Option::Some(Self::NETWORK_TCP_UDP),
                "HTTP_PROXY" => std::option::Option::Some(Self::HTTP_PROXY),
                "TCP_PROXY" => std::option::Option::Some(Self::TCP_PROXY),
                "SSL_PROXY" => std::option::Option::Some(Self::SSL_PROXY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LoadBalancerType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LoadBalancerType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The type definition for a load balancer backend configuration:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BackendType(i32);

    impl BackendType {
        /// Type is unspecified.
        pub const BACKEND_TYPE_UNSPECIFIED: BackendType = BackendType::new(0);

        /// Backend Service as the load balancer's backend.
        pub const BACKEND_SERVICE: BackendType = BackendType::new(1);

        /// Target Pool as the load balancer's backend.
        pub const TARGET_POOL: BackendType = BackendType::new(2);

        /// Target Instance as the load balancer's backend.
        pub const TARGET_INSTANCE: BackendType = BackendType::new(3);

        /// Creates a new BackendType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BACKEND_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BACKEND_SERVICE"),
                2 => std::borrow::Cow::Borrowed("TARGET_POOL"),
                3 => std::borrow::Cow::Borrowed("TARGET_INSTANCE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BACKEND_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::BACKEND_TYPE_UNSPECIFIED)
                }
                "BACKEND_SERVICE" => std::option::Option::Some(Self::BACKEND_SERVICE),
                "TARGET_POOL" => std::option::Option::Some(Self::TARGET_POOL),
                "TARGET_INSTANCE" => std::option::Option::Some(Self::TARGET_INSTANCE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BackendType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BackendType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with a specific load balancer backend.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoadBalancerBackend {
    /// Name of a Compute Engine instance or network endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Compute Engine instance or network endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// State of the health check firewall configuration.
    pub health_check_firewall_state: crate::model::load_balancer_backend::HealthCheckFirewallState,

    /// A list of firewall rule URIs allowing probes from health check IP ranges.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub health_check_allowing_firewall_rules: std::vec::Vec<std::string::String>,

    /// A list of firewall rule URIs blocking probes from health check IP ranges.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub health_check_blocking_firewall_rules: std::vec::Vec<std::string::String>,
}

impl LoadBalancerBackend {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::LoadBalancerBackend::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::LoadBalancerBackend::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [health_check_firewall_state][crate::model::LoadBalancerBackend::health_check_firewall_state].
    pub fn set_health_check_firewall_state<
        T: std::convert::Into<crate::model::load_balancer_backend::HealthCheckFirewallState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_firewall_state = v.into();
        self
    }

    /// Sets the value of [health_check_allowing_firewall_rules][crate::model::LoadBalancerBackend::health_check_allowing_firewall_rules].
    pub fn set_health_check_allowing_firewall_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.health_check_allowing_firewall_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [health_check_blocking_firewall_rules][crate::model::LoadBalancerBackend::health_check_blocking_firewall_rules].
    pub fn set_health_check_blocking_firewall_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.health_check_blocking_firewall_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoadBalancerBackend {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LoadBalancerBackend"
    }
}

/// Defines additional types related to LoadBalancerBackend
pub mod load_balancer_backend {
    #[allow(unused_imports)]
    use super::*;

    /// State of a health check firewall configuration:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HealthCheckFirewallState(i32);

    impl HealthCheckFirewallState {
        /// State is unspecified. Default state if not populated.
        pub const HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED: HealthCheckFirewallState =
            HealthCheckFirewallState::new(0);

        /// There are configured firewall rules to allow health check probes to the
        /// backend.
        pub const CONFIGURED: HealthCheckFirewallState = HealthCheckFirewallState::new(1);

        /// There are firewall rules configured to allow partial health check ranges
        /// or block all health check ranges.
        /// If a health check probe is sent from denied IP ranges,
        /// the health check to the backend will fail. Then, the backend will be
        /// marked unhealthy and will not receive traffic sent to the load balancer.
        pub const MISCONFIGURED: HealthCheckFirewallState = HealthCheckFirewallState::new(2);

        /// Creates a new HealthCheckFirewallState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CONFIGURED"),
                2 => std::borrow::Cow::Borrowed("MISCONFIGURED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED)
                }
                "CONFIGURED" => std::option::Option::Some(Self::CONFIGURED),
                "MISCONFIGURED" => std::option::Option::Some(Self::MISCONFIGURED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for HealthCheckFirewallState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for HealthCheckFirewallState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with a Compute Engine VPN gateway.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpnGatewayInfo {
    /// Name of a VPN gateway.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a VPN gateway.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// URI of a Compute Engine network where the VPN gateway is configured.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// IP address of the VPN gateway.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// A VPN tunnel that is associated with this VPN gateway.
    /// There may be multiple VPN tunnels configured on a VPN gateway, and only
    /// the one relevant to the test is displayed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpn_tunnel_uri: std::string::String,

    /// Name of a Google Cloud region where this VPN gateway is configured.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl VpnGatewayInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::VpnGatewayInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::VpnGatewayInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::VpnGatewayInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::VpnGatewayInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [vpn_tunnel_uri][crate::model::VpnGatewayInfo::vpn_tunnel_uri].
    pub fn set_vpn_tunnel_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpn_tunnel_uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::VpnGatewayInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for VpnGatewayInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpnGatewayInfo"
    }
}

/// For display only. Metadata associated with a Compute Engine VPN tunnel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpnTunnelInfo {
    /// Name of a VPN tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a VPN tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// URI of the VPN gateway at local end of the tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_gateway: std::string::String,

    /// URI of a VPN gateway at remote end of the tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remote_gateway: std::string::String,

    /// Remote VPN gateway's IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remote_gateway_ip: std::string::String,

    /// Local VPN gateway's IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_gateway_ip: std::string::String,

    /// URI of a Compute Engine network where the VPN tunnel is configured.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Name of a Google Cloud region where this VPN tunnel is configured.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Type of the routing policy.
    pub routing_type: crate::model::vpn_tunnel_info::RoutingType,
}

impl VpnTunnelInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::VpnTunnelInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::VpnTunnelInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [source_gateway][crate::model::VpnTunnelInfo::source_gateway].
    pub fn set_source_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_gateway = v.into();
        self
    }

    /// Sets the value of [remote_gateway][crate::model::VpnTunnelInfo::remote_gateway].
    pub fn set_remote_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_gateway = v.into();
        self
    }

    /// Sets the value of [remote_gateway_ip][crate::model::VpnTunnelInfo::remote_gateway_ip].
    pub fn set_remote_gateway_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remote_gateway_ip = v.into();
        self
    }

    /// Sets the value of [source_gateway_ip][crate::model::VpnTunnelInfo::source_gateway_ip].
    pub fn set_source_gateway_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_gateway_ip = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::VpnTunnelInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::VpnTunnelInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [routing_type][crate::model::VpnTunnelInfo::routing_type].
    pub fn set_routing_type<T: std::convert::Into<crate::model::vpn_tunnel_info::RoutingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.routing_type = v.into();
        self
    }
}

impl wkt::message::Message for VpnTunnelInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpnTunnelInfo"
    }
}

/// Defines additional types related to VpnTunnelInfo
pub mod vpn_tunnel_info {
    #[allow(unused_imports)]
    use super::*;

    /// Types of VPN routing policy. For details, refer to [Networks and Tunnel
    /// routing](https://cloud.google.com/network-connectivity/docs/vpn/concepts/choosing-networks-routing/).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RoutingType(i32);

    impl RoutingType {
        /// Unspecified type. Default value.
        pub const ROUTING_TYPE_UNSPECIFIED: RoutingType = RoutingType::new(0);

        /// Route based VPN.
        pub const ROUTE_BASED: RoutingType = RoutingType::new(1);

        /// Policy based routing.
        pub const POLICY_BASED: RoutingType = RoutingType::new(2);

        /// Dynamic (BGP) routing.
        pub const DYNAMIC: RoutingType = RoutingType::new(3);

        /// Creates a new RoutingType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROUTING_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ROUTE_BASED"),
                2 => std::borrow::Cow::Borrowed("POLICY_BASED"),
                3 => std::borrow::Cow::Borrowed("DYNAMIC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROUTING_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ROUTING_TYPE_UNSPECIFIED)
                }
                "ROUTE_BASED" => std::option::Option::Some(Self::ROUTE_BASED),
                "POLICY_BASED" => std::option::Option::Some(Self::POLICY_BASED),
                "DYNAMIC" => std::option::Option::Some(Self::DYNAMIC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RoutingType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RoutingType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. The specification of the endpoints for the test.
/// EndpointInfo is derived from source and destination Endpoint and validated
/// by the backend data plane model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EndpointInfo {
    /// Source IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_ip: std::string::String,

    /// Destination IP address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_ip: std::string::String,

    /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protocol: std::string::String,

    /// Source port. Only valid when protocol is TCP or UDP.
    pub source_port: i32,

    /// Destination port. Only valid when protocol is TCP or UDP.
    pub destination_port: i32,

    /// URI of the network where this packet originates from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_network_uri: std::string::String,

    /// URI of the network where this packet is sent to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_network_uri: std::string::String,

    /// URI of the source telemetry agent this packet originates from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_agent_uri: std::string::String,
}

impl EndpointInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_ip][crate::model::EndpointInfo::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [destination_ip][crate::model::EndpointInfo::destination_ip].
    pub fn set_destination_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_ip = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::EndpointInfo::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [source_port][crate::model::EndpointInfo::source_port].
    pub fn set_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_port = v.into();
        self
    }

    /// Sets the value of [destination_port][crate::model::EndpointInfo::destination_port].
    pub fn set_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.destination_port = v.into();
        self
    }

    /// Sets the value of [source_network_uri][crate::model::EndpointInfo::source_network_uri].
    pub fn set_source_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_network_uri = v.into();
        self
    }

    /// Sets the value of [destination_network_uri][crate::model::EndpointInfo::destination_network_uri].
    pub fn set_destination_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_network_uri = v.into();
        self
    }

    /// Sets the value of [source_agent_uri][crate::model::EndpointInfo::source_agent_uri].
    pub fn set_source_agent_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_agent_uri = v.into();
        self
    }
}

impl wkt::message::Message for EndpointInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.EndpointInfo"
    }
}

/// Details of the final state "deliver" and associated resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeliverInfo {
    /// Target type where the packet is delivered to.
    pub target: crate::model::deliver_info::Target,

    /// URI of the resource that the packet is delivered to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uri: std::string::String,

    /// IP address of the target (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Name of the Cloud Storage Bucket the packet is delivered to (if
    /// applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_bucket: std::string::String,

    /// PSC Google API target the packet is delivered to (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_google_api_target: std::string::String,
}

impl DeliverInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::DeliverInfo::target].
    pub fn set_target<T: std::convert::Into<crate::model::deliver_info::Target>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DeliverInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::DeliverInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [storage_bucket][crate::model::DeliverInfo::storage_bucket].
    pub fn set_storage_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_bucket = v.into();
        self
    }

    /// Sets the value of [psc_google_api_target][crate::model::DeliverInfo::psc_google_api_target].
    pub fn set_psc_google_api_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_google_api_target = v.into();
        self
    }
}

impl wkt::message::Message for DeliverInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DeliverInfo"
    }
}

/// Defines additional types related to DeliverInfo
pub mod deliver_info {
    #[allow(unused_imports)]
    use super::*;

    /// Deliver target types:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Target(i32);

    impl Target {
        /// Target not specified.
        pub const TARGET_UNSPECIFIED: Target = Target::new(0);

        /// Target is a Compute Engine instance.
        pub const INSTANCE: Target = Target::new(1);

        /// Target is the internet.
        pub const INTERNET: Target = Target::new(2);

        /// Target is a Google API.
        pub const GOOGLE_API: Target = Target::new(3);

        /// Target is a Google Kubernetes Engine cluster master.
        pub const GKE_MASTER: Target = Target::new(4);

        /// Target is a Cloud SQL instance.
        pub const CLOUD_SQL_INSTANCE: Target = Target::new(5);

        /// Target is a published service that uses [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
        pub const PSC_PUBLISHED_SERVICE: Target = Target::new(6);

        /// Target is Google APIs that use [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
        pub const PSC_GOOGLE_API: Target = Target::new(7);

        /// Target is a VPC-SC that uses [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
        pub const PSC_VPC_SC: Target = Target::new(8);

        /// Target is a serverless network endpoint group.
        pub const SERVERLESS_NEG: Target = Target::new(9);

        /// Target is a Cloud Storage bucket.
        pub const STORAGE_BUCKET: Target = Target::new(10);

        /// Target is a private network. Used only for return traces.
        pub const PRIVATE_NETWORK: Target = Target::new(11);

        /// Target is a Cloud Function. Used only for return traces.
        pub const CLOUD_FUNCTION: Target = Target::new(12);

        /// Target is a App Engine service version. Used only for return traces.
        pub const APP_ENGINE_VERSION: Target = Target::new(13);

        /// Target is a Cloud Run revision. Used only for return traces.
        pub const CLOUD_RUN_REVISION: Target = Target::new(14);

        /// Target is a Google-managed service. Used only for return traces.
        pub const GOOGLE_MANAGED_SERVICE: Target = Target::new(15);

        /// Target is a Redis Instance.
        pub const REDIS_INSTANCE: Target = Target::new(16);

        /// Target is a Redis Cluster.
        pub const REDIS_CLUSTER: Target = Target::new(17);

        /// Creates a new Target instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TARGET_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INSTANCE"),
                2 => std::borrow::Cow::Borrowed("INTERNET"),
                3 => std::borrow::Cow::Borrowed("GOOGLE_API"),
                4 => std::borrow::Cow::Borrowed("GKE_MASTER"),
                5 => std::borrow::Cow::Borrowed("CLOUD_SQL_INSTANCE"),
                6 => std::borrow::Cow::Borrowed("PSC_PUBLISHED_SERVICE"),
                7 => std::borrow::Cow::Borrowed("PSC_GOOGLE_API"),
                8 => std::borrow::Cow::Borrowed("PSC_VPC_SC"),
                9 => std::borrow::Cow::Borrowed("SERVERLESS_NEG"),
                10 => std::borrow::Cow::Borrowed("STORAGE_BUCKET"),
                11 => std::borrow::Cow::Borrowed("PRIVATE_NETWORK"),
                12 => std::borrow::Cow::Borrowed("CLOUD_FUNCTION"),
                13 => std::borrow::Cow::Borrowed("APP_ENGINE_VERSION"),
                14 => std::borrow::Cow::Borrowed("CLOUD_RUN_REVISION"),
                15 => std::borrow::Cow::Borrowed("GOOGLE_MANAGED_SERVICE"),
                16 => std::borrow::Cow::Borrowed("REDIS_INSTANCE"),
                17 => std::borrow::Cow::Borrowed("REDIS_CLUSTER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TARGET_UNSPECIFIED" => std::option::Option::Some(Self::TARGET_UNSPECIFIED),
                "INSTANCE" => std::option::Option::Some(Self::INSTANCE),
                "INTERNET" => std::option::Option::Some(Self::INTERNET),
                "GOOGLE_API" => std::option::Option::Some(Self::GOOGLE_API),
                "GKE_MASTER" => std::option::Option::Some(Self::GKE_MASTER),
                "CLOUD_SQL_INSTANCE" => std::option::Option::Some(Self::CLOUD_SQL_INSTANCE),
                "PSC_PUBLISHED_SERVICE" => std::option::Option::Some(Self::PSC_PUBLISHED_SERVICE),
                "PSC_GOOGLE_API" => std::option::Option::Some(Self::PSC_GOOGLE_API),
                "PSC_VPC_SC" => std::option::Option::Some(Self::PSC_VPC_SC),
                "SERVERLESS_NEG" => std::option::Option::Some(Self::SERVERLESS_NEG),
                "STORAGE_BUCKET" => std::option::Option::Some(Self::STORAGE_BUCKET),
                "PRIVATE_NETWORK" => std::option::Option::Some(Self::PRIVATE_NETWORK),
                "CLOUD_FUNCTION" => std::option::Option::Some(Self::CLOUD_FUNCTION),
                "APP_ENGINE_VERSION" => std::option::Option::Some(Self::APP_ENGINE_VERSION),
                "CLOUD_RUN_REVISION" => std::option::Option::Some(Self::CLOUD_RUN_REVISION),
                "GOOGLE_MANAGED_SERVICE" => std::option::Option::Some(Self::GOOGLE_MANAGED_SERVICE),
                "REDIS_INSTANCE" => std::option::Option::Some(Self::REDIS_INSTANCE),
                "REDIS_CLUSTER" => std::option::Option::Some(Self::REDIS_CLUSTER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Target {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Target {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of the final state "forward" and associated resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForwardInfo {
    /// Target type where this packet is forwarded to.
    pub target: crate::model::forward_info::Target,

    /// URI of the resource that the packet is forwarded to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uri: std::string::String,

    /// IP address of the target (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,
}

impl ForwardInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::ForwardInfo::target].
    pub fn set_target<T: std::convert::Into<crate::model::forward_info::Target>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::ForwardInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::ForwardInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for ForwardInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ForwardInfo"
    }
}

/// Defines additional types related to ForwardInfo
pub mod forward_info {
    #[allow(unused_imports)]
    use super::*;

    /// Forward target types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Target(i32);

    impl Target {
        /// Target not specified.
        pub const TARGET_UNSPECIFIED: Target = Target::new(0);

        /// Forwarded to a VPC peering network.
        pub const PEERING_VPC: Target = Target::new(1);

        /// Forwarded to a Cloud VPN gateway.
        pub const VPN_GATEWAY: Target = Target::new(2);

        /// Forwarded to a Cloud Interconnect connection.
        pub const INTERCONNECT: Target = Target::new(3);

        /// Forwarded to a Google Kubernetes Engine Container cluster master.
        pub const GKE_MASTER: Target = Target::new(4);

        /// Forwarded to the next hop of a custom route imported from a peering VPC.
        pub const IMPORTED_CUSTOM_ROUTE_NEXT_HOP: Target = Target::new(5);

        /// Forwarded to a Cloud SQL instance.
        pub const CLOUD_SQL_INSTANCE: Target = Target::new(6);

        /// Forwarded to a VPC network in another project.
        pub const ANOTHER_PROJECT: Target = Target::new(7);

        /// Forwarded to an NCC Hub.
        pub const NCC_HUB: Target = Target::new(8);

        /// Forwarded to a router appliance.
        pub const ROUTER_APPLIANCE: Target = Target::new(9);

        /// Creates a new Target instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TARGET_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PEERING_VPC"),
                2 => std::borrow::Cow::Borrowed("VPN_GATEWAY"),
                3 => std::borrow::Cow::Borrowed("INTERCONNECT"),
                4 => std::borrow::Cow::Borrowed("GKE_MASTER"),
                5 => std::borrow::Cow::Borrowed("IMPORTED_CUSTOM_ROUTE_NEXT_HOP"),
                6 => std::borrow::Cow::Borrowed("CLOUD_SQL_INSTANCE"),
                7 => std::borrow::Cow::Borrowed("ANOTHER_PROJECT"),
                8 => std::borrow::Cow::Borrowed("NCC_HUB"),
                9 => std::borrow::Cow::Borrowed("ROUTER_APPLIANCE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TARGET_UNSPECIFIED" => std::option::Option::Some(Self::TARGET_UNSPECIFIED),
                "PEERING_VPC" => std::option::Option::Some(Self::PEERING_VPC),
                "VPN_GATEWAY" => std::option::Option::Some(Self::VPN_GATEWAY),
                "INTERCONNECT" => std::option::Option::Some(Self::INTERCONNECT),
                "GKE_MASTER" => std::option::Option::Some(Self::GKE_MASTER),
                "IMPORTED_CUSTOM_ROUTE_NEXT_HOP" => {
                    std::option::Option::Some(Self::IMPORTED_CUSTOM_ROUTE_NEXT_HOP)
                }
                "CLOUD_SQL_INSTANCE" => std::option::Option::Some(Self::CLOUD_SQL_INSTANCE),
                "ANOTHER_PROJECT" => std::option::Option::Some(Self::ANOTHER_PROJECT),
                "NCC_HUB" => std::option::Option::Some(Self::NCC_HUB),
                "ROUTER_APPLIANCE" => std::option::Option::Some(Self::ROUTER_APPLIANCE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Target {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Target {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of the final state "abort" and associated resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AbortInfo {
    /// Causes that the analysis is aborted.
    pub cause: crate::model::abort_info::Cause,

    /// URI of the resource that caused the abort.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uri: std::string::String,

    /// IP address that caused the abort.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// List of project IDs the user specified in the request but lacks access to.
    /// In this case, analysis is aborted with the PERMISSION_DENIED cause.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub projects_missing_permission: std::vec::Vec<std::string::String>,
}

impl AbortInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cause][crate::model::AbortInfo::cause].
    pub fn set_cause<T: std::convert::Into<crate::model::abort_info::Cause>>(
        mut self,
        v: T,
    ) -> Self {
        self.cause = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::AbortInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::AbortInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [projects_missing_permission][crate::model::AbortInfo::projects_missing_permission].
    pub fn set_projects_missing_permission<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.projects_missing_permission = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AbortInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.AbortInfo"
    }
}

/// Defines additional types related to AbortInfo
pub mod abort_info {
    #[allow(unused_imports)]
    use super::*;

    /// Abort cause types:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Cause(i32);

    impl Cause {
        /// Cause is unspecified.
        pub const CAUSE_UNSPECIFIED: Cause = Cause::new(0);

        /// Aborted due to unknown network. Deprecated, not used in the new tests.
        pub const UNKNOWN_NETWORK: Cause = Cause::new(1);

        /// Aborted because no project information can be derived from the test
        /// input. Deprecated, not used in the new tests.
        pub const UNKNOWN_PROJECT: Cause = Cause::new(3);

        /// Aborted because traffic is sent from a public IP to an instance without
        /// an external IP. Deprecated, not used in the new tests.
        pub const NO_EXTERNAL_IP: Cause = Cause::new(7);

        /// Aborted because none of the traces matches destination information
        /// specified in the input test request. Deprecated, not used in the new
        /// tests.
        pub const UNINTENDED_DESTINATION: Cause = Cause::new(8);

        /// Aborted because the source endpoint could not be found. Deprecated, not
        /// used in the new tests.
        pub const SOURCE_ENDPOINT_NOT_FOUND: Cause = Cause::new(11);

        /// Aborted because the source network does not match the source endpoint.
        /// Deprecated, not used in the new tests.
        pub const MISMATCHED_SOURCE_NETWORK: Cause = Cause::new(12);

        /// Aborted because the destination endpoint could not be found. Deprecated,
        /// not used in the new tests.
        pub const DESTINATION_ENDPOINT_NOT_FOUND: Cause = Cause::new(13);

        /// Aborted because the destination network does not match the destination
        /// endpoint. Deprecated, not used in the new tests.
        pub const MISMATCHED_DESTINATION_NETWORK: Cause = Cause::new(14);

        /// Aborted because no endpoint with the packet's destination IP address is
        /// found.
        pub const UNKNOWN_IP: Cause = Cause::new(2);

        /// Aborted because no endpoint with the packet's destination IP is found in
        /// the Google-managed project.
        pub const GOOGLE_MANAGED_SERVICE_UNKNOWN_IP: Cause = Cause::new(32);

        /// Aborted because the source IP address doesn't belong to any of the
        /// subnets of the source VPC network.
        pub const SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK: Cause = Cause::new(23);

        /// Aborted because user lacks permission to access all or part of the
        /// network configurations required to run the test.
        pub const PERMISSION_DENIED: Cause = Cause::new(4);

        /// Aborted because user lacks permission to access Cloud NAT configs
        /// required to run the test.
        pub const PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS: Cause = Cause::new(28);

        /// Aborted because user lacks permission to access Network endpoint group
        /// endpoint configs required to run the test.
        pub const PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS: Cause = Cause::new(29);

        /// Aborted because user lacks permission to access Cloud Router configs
        /// required to run the test.
        pub const PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS: Cause = Cause::new(36);

        /// Aborted because no valid source or destination endpoint is derived from
        /// the input test request.
        pub const NO_SOURCE_LOCATION: Cause = Cause::new(5);

        /// Aborted because the source or destination endpoint specified in
        /// the request is invalid. Some examples:
        ///
        /// - The request might contain malformed resource URI, project ID, or IP
        ///   address.
        /// - The request might contain inconsistent information (for example, the
        ///   request might include both the instance and the network, but the instance
        ///   might not have a NIC in that network).
        pub const INVALID_ARGUMENT: Cause = Cause::new(6);

        /// Aborted because the number of steps in the trace exceeds a certain
        /// limit. It might be caused by a routing loop.
        pub const TRACE_TOO_LONG: Cause = Cause::new(9);

        /// Aborted due to internal server error.
        pub const INTERNAL_ERROR: Cause = Cause::new(10);

        /// Aborted because the test scenario is not supported.
        pub const UNSUPPORTED: Cause = Cause::new(15);

        /// Aborted because the source and destination resources have no common IP
        /// version.
        pub const MISMATCHED_IP_VERSION: Cause = Cause::new(16);

        /// Aborted because the connection between the control plane and the node of
        /// the source cluster is initiated by the node and managed by the
        /// Konnectivity proxy.
        pub const GKE_KONNECTIVITY_PROXY_UNSUPPORTED: Cause = Cause::new(17);

        /// Aborted because expected resource configuration was missing.
        pub const RESOURCE_CONFIG_NOT_FOUND: Cause = Cause::new(18);

        /// Aborted because expected VM instance configuration was missing.
        pub const VM_INSTANCE_CONFIG_NOT_FOUND: Cause = Cause::new(24);

        /// Aborted because expected network configuration was missing.
        pub const NETWORK_CONFIG_NOT_FOUND: Cause = Cause::new(25);

        /// Aborted because expected firewall configuration was missing.
        pub const FIREWALL_CONFIG_NOT_FOUND: Cause = Cause::new(26);

        /// Aborted because expected route configuration was missing.
        pub const ROUTE_CONFIG_NOT_FOUND: Cause = Cause::new(27);

        /// Aborted because a PSC endpoint selection for the Google-managed service
        /// is ambiguous (several PSC endpoints satisfy test input).
        pub const GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT: Cause = Cause::new(19);

        /// Aborted because tests with a PSC-based Cloud SQL instance as a source are
        /// not supported.
        pub const SOURCE_PSC_CLOUD_SQL_UNSUPPORTED: Cause = Cause::new(20);

        /// Aborted because tests with a Redis Cluster as a source are not supported.
        pub const SOURCE_REDIS_CLUSTER_UNSUPPORTED: Cause = Cause::new(34);

        /// Aborted because tests with a Redis Instance as a source are not
        /// supported.
        pub const SOURCE_REDIS_INSTANCE_UNSUPPORTED: Cause = Cause::new(35);

        /// Aborted because tests with a forwarding rule as a source are not
        /// supported.
        pub const SOURCE_FORWARDING_RULE_UNSUPPORTED: Cause = Cause::new(21);

        /// Aborted because one of the endpoints is a non-routable IP address
        /// (loopback, link-local, etc).
        pub const NON_ROUTABLE_IP_ADDRESS: Cause = Cause::new(22);

        /// Aborted due to an unknown issue in the Google-managed project.
        pub const UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT: Cause = Cause::new(30);

        /// Aborted due to an unsupported configuration of the Google-managed
        /// project.
        pub const UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG: Cause = Cause::new(31);

        /// Creates a new Cause instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CAUSE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("UNKNOWN_NETWORK"),
                2 => std::borrow::Cow::Borrowed("UNKNOWN_IP"),
                3 => std::borrow::Cow::Borrowed("UNKNOWN_PROJECT"),
                4 => std::borrow::Cow::Borrowed("PERMISSION_DENIED"),
                5 => std::borrow::Cow::Borrowed("NO_SOURCE_LOCATION"),
                6 => std::borrow::Cow::Borrowed("INVALID_ARGUMENT"),
                7 => std::borrow::Cow::Borrowed("NO_EXTERNAL_IP"),
                8 => std::borrow::Cow::Borrowed("UNINTENDED_DESTINATION"),
                9 => std::borrow::Cow::Borrowed("TRACE_TOO_LONG"),
                10 => std::borrow::Cow::Borrowed("INTERNAL_ERROR"),
                11 => std::borrow::Cow::Borrowed("SOURCE_ENDPOINT_NOT_FOUND"),
                12 => std::borrow::Cow::Borrowed("MISMATCHED_SOURCE_NETWORK"),
                13 => std::borrow::Cow::Borrowed("DESTINATION_ENDPOINT_NOT_FOUND"),
                14 => std::borrow::Cow::Borrowed("MISMATCHED_DESTINATION_NETWORK"),
                15 => std::borrow::Cow::Borrowed("UNSUPPORTED"),
                16 => std::borrow::Cow::Borrowed("MISMATCHED_IP_VERSION"),
                17 => std::borrow::Cow::Borrowed("GKE_KONNECTIVITY_PROXY_UNSUPPORTED"),
                18 => std::borrow::Cow::Borrowed("RESOURCE_CONFIG_NOT_FOUND"),
                19 => std::borrow::Cow::Borrowed("GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT"),
                20 => std::borrow::Cow::Borrowed("SOURCE_PSC_CLOUD_SQL_UNSUPPORTED"),
                21 => std::borrow::Cow::Borrowed("SOURCE_FORWARDING_RULE_UNSUPPORTED"),
                22 => std::borrow::Cow::Borrowed("NON_ROUTABLE_IP_ADDRESS"),
                23 => std::borrow::Cow::Borrowed("SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK"),
                24 => std::borrow::Cow::Borrowed("VM_INSTANCE_CONFIG_NOT_FOUND"),
                25 => std::borrow::Cow::Borrowed("NETWORK_CONFIG_NOT_FOUND"),
                26 => std::borrow::Cow::Borrowed("FIREWALL_CONFIG_NOT_FOUND"),
                27 => std::borrow::Cow::Borrowed("ROUTE_CONFIG_NOT_FOUND"),
                28 => std::borrow::Cow::Borrowed("PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS"),
                29 => std::borrow::Cow::Borrowed("PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS"),
                30 => std::borrow::Cow::Borrowed("UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT"),
                31 => std::borrow::Cow::Borrowed("UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG"),
                32 => std::borrow::Cow::Borrowed("GOOGLE_MANAGED_SERVICE_UNKNOWN_IP"),
                34 => std::borrow::Cow::Borrowed("SOURCE_REDIS_CLUSTER_UNSUPPORTED"),
                35 => std::borrow::Cow::Borrowed("SOURCE_REDIS_INSTANCE_UNSUPPORTED"),
                36 => std::borrow::Cow::Borrowed("PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CAUSE_UNSPECIFIED" => std::option::Option::Some(Self::CAUSE_UNSPECIFIED),
                "UNKNOWN_NETWORK" => std::option::Option::Some(Self::UNKNOWN_NETWORK),
                "UNKNOWN_PROJECT" => std::option::Option::Some(Self::UNKNOWN_PROJECT),
                "NO_EXTERNAL_IP" => std::option::Option::Some(Self::NO_EXTERNAL_IP),
                "UNINTENDED_DESTINATION" => std::option::Option::Some(Self::UNINTENDED_DESTINATION),
                "SOURCE_ENDPOINT_NOT_FOUND" => {
                    std::option::Option::Some(Self::SOURCE_ENDPOINT_NOT_FOUND)
                }
                "MISMATCHED_SOURCE_NETWORK" => {
                    std::option::Option::Some(Self::MISMATCHED_SOURCE_NETWORK)
                }
                "DESTINATION_ENDPOINT_NOT_FOUND" => {
                    std::option::Option::Some(Self::DESTINATION_ENDPOINT_NOT_FOUND)
                }
                "MISMATCHED_DESTINATION_NETWORK" => {
                    std::option::Option::Some(Self::MISMATCHED_DESTINATION_NETWORK)
                }
                "UNKNOWN_IP" => std::option::Option::Some(Self::UNKNOWN_IP),
                "GOOGLE_MANAGED_SERVICE_UNKNOWN_IP" => {
                    std::option::Option::Some(Self::GOOGLE_MANAGED_SERVICE_UNKNOWN_IP)
                }
                "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK" => {
                    std::option::Option::Some(Self::SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK)
                }
                "PERMISSION_DENIED" => std::option::Option::Some(Self::PERMISSION_DENIED),
                "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS" => {
                    std::option::Option::Some(Self::PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS)
                }
                "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS" => {
                    std::option::Option::Some(Self::PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS)
                }
                "PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS" => {
                    std::option::Option::Some(Self::PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS)
                }
                "NO_SOURCE_LOCATION" => std::option::Option::Some(Self::NO_SOURCE_LOCATION),
                "INVALID_ARGUMENT" => std::option::Option::Some(Self::INVALID_ARGUMENT),
                "TRACE_TOO_LONG" => std::option::Option::Some(Self::TRACE_TOO_LONG),
                "INTERNAL_ERROR" => std::option::Option::Some(Self::INTERNAL_ERROR),
                "UNSUPPORTED" => std::option::Option::Some(Self::UNSUPPORTED),
                "MISMATCHED_IP_VERSION" => std::option::Option::Some(Self::MISMATCHED_IP_VERSION),
                "GKE_KONNECTIVITY_PROXY_UNSUPPORTED" => {
                    std::option::Option::Some(Self::GKE_KONNECTIVITY_PROXY_UNSUPPORTED)
                }
                "RESOURCE_CONFIG_NOT_FOUND" => {
                    std::option::Option::Some(Self::RESOURCE_CONFIG_NOT_FOUND)
                }
                "VM_INSTANCE_CONFIG_NOT_FOUND" => {
                    std::option::Option::Some(Self::VM_INSTANCE_CONFIG_NOT_FOUND)
                }
                "NETWORK_CONFIG_NOT_FOUND" => {
                    std::option::Option::Some(Self::NETWORK_CONFIG_NOT_FOUND)
                }
                "FIREWALL_CONFIG_NOT_FOUND" => {
                    std::option::Option::Some(Self::FIREWALL_CONFIG_NOT_FOUND)
                }
                "ROUTE_CONFIG_NOT_FOUND" => std::option::Option::Some(Self::ROUTE_CONFIG_NOT_FOUND),
                "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT" => {
                    std::option::Option::Some(Self::GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT)
                }
                "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED" => {
                    std::option::Option::Some(Self::SOURCE_PSC_CLOUD_SQL_UNSUPPORTED)
                }
                "SOURCE_REDIS_CLUSTER_UNSUPPORTED" => {
                    std::option::Option::Some(Self::SOURCE_REDIS_CLUSTER_UNSUPPORTED)
                }
                "SOURCE_REDIS_INSTANCE_UNSUPPORTED" => {
                    std::option::Option::Some(Self::SOURCE_REDIS_INSTANCE_UNSUPPORTED)
                }
                "SOURCE_FORWARDING_RULE_UNSUPPORTED" => {
                    std::option::Option::Some(Self::SOURCE_FORWARDING_RULE_UNSUPPORTED)
                }
                "NON_ROUTABLE_IP_ADDRESS" => {
                    std::option::Option::Some(Self::NON_ROUTABLE_IP_ADDRESS)
                }
                "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT" => {
                    std::option::Option::Some(Self::UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT)
                }
                "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG" => {
                    std::option::Option::Some(Self::UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Cause {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Cause {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of the final state "drop" and associated resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DropInfo {
    /// Cause that the packet is dropped.
    pub cause: crate::model::drop_info::Cause,

    /// URI of the resource that caused the drop.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_uri: std::string::String,

    /// Source IP address of the dropped packet (if relevant).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_ip: std::string::String,

    /// Destination IP address of the dropped packet (if relevant).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_ip: std::string::String,

    /// Region of the dropped packet (if relevant).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl DropInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cause][crate::model::DropInfo::cause].
    pub fn set_cause<T: std::convert::Into<crate::model::drop_info::Cause>>(
        mut self,
        v: T,
    ) -> Self {
        self.cause = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DropInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [source_ip][crate::model::DropInfo::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [destination_ip][crate::model::DropInfo::destination_ip].
    pub fn set_destination_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_ip = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DropInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for DropInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DropInfo"
    }
}

/// Defines additional types related to DropInfo
pub mod drop_info {
    #[allow(unused_imports)]
    use super::*;

    /// Drop cause types:
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Cause(i32);

    impl Cause {
        /// Cause is unspecified.
        pub const CAUSE_UNSPECIFIED: Cause = Cause::new(0);

        /// Destination external address cannot be resolved to a known target. If
        /// the address is used in a Google Cloud project, provide the project ID
        /// as test input.
        pub const UNKNOWN_EXTERNAL_ADDRESS: Cause = Cause::new(1);

        /// A Compute Engine instance can only send or receive a packet with a
        /// foreign IP address if ip_forward is enabled.
        pub const FOREIGN_IP_DISALLOWED: Cause = Cause::new(2);

        /// Dropped due to a firewall rule, unless allowed due to connection
        /// tracking.
        pub const FIREWALL_RULE: Cause = Cause::new(3);

        /// Dropped due to no matching routes.
        pub const NO_ROUTE: Cause = Cause::new(4);

        /// Dropped due to invalid route. Route's next hop is a blackhole.
        pub const ROUTE_BLACKHOLE: Cause = Cause::new(5);

        /// Packet is sent to a wrong (unintended) network. Example: you trace a
        /// packet from VM1:Network1 to VM2:Network2, however, the route configured
        /// in Network1 sends the packet destined for VM2's IP address to Network3.
        pub const ROUTE_WRONG_NETWORK: Cause = Cause::new(6);

        /// Route's next hop IP address cannot be resolved to a GCP resource.
        pub const ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED: Cause = Cause::new(42);

        /// Route's next hop resource is not found.
        pub const ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND: Cause = Cause::new(43);

        /// Route's next hop instance doesn't have a NIC in the route's network.
        pub const ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK: Cause = Cause::new(49);

        /// Route's next hop IP address is not a primary IP address of the next hop
        /// instance.
        pub const ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP: Cause = Cause::new(50);

        /// Route's next hop forwarding rule doesn't match next hop IP address.
        pub const ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH: Cause = Cause::new(51);

        /// Route's next hop VPN tunnel is down (does not have valid IKE SAs).
        pub const ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED: Cause = Cause::new(52);

        /// Route's next hop forwarding rule type is invalid (it's not a forwarding
        /// rule of the internal passthrough load balancer).
        pub const ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID: Cause = Cause::new(53);

        /// Packet is sent from the Internet to the private IPv6 address.
        pub const NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS: Cause = Cause::new(44);

        /// The packet does not match a policy-based VPN tunnel local selector.
        pub const VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH: Cause = Cause::new(45);

        /// The packet does not match a policy-based VPN tunnel remote selector.
        pub const VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH: Cause = Cause::new(46);

        /// Packet with internal destination address sent to the internet gateway.
        pub const PRIVATE_TRAFFIC_TO_INTERNET: Cause = Cause::new(7);

        /// Instance with only an internal IP address tries to access Google API and
        /// services, but private Google access is not enabled in the subnet.
        pub const PRIVATE_GOOGLE_ACCESS_DISALLOWED: Cause = Cause::new(8);

        /// Source endpoint tries to access Google API and services through the VPN
        /// tunnel to another network, but Private Google Access needs to be enabled
        /// in the source endpoint network.
        pub const PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED: Cause = Cause::new(47);

        /// Instance with only an internal IP address tries to access external hosts,
        /// but Cloud NAT is not enabled in the subnet, unless special configurations
        /// on a VM allow this connection.
        pub const NO_EXTERNAL_ADDRESS: Cause = Cause::new(9);

        /// Destination internal address cannot be resolved to a known target. If
        /// this is a shared VPC scenario, verify if the service project ID is
        /// provided as test input. Otherwise, verify if the IP address is being
        /// used in the project.
        pub const UNKNOWN_INTERNAL_ADDRESS: Cause = Cause::new(10);

        /// Forwarding rule's protocol and ports do not match the packet header.
        pub const FORWARDING_RULE_MISMATCH: Cause = Cause::new(11);

        /// Forwarding rule does not have backends configured.
        pub const FORWARDING_RULE_NO_INSTANCES: Cause = Cause::new(12);

        /// Firewalls block the health check probes to the backends and cause
        /// the backends to be unavailable for traffic from the load balancer.
        /// For more details, see [Health check firewall
        /// rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
        pub const FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK: Cause = Cause::new(13);

        /// Packet is sent from or to a Compute Engine instance that is not in a
        /// running state.
        pub const INSTANCE_NOT_RUNNING: Cause = Cause::new(14);

        /// Packet sent from or to a GKE cluster that is not in running state.
        pub const GKE_CLUSTER_NOT_RUNNING: Cause = Cause::new(27);

        /// Packet sent from or to a Cloud SQL instance that is not in running state.
        pub const CLOUD_SQL_INSTANCE_NOT_RUNNING: Cause = Cause::new(28);

        /// Packet sent from or to a Redis Instance that is not in running state.
        pub const REDIS_INSTANCE_NOT_RUNNING: Cause = Cause::new(68);

        /// Packet sent from or to a Redis Cluster that is not in running state.
        pub const REDIS_CLUSTER_NOT_RUNNING: Cause = Cause::new(69);

        /// The type of traffic is blocked and the user cannot configure a firewall
        /// rule to enable it. See [Always blocked
        /// traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic) for
        /// more details.
        pub const TRAFFIC_TYPE_BLOCKED: Cause = Cause::new(15);

        /// Access to Google Kubernetes Engine cluster master's endpoint is not
        /// authorized. See [Access to the cluster
        /// endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
        /// for more details.
        pub const GKE_MASTER_UNAUTHORIZED_ACCESS: Cause = Cause::new(16);

        /// Access to the Cloud SQL instance endpoint is not authorized.
        /// See [Authorizing with authorized
        /// networks](https://cloud.google.com/sql/docs/mysql/authorize-networks) for
        /// more details.
        pub const CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS: Cause = Cause::new(17);

        /// Packet was dropped inside Google Kubernetes Engine Service.
        pub const DROPPED_INSIDE_GKE_SERVICE: Cause = Cause::new(18);

        /// Packet was dropped inside Cloud SQL Service.
        pub const DROPPED_INSIDE_CLOUD_SQL_SERVICE: Cause = Cause::new(19);

        /// Packet was dropped because there is no peering between the originating
        /// network and the Google Managed Services Network.
        pub const GOOGLE_MANAGED_SERVICE_NO_PEERING: Cause = Cause::new(20);

        /// Packet was dropped because the Google-managed service uses Private
        /// Service Connect (PSC), but the PSC endpoint is not found in the project.
        pub const GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT: Cause = Cause::new(38);

        /// Packet was dropped because the GKE cluster uses Private Service Connect
        /// (PSC), but the PSC endpoint is not found in the project.
        pub const GKE_PSC_ENDPOINT_MISSING: Cause = Cause::new(36);

        /// Packet was dropped because the Cloud SQL instance has neither a private
        /// nor a public IP address.
        pub const CLOUD_SQL_INSTANCE_NO_IP_ADDRESS: Cause = Cause::new(21);

        /// Packet was dropped because a GKE cluster private endpoint is
        /// unreachable from a region different from the cluster's region.
        pub const GKE_CONTROL_PLANE_REGION_MISMATCH: Cause = Cause::new(30);

        /// Packet sent from a public GKE cluster control plane to a private
        /// IP address.
        pub const PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION: Cause = Cause::new(31);

        /// Packet was dropped because there is no route from a GKE cluster
        /// control plane to a destination network.
        pub const GKE_CONTROL_PLANE_NO_ROUTE: Cause = Cause::new(32);

        /// Packet sent from a Cloud SQL instance to an external IP address is not
        /// allowed. The Cloud SQL instance is not configured to send packets to
        /// external IP addresses.
        pub const CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC: Cause = Cause::new(33);

        /// Packet sent from a Cloud SQL instance with only a public IP address to a
        /// private IP address.
        pub const PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION: Cause = Cause::new(34);

        /// Packet was dropped because there is no route from a Cloud SQL
        /// instance to a destination network.
        pub const CLOUD_SQL_INSTANCE_NO_ROUTE: Cause = Cause::new(35);

        /// Packet was dropped because the Cloud SQL instance requires all
        /// connections to use Cloud SQL connectors and to target the Cloud SQL proxy
        /// port (3307).
        pub const CLOUD_SQL_CONNECTOR_REQUIRED: Cause = Cause::new(63);

        /// Packet could be dropped because the Cloud Function is not in an active
        /// status.
        pub const CLOUD_FUNCTION_NOT_ACTIVE: Cause = Cause::new(22);

        /// Packet could be dropped because no VPC connector is set.
        pub const VPC_CONNECTOR_NOT_SET: Cause = Cause::new(23);

        /// Packet could be dropped because the VPC connector is not in a running
        /// state.
        pub const VPC_CONNECTOR_NOT_RUNNING: Cause = Cause::new(24);

        /// Packet could be dropped because the traffic from the serverless service
        /// to the VPC connector is not allowed.
        pub const VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED: Cause = Cause::new(60);

        /// Packet could be dropped because the health check traffic to the VPC
        /// connector is not allowed.
        pub const VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED: Cause = Cause::new(61);

        /// Packet could be dropped because it was sent from a different region
        /// to a regional forwarding without global access.
        pub const FORWARDING_RULE_REGION_MISMATCH: Cause = Cause::new(25);

        /// The Private Service Connect endpoint is in a project that is not approved
        /// to connect to the service.
        pub const PSC_CONNECTION_NOT_ACCEPTED: Cause = Cause::new(26);

        /// The packet is sent to the Private Service Connect endpoint over the
        /// peering, but [it's not
        /// supported](https://cloud.google.com/vpc/docs/configure-private-service-connect-services#on-premises).
        pub const PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK: Cause = Cause::new(41);

        /// The packet is sent to the Private Service Connect backend (network
        /// endpoint group), but the producer PSC forwarding rule does not have
        /// global access enabled.
        pub const PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS: Cause = Cause::new(48);

        /// The packet is sent to the Private Service Connect backend (network
        /// endpoint group), but the producer PSC forwarding rule has multiple ports
        /// specified.
        pub const PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS: Cause = Cause::new(54);

        /// The packet is sent to the Private Service Connect backend (network
        /// endpoint group) targeting a Cloud SQL service attachment, but this
        /// configuration is not supported.
        pub const CLOUD_SQL_PSC_NEG_UNSUPPORTED: Cause = Cause::new(58);

        /// No NAT subnets are defined for the PSC service attachment.
        pub const NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT: Cause = Cause::new(57);

        /// PSC endpoint is accessed via NCC, but PSC transitivity configuration is
        /// not yet propagated.
        pub const PSC_TRANSITIVITY_NOT_PROPAGATED: Cause = Cause::new(64);

        /// The packet sent from the hybrid NEG proxy matches a non-dynamic route,
        /// but such a configuration is not supported.
        pub const HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED: Cause = Cause::new(55);

        /// The packet sent from the hybrid NEG proxy matches a dynamic route with a
        /// next hop in a different region, but such a configuration is not
        /// supported.
        pub const HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED: Cause = Cause::new(56);

        /// Packet sent from a Cloud Run revision that is not ready.
        pub const CLOUD_RUN_REVISION_NOT_READY: Cause = Cause::new(29);

        /// Packet was dropped inside Private Service Connect service producer.
        pub const DROPPED_INSIDE_PSC_SERVICE_PRODUCER: Cause = Cause::new(37);

        /// Packet sent to a load balancer, which requires a proxy-only subnet and
        /// the subnet is not found.
        pub const LOAD_BALANCER_HAS_NO_PROXY_SUBNET: Cause = Cause::new(39);

        /// Packet sent to Cloud Nat without active NAT IPs.
        pub const CLOUD_NAT_NO_ADDRESSES: Cause = Cause::new(40);

        /// Packet is stuck in a routing loop.
        pub const ROUTING_LOOP: Cause = Cause::new(59);

        /// Packet is dropped inside a Google-managed service due to being delivered
        /// in return trace to an endpoint that doesn't match the endpoint the packet
        /// was sent from in forward trace. Used only for return traces.
        pub const DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE: Cause = Cause::new(62);

        /// Packet is dropped due to a load balancer backend instance not having a
        /// network interface in the network expected by the load balancer.
        pub const LOAD_BALANCER_BACKEND_INVALID_NETWORK: Cause = Cause::new(65);

        /// Packet is dropped due to a backend service named port not being defined
        /// on the instance group level.
        pub const BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED: Cause = Cause::new(66);

        /// Packet is dropped due to a destination IP range being part of a Private
        /// NAT IP range.
        pub const DESTINATION_IS_PRIVATE_NAT_IP_RANGE: Cause = Cause::new(67);

        /// Generic drop cause for a packet being dropped inside a Redis Instance
        /// service project.
        pub const DROPPED_INSIDE_REDIS_INSTANCE_SERVICE: Cause = Cause::new(70);

        /// Packet is dropped due to an unsupported port being used to connect to a
        /// Redis Instance. Port 6379 should be used to connect to a Redis Instance.
        pub const REDIS_INSTANCE_UNSUPPORTED_PORT: Cause = Cause::new(71);

        /// Packet is dropped due to connecting from PUPI address to a PSA based
        /// Redis Instance.
        pub const REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS: Cause = Cause::new(72);

        /// Packet is dropped due to no route to the destination network.
        pub const REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK: Cause = Cause::new(73);

        /// Redis Instance does not have an external IP address.
        pub const REDIS_INSTANCE_NO_EXTERNAL_IP: Cause = Cause::new(74);

        /// Packet is dropped due to an unsupported protocol being used to connect to
        /// a Redis Instance. Only TCP connections are accepted by a Redis Instance.
        pub const REDIS_INSTANCE_UNSUPPORTED_PROTOCOL: Cause = Cause::new(78);

        /// Generic drop cause for a packet being dropped inside a Redis Cluster
        /// service project.
        pub const DROPPED_INSIDE_REDIS_CLUSTER_SERVICE: Cause = Cause::new(75);

        /// Packet is dropped due to an unsupported port being used to connect to a
        /// Redis Cluster. Ports 6379 and 11000 to 13047 should be used to connect to
        /// a Redis Cluster.
        pub const REDIS_CLUSTER_UNSUPPORTED_PORT: Cause = Cause::new(76);

        /// Redis Cluster does not have an external IP address.
        pub const REDIS_CLUSTER_NO_EXTERNAL_IP: Cause = Cause::new(77);

        /// Packet is dropped due to an unsupported protocol being used to connect to
        /// a Redis Cluster. Only TCP connections are accepted by a Redis Cluster.
        pub const REDIS_CLUSTER_UNSUPPORTED_PROTOCOL: Cause = Cause::new(79);

        /// Packet from the non-GCP (on-prem) or unknown GCP network is dropped due
        /// to the destination IP address not belonging to any IP prefix advertised
        /// via BGP by the Cloud Router.
        pub const NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION: Cause = Cause::new(80);

        /// Packet from the non-GCP (on-prem) or unknown GCP network is dropped due
        /// to the destination IP address not belonging to any IP prefix included to
        /// the local traffic selector of the VPN tunnel.
        pub const NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION: Cause = Cause::new(81);

        /// Packet from the unknown peered network is dropped due to no known route
        /// from the source network to the destination IP address.
        pub const NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION: Cause = Cause::new(82);

        /// Sending packets processed by the Private NAT Gateways to the Private
        /// Service Connect endpoints is not supported.
        pub const PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED: Cause = Cause::new(83);

        /// Creates a new Cause instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CAUSE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("UNKNOWN_EXTERNAL_ADDRESS"),
                2 => std::borrow::Cow::Borrowed("FOREIGN_IP_DISALLOWED"),
                3 => std::borrow::Cow::Borrowed("FIREWALL_RULE"),
                4 => std::borrow::Cow::Borrowed("NO_ROUTE"),
                5 => std::borrow::Cow::Borrowed("ROUTE_BLACKHOLE"),
                6 => std::borrow::Cow::Borrowed("ROUTE_WRONG_NETWORK"),
                7 => std::borrow::Cow::Borrowed("PRIVATE_TRAFFIC_TO_INTERNET"),
                8 => std::borrow::Cow::Borrowed("PRIVATE_GOOGLE_ACCESS_DISALLOWED"),
                9 => std::borrow::Cow::Borrowed("NO_EXTERNAL_ADDRESS"),
                10 => std::borrow::Cow::Borrowed("UNKNOWN_INTERNAL_ADDRESS"),
                11 => std::borrow::Cow::Borrowed("FORWARDING_RULE_MISMATCH"),
                12 => std::borrow::Cow::Borrowed("FORWARDING_RULE_NO_INSTANCES"),
                13 => std::borrow::Cow::Borrowed(
                    "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK",
                ),
                14 => std::borrow::Cow::Borrowed("INSTANCE_NOT_RUNNING"),
                15 => std::borrow::Cow::Borrowed("TRAFFIC_TYPE_BLOCKED"),
                16 => std::borrow::Cow::Borrowed("GKE_MASTER_UNAUTHORIZED_ACCESS"),
                17 => std::borrow::Cow::Borrowed("CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS"),
                18 => std::borrow::Cow::Borrowed("DROPPED_INSIDE_GKE_SERVICE"),
                19 => std::borrow::Cow::Borrowed("DROPPED_INSIDE_CLOUD_SQL_SERVICE"),
                20 => std::borrow::Cow::Borrowed("GOOGLE_MANAGED_SERVICE_NO_PEERING"),
                21 => std::borrow::Cow::Borrowed("CLOUD_SQL_INSTANCE_NO_IP_ADDRESS"),
                22 => std::borrow::Cow::Borrowed("CLOUD_FUNCTION_NOT_ACTIVE"),
                23 => std::borrow::Cow::Borrowed("VPC_CONNECTOR_NOT_SET"),
                24 => std::borrow::Cow::Borrowed("VPC_CONNECTOR_NOT_RUNNING"),
                25 => std::borrow::Cow::Borrowed("FORWARDING_RULE_REGION_MISMATCH"),
                26 => std::borrow::Cow::Borrowed("PSC_CONNECTION_NOT_ACCEPTED"),
                27 => std::borrow::Cow::Borrowed("GKE_CLUSTER_NOT_RUNNING"),
                28 => std::borrow::Cow::Borrowed("CLOUD_SQL_INSTANCE_NOT_RUNNING"),
                29 => std::borrow::Cow::Borrowed("CLOUD_RUN_REVISION_NOT_READY"),
                30 => std::borrow::Cow::Borrowed("GKE_CONTROL_PLANE_REGION_MISMATCH"),
                31 => std::borrow::Cow::Borrowed("PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION"),
                32 => std::borrow::Cow::Borrowed("GKE_CONTROL_PLANE_NO_ROUTE"),
                33 => std::borrow::Cow::Borrowed(
                    "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC",
                ),
                34 => {
                    std::borrow::Cow::Borrowed("PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION")
                }
                35 => std::borrow::Cow::Borrowed("CLOUD_SQL_INSTANCE_NO_ROUTE"),
                36 => std::borrow::Cow::Borrowed("GKE_PSC_ENDPOINT_MISSING"),
                37 => std::borrow::Cow::Borrowed("DROPPED_INSIDE_PSC_SERVICE_PRODUCER"),
                38 => std::borrow::Cow::Borrowed("GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT"),
                39 => std::borrow::Cow::Borrowed("LOAD_BALANCER_HAS_NO_PROXY_SUBNET"),
                40 => std::borrow::Cow::Borrowed("CLOUD_NAT_NO_ADDRESSES"),
                41 => std::borrow::Cow::Borrowed("PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK"),
                42 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED"),
                43 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND"),
                44 => std::borrow::Cow::Borrowed("NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS"),
                45 => std::borrow::Cow::Borrowed("VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH"),
                46 => std::borrow::Cow::Borrowed("VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH"),
                47 => {
                    std::borrow::Cow::Borrowed("PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED")
                }
                48 => std::borrow::Cow::Borrowed("PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS"),
                49 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK"),
                50 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP"),
                51 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH"),
                52 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED"),
                53 => std::borrow::Cow::Borrowed("ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID"),
                54 => std::borrow::Cow::Borrowed("PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS"),
                55 => std::borrow::Cow::Borrowed("HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED"),
                56 => std::borrow::Cow::Borrowed("HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED"),
                57 => std::borrow::Cow::Borrowed("NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT"),
                58 => std::borrow::Cow::Borrowed("CLOUD_SQL_PSC_NEG_UNSUPPORTED"),
                59 => std::borrow::Cow::Borrowed("ROUTING_LOOP"),
                60 => std::borrow::Cow::Borrowed("VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED"),
                61 => std::borrow::Cow::Borrowed("VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED"),
                62 => std::borrow::Cow::Borrowed("DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE"),
                63 => std::borrow::Cow::Borrowed("CLOUD_SQL_CONNECTOR_REQUIRED"),
                64 => std::borrow::Cow::Borrowed("PSC_TRANSITIVITY_NOT_PROPAGATED"),
                65 => std::borrow::Cow::Borrowed("LOAD_BALANCER_BACKEND_INVALID_NETWORK"),
                66 => std::borrow::Cow::Borrowed("BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED"),
                67 => std::borrow::Cow::Borrowed("DESTINATION_IS_PRIVATE_NAT_IP_RANGE"),
                68 => std::borrow::Cow::Borrowed("REDIS_INSTANCE_NOT_RUNNING"),
                69 => std::borrow::Cow::Borrowed("REDIS_CLUSTER_NOT_RUNNING"),
                70 => std::borrow::Cow::Borrowed("DROPPED_INSIDE_REDIS_INSTANCE_SERVICE"),
                71 => std::borrow::Cow::Borrowed("REDIS_INSTANCE_UNSUPPORTED_PORT"),
                72 => std::borrow::Cow::Borrowed("REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS"),
                73 => std::borrow::Cow::Borrowed("REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK"),
                74 => std::borrow::Cow::Borrowed("REDIS_INSTANCE_NO_EXTERNAL_IP"),
                75 => std::borrow::Cow::Borrowed("DROPPED_INSIDE_REDIS_CLUSTER_SERVICE"),
                76 => std::borrow::Cow::Borrowed("REDIS_CLUSTER_UNSUPPORTED_PORT"),
                77 => std::borrow::Cow::Borrowed("REDIS_CLUSTER_NO_EXTERNAL_IP"),
                78 => std::borrow::Cow::Borrowed("REDIS_INSTANCE_UNSUPPORTED_PROTOCOL"),
                79 => std::borrow::Cow::Borrowed("REDIS_CLUSTER_UNSUPPORTED_PROTOCOL"),
                80 => std::borrow::Cow::Borrowed("NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION"),
                81 => std::borrow::Cow::Borrowed("NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION"),
                82 => {
                    std::borrow::Cow::Borrowed("NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION")
                }
                83 => std::borrow::Cow::Borrowed("PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CAUSE_UNSPECIFIED" => std::option::Option::Some(Self::CAUSE_UNSPECIFIED),
                "UNKNOWN_EXTERNAL_ADDRESS" => {
                    std::option::Option::Some(Self::UNKNOWN_EXTERNAL_ADDRESS)
                }
                "FOREIGN_IP_DISALLOWED" => std::option::Option::Some(Self::FOREIGN_IP_DISALLOWED),
                "FIREWALL_RULE" => std::option::Option::Some(Self::FIREWALL_RULE),
                "NO_ROUTE" => std::option::Option::Some(Self::NO_ROUTE),
                "ROUTE_BLACKHOLE" => std::option::Option::Some(Self::ROUTE_BLACKHOLE),
                "ROUTE_WRONG_NETWORK" => std::option::Option::Some(Self::ROUTE_WRONG_NETWORK),
                "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED)
                }
                "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND)
                }
                "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK)
                }
                "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP)
                }
                "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH)
                }
                "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED)
                }
                "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID" => {
                    std::option::Option::Some(Self::ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID)
                }
                "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS" => {
                    std::option::Option::Some(Self::NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS)
                }
                "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH" => {
                    std::option::Option::Some(Self::VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH)
                }
                "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH" => {
                    std::option::Option::Some(Self::VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH)
                }
                "PRIVATE_TRAFFIC_TO_INTERNET" => {
                    std::option::Option::Some(Self::PRIVATE_TRAFFIC_TO_INTERNET)
                }
                "PRIVATE_GOOGLE_ACCESS_DISALLOWED" => {
                    std::option::Option::Some(Self::PRIVATE_GOOGLE_ACCESS_DISALLOWED)
                }
                "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED" => std::option::Option::Some(
                    Self::PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED,
                ),
                "NO_EXTERNAL_ADDRESS" => std::option::Option::Some(Self::NO_EXTERNAL_ADDRESS),
                "UNKNOWN_INTERNAL_ADDRESS" => {
                    std::option::Option::Some(Self::UNKNOWN_INTERNAL_ADDRESS)
                }
                "FORWARDING_RULE_MISMATCH" => {
                    std::option::Option::Some(Self::FORWARDING_RULE_MISMATCH)
                }
                "FORWARDING_RULE_NO_INSTANCES" => {
                    std::option::Option::Some(Self::FORWARDING_RULE_NO_INSTANCES)
                }
                "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK" => {
                    std::option::Option::Some(
                        Self::FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK,
                    )
                }
                "INSTANCE_NOT_RUNNING" => std::option::Option::Some(Self::INSTANCE_NOT_RUNNING),
                "GKE_CLUSTER_NOT_RUNNING" => {
                    std::option::Option::Some(Self::GKE_CLUSTER_NOT_RUNNING)
                }
                "CLOUD_SQL_INSTANCE_NOT_RUNNING" => {
                    std::option::Option::Some(Self::CLOUD_SQL_INSTANCE_NOT_RUNNING)
                }
                "REDIS_INSTANCE_NOT_RUNNING" => {
                    std::option::Option::Some(Self::REDIS_INSTANCE_NOT_RUNNING)
                }
                "REDIS_CLUSTER_NOT_RUNNING" => {
                    std::option::Option::Some(Self::REDIS_CLUSTER_NOT_RUNNING)
                }
                "TRAFFIC_TYPE_BLOCKED" => std::option::Option::Some(Self::TRAFFIC_TYPE_BLOCKED),
                "GKE_MASTER_UNAUTHORIZED_ACCESS" => {
                    std::option::Option::Some(Self::GKE_MASTER_UNAUTHORIZED_ACCESS)
                }
                "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS" => {
                    std::option::Option::Some(Self::CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS)
                }
                "DROPPED_INSIDE_GKE_SERVICE" => {
                    std::option::Option::Some(Self::DROPPED_INSIDE_GKE_SERVICE)
                }
                "DROPPED_INSIDE_CLOUD_SQL_SERVICE" => {
                    std::option::Option::Some(Self::DROPPED_INSIDE_CLOUD_SQL_SERVICE)
                }
                "GOOGLE_MANAGED_SERVICE_NO_PEERING" => {
                    std::option::Option::Some(Self::GOOGLE_MANAGED_SERVICE_NO_PEERING)
                }
                "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT" => {
                    std::option::Option::Some(Self::GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT)
                }
                "GKE_PSC_ENDPOINT_MISSING" => {
                    std::option::Option::Some(Self::GKE_PSC_ENDPOINT_MISSING)
                }
                "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS" => {
                    std::option::Option::Some(Self::CLOUD_SQL_INSTANCE_NO_IP_ADDRESS)
                }
                "GKE_CONTROL_PLANE_REGION_MISMATCH" => {
                    std::option::Option::Some(Self::GKE_CONTROL_PLANE_REGION_MISMATCH)
                }
                "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION" => {
                    std::option::Option::Some(Self::PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION)
                }
                "GKE_CONTROL_PLANE_NO_ROUTE" => {
                    std::option::Option::Some(Self::GKE_CONTROL_PLANE_NO_ROUTE)
                }
                "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC" => {
                    std::option::Option::Some(
                        Self::CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC,
                    )
                }
                "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION" => std::option::Option::Some(
                    Self::PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION,
                ),
                "CLOUD_SQL_INSTANCE_NO_ROUTE" => {
                    std::option::Option::Some(Self::CLOUD_SQL_INSTANCE_NO_ROUTE)
                }
                "CLOUD_SQL_CONNECTOR_REQUIRED" => {
                    std::option::Option::Some(Self::CLOUD_SQL_CONNECTOR_REQUIRED)
                }
                "CLOUD_FUNCTION_NOT_ACTIVE" => {
                    std::option::Option::Some(Self::CLOUD_FUNCTION_NOT_ACTIVE)
                }
                "VPC_CONNECTOR_NOT_SET" => std::option::Option::Some(Self::VPC_CONNECTOR_NOT_SET),
                "VPC_CONNECTOR_NOT_RUNNING" => {
                    std::option::Option::Some(Self::VPC_CONNECTOR_NOT_RUNNING)
                }
                "VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED" => {
                    std::option::Option::Some(Self::VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED)
                }
                "VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED" => {
                    std::option::Option::Some(Self::VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED)
                }
                "FORWARDING_RULE_REGION_MISMATCH" => {
                    std::option::Option::Some(Self::FORWARDING_RULE_REGION_MISMATCH)
                }
                "PSC_CONNECTION_NOT_ACCEPTED" => {
                    std::option::Option::Some(Self::PSC_CONNECTION_NOT_ACCEPTED)
                }
                "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK" => {
                    std::option::Option::Some(Self::PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK)
                }
                "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS" => {
                    std::option::Option::Some(Self::PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS)
                }
                "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS" => {
                    std::option::Option::Some(Self::PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS)
                }
                "CLOUD_SQL_PSC_NEG_UNSUPPORTED" => {
                    std::option::Option::Some(Self::CLOUD_SQL_PSC_NEG_UNSUPPORTED)
                }
                "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT" => {
                    std::option::Option::Some(Self::NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT)
                }
                "PSC_TRANSITIVITY_NOT_PROPAGATED" => {
                    std::option::Option::Some(Self::PSC_TRANSITIVITY_NOT_PROPAGATED)
                }
                "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED" => {
                    std::option::Option::Some(Self::HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED)
                }
                "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED" => {
                    std::option::Option::Some(Self::HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED)
                }
                "CLOUD_RUN_REVISION_NOT_READY" => {
                    std::option::Option::Some(Self::CLOUD_RUN_REVISION_NOT_READY)
                }
                "DROPPED_INSIDE_PSC_SERVICE_PRODUCER" => {
                    std::option::Option::Some(Self::DROPPED_INSIDE_PSC_SERVICE_PRODUCER)
                }
                "LOAD_BALANCER_HAS_NO_PROXY_SUBNET" => {
                    std::option::Option::Some(Self::LOAD_BALANCER_HAS_NO_PROXY_SUBNET)
                }
                "CLOUD_NAT_NO_ADDRESSES" => std::option::Option::Some(Self::CLOUD_NAT_NO_ADDRESSES),
                "ROUTING_LOOP" => std::option::Option::Some(Self::ROUTING_LOOP),
                "DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE" => {
                    std::option::Option::Some(Self::DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE)
                }
                "LOAD_BALANCER_BACKEND_INVALID_NETWORK" => {
                    std::option::Option::Some(Self::LOAD_BALANCER_BACKEND_INVALID_NETWORK)
                }
                "BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED" => {
                    std::option::Option::Some(Self::BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED)
                }
                "DESTINATION_IS_PRIVATE_NAT_IP_RANGE" => {
                    std::option::Option::Some(Self::DESTINATION_IS_PRIVATE_NAT_IP_RANGE)
                }
                "DROPPED_INSIDE_REDIS_INSTANCE_SERVICE" => {
                    std::option::Option::Some(Self::DROPPED_INSIDE_REDIS_INSTANCE_SERVICE)
                }
                "REDIS_INSTANCE_UNSUPPORTED_PORT" => {
                    std::option::Option::Some(Self::REDIS_INSTANCE_UNSUPPORTED_PORT)
                }
                "REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS" => {
                    std::option::Option::Some(Self::REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS)
                }
                "REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK" => {
                    std::option::Option::Some(Self::REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK)
                }
                "REDIS_INSTANCE_NO_EXTERNAL_IP" => {
                    std::option::Option::Some(Self::REDIS_INSTANCE_NO_EXTERNAL_IP)
                }
                "REDIS_INSTANCE_UNSUPPORTED_PROTOCOL" => {
                    std::option::Option::Some(Self::REDIS_INSTANCE_UNSUPPORTED_PROTOCOL)
                }
                "DROPPED_INSIDE_REDIS_CLUSTER_SERVICE" => {
                    std::option::Option::Some(Self::DROPPED_INSIDE_REDIS_CLUSTER_SERVICE)
                }
                "REDIS_CLUSTER_UNSUPPORTED_PORT" => {
                    std::option::Option::Some(Self::REDIS_CLUSTER_UNSUPPORTED_PORT)
                }
                "REDIS_CLUSTER_NO_EXTERNAL_IP" => {
                    std::option::Option::Some(Self::REDIS_CLUSTER_NO_EXTERNAL_IP)
                }
                "REDIS_CLUSTER_UNSUPPORTED_PROTOCOL" => {
                    std::option::Option::Some(Self::REDIS_CLUSTER_UNSUPPORTED_PROTOCOL)
                }
                "NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION" => {
                    std::option::Option::Some(Self::NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION)
                }
                "NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION" => {
                    std::option::Option::Some(Self::NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION)
                }
                "NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION" => std::option::Option::Some(
                    Self::NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION,
                ),
                "PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED" => {
                    std::option::Option::Some(Self::PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Cause {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Cause {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with a Google Kubernetes Engine (GKE)
/// cluster master.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GKEMasterInfo {
    /// URI of a GKE cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uri: std::string::String,

    /// URI of a GKE cluster network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_network_uri: std::string::String,

    /// Internal IP address of a GKE cluster control plane.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// External IP address of a GKE cluster control plane.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_ip: std::string::String,

    /// DNS endpoint of a GKE cluster control plane.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns_endpoint: std::string::String,
}

impl GKEMasterInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_uri][crate::model::GKEMasterInfo::cluster_uri].
    pub fn set_cluster_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uri = v.into();
        self
    }

    /// Sets the value of [cluster_network_uri][crate::model::GKEMasterInfo::cluster_network_uri].
    pub fn set_cluster_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_network_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::GKEMasterInfo::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::GKEMasterInfo::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [dns_endpoint][crate::model::GKEMasterInfo::dns_endpoint].
    pub fn set_dns_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_endpoint = v.into();
        self
    }
}

impl wkt::message::Message for GKEMasterInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GKEMasterInfo"
    }
}

/// For display only. Metadata associated with a Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSQLInstanceInfo {
    /// Name of a Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// URI of a Cloud SQL instance network or empty string if the instance does
    /// not have one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Internal IP address of a Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// External IP address of a Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_ip: std::string::String,

    /// Region in which the Cloud SQL instance is running.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl CloudSQLInstanceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::CloudSQLInstanceInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CloudSQLInstanceInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::CloudSQLInstanceInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::CloudSQLInstanceInfo::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::CloudSQLInstanceInfo::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CloudSQLInstanceInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for CloudSQLInstanceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CloudSQLInstanceInfo"
    }
}

/// For display only. Metadata associated with a Cloud Redis Instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedisInstanceInfo {
    /// Name of a Cloud Redis Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Cloud Redis Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// URI of a Cloud Redis Instance network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Primary endpoint IP address of a Cloud Redis Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_endpoint_ip: std::string::String,

    /// Read endpoint IP address of a Cloud Redis Instance (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub read_endpoint_ip: std::string::String,

    /// Region in which the Cloud Redis Instance is defined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl RedisInstanceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::RedisInstanceInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::RedisInstanceInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::RedisInstanceInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [primary_endpoint_ip][crate::model::RedisInstanceInfo::primary_endpoint_ip].
    pub fn set_primary_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [read_endpoint_ip][crate::model::RedisInstanceInfo::read_endpoint_ip].
    pub fn set_read_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [region][crate::model::RedisInstanceInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for RedisInstanceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RedisInstanceInfo"
    }
}

/// For display only. Metadata associated with a Redis Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedisClusterInfo {
    /// Name of a Redis Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Redis Cluster in format
    /// "projects/{project_id}/locations/{location}/clusters/{cluster_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// URI of a Redis Cluster network in format
    /// "projects/{project_id}/global/networks/{network_id}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Discovery endpoint IP address of a Redis Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub discovery_endpoint_ip_address: std::string::String,

    /// Secondary endpoint IP address of a Redis Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_endpoint_ip_address: std::string::String,

    /// Name of the region in which the Redis Cluster is defined. For example,
    /// "us-central1".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl RedisClusterInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::RedisClusterInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::RedisClusterInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::RedisClusterInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [discovery_endpoint_ip_address][crate::model::RedisClusterInfo::discovery_endpoint_ip_address].
    pub fn set_discovery_endpoint_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_endpoint_ip_address = v.into();
        self
    }

    /// Sets the value of [secondary_endpoint_ip_address][crate::model::RedisClusterInfo::secondary_endpoint_ip_address].
    pub fn set_secondary_endpoint_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_endpoint_ip_address = v.into();
        self
    }

    /// Sets the value of [location][crate::model::RedisClusterInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for RedisClusterInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RedisClusterInfo"
    }
}

/// For display only. Metadata associated with a Cloud Function.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudFunctionInfo {
    /// Name of a Cloud Function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Cloud Function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Location in which the Cloud Function is deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Latest successfully deployed version id of the Cloud Function.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub version_id: i64,
}

impl CloudFunctionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::CloudFunctionInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CloudFunctionInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [location][crate::model::CloudFunctionInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::CloudFunctionInfo::version_id].
    pub fn set_version_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudFunctionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CloudFunctionInfo"
    }
}

/// For display only. Metadata associated with a Cloud Run revision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRunRevisionInfo {
    /// Name of a Cloud Run revision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a Cloud Run revision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Location in which this revision is deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// URI of Cloud Run service this revision belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_uri: std::string::String,
}

impl CloudRunRevisionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::CloudRunRevisionInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CloudRunRevisionInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [location][crate::model::CloudRunRevisionInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [service_uri][crate::model::CloudRunRevisionInfo::service_uri].
    pub fn set_service_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_uri = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunRevisionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CloudRunRevisionInfo"
    }
}

/// For display only. Metadata associated with an App Engine version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppEngineVersionInfo {
    /// Name of an App Engine version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of an App Engine version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Runtime of the App Engine version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime: std::string::String,

    /// App Engine execution environment for a version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment: std::string::String,
}

impl AppEngineVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::AppEngineVersionInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::AppEngineVersionInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [runtime][crate::model::AppEngineVersionInfo::runtime].
    pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::AppEngineVersionInfo::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.AppEngineVersionInfo"
    }
}

/// For display only. Metadata associated with a VPC connector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcConnectorInfo {
    /// Name of a VPC connector.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// URI of a VPC connector.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Location in which the VPC connector is deployed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl VpcConnectorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::VpcConnectorInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::VpcConnectorInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [location][crate::model::VpcConnectorInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for VpcConnectorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpcConnectorInfo"
    }
}

/// For display only. Metadata associated with NAT.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NatInfo {
    /// Type of NAT.
    #[serde(rename = "type")]
    pub r#type: crate::model::nat_info::Type,

    /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protocol: std::string::String,

    /// URI of the network where NAT translation takes place.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Source IP address before NAT translation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub old_source_ip: std::string::String,

    /// Source IP address after NAT translation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_source_ip: std::string::String,

    /// Destination IP address before NAT translation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub old_destination_ip: std::string::String,

    /// Destination IP address after NAT translation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_destination_ip: std::string::String,

    /// Source port before NAT translation. Only valid when protocol is TCP or UDP.
    pub old_source_port: i32,

    /// Source port after NAT translation. Only valid when protocol is TCP or UDP.
    pub new_source_port: i32,

    /// Destination port before NAT translation. Only valid when protocol is TCP or
    /// UDP.
    pub old_destination_port: i32,

    /// Destination port after NAT translation. Only valid when protocol is TCP or
    /// UDP.
    pub new_destination_port: i32,

    /// Uri of the Cloud Router. Only valid when type is CLOUD_NAT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub router_uri: std::string::String,

    /// The name of Cloud NAT Gateway. Only valid when type is CLOUD_NAT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nat_gateway_name: std::string::String,
}

impl NatInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::NatInfo::type].
    pub fn set_type<T: std::convert::Into<crate::model::nat_info::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::NatInfo::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::NatInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [old_source_ip][crate::model::NatInfo::old_source_ip].
    pub fn set_old_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.old_source_ip = v.into();
        self
    }

    /// Sets the value of [new_source_ip][crate::model::NatInfo::new_source_ip].
    pub fn set_new_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_source_ip = v.into();
        self
    }

    /// Sets the value of [old_destination_ip][crate::model::NatInfo::old_destination_ip].
    pub fn set_old_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.old_destination_ip = v.into();
        self
    }

    /// Sets the value of [new_destination_ip][crate::model::NatInfo::new_destination_ip].
    pub fn set_new_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_destination_ip = v.into();
        self
    }

    /// Sets the value of [old_source_port][crate::model::NatInfo::old_source_port].
    pub fn set_old_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_source_port = v.into();
        self
    }

    /// Sets the value of [new_source_port][crate::model::NatInfo::new_source_port].
    pub fn set_new_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_source_port = v.into();
        self
    }

    /// Sets the value of [old_destination_port][crate::model::NatInfo::old_destination_port].
    pub fn set_old_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_destination_port = v.into();
        self
    }

    /// Sets the value of [new_destination_port][crate::model::NatInfo::new_destination_port].
    pub fn set_new_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_destination_port = v.into();
        self
    }

    /// Sets the value of [router_uri][crate::model::NatInfo::router_uri].
    pub fn set_router_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.router_uri = v.into();
        self
    }

    /// Sets the value of [nat_gateway_name][crate::model::NatInfo::nat_gateway_name].
    pub fn set_nat_gateway_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nat_gateway_name = v.into();
        self
    }
}

impl wkt::message::Message for NatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.NatInfo"
    }
}

/// Defines additional types related to NatInfo
pub mod nat_info {
    #[allow(unused_imports)]
    use super::*;

    /// Types of NAT.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Type is unspecified.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// From Compute Engine instance's internal address to external address.
        pub const INTERNAL_TO_EXTERNAL: Type = Type::new(1);

        /// From Compute Engine instance's external address to internal address.
        pub const EXTERNAL_TO_INTERNAL: Type = Type::new(2);

        /// Cloud NAT Gateway.
        pub const CLOUD_NAT: Type = Type::new(3);

        /// Private service connect NAT.
        pub const PRIVATE_SERVICE_CONNECT: Type = Type::new(4);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INTERNAL_TO_EXTERNAL"),
                2 => std::borrow::Cow::Borrowed("EXTERNAL_TO_INTERNAL"),
                3 => std::borrow::Cow::Borrowed("CLOUD_NAT"),
                4 => std::borrow::Cow::Borrowed("PRIVATE_SERVICE_CONNECT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "INTERNAL_TO_EXTERNAL" => std::option::Option::Some(Self::INTERNAL_TO_EXTERNAL),
                "EXTERNAL_TO_INTERNAL" => std::option::Option::Some(Self::EXTERNAL_TO_INTERNAL),
                "CLOUD_NAT" => std::option::Option::Some(Self::CLOUD_NAT),
                "PRIVATE_SERVICE_CONNECT" => {
                    std::option::Option::Some(Self::PRIVATE_SERVICE_CONNECT)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with ProxyConnection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProxyConnectionInfo {
    /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protocol: std::string::String,

    /// Source IP address of an original connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub old_source_ip: std::string::String,

    /// Source IP address of a new connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_source_ip: std::string::String,

    /// Destination IP address of an original connection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub old_destination_ip: std::string::String,

    /// Destination IP address of a new connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_destination_ip: std::string::String,

    /// Source port of an original connection. Only valid when protocol is TCP or
    /// UDP.
    pub old_source_port: i32,

    /// Source port of a new connection. Only valid when protocol is TCP or UDP.
    pub new_source_port: i32,

    /// Destination port of an original connection. Only valid when protocol is TCP
    /// or UDP.
    pub old_destination_port: i32,

    /// Destination port of a new connection. Only valid when protocol is TCP or
    /// UDP.
    pub new_destination_port: i32,

    /// Uri of proxy subnet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_uri: std::string::String,

    /// URI of the network where connection is proxied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,
}

impl ProxyConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protocol][crate::model::ProxyConnectionInfo::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [old_source_ip][crate::model::ProxyConnectionInfo::old_source_ip].
    pub fn set_old_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.old_source_ip = v.into();
        self
    }

    /// Sets the value of [new_source_ip][crate::model::ProxyConnectionInfo::new_source_ip].
    pub fn set_new_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_source_ip = v.into();
        self
    }

    /// Sets the value of [old_destination_ip][crate::model::ProxyConnectionInfo::old_destination_ip].
    pub fn set_old_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.old_destination_ip = v.into();
        self
    }

    /// Sets the value of [new_destination_ip][crate::model::ProxyConnectionInfo::new_destination_ip].
    pub fn set_new_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_destination_ip = v.into();
        self
    }

    /// Sets the value of [old_source_port][crate::model::ProxyConnectionInfo::old_source_port].
    pub fn set_old_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_source_port = v.into();
        self
    }

    /// Sets the value of [new_source_port][crate::model::ProxyConnectionInfo::new_source_port].
    pub fn set_new_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_source_port = v.into();
        self
    }

    /// Sets the value of [old_destination_port][crate::model::ProxyConnectionInfo::old_destination_port].
    pub fn set_old_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_destination_port = v.into();
        self
    }

    /// Sets the value of [new_destination_port][crate::model::ProxyConnectionInfo::new_destination_port].
    pub fn set_new_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_destination_port = v.into();
        self
    }

    /// Sets the value of [subnet_uri][crate::model::ProxyConnectionInfo::subnet_uri].
    pub fn set_subnet_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::ProxyConnectionInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }
}

impl wkt::message::Message for ProxyConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ProxyConnectionInfo"
    }
}

/// For display only. Metadata associated with the load balancer backend.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoadBalancerBackendInfo {
    /// Display name of the backend. For example, it might be an instance name for
    /// the instance group backends, or an IP address and port for zonal network
    /// endpoint group backends.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// URI of the backend instance (if applicable). Populated for instance group
    /// backends, and zonal NEG backends.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_uri: std::string::String,

    /// URI of the backend service this backend belongs to (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backend_service_uri: std::string::String,

    /// URI of the instance group this backend belongs to (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_group_uri: std::string::String,

    /// URI of the network endpoint group this backend belongs to (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_endpoint_group_uri: std::string::String,

    /// URI of the backend bucket this backend targets (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backend_bucket_uri: std::string::String,

    /// URI of the PSC service attachment this PSC NEG backend targets (if
    /// applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_service_attachment_uri: std::string::String,

    /// PSC Google API target this PSC NEG backend targets (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_google_api_target: std::string::String,

    /// URI of the health check attached to this backend (if applicable).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_check_uri: std::string::String,

    /// Output only. Health check firewalls configuration state for the backend.
    /// This is a result of the static firewall analysis (verifying that health
    /// check traffic from required IP ranges to the backend is allowed or not).
    /// The backend might still be unhealthy even if these firewalls are
    /// configured. Please refer to the documentation for more information:
    /// <https://cloud.google.com/load-balancing/docs/firewall-rules>
    pub health_check_firewalls_config_state:
        crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState,
}

impl LoadBalancerBackendInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LoadBalancerBackendInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_uri][crate::model::LoadBalancerBackendInfo::instance_uri].
    pub fn set_instance_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uri = v.into();
        self
    }

    /// Sets the value of [backend_service_uri][crate::model::LoadBalancerBackendInfo::backend_service_uri].
    pub fn set_backend_service_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backend_service_uri = v.into();
        self
    }

    /// Sets the value of [instance_group_uri][crate::model::LoadBalancerBackendInfo::instance_group_uri].
    pub fn set_instance_group_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_group_uri = v.into();
        self
    }

    /// Sets the value of [network_endpoint_group_uri][crate::model::LoadBalancerBackendInfo::network_endpoint_group_uri].
    pub fn set_network_endpoint_group_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_endpoint_group_uri = v.into();
        self
    }

    /// Sets the value of [backend_bucket_uri][crate::model::LoadBalancerBackendInfo::backend_bucket_uri].
    pub fn set_backend_bucket_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backend_bucket_uri = v.into();
        self
    }

    /// Sets the value of [psc_service_attachment_uri][crate::model::LoadBalancerBackendInfo::psc_service_attachment_uri].
    pub fn set_psc_service_attachment_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_service_attachment_uri = v.into();
        self
    }

    /// Sets the value of [psc_google_api_target][crate::model::LoadBalancerBackendInfo::psc_google_api_target].
    pub fn set_psc_google_api_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_google_api_target = v.into();
        self
    }

    /// Sets the value of [health_check_uri][crate::model::LoadBalancerBackendInfo::health_check_uri].
    pub fn set_health_check_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_uri = v.into();
        self
    }

    /// Sets the value of [health_check_firewalls_config_state][crate::model::LoadBalancerBackendInfo::health_check_firewalls_config_state].
    pub fn set_health_check_firewalls_config_state<
        T: std::convert::Into<
            crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_firewalls_config_state = v.into();
        self
    }
}

impl wkt::message::Message for LoadBalancerBackendInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LoadBalancerBackendInfo"
    }
}

/// Defines additional types related to LoadBalancerBackendInfo
pub mod load_balancer_backend_info {
    #[allow(unused_imports)]
    use super::*;

    /// Health check firewalls configuration state enum.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HealthCheckFirewallsConfigState(i32);

    impl HealthCheckFirewallsConfigState {
        /// Configuration state unspecified. It usually means that the backend has
        /// no health check attached, or there was an unexpected configuration error
        /// preventing Connectivity tests from verifying health check configuration.
        pub const HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED: HealthCheckFirewallsConfigState =
            HealthCheckFirewallsConfigState::new(0);

        /// Firewall rules (policies) allowing health check traffic from all required
        /// IP ranges to the backend are configured.
        pub const FIREWALLS_CONFIGURED: HealthCheckFirewallsConfigState =
            HealthCheckFirewallsConfigState::new(1);

        /// Firewall rules (policies) allow health check traffic only from a part of
        /// required IP ranges.
        pub const FIREWALLS_PARTIALLY_CONFIGURED: HealthCheckFirewallsConfigState =
            HealthCheckFirewallsConfigState::new(2);

        /// Firewall rules (policies) deny health check traffic from all required
        /// IP ranges to the backend.
        pub const FIREWALLS_NOT_CONFIGURED: HealthCheckFirewallsConfigState =
            HealthCheckFirewallsConfigState::new(3);

        /// The network contains firewall rules of unsupported types, so Connectivity
        /// tests were not able to verify health check configuration status. Please
        /// refer to the documentation for the list of unsupported configurations:
        /// <https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs>
        pub const FIREWALLS_UNSUPPORTED: HealthCheckFirewallsConfigState =
            HealthCheckFirewallsConfigState::new(4);

        /// Creates a new HealthCheckFirewallsConfigState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FIREWALLS_CONFIGURED"),
                2 => std::borrow::Cow::Borrowed("FIREWALLS_PARTIALLY_CONFIGURED"),
                3 => std::borrow::Cow::Borrowed("FIREWALLS_NOT_CONFIGURED"),
                4 => std::borrow::Cow::Borrowed("FIREWALLS_UNSUPPORTED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED)
                }
                "FIREWALLS_CONFIGURED" => std::option::Option::Some(Self::FIREWALLS_CONFIGURED),
                "FIREWALLS_PARTIALLY_CONFIGURED" => {
                    std::option::Option::Some(Self::FIREWALLS_PARTIALLY_CONFIGURED)
                }
                "FIREWALLS_NOT_CONFIGURED" => {
                    std::option::Option::Some(Self::FIREWALLS_NOT_CONFIGURED)
                }
                "FIREWALLS_UNSUPPORTED" => std::option::Option::Some(Self::FIREWALLS_UNSUPPORTED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for HealthCheckFirewallsConfigState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for HealthCheckFirewallsConfigState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// For display only. Metadata associated with Storage Bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageBucketInfo {
    /// Cloud Storage Bucket name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,
}

impl StorageBucketInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageBucketInfo::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }
}

impl wkt::message::Message for StorageBucketInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.StorageBucketInfo"
    }
}

/// For display only. Metadata associated with the serverless network endpoint
/// group backend.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServerlessNegInfo {
    /// URI of the serverless network endpoint group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub neg_uri: std::string::String,
}

impl ServerlessNegInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neg_uri][crate::model::ServerlessNegInfo::neg_uri].
    pub fn set_neg_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.neg_uri = v.into();
        self
    }
}

impl wkt::message::Message for ServerlessNegInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ServerlessNegInfo"
    }
}

/// Request for the `ListVpcFlowLogsConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVpcFlowLogsConfigsRequest {
    /// Required. The parent resource of the VpcFlowLogsConfig:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Number of `VpcFlowLogsConfigs` to return.
    pub page_size: i32,

    /// Optional. Page token from an earlier query, as returned in
    /// `next_page_token`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Lists the `VpcFlowLogsConfigs` that match the filter expression.
    /// A filter expression must use the supported [CEL logic operators]
    /// (<https://cloud.google.com/vpc/docs/about-flow-logs-records#supported_cel_logic_operators>).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Field to use to sort the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListVpcFlowLogsConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVpcFlowLogsConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVpcFlowLogsConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVpcFlowLogsConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVpcFlowLogsConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVpcFlowLogsConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVpcFlowLogsConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListVpcFlowLogsConfigsRequest"
    }
}

/// Response for the `ListVpcFlowLogsConfigs` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVpcFlowLogsConfigsResponse {
    /// List of VPC Flow Log configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vpc_flow_logs_configs: std::vec::Vec<crate::model::VpcFlowLogsConfig>,

    /// Page token to fetch the next set of configurations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached (when querying all locations with `-`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListVpcFlowLogsConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListVpcFlowLogsConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [vpc_flow_logs_configs][crate::model::ListVpcFlowLogsConfigsResponse::vpc_flow_logs_configs].
    pub fn set_vpc_flow_logs_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VpcFlowLogsConfig>,
    {
        use std::iter::Iterator;
        self.vpc_flow_logs_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVpcFlowLogsConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVpcFlowLogsConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListVpcFlowLogsConfigsResponse"
    }
}

impl gax::paginator::PageableResponse for ListVpcFlowLogsConfigsResponse {
    type PageItem = crate::model::VpcFlowLogsConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vpc_flow_logs_configs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for the `GetVpcFlowLogsConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVpcFlowLogsConfigRequest {
    /// Required. `VpcFlowLogsConfig` resource name using the form:
    /// `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVpcFlowLogsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GetVpcFlowLogsConfigRequest"
    }
}

/// Request for the `CreateVpcFlowLogsConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVpcFlowLogsConfigRequest {
    /// Required. The parent resource of the VPC Flow Logs configuration to create:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the `VpcFlowLogsConfig`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_flow_logs_config_id: std::string::String,

    /// Required. A `VpcFlowLogsConfig` resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_flow_logs_config: std::option::Option<crate::model::VpcFlowLogsConfig>,
}

impl CreateVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVpcFlowLogsConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vpc_flow_logs_config_id][crate::model::CreateVpcFlowLogsConfigRequest::vpc_flow_logs_config_id].
    pub fn set_vpc_flow_logs_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_flow_logs_config_id = v.into();
        self
    }

    /// Sets the value of [vpc_flow_logs_config][crate::model::CreateVpcFlowLogsConfigRequest::vpc_flow_logs_config].
    pub fn set_vpc_flow_logs_config<
        T: std::convert::Into<std::option::Option<crate::model::VpcFlowLogsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_flow_logs_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CreateVpcFlowLogsConfigRequest"
    }
}

/// Request for the `UpdateVpcFlowLogsConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVpcFlowLogsConfigRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_flow_logs_config: std::option::Option<crate::model::VpcFlowLogsConfig>,
}

impl UpdateVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateVpcFlowLogsConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [vpc_flow_logs_config][crate::model::UpdateVpcFlowLogsConfigRequest::vpc_flow_logs_config].
    pub fn set_vpc_flow_logs_config<
        T: std::convert::Into<std::option::Option<crate::model::VpcFlowLogsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_flow_logs_config = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.UpdateVpcFlowLogsConfigRequest"
    }
}

/// Request for the `DeleteVpcFlowLogsConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVpcFlowLogsConfigRequest {
    /// Required. `VpcFlowLogsConfig` resource name using the form:
    /// `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVpcFlowLogsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DeleteVpcFlowLogsConfigRequest"
    }
}

/// A configuration to generate VPC Flow Logs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcFlowLogsConfig {
    /// Identifier. Unique name of the configuration using the form:
    /// `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The user-supplied description of the VPC Flow Logs configuration.
    /// Maximum of 512 characters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Optional. The state of the VPC Flow Log configuration. Default value is
    /// ENABLED. When creating a new configuration, it must be enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state: std::option::Option<crate::model::vpc_flow_logs_config::State>,

    /// Optional. The aggregation interval for the logs. Default value is
    /// INTERVAL_5_SEC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aggregation_interval:
        std::option::Option<crate::model::vpc_flow_logs_config::AggregationInterval>,

    /// Optional. The value of the field must be in (0, 1]. The sampling rate of
    /// VPC Flow Logs where 1.0 means all collected logs are reported. Setting the
    /// sampling rate to 0.0 is not allowed. If you want to disable VPC Flow Logs,
    /// use the state field instead. Default value is 1.0.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub flow_sampling: std::option::Option<f32>,

    /// Optional. Configures whether all, none or a subset of metadata fields
    /// should be added to the reported VPC flow logs. Default value is
    /// INCLUDE_ALL_METADATA.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::vpc_flow_logs_config::Metadata>,

    /// Optional. Custom metadata fields to include in the reported VPC flow logs.
    /// Can only be specified if "metadata" was set to CUSTOM_METADATA.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metadata_fields: std::vec::Vec<std::string::String>,

    /// Optional. Export filter used to define which VPC Flow Logs should be
    /// logged.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter_expr: std::option::Option<std::string::String>,

    /// Output only. A diagnostic bit - describes the state of the configured
    /// target resource for diagnostic purposes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_resource_state:
        std::option::Option<crate::model::vpc_flow_logs_config::TargetResourceState>,

    /// Optional. Resource labels to represent user-provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time the config was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the config was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Reference to the resource of the config scope. That is, the scope from
    /// which traffic is logged. The target resource must belong to the same
    /// project as the configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_resource: std::option::Option<crate::model::vpc_flow_logs_config::TargetResource>,
}

impl VpcFlowLogsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpcFlowLogsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VpcFlowLogsConfig::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::VpcFlowLogsConfig::state].
    pub fn set_state<
        T: std::convert::Into<std::option::Option<crate::model::vpc_flow_logs_config::State>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [aggregation_interval][crate::model::VpcFlowLogsConfig::aggregation_interval].
    pub fn set_aggregation_interval<
        T: std::convert::Into<
            std::option::Option<crate::model::vpc_flow_logs_config::AggregationInterval>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_interval = v.into();
        self
    }

    /// Sets the value of [flow_sampling][crate::model::VpcFlowLogsConfig::flow_sampling].
    pub fn set_flow_sampling<T: std::convert::Into<std::option::Option<f32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.flow_sampling = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::VpcFlowLogsConfig::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::vpc_flow_logs_config::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [filter_expr][crate::model::VpcFlowLogsConfig::filter_expr].
    pub fn set_filter_expr<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_expr = v.into();
        self
    }

    /// Sets the value of [target_resource_state][crate::model::VpcFlowLogsConfig::target_resource_state].
    pub fn set_target_resource_state<
        T: std::convert::Into<
            std::option::Option<crate::model::vpc_flow_logs_config::TargetResourceState>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VpcFlowLogsConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::VpcFlowLogsConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [metadata_fields][crate::model::VpcFlowLogsConfig::metadata_fields].
    pub fn set_metadata_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::VpcFlowLogsConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `target_resource`.
    pub fn set_target_resource<
        T: std::convert::Into<std::option::Option<crate::model::vpc_flow_logs_config::TargetResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource = v.into();
        self
    }

    /// The value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// if it holds a `InterconnectAttachment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_interconnect_attachment(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_resource.as_ref().and_then(|v| match v {
            crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// if it holds a `VpnTunnel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vpn_tunnel(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_resource.as_ref().and_then(|v| match v {
            crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// to hold a `InterconnectAttachment`.
    ///
    /// Note that all the setters affecting `target_resource` are
    /// mutually exclusive.
    pub fn set_interconnect_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource = std::option::Option::Some(
            crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(v.into()),
        );
        self
    }

    /// Sets the value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// to hold a `VpnTunnel`.
    ///
    /// Note that all the setters affecting `target_resource` are
    /// mutually exclusive.
    pub fn set_vpn_tunnel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_resource = std::option::Option::Some(
            crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VpcFlowLogsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpcFlowLogsConfig"
    }
}

/// Defines additional types related to VpcFlowLogsConfig
pub mod vpc_flow_logs_config {
    #[allow(unused_imports)]
    use super::*;

    /// Determines whether this configuration will be generating logs.
    /// Setting state=DISABLED will pause the log generation for this config.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// If not specified, will default to ENABLED.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// When ENABLED, this configuration will generate logs.
        pub const ENABLED: State = State::new(1);

        /// When DISABLED, this configuration will not generate logs.
        pub const DISABLED: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLED"),
                2 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Toggles the aggregation interval for collecting flow logs by 5-tuple.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AggregationInterval(i32);

    impl AggregationInterval {
        /// If not specified, will default to INTERVAL_5_SEC.
        pub const AGGREGATION_INTERVAL_UNSPECIFIED: AggregationInterval =
            AggregationInterval::new(0);

        /// Aggregate logs in 5s intervals.
        pub const INTERVAL_5_SEC: AggregationInterval = AggregationInterval::new(1);

        /// Aggregate logs in 30s intervals.
        pub const INTERVAL_30_SEC: AggregationInterval = AggregationInterval::new(2);

        /// Aggregate logs in 1m intervals.
        pub const INTERVAL_1_MIN: AggregationInterval = AggregationInterval::new(3);

        /// Aggregate logs in 5m intervals.
        pub const INTERVAL_5_MIN: AggregationInterval = AggregationInterval::new(4);

        /// Aggregate logs in 10m intervals.
        pub const INTERVAL_10_MIN: AggregationInterval = AggregationInterval::new(5);

        /// Aggregate logs in 15m intervals.
        pub const INTERVAL_15_MIN: AggregationInterval = AggregationInterval::new(6);

        /// Creates a new AggregationInterval instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("AGGREGATION_INTERVAL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INTERVAL_5_SEC"),
                2 => std::borrow::Cow::Borrowed("INTERVAL_30_SEC"),
                3 => std::borrow::Cow::Borrowed("INTERVAL_1_MIN"),
                4 => std::borrow::Cow::Borrowed("INTERVAL_5_MIN"),
                5 => std::borrow::Cow::Borrowed("INTERVAL_10_MIN"),
                6 => std::borrow::Cow::Borrowed("INTERVAL_15_MIN"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "AGGREGATION_INTERVAL_UNSPECIFIED" => {
                    std::option::Option::Some(Self::AGGREGATION_INTERVAL_UNSPECIFIED)
                }
                "INTERVAL_5_SEC" => std::option::Option::Some(Self::INTERVAL_5_SEC),
                "INTERVAL_30_SEC" => std::option::Option::Some(Self::INTERVAL_30_SEC),
                "INTERVAL_1_MIN" => std::option::Option::Some(Self::INTERVAL_1_MIN),
                "INTERVAL_5_MIN" => std::option::Option::Some(Self::INTERVAL_5_MIN),
                "INTERVAL_10_MIN" => std::option::Option::Some(Self::INTERVAL_10_MIN),
                "INTERVAL_15_MIN" => std::option::Option::Some(Self::INTERVAL_15_MIN),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AggregationInterval {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AggregationInterval {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Configures which log fields would be included.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Metadata(i32);

    impl Metadata {
        /// If not specified, will default to INCLUDE_ALL_METADATA.
        pub const METADATA_UNSPECIFIED: Metadata = Metadata::new(0);

        /// Include all metadata fields.
        pub const INCLUDE_ALL_METADATA: Metadata = Metadata::new(1);

        /// Exclude all metadata fields.
        pub const EXCLUDE_ALL_METADATA: Metadata = Metadata::new(2);

        /// Include only custom fields (specified in metadata_fields).
        pub const CUSTOM_METADATA: Metadata = Metadata::new(3);

        /// Creates a new Metadata instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("METADATA_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INCLUDE_ALL_METADATA"),
                2 => std::borrow::Cow::Borrowed("EXCLUDE_ALL_METADATA"),
                3 => std::borrow::Cow::Borrowed("CUSTOM_METADATA"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "METADATA_UNSPECIFIED" => std::option::Option::Some(Self::METADATA_UNSPECIFIED),
                "INCLUDE_ALL_METADATA" => std::option::Option::Some(Self::INCLUDE_ALL_METADATA),
                "EXCLUDE_ALL_METADATA" => std::option::Option::Some(Self::EXCLUDE_ALL_METADATA),
                "CUSTOM_METADATA" => std::option::Option::Some(Self::CUSTOM_METADATA),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Metadata {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Metadata {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Optional states of the target resource that are used as part of the
    /// diagnostic bit.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TargetResourceState(i32);

    impl TargetResourceState {
        /// Unspecified target resource state.
        pub const TARGET_RESOURCE_STATE_UNSPECIFIED: TargetResourceState =
            TargetResourceState::new(0);

        /// Indicates that the target resource exists.
        pub const TARGET_RESOURCE_EXISTS: TargetResourceState = TargetResourceState::new(1);

        /// Indicates that the target resource does not exist.
        pub const TARGET_RESOURCE_DOES_NOT_EXIST: TargetResourceState = TargetResourceState::new(2);

        /// Creates a new TargetResourceState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TARGET_RESOURCE_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TARGET_RESOURCE_EXISTS"),
                2 => std::borrow::Cow::Borrowed("TARGET_RESOURCE_DOES_NOT_EXIST"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TARGET_RESOURCE_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TARGET_RESOURCE_STATE_UNSPECIFIED)
                }
                "TARGET_RESOURCE_EXISTS" => std::option::Option::Some(Self::TARGET_RESOURCE_EXISTS),
                "TARGET_RESOURCE_DOES_NOT_EXIST" => {
                    std::option::Option::Some(Self::TARGET_RESOURCE_DOES_NOT_EXIST)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TargetResourceState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TargetResourceState {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Reference to the resource of the config scope. That is, the scope from
    /// which traffic is logged. The target resource must belong to the same
    /// project as the configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetResource {
        /// Traffic will be logged from the Interconnect Attachment.
        /// Format:
        /// projects/{project_id}/regions/{region}/interconnectAttachments/{name}
        InterconnectAttachment(std::string::String),
        /// Traffic will be logged from the VPN Tunnel.
        /// Format: projects/{project_id}/regions/{region}/vpnTunnels/{name}
        VpnTunnel(std::string::String),
    }
}

/// Type of a load balancer. For more information, see [Summary of Google Cloud
/// load
/// balancers](https://cloud.google.com/load-balancing/docs/load-balancing-overview#summary-of-google-cloud-load-balancers).
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct LoadBalancerType(i32);

impl LoadBalancerType {
    /// Forwarding rule points to a different target than a load balancer or a
    /// load balancer type is unknown.
    pub const LOAD_BALANCER_TYPE_UNSPECIFIED: LoadBalancerType = LoadBalancerType::new(0);

    /// Global external HTTP(S) load balancer.
    pub const HTTPS_ADVANCED_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(1);

    /// Global external HTTP(S) load balancer (classic)
    pub const HTTPS_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(2);

    /// Regional external HTTP(S) load balancer.
    pub const REGIONAL_HTTPS_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(3);

    /// Internal HTTP(S) load balancer.
    pub const INTERNAL_HTTPS_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(4);

    /// External SSL proxy load balancer.
    pub const SSL_PROXY_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(5);

    /// External TCP proxy load balancer.
    pub const TCP_PROXY_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(6);

    /// Internal regional TCP proxy load balancer.
    pub const INTERNAL_TCP_PROXY_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(7);

    /// External TCP/UDP Network load balancer.
    pub const NETWORK_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(8);

    /// Target-pool based external TCP/UDP Network load balancer.
    pub const LEGACY_NETWORK_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(9);

    /// Internal TCP/UDP load balancer.
    pub const TCP_UDP_INTERNAL_LOAD_BALANCER: LoadBalancerType = LoadBalancerType::new(10);

    /// Creates a new LoadBalancerType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("LOAD_BALANCER_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("HTTPS_ADVANCED_LOAD_BALANCER"),
            2 => std::borrow::Cow::Borrowed("HTTPS_LOAD_BALANCER"),
            3 => std::borrow::Cow::Borrowed("REGIONAL_HTTPS_LOAD_BALANCER"),
            4 => std::borrow::Cow::Borrowed("INTERNAL_HTTPS_LOAD_BALANCER"),
            5 => std::borrow::Cow::Borrowed("SSL_PROXY_LOAD_BALANCER"),
            6 => std::borrow::Cow::Borrowed("TCP_PROXY_LOAD_BALANCER"),
            7 => std::borrow::Cow::Borrowed("INTERNAL_TCP_PROXY_LOAD_BALANCER"),
            8 => std::borrow::Cow::Borrowed("NETWORK_LOAD_BALANCER"),
            9 => std::borrow::Cow::Borrowed("LEGACY_NETWORK_LOAD_BALANCER"),
            10 => std::borrow::Cow::Borrowed("TCP_UDP_INTERNAL_LOAD_BALANCER"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "LOAD_BALANCER_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::LOAD_BALANCER_TYPE_UNSPECIFIED)
            }
            "HTTPS_ADVANCED_LOAD_BALANCER" => {
                std::option::Option::Some(Self::HTTPS_ADVANCED_LOAD_BALANCER)
            }
            "HTTPS_LOAD_BALANCER" => std::option::Option::Some(Self::HTTPS_LOAD_BALANCER),
            "REGIONAL_HTTPS_LOAD_BALANCER" => {
                std::option::Option::Some(Self::REGIONAL_HTTPS_LOAD_BALANCER)
            }
            "INTERNAL_HTTPS_LOAD_BALANCER" => {
                std::option::Option::Some(Self::INTERNAL_HTTPS_LOAD_BALANCER)
            }
            "SSL_PROXY_LOAD_BALANCER" => std::option::Option::Some(Self::SSL_PROXY_LOAD_BALANCER),
            "TCP_PROXY_LOAD_BALANCER" => std::option::Option::Some(Self::TCP_PROXY_LOAD_BALANCER),
            "INTERNAL_TCP_PROXY_LOAD_BALANCER" => {
                std::option::Option::Some(Self::INTERNAL_TCP_PROXY_LOAD_BALANCER)
            }
            "NETWORK_LOAD_BALANCER" => std::option::Option::Some(Self::NETWORK_LOAD_BALANCER),
            "LEGACY_NETWORK_LOAD_BALANCER" => {
                std::option::Option::Some(Self::LEGACY_NETWORK_LOAD_BALANCER)
            }
            "TCP_UDP_INTERNAL_LOAD_BALANCER" => {
                std::option::Option::Some(Self::TCP_UDP_INTERNAL_LOAD_BALANCER)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for LoadBalancerType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for LoadBalancerType {
    fn default() -> Self {
        Self::new(0)
    }
}
