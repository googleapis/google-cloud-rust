// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Connectivity Test for a network reachability analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectivityTest {
    /// Identifier. Unique name of the resource using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    pub name: std::string::String,

    /// The user-supplied description of the Connectivity Test.
    /// Maximum of 512 characters.
    pub description: std::string::String,

    /// Required. Source specification of the Connectivity Test.
    ///
    /// You can use a combination of source IP address, URI of a supported
    /// endpoint, project ID, or VPC network to identify the source location.
    ///
    /// Reachability analysis might proceed even if the source location is
    /// ambiguous. However, the test result might include endpoints or use a source
    /// that you don't intend to test.
    pub source: std::option::Option<crate::model::Endpoint>,

    /// Required. Destination specification of the Connectivity Test.
    ///
    /// You can use a combination of destination IP address, URI of a supported
    /// endpoint, project ID, or VPC network to identify the destination location.
    ///
    /// Reachability analysis proceeds even if the destination location is
    /// ambiguous. However, the test result might include endpoints or use a
    /// destination that you don't intend to test.
    pub destination: std::option::Option<crate::model::Endpoint>,

    /// IP Protocol of the test. When not provided, "TCP" is assumed.
    pub protocol: std::string::String,

    /// Other projects that may be relevant for reachability analysis.
    /// This is applicable to scenarios where a test can cross project boundaries.
    pub related_projects: std::vec::Vec<std::string::String>,

    /// Output only. The display name of a Connectivity Test.
    pub display_name: std::string::String,

    /// Resource labels to represent user-provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time the test was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the test's configuration was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The reachability details of this test from the latest run.
    /// The details are updated when creating a new test, updating an
    /// existing test, or triggering a one-time rerun of an existing test.
    pub reachability_details: std::option::Option<crate::model::ReachabilityDetails>,

    /// Output only. The probing details of this test from the latest run, present
    /// for applicable tests only. The details are updated when creating a new
    /// test, updating an existing test, or triggering a one-time rerun of an
    /// existing test.
    pub probing_details: std::option::Option<crate::model::ProbingDetails>,

    /// Whether run analysis for the return path from destination to source.
    /// Default value is false.
    pub round_trip: bool,

    /// Output only. The reachability details of this test from the latest run for
    /// the return path. The details are updated when creating a new test,
    /// updating an existing test, or triggering a one-time rerun of an existing
    /// test.
    pub return_reachability_details: std::option::Option<crate::model::ReachabilityDetails>,

    /// Whether the analysis should skip firewall checking. Default value is false.
    pub bypass_firewall_checks: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectivityTest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectivityTest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConnectivityTest::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ConnectivityTest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::ConnectivityTest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination][crate::model::ConnectivityTest::destination].
    pub fn set_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination][crate::model::ConnectivityTest::destination].
    pub fn set_or_clear_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Endpoint>,
    {
        self.destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [protocol][crate::model::ConnectivityTest::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [related_projects][crate::model::ConnectivityTest::related_projects].
    pub fn set_related_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectivityTest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ConnectivityTest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectivityTest::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectivityTest::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectivityTest::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectivityTest::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reachability_details][crate::model::ConnectivityTest::reachability_details].
    pub fn set_reachability_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReachabilityDetails>,
    {
        self.reachability_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reachability_details][crate::model::ConnectivityTest::reachability_details].
    pub fn set_or_clear_reachability_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReachabilityDetails>,
    {
        self.reachability_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [probing_details][crate::model::ConnectivityTest::probing_details].
    pub fn set_probing_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProbingDetails>,
    {
        self.probing_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [probing_details][crate::model::ConnectivityTest::probing_details].
    pub fn set_or_clear_probing_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProbingDetails>,
    {
        self.probing_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [round_trip][crate::model::ConnectivityTest::round_trip].
    pub fn set_round_trip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.round_trip = v.into();
        self
    }

    /// Sets the value of [return_reachability_details][crate::model::ConnectivityTest::return_reachability_details].
    pub fn set_return_reachability_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReachabilityDetails>,
    {
        self.return_reachability_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [return_reachability_details][crate::model::ConnectivityTest::return_reachability_details].
    pub fn set_or_clear_return_reachability_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReachabilityDetails>,
    {
        self.return_reachability_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bypass_firewall_checks][crate::model::ConnectivityTest::bypass_firewall_checks].
    pub fn set_bypass_firewall_checks<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.bypass_firewall_checks = v.into();
        self
    }
}

impl wkt::message::Message for ConnectivityTest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ConnectivityTest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectivityTest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __source,
            __destination,
            __protocol,
            __related_projects,
            __display_name,
            __labels,
            __create_time,
            __update_time,
            __reachability_details,
            __probing_details,
            __round_trip,
            __return_reachability_details,
            __bypass_firewall_checks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectivityTest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "source" => Ok(__FieldTag::__source),
                            "destination" => Ok(__FieldTag::__destination),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "relatedProjects" => Ok(__FieldTag::__related_projects),
                            "related_projects" => Ok(__FieldTag::__related_projects),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "reachabilityDetails" => Ok(__FieldTag::__reachability_details),
                            "reachability_details" => Ok(__FieldTag::__reachability_details),
                            "probingDetails" => Ok(__FieldTag::__probing_details),
                            "probing_details" => Ok(__FieldTag::__probing_details),
                            "roundTrip" => Ok(__FieldTag::__round_trip),
                            "round_trip" => Ok(__FieldTag::__round_trip),
                            "returnReachabilityDetails" => {
                                Ok(__FieldTag::__return_reachability_details)
                            }
                            "return_reachability_details" => {
                                Ok(__FieldTag::__return_reachability_details)
                            }
                            "bypassFirewallChecks" => Ok(__FieldTag::__bypass_firewall_checks),
                            "bypass_firewall_checks" => Ok(__FieldTag::__bypass_firewall_checks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectivityTest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectivityTest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Endpoint>>()?;
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination =
                                map.next_value::<std::option::Option<crate::model::Endpoint>>()?;
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_projects => {
                            if !fields.insert(__FieldTag::__related_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_projects",
                                ));
                            }
                            result.related_projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__reachability_details => {
                            if !fields.insert(__FieldTag::__reachability_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reachability_details",
                                ));
                            }
                            result.reachability_details = map.next_value::<std::option::Option<crate::model::ReachabilityDetails>>()?
                                ;
                        }
                        __FieldTag::__probing_details => {
                            if !fields.insert(__FieldTag::__probing_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for probing_details",
                                ));
                            }
                            result.probing_details = map
                                .next_value::<std::option::Option<crate::model::ProbingDetails>>(
                                )?;
                        }
                        __FieldTag::__round_trip => {
                            if !fields.insert(__FieldTag::__round_trip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for round_trip",
                                ));
                            }
                            result.round_trip = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_reachability_details => {
                            if !fields.insert(__FieldTag::__return_reachability_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_reachability_details",
                                ));
                            }
                            result.return_reachability_details = map.next_value::<std::option::Option<crate::model::ReachabilityDetails>>()?
                                ;
                        }
                        __FieldTag::__bypass_firewall_checks => {
                            if !fields.insert(__FieldTag::__bypass_firewall_checks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bypass_firewall_checks",
                                ));
                            }
                            result.bypass_firewall_checks = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectivityTest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.related_projects.is_empty() {
            state.serialize_entry("relatedProjects", &self.related_projects)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.reachability_details.is_some() {
            state.serialize_entry("reachabilityDetails", &self.reachability_details)?;
        }
        if self.probing_details.is_some() {
            state.serialize_entry("probingDetails", &self.probing_details)?;
        }
        if !wkt::internal::is_default(&self.round_trip) {
            state.serialize_entry("roundTrip", &self.round_trip)?;
        }
        if self.return_reachability_details.is_some() {
            state.serialize_entry(
                "returnReachabilityDetails",
                &self.return_reachability_details,
            )?;
        }
        if !wkt::internal::is_default(&self.bypass_firewall_checks) {
            state.serialize_entry("bypassFirewallChecks", &self.bypass_firewall_checks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectivityTest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectivityTest");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("source", &self.source);
        debug_struct.field("destination", &self.destination);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("related_projects", &self.related_projects);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("reachability_details", &self.reachability_details);
        debug_struct.field("probing_details", &self.probing_details);
        debug_struct.field("round_trip", &self.round_trip);
        debug_struct.field(
            "return_reachability_details",
            &self.return_reachability_details,
        );
        debug_struct.field("bypass_firewall_checks", &self.bypass_firewall_checks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Source or destination of the Connectivity Test.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Endpoint {
    /// The IP address of the endpoint, which can be an external or internal IP.
    pub ip_address: std::string::String,

    /// The IP protocol port of the endpoint.
    /// Only applicable when protocol is TCP or UDP.
    pub port: i32,

    /// A Compute Engine instance URI.
    pub instance: std::string::String,

    /// A forwarding rule and its corresponding IP address represent the frontend
    /// configuration of a Google Cloud load balancer. Forwarding rules are also
    /// used for protocol forwarding, Private Service Connect and other network
    /// services to provide forwarding information in the control plane. Applicable
    /// only to destination endpoint. Format:
    /// projects/{project}/global/forwardingRules/{id} or
    /// projects/{project}/regions/{region}/forwardingRules/{id}
    pub forwarding_rule: std::string::String,

    /// Output only. Specifies the type of the target of the forwarding rule.
    pub forwarding_rule_target: std::option::Option<crate::model::endpoint::ForwardingRuleTarget>,

    /// Output only. ID of the load balancer the forwarding rule points to. Empty
    /// for forwarding rules not related to load balancers.
    pub load_balancer_id: std::option::Option<std::string::String>,

    /// Output only. Type of the load balancer the forwarding rule points to.
    pub load_balancer_type: std::option::Option<crate::model::LoadBalancerType>,

    /// A cluster URI for [Google Kubernetes Engine cluster control
    /// plane](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
    pub gke_master_cluster: std::string::String,

    /// DNS endpoint of [Google Kubernetes Engine cluster control
    /// plane](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
    /// Requires gke_master_cluster to be set, can't be used simultaneoulsly with
    /// ip_address or network. Applicable only to destination endpoint.
    pub fqdn: std::string::String,

    /// A [Cloud SQL](https://cloud.google.com/sql) instance URI.
    pub cloud_sql_instance: std::string::String,

    /// A [Redis Instance](https://cloud.google.com/memorystore/docs/redis) URI.
    /// Applicable only to destination endpoint.
    pub redis_instance: std::string::String,

    /// A [Redis Cluster](https://cloud.google.com/memorystore/docs/cluster) URI.
    /// Applicable only to destination endpoint.
    pub redis_cluster: std::string::String,

    /// A [Cloud Function](https://cloud.google.com/functions). Applicable only to
    /// source endpoint.
    pub cloud_function: std::option::Option<crate::model::endpoint::CloudFunctionEndpoint>,

    /// An [App Engine](https://cloud.google.com/appengine) [service
    /// version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions).
    /// Applicable only to source endpoint.
    pub app_engine_version: std::option::Option<crate::model::endpoint::AppEngineVersionEndpoint>,

    /// A [Cloud Run](https://cloud.google.com/run)
    /// [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
    /// Applicable only to source endpoint.
    pub cloud_run_revision: std::option::Option<crate::model::endpoint::CloudRunRevisionEndpoint>,

    /// A VPC network URI.
    pub network: std::string::String,

    /// Type of the network where the endpoint is located.
    /// Applicable only to source endpoint, as destination network type can be
    /// inferred from the source.
    pub network_type: crate::model::endpoint::NetworkType,

    /// Project ID where the endpoint is located.
    /// The project ID can be derived from the URI if you provide a endpoint or
    /// network URI.
    /// The following are two cases where you may need to provide the project ID:
    ///
    /// 1. Only the IP address is specified, and the IP address is within a Google
    ///    Cloud project.
    /// 1. When you are using Shared VPC and the IP address that you provide is
    ///    from the service project. In this case, the network that the IP address
    ///    resides in is defined in the host project.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Endpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_address][crate::model::Endpoint::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::Endpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::Endpoint::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::Endpoint::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [forwarding_rule_target][crate::model::Endpoint::forwarding_rule_target].
    pub fn set_forwarding_rule_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::ForwardingRuleTarget>,
    {
        self.forwarding_rule_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [forwarding_rule_target][crate::model::Endpoint::forwarding_rule_target].
    pub fn set_or_clear_forwarding_rule_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::ForwardingRuleTarget>,
    {
        self.forwarding_rule_target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [load_balancer_id][crate::model::Endpoint::load_balancer_id].
    pub fn set_load_balancer_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.load_balancer_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [load_balancer_id][crate::model::Endpoint::load_balancer_id].
    pub fn set_or_clear_load_balancer_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.load_balancer_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [load_balancer_type][crate::model::Endpoint::load_balancer_type].
    pub fn set_load_balancer_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoadBalancerType>,
    {
        self.load_balancer_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [load_balancer_type][crate::model::Endpoint::load_balancer_type].
    pub fn set_or_clear_load_balancer_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoadBalancerType>,
    {
        self.load_balancer_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gke_master_cluster][crate::model::Endpoint::gke_master_cluster].
    pub fn set_gke_master_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gke_master_cluster = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Endpoint::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [cloud_sql_instance][crate::model::Endpoint::cloud_sql_instance].
    pub fn set_cloud_sql_instance<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_sql_instance = v.into();
        self
    }

    /// Sets the value of [redis_instance][crate::model::Endpoint::redis_instance].
    pub fn set_redis_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redis_instance = v.into();
        self
    }

    /// Sets the value of [redis_cluster][crate::model::Endpoint::redis_cluster].
    pub fn set_redis_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redis_cluster = v.into();
        self
    }

    /// Sets the value of [cloud_function][crate::model::Endpoint::cloud_function].
    pub fn set_cloud_function<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::CloudFunctionEndpoint>,
    {
        self.cloud_function = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_function][crate::model::Endpoint::cloud_function].
    pub fn set_or_clear_cloud_function<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::CloudFunctionEndpoint>,
    {
        self.cloud_function = v.map(|x| x.into());
        self
    }

    /// Sets the value of [app_engine_version][crate::model::Endpoint::app_engine_version].
    pub fn set_app_engine_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::AppEngineVersionEndpoint>,
    {
        self.app_engine_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_engine_version][crate::model::Endpoint::app_engine_version].
    pub fn set_or_clear_app_engine_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::AppEngineVersionEndpoint>,
    {
        self.app_engine_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_run_revision][crate::model::Endpoint::cloud_run_revision].
    pub fn set_cloud_run_revision<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::CloudRunRevisionEndpoint>,
    {
        self.cloud_run_revision = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run_revision][crate::model::Endpoint::cloud_run_revision].
    pub fn set_or_clear_cloud_run_revision<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::endpoint::CloudRunRevisionEndpoint>,
    {
        self.cloud_run_revision = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::Endpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [network_type][crate::model::Endpoint::network_type].
    pub fn set_network_type<T: std::convert::Into<crate::model::endpoint::NetworkType>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_type = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Endpoint::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for Endpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Endpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_address,
            __port,
            __instance,
            __forwarding_rule,
            __forwarding_rule_target,
            __load_balancer_id,
            __load_balancer_type,
            __gke_master_cluster,
            __fqdn,
            __cloud_sql_instance,
            __redis_instance,
            __redis_cluster,
            __cloud_function,
            __app_engine_version,
            __cloud_run_revision,
            __network,
            __network_type,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Endpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "port" => Ok(__FieldTag::__port),
                            "instance" => Ok(__FieldTag::__instance),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "forwardingRuleTarget" => Ok(__FieldTag::__forwarding_rule_target),
                            "forwarding_rule_target" => Ok(__FieldTag::__forwarding_rule_target),
                            "loadBalancerId" => Ok(__FieldTag::__load_balancer_id),
                            "load_balancer_id" => Ok(__FieldTag::__load_balancer_id),
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            "gkeMasterCluster" => Ok(__FieldTag::__gke_master_cluster),
                            "gke_master_cluster" => Ok(__FieldTag::__gke_master_cluster),
                            "fqdn" => Ok(__FieldTag::__fqdn),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "redisInstance" => Ok(__FieldTag::__redis_instance),
                            "redis_instance" => Ok(__FieldTag::__redis_instance),
                            "redisCluster" => Ok(__FieldTag::__redis_cluster),
                            "redis_cluster" => Ok(__FieldTag::__redis_cluster),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "appEngineVersion" => Ok(__FieldTag::__app_engine_version),
                            "app_engine_version" => Ok(__FieldTag::__app_engine_version),
                            "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                            "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                            "network" => Ok(__FieldTag::__network),
                            "networkType" => Ok(__FieldTag::__network_type),
                            "network_type" => Ok(__FieldTag::__network_type),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Endpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Endpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule",
                                ));
                            }
                            result.forwarding_rule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__forwarding_rule_target => {
                            if !fields.insert(__FieldTag::__forwarding_rule_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule_target",
                                ));
                            }
                            result.forwarding_rule_target =
                                map.next_value::<std::option::Option<
                                    crate::model::endpoint::ForwardingRuleTarget,
                                >>()?;
                        }
                        __FieldTag::__load_balancer_id => {
                            if !fields.insert(__FieldTag::__load_balancer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_id",
                                ));
                            }
                            result.load_balancer_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map
                                .next_value::<std::option::Option<crate::model::LoadBalancerType>>(
                                )?;
                        }
                        __FieldTag::__gke_master_cluster => {
                            if !fields.insert(__FieldTag::__gke_master_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_master_cluster",
                                ));
                            }
                            result.gke_master_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fqdn => {
                            if !fields.insert(__FieldTag::__fqdn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fqdn",
                                ));
                            }
                            result.fqdn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_instance",
                                ));
                            }
                            result.cloud_sql_instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redis_instance => {
                            if !fields.insert(__FieldTag::__redis_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_instance",
                                ));
                            }
                            result.redis_instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redis_cluster => {
                            if !fields.insert(__FieldTag::__redis_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_cluster",
                                ));
                            }
                            result.redis_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_function",
                                ));
                            }
                            result.cloud_function = map.next_value::<std::option::Option<
                                crate::model::endpoint::CloudFunctionEndpoint,
                            >>()?;
                        }
                        __FieldTag::__app_engine_version => {
                            if !fields.insert(__FieldTag::__app_engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_version",
                                ));
                            }
                            result.app_engine_version = map.next_value::<std::option::Option<
                                crate::model::endpoint::AppEngineVersionEndpoint,
                            >>()?;
                        }
                        __FieldTag::__cloud_run_revision => {
                            if !fields.insert(__FieldTag::__cloud_run_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run_revision",
                                ));
                            }
                            result.cloud_run_revision = map.next_value::<std::option::Option<
                                crate::model::endpoint::CloudRunRevisionEndpoint,
                            >>()?;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_type => {
                            if !fields.insert(__FieldTag::__network_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_type",
                                ));
                            }
                            result.network_type = map.next_value::<std::option::Option<crate::model::endpoint::NetworkType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Endpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.forwarding_rule.is_empty() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if self.forwarding_rule_target.is_some() {
            state.serialize_entry("forwardingRuleTarget", &self.forwarding_rule_target)?;
        }
        if self.load_balancer_id.is_some() {
            state.serialize_entry("loadBalancerId", &self.load_balancer_id)?;
        }
        if self.load_balancer_type.is_some() {
            state.serialize_entry("loadBalancerType", &self.load_balancer_type)?;
        }
        if !self.gke_master_cluster.is_empty() {
            state.serialize_entry("gkeMasterCluster", &self.gke_master_cluster)?;
        }
        if !self.fqdn.is_empty() {
            state.serialize_entry("fqdn", &self.fqdn)?;
        }
        if !self.cloud_sql_instance.is_empty() {
            state.serialize_entry("cloudSqlInstance", &self.cloud_sql_instance)?;
        }
        if !self.redis_instance.is_empty() {
            state.serialize_entry("redisInstance", &self.redis_instance)?;
        }
        if !self.redis_cluster.is_empty() {
            state.serialize_entry("redisCluster", &self.redis_cluster)?;
        }
        if self.cloud_function.is_some() {
            state.serialize_entry("cloudFunction", &self.cloud_function)?;
        }
        if self.app_engine_version.is_some() {
            state.serialize_entry("appEngineVersion", &self.app_engine_version)?;
        }
        if self.cloud_run_revision.is_some() {
            state.serialize_entry("cloudRunRevision", &self.cloud_run_revision)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !wkt::internal::is_default(&self.network_type) {
            state.serialize_entry("networkType", &self.network_type)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Endpoint");
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("port", &self.port);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("forwarding_rule", &self.forwarding_rule);
        debug_struct.field("forwarding_rule_target", &self.forwarding_rule_target);
        debug_struct.field("load_balancer_id", &self.load_balancer_id);
        debug_struct.field("load_balancer_type", &self.load_balancer_type);
        debug_struct.field("gke_master_cluster", &self.gke_master_cluster);
        debug_struct.field("fqdn", &self.fqdn);
        debug_struct.field("cloud_sql_instance", &self.cloud_sql_instance);
        debug_struct.field("redis_instance", &self.redis_instance);
        debug_struct.field("redis_cluster", &self.redis_cluster);
        debug_struct.field("cloud_function", &self.cloud_function);
        debug_struct.field("app_engine_version", &self.app_engine_version);
        debug_struct.field("cloud_run_revision", &self.cloud_run_revision);
        debug_struct.field("network", &self.network);
        debug_struct.field("network_type", &self.network_type);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Endpoint].
pub mod endpoint {
    #[allow(unused_imports)]
    use super::*;

    /// Wrapper for Cloud Function attributes.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudFunctionEndpoint {
        /// A [Cloud Function](https://cloud.google.com/functions) name.
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudFunctionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::endpoint::CloudFunctionEndpoint::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudFunctionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint.CloudFunctionEndpoint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudFunctionEndpoint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudFunctionEndpoint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudFunctionEndpoint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudFunctionEndpoint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudFunctionEndpoint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CloudFunctionEndpoint {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CloudFunctionEndpoint");
            debug_struct.field("uri", &self.uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Wrapper for the App Engine service version attributes.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AppEngineVersionEndpoint {
        /// An [App Engine](https://cloud.google.com/appengine) [service
        /// version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions)
        /// name.
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AppEngineVersionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::endpoint::AppEngineVersionEndpoint::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for AppEngineVersionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint.AppEngineVersionEndpoint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AppEngineVersionEndpoint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AppEngineVersionEndpoint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AppEngineVersionEndpoint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AppEngineVersionEndpoint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AppEngineVersionEndpoint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AppEngineVersionEndpoint {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AppEngineVersionEndpoint");
            debug_struct.field("uri", &self.uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Wrapper for Cloud Run revision attributes.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudRunRevisionEndpoint {
        /// A [Cloud Run](https://cloud.google.com/run)
        /// [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
        /// URI. The format is:
        /// projects/{project}/locations/{location}/revisions/{revision}
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudRunRevisionEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::endpoint::CloudRunRevisionEndpoint::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CloudRunRevisionEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.Endpoint.CloudRunRevisionEndpoint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudRunRevisionEndpoint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudRunRevisionEndpoint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudRunRevisionEndpoint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudRunRevisionEndpoint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudRunRevisionEndpoint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CloudRunRevisionEndpoint {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CloudRunRevisionEndpoint");
            debug_struct.field("uri", &self.uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The type definition of an endpoint's network. Use one of the
    /// following choices:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkType {
        /// Default type if unspecified.
        Unspecified,
        /// A network hosted within Google Cloud.
        /// To receive more detailed output, specify the URI for the source or
        /// destination network.
        GcpNetwork,
        /// A network hosted outside of Google Cloud.
        /// This can be an on-premises network, an internet resource or a network
        /// hosted by another cloud provider.
        NonGcpNetwork,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkType::value] or
        /// [NetworkType::name].
        UnknownValue(network_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GcpNetwork => std::option::Option::Some(1),
                Self::NonGcpNetwork => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NETWORK_TYPE_UNSPECIFIED"),
                Self::GcpNetwork => std::option::Option::Some("GCP_NETWORK"),
                Self::NonGcpNetwork => std::option::Option::Some("NON_GCP_NETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GcpNetwork,
                2 => Self::NonGcpNetwork,
                _ => Self::UnknownValue(network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GCP_NETWORK" => Self::GcpNetwork,
                "NON_GCP_NETWORK" => Self::NonGcpNetwork,
                _ => Self::UnknownValue(network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GcpNetwork => serializer.serialize_i32(1),
                Self::NonGcpNetwork => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkType>::new(
                ".google.cloud.networkmanagement.v1.Endpoint.NetworkType",
            ))
        }
    }

    /// Type of the target of a forwarding rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ForwardingRuleTarget {
        /// Forwarding rule target is unknown.
        Unspecified,
        /// Compute Engine instance for protocol forwarding.
        Instance,
        /// Load Balancer. The specific type can be found from [load_balancer_type]
        /// [google.cloud.networkmanagement.v1.Endpoint.load_balancer_type].
        LoadBalancer,
        /// Classic Cloud VPN Gateway.
        VpnGateway,
        /// Forwarding Rule is a Private Service Connect endpoint.
        Psc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ForwardingRuleTarget::value] or
        /// [ForwardingRuleTarget::name].
        UnknownValue(forwarding_rule_target::UnknownValue),
    }

    #[doc(hidden)]
    pub mod forwarding_rule_target {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ForwardingRuleTarget {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Instance => std::option::Option::Some(1),
                Self::LoadBalancer => std::option::Option::Some(2),
                Self::VpnGateway => std::option::Option::Some(3),
                Self::Psc => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("FORWARDING_RULE_TARGET_UNSPECIFIED")
                }
                Self::Instance => std::option::Option::Some("INSTANCE"),
                Self::LoadBalancer => std::option::Option::Some("LOAD_BALANCER"),
                Self::VpnGateway => std::option::Option::Some("VPN_GATEWAY"),
                Self::Psc => std::option::Option::Some("PSC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ForwardingRuleTarget {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ForwardingRuleTarget {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ForwardingRuleTarget {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Instance,
                2 => Self::LoadBalancer,
                3 => Self::VpnGateway,
                4 => Self::Psc,
                _ => Self::UnknownValue(forwarding_rule_target::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ForwardingRuleTarget {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORWARDING_RULE_TARGET_UNSPECIFIED" => Self::Unspecified,
                "INSTANCE" => Self::Instance,
                "LOAD_BALANCER" => Self::LoadBalancer,
                "VPN_GATEWAY" => Self::VpnGateway,
                "PSC" => Self::Psc,
                _ => Self::UnknownValue(forwarding_rule_target::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ForwardingRuleTarget {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Instance => serializer.serialize_i32(1),
                Self::LoadBalancer => serializer.serialize_i32(2),
                Self::VpnGateway => serializer.serialize_i32(3),
                Self::Psc => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ForwardingRuleTarget {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ForwardingRuleTarget>::new(
                ".google.cloud.networkmanagement.v1.Endpoint.ForwardingRuleTarget",
            ))
        }
    }
}

/// Results of the configuration analysis from the last run of the test.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReachabilityDetails {
    /// The overall result of the test's configuration analysis.
    pub result: crate::model::reachability_details::Result,

    /// The time of the configuration analysis.
    pub verify_time: std::option::Option<wkt::Timestamp>,

    /// The details of a failure or a cancellation of reachability analysis.
    pub error: std::option::Option<rpc::model::Status>,

    /// Result may contain a list of traces if a test has multiple possible
    /// paths in the network, such as when destination endpoint is a load balancer
    /// with multiple backends.
    pub traces: std::vec::Vec<crate::model::Trace>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReachabilityDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ReachabilityDetails::result].
    pub fn set_result<T: std::convert::Into<crate::model::reachability_details::Result>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [verify_time][crate::model::ReachabilityDetails::verify_time].
    pub fn set_verify_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.verify_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_time][crate::model::ReachabilityDetails::verify_time].
    pub fn set_or_clear_verify_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.verify_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::ReachabilityDetails::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ReachabilityDetails::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [traces][crate::model::ReachabilityDetails::traces].
    pub fn set_traces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trace>,
    {
        use std::iter::Iterator;
        self.traces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReachabilityDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ReachabilityDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReachabilityDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __verify_time,
            __error,
            __traces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReachabilityDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "verifyTime" => Ok(__FieldTag::__verify_time),
                            "verify_time" => Ok(__FieldTag::__verify_time),
                            "error" => Ok(__FieldTag::__error),
                            "traces" => Ok(__FieldTag::__traces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReachabilityDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReachabilityDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::reachability_details::Result>>()?.unwrap_or_default();
                        }
                        __FieldTag::__verify_time => {
                            if !fields.insert(__FieldTag::__verify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_time",
                                ));
                            }
                            result.verify_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__traces => {
                            if !fields.insert(__FieldTag::__traces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traces",
                                ));
                            }
                            result.traces = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Trace>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReachabilityDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if self.verify_time.is_some() {
            state.serialize_entry("verifyTime", &self.verify_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.traces.is_empty() {
            state.serialize_entry("traces", &self.traces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReachabilityDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReachabilityDetails");
        debug_struct.field("result", &self.result);
        debug_struct.field("verify_time", &self.verify_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("traces", &self.traces);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReachabilityDetails].
pub mod reachability_details {
    #[allow(unused_imports)]
    use super::*;

    /// The overall result of the test's configuration analysis.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// No result was specified.
        Unspecified,
        /// Possible scenarios are:
        ///
        /// * The configuration analysis determined that a packet originating from
        ///   the source is expected to reach the destination.
        /// * The analysis didn't complete because the user lacks permission for
        ///   some of the resources in the trace. However, at the time the user's
        ///   permission became insufficient, the trace had been successful so far.
        Reachable,
        /// A packet originating from the source is expected to be dropped before
        /// reaching the destination.
        Unreachable,
        /// The source and destination endpoints do not uniquely identify
        /// the test location in the network, and the reachability result contains
        /// multiple traces. For some traces, a packet could be delivered, and for
        /// others, it would not be. This result is also assigned to
        /// configuration analysis of return path if on its own it should be
        /// REACHABLE, but configuration analysis of forward path is AMBIGUOUS.
        Ambiguous,
        /// The configuration analysis did not complete. Possible reasons are:
        ///
        /// * A permissions error occurred--for example, the user might not have
        ///   read permission for all of the resources named in the test.
        /// * An internal error occurred.
        /// * The analyzer received an invalid or unsupported argument or was unable
        ///   to identify a known endpoint.
        Undetermined,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Reachable => std::option::Option::Some(1),
                Self::Unreachable => std::option::Option::Some(2),
                Self::Ambiguous => std::option::Option::Some(4),
                Self::Undetermined => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::Reachable => std::option::Option::Some("REACHABLE"),
                Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                Self::Ambiguous => std::option::Option::Some("AMBIGUOUS"),
                Self::Undetermined => std::option::Option::Some("UNDETERMINED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Reachable,
                2 => Self::Unreachable,
                4 => Self::Ambiguous,
                5 => Self::Undetermined,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "REACHABLE" => Self::Reachable,
                "UNREACHABLE" => Self::Unreachable,
                "AMBIGUOUS" => Self::Ambiguous,
                "UNDETERMINED" => Self::Undetermined,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Reachable => serializer.serialize_i32(1),
                Self::Unreachable => serializer.serialize_i32(2),
                Self::Ambiguous => serializer.serialize_i32(4),
                Self::Undetermined => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.cloud.networkmanagement.v1.ReachabilityDetails.Result",
            ))
        }
    }
}

/// Latency percentile rank and value.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LatencyPercentile {
    /// Percentage of samples this data point applies to.
    pub percent: i32,

    /// percent-th percentile of latency observed, in microseconds.
    /// Fraction of percent/100 of samples have latency lower or
    /// equal to the value of this field.
    pub latency_micros: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LatencyPercentile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [percent][crate::model::LatencyPercentile::percent].
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.percent = v.into();
        self
    }

    /// Sets the value of [latency_micros][crate::model::LatencyPercentile::latency_micros].
    pub fn set_latency_micros<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.latency_micros = v.into();
        self
    }
}

impl wkt::message::Message for LatencyPercentile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LatencyPercentile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LatencyPercentile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __percent,
            __latency_micros,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatencyPercentile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "percent" => Ok(__FieldTag::__percent),
                            "latencyMicros" => Ok(__FieldTag::__latency_micros),
                            "latency_micros" => Ok(__FieldTag::__latency_micros),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LatencyPercentile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatencyPercentile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__latency_micros => {
                            if !fields.insert(__FieldTag::__latency_micros) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latency_micros",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.latency_micros =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LatencyPercentile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percent", &__With(&self.percent))?;
        }
        if !wkt::internal::is_default(&self.latency_micros) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("latencyMicros", &__With(&self.latency_micros))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LatencyPercentile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LatencyPercentile");
        debug_struct.field("percent", &self.percent);
        debug_struct.field("latency_micros", &self.latency_micros);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes measured latency distribution.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LatencyDistribution {
    /// Representative latency percentiles.
    pub latency_percentiles: std::vec::Vec<crate::model::LatencyPercentile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LatencyDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [latency_percentiles][crate::model::LatencyDistribution::latency_percentiles].
    pub fn set_latency_percentiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LatencyPercentile>,
    {
        use std::iter::Iterator;
        self.latency_percentiles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LatencyDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LatencyDistribution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LatencyDistribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __latency_percentiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatencyDistribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latencyPercentiles" => Ok(__FieldTag::__latency_percentiles),
                            "latency_percentiles" => Ok(__FieldTag::__latency_percentiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LatencyDistribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatencyDistribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__latency_percentiles => {
                            if !fields.insert(__FieldTag::__latency_percentiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latency_percentiles",
                                ));
                            }
                            result.latency_percentiles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LatencyPercentile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LatencyDistribution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.latency_percentiles.is_empty() {
            state.serialize_entry("latencyPercentiles", &self.latency_percentiles)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LatencyDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LatencyDistribution");
        debug_struct.field("latency_percentiles", &self.latency_percentiles);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Results of active probing from the last run of the test.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProbingDetails {
    /// The overall result of active probing.
    pub result: crate::model::probing_details::ProbingResult,

    /// The time that reachability was assessed through active probing.
    pub verify_time: std::option::Option<wkt::Timestamp>,

    /// Details about an internal failure or the cancellation of active probing.
    pub error: std::option::Option<rpc::model::Status>,

    /// The reason probing was aborted.
    pub abort_cause: crate::model::probing_details::ProbingAbortCause,

    /// Number of probes sent.
    pub sent_probe_count: i32,

    /// Number of probes that reached the destination.
    pub successful_probe_count: i32,

    /// The source and destination endpoints derived from the test input and used
    /// for active probing.
    pub endpoint_info: std::option::Option<crate::model::EndpointInfo>,

    /// Latency as measured by active probing in one direction:
    /// from the source to the destination endpoint.
    pub probing_latency: std::option::Option<crate::model::LatencyDistribution>,

    /// The EdgeLocation from which a packet destined for/originating from the
    /// internet will egress/ingress the Google network.
    /// This will only be populated for a connectivity test which has an internet
    /// destination/source address.
    /// The absence of this field *must not* be used as an indication that the
    /// destination/source is part of the Google network.
    pub destination_egress_location:
        std::option::Option<crate::model::probing_details::EdgeLocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProbingDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ProbingDetails::result].
    pub fn set_result<T: std::convert::Into<crate::model::probing_details::ProbingResult>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [verify_time][crate::model::ProbingDetails::verify_time].
    pub fn set_verify_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.verify_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_time][crate::model::ProbingDetails::verify_time].
    pub fn set_or_clear_verify_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.verify_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::ProbingDetails::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ProbingDetails::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [abort_cause][crate::model::ProbingDetails::abort_cause].
    pub fn set_abort_cause<
        T: std::convert::Into<crate::model::probing_details::ProbingAbortCause>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.abort_cause = v.into();
        self
    }

    /// Sets the value of [sent_probe_count][crate::model::ProbingDetails::sent_probe_count].
    pub fn set_sent_probe_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sent_probe_count = v.into();
        self
    }

    /// Sets the value of [successful_probe_count][crate::model::ProbingDetails::successful_probe_count].
    pub fn set_successful_probe_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.successful_probe_count = v.into();
        self
    }

    /// Sets the value of [endpoint_info][crate::model::ProbingDetails::endpoint_info].
    pub fn set_endpoint_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EndpointInfo>,
    {
        self.endpoint_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoint_info][crate::model::ProbingDetails::endpoint_info].
    pub fn set_or_clear_endpoint_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EndpointInfo>,
    {
        self.endpoint_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [probing_latency][crate::model::ProbingDetails::probing_latency].
    pub fn set_probing_latency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LatencyDistribution>,
    {
        self.probing_latency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [probing_latency][crate::model::ProbingDetails::probing_latency].
    pub fn set_or_clear_probing_latency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LatencyDistribution>,
    {
        self.probing_latency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_egress_location][crate::model::ProbingDetails::destination_egress_location].
    pub fn set_destination_egress_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::probing_details::EdgeLocation>,
    {
        self.destination_egress_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination_egress_location][crate::model::ProbingDetails::destination_egress_location].
    pub fn set_or_clear_destination_egress_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::probing_details::EdgeLocation>,
    {
        self.destination_egress_location = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProbingDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ProbingDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProbingDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __verify_time,
            __error,
            __abort_cause,
            __sent_probe_count,
            __successful_probe_count,
            __endpoint_info,
            __probing_latency,
            __destination_egress_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProbingDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "verifyTime" => Ok(__FieldTag::__verify_time),
                            "verify_time" => Ok(__FieldTag::__verify_time),
                            "error" => Ok(__FieldTag::__error),
                            "abortCause" => Ok(__FieldTag::__abort_cause),
                            "abort_cause" => Ok(__FieldTag::__abort_cause),
                            "sentProbeCount" => Ok(__FieldTag::__sent_probe_count),
                            "sent_probe_count" => Ok(__FieldTag::__sent_probe_count),
                            "successfulProbeCount" => Ok(__FieldTag::__successful_probe_count),
                            "successful_probe_count" => Ok(__FieldTag::__successful_probe_count),
                            "endpointInfo" => Ok(__FieldTag::__endpoint_info),
                            "endpoint_info" => Ok(__FieldTag::__endpoint_info),
                            "probingLatency" => Ok(__FieldTag::__probing_latency),
                            "probing_latency" => Ok(__FieldTag::__probing_latency),
                            "destinationEgressLocation" => {
                                Ok(__FieldTag::__destination_egress_location)
                            }
                            "destination_egress_location" => {
                                Ok(__FieldTag::__destination_egress_location)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProbingDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProbingDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result =
                                map.next_value::<std::option::Option<
                                    crate::model::probing_details::ProbingResult,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verify_time => {
                            if !fields.insert(__FieldTag::__verify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_time",
                                ));
                            }
                            result.verify_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__abort_cause => {
                            if !fields.insert(__FieldTag::__abort_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abort_cause",
                                ));
                            }
                            result.abort_cause = map
                                .next_value::<std::option::Option<
                                    crate::model::probing_details::ProbingAbortCause,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sent_probe_count => {
                            if !fields.insert(__FieldTag::__sent_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sent_probe_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sent_probe_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__successful_probe_count => {
                            if !fields.insert(__FieldTag::__successful_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for successful_probe_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.successful_probe_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__endpoint_info => {
                            if !fields.insert(__FieldTag::__endpoint_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_info",
                                ));
                            }
                            result.endpoint_info = map
                                .next_value::<std::option::Option<crate::model::EndpointInfo>>()?;
                        }
                        __FieldTag::__probing_latency => {
                            if !fields.insert(__FieldTag::__probing_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for probing_latency",
                                ));
                            }
                            result.probing_latency = map.next_value::<std::option::Option<crate::model::LatencyDistribution>>()?
                                ;
                        }
                        __FieldTag::__destination_egress_location => {
                            if !fields.insert(__FieldTag::__destination_egress_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_egress_location",
                                ));
                            }
                            result.destination_egress_location =
                                map.next_value::<std::option::Option<
                                    crate::model::probing_details::EdgeLocation,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProbingDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if self.verify_time.is_some() {
            state.serialize_entry("verifyTime", &self.verify_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !wkt::internal::is_default(&self.abort_cause) {
            state.serialize_entry("abortCause", &self.abort_cause)?;
        }
        if !wkt::internal::is_default(&self.sent_probe_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sentProbeCount", &__With(&self.sent_probe_count))?;
        }
        if !wkt::internal::is_default(&self.successful_probe_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "successfulProbeCount",
                &__With(&self.successful_probe_count),
            )?;
        }
        if self.endpoint_info.is_some() {
            state.serialize_entry("endpointInfo", &self.endpoint_info)?;
        }
        if self.probing_latency.is_some() {
            state.serialize_entry("probingLatency", &self.probing_latency)?;
        }
        if self.destination_egress_location.is_some() {
            state.serialize_entry(
                "destinationEgressLocation",
                &self.destination_egress_location,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProbingDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProbingDetails");
        debug_struct.field("result", &self.result);
        debug_struct.field("verify_time", &self.verify_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("abort_cause", &self.abort_cause);
        debug_struct.field("sent_probe_count", &self.sent_probe_count);
        debug_struct.field("successful_probe_count", &self.successful_probe_count);
        debug_struct.field("endpoint_info", &self.endpoint_info);
        debug_struct.field("probing_latency", &self.probing_latency);
        debug_struct.field(
            "destination_egress_location",
            &self.destination_egress_location,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProbingDetails].
pub mod probing_details {
    #[allow(unused_imports)]
    use super::*;

    /// Representation of a network edge location as per
    /// <https://cloud.google.com/vpc/docs/edge-locations>.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EdgeLocation {
        /// Name of the metropolitan area.
        pub metropolitan_area: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EdgeLocation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metropolitan_area][crate::model::probing_details::EdgeLocation::metropolitan_area].
        pub fn set_metropolitan_area<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.metropolitan_area = v.into();
            self
        }
    }

    impl wkt::message::Message for EdgeLocation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.networkmanagement.v1.ProbingDetails.EdgeLocation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EdgeLocation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __metropolitan_area,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EdgeLocation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "metropolitanArea" => Ok(__FieldTag::__metropolitan_area),
                                "metropolitan_area" => Ok(__FieldTag::__metropolitan_area),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EdgeLocation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EdgeLocation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__metropolitan_area => {
                                if !fields.insert(__FieldTag::__metropolitan_area) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metropolitan_area",
                                    ));
                                }
                                result.metropolitan_area = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EdgeLocation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.metropolitan_area.is_empty() {
                state.serialize_entry("metropolitanArea", &self.metropolitan_area)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for EdgeLocation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("EdgeLocation");
            debug_struct.field("metropolitan_area", &self.metropolitan_area);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Overall probing result of the test.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProbingResult {
        /// No result was specified.
        Unspecified,
        /// At least 95% of packets reached the destination.
        Reachable,
        /// No packets reached the destination.
        Unreachable,
        /// Less than 95% of packets reached the destination.
        ReachabilityInconsistent,
        /// Reachability could not be determined. Possible reasons are:
        ///
        /// * The user lacks permission to access some of the network resources
        ///   required to run the test.
        /// * No valid source endpoint could be derived from the request.
        /// * An internal error occurred.
        Undetermined,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProbingResult::value] or
        /// [ProbingResult::name].
        UnknownValue(probing_result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod probing_result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProbingResult {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Reachable => std::option::Option::Some(1),
                Self::Unreachable => std::option::Option::Some(2),
                Self::ReachabilityInconsistent => std::option::Option::Some(3),
                Self::Undetermined => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROBING_RESULT_UNSPECIFIED"),
                Self::Reachable => std::option::Option::Some("REACHABLE"),
                Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                Self::ReachabilityInconsistent => {
                    std::option::Option::Some("REACHABILITY_INCONSISTENT")
                }
                Self::Undetermined => std::option::Option::Some("UNDETERMINED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProbingResult {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProbingResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProbingResult {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Reachable,
                2 => Self::Unreachable,
                3 => Self::ReachabilityInconsistent,
                4 => Self::Undetermined,
                _ => Self::UnknownValue(probing_result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProbingResult {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROBING_RESULT_UNSPECIFIED" => Self::Unspecified,
                "REACHABLE" => Self::Reachable,
                "UNREACHABLE" => Self::Unreachable,
                "REACHABILITY_INCONSISTENT" => Self::ReachabilityInconsistent,
                "UNDETERMINED" => Self::Undetermined,
                _ => Self::UnknownValue(probing_result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProbingResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Reachable => serializer.serialize_i32(1),
                Self::Unreachable => serializer.serialize_i32(2),
                Self::ReachabilityInconsistent => serializer.serialize_i32(3),
                Self::Undetermined => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProbingResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProbingResult>::new(
                ".google.cloud.networkmanagement.v1.ProbingDetails.ProbingResult",
            ))
        }
    }

    /// Abort cause types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProbingAbortCause {
        /// No reason was specified.
        Unspecified,
        /// The user lacks permission to access some of the
        /// network resources required to run the test.
        PermissionDenied,
        /// No valid source endpoint could be derived from the request.
        NoSourceLocation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProbingAbortCause::value] or
        /// [ProbingAbortCause::name].
        UnknownValue(probing_abort_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod probing_abort_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProbingAbortCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PermissionDenied => std::option::Option::Some(1),
                Self::NoSourceLocation => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROBING_ABORT_CAUSE_UNSPECIFIED"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::NoSourceLocation => std::option::Option::Some("NO_SOURCE_LOCATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProbingAbortCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProbingAbortCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProbingAbortCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PermissionDenied,
                2 => Self::NoSourceLocation,
                _ => Self::UnknownValue(probing_abort_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProbingAbortCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROBING_ABORT_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "NO_SOURCE_LOCATION" => Self::NoSourceLocation,
                _ => Self::UnknownValue(probing_abort_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProbingAbortCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PermissionDenied => serializer.serialize_i32(1),
                Self::NoSourceLocation => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProbingAbortCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProbingAbortCause>::new(
                ".google.cloud.networkmanagement.v1.ProbingDetails.ProbingAbortCause",
            ))
        }
    }
}

/// Request for the `ListConnectivityTests` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectivityTestsRequest {
    /// Required. The parent resource of the Connectivity Tests:
    /// `projects/{project_id}/locations/global`
    pub parent: std::string::String,

    /// Number of `ConnectivityTests` to return.
    pub page_size: i32,

    /// Page token from an earlier query, as returned in `next_page_token`.
    pub page_token: std::string::String,

    /// Lists the `ConnectivityTests` that match the filter expression. A filter
    /// expression filters the resources listed in the response. The expression
    /// must be of the form `<field> <operator> <value>` where operators: `<`, `>`,
    /// `<=`,
    /// `>=`,
    /// `!=`, `=`, `:` are supported (colon `:` represents a HAS operator which is
    /// roughly synonymous with equality). \<field\> can refer to a proto or JSON
    /// field, or a synthetic field. Field names can be camelCase or snake_case.
    ///
    /// Examples:
    ///
    /// - Filter by name:
    ///   name = "projects/proj-1/locations/global/connectivityTests/test-1
    ///
    /// - Filter by labels:
    ///
    ///   - Resources that have a key called `foo`
    ///     labels.foo:*
    ///   - Resources that have a key called `foo` whose value is `bar`
    ///     labels.foo = bar
    pub filter: std::string::String,

    /// Field to use to sort the list.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectivityTestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectivityTestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectivityTestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectivityTestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectivityTestsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectivityTestsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectivityTestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListConnectivityTestsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectivityTestsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectivityTestsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectivityTestsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectivityTestsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectivityTestsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectivityTestsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectivityTestsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListConnectivityTests` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectivityTestsResponse {
    /// List of Connectivity Tests.
    pub resources: std::vec::Vec<crate::model::ConnectivityTest>,

    /// Page token to fetch the next set of Connectivity Tests.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached (when querying all locations with `-`).
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectivityTestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resources][crate::model::ListConnectivityTestsResponse::resources].
    pub fn set_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectivityTest>,
    {
        use std::iter::Iterator;
        self.resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectivityTestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectivityTestsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectivityTestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListConnectivityTestsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectivityTestsResponse {
    type PageItem = crate::model::ConnectivityTest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectivityTestsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectivityTestsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resources" => Ok(__FieldTag::__resources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectivityTestsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectivityTestsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectivityTest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectivityTestsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectivityTestsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectivityTestsResponse");
        debug_struct.field("resources", &self.resources);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `GetConnectivityTest` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectivityTestRequest {
    /// Required. `ConnectivityTest` resource name using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectivityTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GetConnectivityTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectivityTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectivityTestRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `CreateConnectivityTest` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectivityTestRequest {
    /// Required. The parent resource of the Connectivity Test to create:
    /// `projects/{project_id}/locations/global`
    pub parent: std::string::String,

    /// Required. The logical name of the Connectivity Test in your project
    /// with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-40 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the customer project
    pub test_id: std::string::String,

    /// Required. A `ConnectivityTest` resource
    pub resource: std::option::Option<crate::model::ConnectivityTest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectivityTestRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [test_id][crate::model::CreateConnectivityTestRequest::test_id].
    pub fn set_test_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_id = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::CreateConnectivityTestRequest::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectivityTest>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::CreateConnectivityTestRequest::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectivityTest>,
    {
        self.resource = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CreateConnectivityTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __test_id,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "testId" => Ok(__FieldTag::__test_id),
                            "test_id" => Ok(__FieldTag::__test_id),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_id => {
                            if !fields.insert(__FieldTag::__test_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_id",
                                ));
                            }
                            result.test_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<crate::model::ConnectivityTest>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.test_id.is_empty() {
            state.serialize_entry("testId", &self.test_id)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConnectivityTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectivityTestRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("test_id", &self.test_id);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `UpdateConnectivityTest` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectivityTestRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in update_mask are updated.
    pub resource: std::option::Option<crate::model::ConnectivityTest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectivityTestRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectivityTestRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource][crate::model::UpdateConnectivityTestRequest::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectivityTest>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::UpdateConnectivityTestRequest::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectivityTest>,
    {
        self.resource = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.UpdateConnectivityTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<crate::model::ConnectivityTest>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConnectivityTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectivityTestRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `DeleteConnectivityTest` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectivityTestRequest {
    /// Required. Connectivity Test resource name using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectivityTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DeleteConnectivityTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConnectivityTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectivityTestRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `RerunConnectivityTest` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RerunConnectivityTestRequest {
    /// Required. Connectivity Test resource name using the form:
    /// `projects/{project_id}/locations/global/connectivityTests/{test_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RerunConnectivityTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RerunConnectivityTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RerunConnectivityTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RerunConnectivityTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RerunConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RerunConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RerunConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RerunConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RerunConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RerunConnectivityTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RerunConnectivityTestRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata describing an [Operation][google.longrunning.Operation]
///
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Target of the operation - for example
    /// projects/project-1/locations/global/connectivityTests/test-1
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    pub status_detail: std::string::String,

    /// Specifies if cancellation was requested for the operation.
    pub cancel_requested: bool,

    /// API version.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_detail][crate::model::OperationMetadata::status_detail].
    pub fn set_status_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_detail = v.into();
        self
    }

    /// Sets the value of [cancel_requested][crate::model::OperationMetadata::cancel_requested].
    pub fn set_cancel_requested<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancel_requested = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_detail,
            __cancel_requested,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusDetail" => Ok(__FieldTag::__status_detail),
                            "status_detail" => Ok(__FieldTag::__status_detail),
                            "cancelRequested" => Ok(__FieldTag::__cancel_requested),
                            "cancel_requested" => Ok(__FieldTag::__cancel_requested),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_detail => {
                            if !fields.insert(__FieldTag::__status_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_detail",
                                ));
                            }
                            result.status_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cancel_requested => {
                            if !fields.insert(__FieldTag::__cancel_requested) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_requested",
                                ));
                            }
                            result.cancel_requested = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_detail.is_empty() {
            state.serialize_entry("statusDetail", &self.status_detail)?;
        }
        if !wkt::internal::is_default(&self.cancel_requested) {
            state.serialize_entry("cancelRequested", &self.cancel_requested)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_detail", &self.status_detail);
        debug_struct.field("cancel_requested", &self.cancel_requested);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Trace represents one simulated packet forwarding path.
///
/// * Each trace contains multiple ordered steps.
/// * Each step is in a particular state with associated configuration.
/// * State is categorized as final or non-final states.
/// * Each final state has a reason associated.
/// * Each trace must end with a final state (the last step).
///
/// ```norust
///   |---------------------Trace----------------------|
///   Step1(State) Step2(State) ---  StepN(State(final))
/// ```
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Trace {
    /// Derived from the source and destination endpoints definition specified by
    /// user request, and validated by the data plane model.
    /// If there are multiple traces starting from different source locations, then
    /// the endpoint_info may be different between traces.
    pub endpoint_info: std::option::Option<crate::model::EndpointInfo>,

    /// A trace of a test contains multiple steps from the initial state to the
    /// final state (delivered, dropped, forwarded, or aborted).
    ///
    /// The steps are ordered by the processing sequence within the simulated
    /// network state machine. It is critical to preserve the order of the steps
    /// and avoid reordering or sorting them.
    pub steps: std::vec::Vec<crate::model::Step>,

    /// ID of trace. For forward traces, this ID is unique for each trace. For
    /// return traces, it matches ID of associated forward trace. A single forward
    /// trace can be associated with none, one or more than one return trace.
    pub forward_trace_id: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoint_info][crate::model::Trace::endpoint_info].
    pub fn set_endpoint_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EndpointInfo>,
    {
        self.endpoint_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoint_info][crate::model::Trace::endpoint_info].
    pub fn set_or_clear_endpoint_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EndpointInfo>,
    {
        self.endpoint_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [steps][crate::model::Trace::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [forward_trace_id][crate::model::Trace::forward_trace_id].
    pub fn set_forward_trace_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.forward_trace_id = v.into();
        self
    }
}

impl wkt::message::Message for Trace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.Trace"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Trace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint_info,
            __steps,
            __forward_trace_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Trace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpointInfo" => Ok(__FieldTag::__endpoint_info),
                            "endpoint_info" => Ok(__FieldTag::__endpoint_info),
                            "steps" => Ok(__FieldTag::__steps),
                            "forwardTraceId" => Ok(__FieldTag::__forward_trace_id),
                            "forward_trace_id" => Ok(__FieldTag::__forward_trace_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Trace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Trace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint_info => {
                            if !fields.insert(__FieldTag::__endpoint_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_info",
                                ));
                            }
                            result.endpoint_info = map
                                .next_value::<std::option::Option<crate::model::EndpointInfo>>()?;
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Step>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__forward_trace_id => {
                            if !fields.insert(__FieldTag::__forward_trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forward_trace_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.forward_trace_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Trace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.endpoint_info.is_some() {
            state.serialize_entry("endpointInfo", &self.endpoint_info)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !wkt::internal::is_default(&self.forward_trace_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("forwardTraceId", &__With(&self.forward_trace_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Trace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Trace");
        debug_struct.field("endpoint_info", &self.endpoint_info);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("forward_trace_id", &self.forward_trace_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A simulated forwarding path is composed of multiple steps.
/// Each step has a well-defined state and an associated configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Step {
    /// A description of the step. Usually this is a summary of the state.
    pub description: std::string::String,

    /// Each step is in one of the pre-defined states.
    pub state: crate::model::step::State,

    /// This is a step that leads to the final state Drop.
    pub causes_drop: bool,

    /// Project ID that contains the configuration this step is validating.
    pub project_id: std::string::String,

    /// Configuration or metadata associated with each step.
    /// The configuration is filtered based on viewer's permission. If a viewer
    /// has no permission to view the configuration in this step, for non-final
    /// states a special state is populated (VIEWER_PERMISSION_MISSING), and for
    /// final state the configuration is cleared.
    pub step_info: std::option::Option<crate::model::step::StepInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Step {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Step::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Step::state].
    pub fn set_state<T: std::convert::Into<crate::model::step::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [causes_drop][crate::model::Step::causes_drop].
    pub fn set_causes_drop<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.causes_drop = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::Step::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [step_info][crate::model::Step::step_info].
    ///
    /// Note that all the setters affecting `step_info` are mutually
    /// exclusive.
    pub fn set_step_info<
        T: std::convert::Into<std::option::Option<crate::model::step::StepInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = v.into();
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Instance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instance(&self) -> std::option::Option<&std::boxed::Box<crate::model::InstanceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Instance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Instance`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_instance<T: std::convert::Into<std::boxed::Box<crate::model::InstanceInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::Instance(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Firewall`, `None` if the field is not set or
    /// holds a different branch.
    pub fn firewall(&self) -> std::option::Option<&std::boxed::Box<crate::model::FirewallInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Firewall(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Firewall`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_firewall<T: std::convert::Into<std::boxed::Box<crate::model::FirewallInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::Firewall(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Route`, `None` if the field is not set or
    /// holds a different branch.
    pub fn route(&self) -> std::option::Option<&std::boxed::Box<crate::model::RouteInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Route(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Route`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_route<T: std::convert::Into<std::boxed::Box<crate::model::RouteInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Route(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Endpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn endpoint(&self) -> std::option::Option<&std::boxed::Box<crate::model::EndpointInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Endpoint(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Endpoint`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_endpoint<T: std::convert::Into<std::boxed::Box<crate::model::EndpointInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::Endpoint(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `GoogleService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleServiceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::GoogleService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `GoogleService`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_google_service<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleServiceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::GoogleService(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ForwardingRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn forwarding_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardingRuleInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ForwardingRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ForwardingRule`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_forwarding_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardingRuleInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::ForwardingRule(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `VpnGateway`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpn_gateway(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpnGatewayInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::VpnGateway(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `VpnGateway`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_vpn_gateway<T: std::convert::Into<std::boxed::Box<crate::model::VpnGatewayInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::VpnGateway(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `VpnTunnel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpn_tunnel(&self) -> std::option::Option<&std::boxed::Box<crate::model::VpnTunnelInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::VpnTunnel(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `VpnTunnel`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_vpn_tunnel<T: std::convert::Into<std::boxed::Box<crate::model::VpnTunnelInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::VpnTunnel(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `VpcConnector`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpc_connector(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcConnectorInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::VpcConnector(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `VpcConnector`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_vpc_connector<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcConnectorInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::VpcConnector(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `DirectVpcEgressConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn direct_vpc_egress_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DirectVpcEgressConnectionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::DirectVpcEgressConnection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `DirectVpcEgressConnection`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_direct_vpc_egress_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::DirectVpcEgressConnectionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(
            crate::model::step::StepInfo::DirectVpcEgressConnection(v.into()),
        );
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ServerlessExternalConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serverless_external_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ServerlessExternalConnectionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ServerlessExternalConnection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ServerlessExternalConnection`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_serverless_external_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::ServerlessExternalConnectionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(
            crate::model::step::StepInfo::ServerlessExternalConnection(v.into()),
        );
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Deliver`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deliver(&self) -> std::option::Option<&std::boxed::Box<crate::model::DeliverInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Deliver(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Deliver`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_deliver<T: std::convert::Into<std::boxed::Box<crate::model::DeliverInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Deliver(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Forward`, `None` if the field is not set or
    /// holds a different branch.
    pub fn forward(&self) -> std::option::Option<&std::boxed::Box<crate::model::ForwardInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Forward(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Forward`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_forward<T: std::convert::Into<std::boxed::Box<crate::model::ForwardInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Forward(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Abort`, `None` if the field is not set or
    /// holds a different branch.
    pub fn abort(&self) -> std::option::Option<&std::boxed::Box<crate::model::AbortInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Abort(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Abort`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_abort<T: std::convert::Into<std::boxed::Box<crate::model::AbortInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Abort(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Drop`, `None` if the field is not set or
    /// holds a different branch.
    pub fn drop(&self) -> std::option::Option<&std::boxed::Box<crate::model::DropInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Drop(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Drop`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_drop<T: std::convert::Into<std::boxed::Box<crate::model::DropInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Drop(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `LoadBalancer`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn load_balancer(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LoadBalancerInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::LoadBalancer(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `LoadBalancer`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_load_balancer<
        T: std::convert::Into<std::boxed::Box<crate::model::LoadBalancerInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::LoadBalancer(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Network`, `None` if the field is not set or
    /// holds a different branch.
    pub fn network(&self) -> std::option::Option<&std::boxed::Box<crate::model::NetworkInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Network(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Network`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_network<T: std::convert::Into<std::boxed::Box<crate::model::NetworkInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Network(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `GkeMaster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_master(&self) -> std::option::Option<&std::boxed::Box<crate::model::GKEMasterInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::GkeMaster(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `GkeMaster`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_gke_master<T: std::convert::Into<std::boxed::Box<crate::model::GKEMasterInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::GkeMaster(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `CloudSqlInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSQLInstanceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::CloudSqlInstance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `CloudSqlInstance`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_cloud_sql_instance<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLInstanceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::CloudSqlInstance(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `RedisInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redis_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedisInstanceInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::RedisInstance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `RedisInstance`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_redis_instance<
        T: std::convert::Into<std::boxed::Box<crate::model::RedisInstanceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::RedisInstance(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `RedisCluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redis_cluster(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedisClusterInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::RedisCluster(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `RedisCluster`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_redis_cluster<
        T: std::convert::Into<std::boxed::Box<crate::model::RedisClusterInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::RedisCluster(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `CloudFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_function(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudFunctionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::CloudFunction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `CloudFunction`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_cloud_function<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudFunctionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::CloudFunction(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `AppEngineVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn app_engine_version(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppEngineVersionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::AppEngineVersion(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `AppEngineVersion`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_app_engine_version<
        T: std::convert::Into<std::boxed::Box<crate::model::AppEngineVersionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::AppEngineVersion(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `CloudRunRevision`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_run_revision(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudRunRevisionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::CloudRunRevision(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `CloudRunRevision`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_cloud_run_revision<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudRunRevisionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::CloudRunRevision(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `Nat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn nat(&self) -> std::option::Option<&std::boxed::Box<crate::model::NatInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::Nat(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `Nat`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_nat<T: std::convert::Into<std::boxed::Box<crate::model::NatInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(crate::model::step::StepInfo::Nat(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ProxyConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn proxy_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProxyConnectionInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ProxyConnection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ProxyConnection`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_proxy_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::ProxyConnectionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::ProxyConnection(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `LoadBalancerBackendInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn load_balancer_backend_info(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LoadBalancerBackendInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::LoadBalancerBackendInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `LoadBalancerBackendInfo`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_load_balancer_backend_info<
        T: std::convert::Into<std::boxed::Box<crate::model::LoadBalancerBackendInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info = std::option::Option::Some(
            crate::model::step::StepInfo::LoadBalancerBackendInfo(v.into()),
        );
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `StorageBucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_bucket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageBucketInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::StorageBucket(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `StorageBucket`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_storage_bucket<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageBucketInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::StorageBucket(v.into()));
        self
    }

    /// The value of [step_info][crate::model::Step::step_info]
    /// if it holds a `ServerlessNeg`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serverless_neg(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ServerlessNegInfo>> {
        #[allow(unreachable_patterns)]
        self.step_info.as_ref().and_then(|v| match v {
            crate::model::step::StepInfo::ServerlessNeg(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step_info][crate::model::Step::step_info]
    /// to hold a `ServerlessNeg`.
    ///
    /// Note that all the setters affecting `step_info` are
    /// mutually exclusive.
    pub fn set_serverless_neg<
        T: std::convert::Into<std::boxed::Box<crate::model::ServerlessNegInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step_info =
            std::option::Option::Some(crate::model::step::StepInfo::ServerlessNeg(v.into()));
        self
    }
}

impl wkt::message::Message for Step {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.Step"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Step {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __state,
            __causes_drop,
            __project_id,
            __instance,
            __firewall,
            __route,
            __endpoint,
            __google_service,
            __forwarding_rule,
            __vpn_gateway,
            __vpn_tunnel,
            __vpc_connector,
            __direct_vpc_egress_connection,
            __serverless_external_connection,
            __deliver,
            __forward,
            __abort,
            __drop,
            __load_balancer,
            __network,
            __gke_master,
            __cloud_sql_instance,
            __redis_instance,
            __redis_cluster,
            __cloud_function,
            __app_engine_version,
            __cloud_run_revision,
            __nat,
            __proxy_connection,
            __load_balancer_backend_info,
            __storage_bucket,
            __serverless_neg,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Step")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "causesDrop" => Ok(__FieldTag::__causes_drop),
                            "causes_drop" => Ok(__FieldTag::__causes_drop),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "firewall" => Ok(__FieldTag::__firewall),
                            "route" => Ok(__FieldTag::__route),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "googleService" => Ok(__FieldTag::__google_service),
                            "google_service" => Ok(__FieldTag::__google_service),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "vpnGateway" => Ok(__FieldTag::__vpn_gateway),
                            "vpn_gateway" => Ok(__FieldTag::__vpn_gateway),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpcConnector" => Ok(__FieldTag::__vpc_connector),
                            "vpc_connector" => Ok(__FieldTag::__vpc_connector),
                            "directVpcEgressConnection" => {
                                Ok(__FieldTag::__direct_vpc_egress_connection)
                            }
                            "direct_vpc_egress_connection" => {
                                Ok(__FieldTag::__direct_vpc_egress_connection)
                            }
                            "serverlessExternalConnection" => {
                                Ok(__FieldTag::__serverless_external_connection)
                            }
                            "serverless_external_connection" => {
                                Ok(__FieldTag::__serverless_external_connection)
                            }
                            "deliver" => Ok(__FieldTag::__deliver),
                            "forward" => Ok(__FieldTag::__forward),
                            "abort" => Ok(__FieldTag::__abort),
                            "drop" => Ok(__FieldTag::__drop),
                            "loadBalancer" => Ok(__FieldTag::__load_balancer),
                            "load_balancer" => Ok(__FieldTag::__load_balancer),
                            "network" => Ok(__FieldTag::__network),
                            "gkeMaster" => Ok(__FieldTag::__gke_master),
                            "gke_master" => Ok(__FieldTag::__gke_master),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "redisInstance" => Ok(__FieldTag::__redis_instance),
                            "redis_instance" => Ok(__FieldTag::__redis_instance),
                            "redisCluster" => Ok(__FieldTag::__redis_cluster),
                            "redis_cluster" => Ok(__FieldTag::__redis_cluster),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "appEngineVersion" => Ok(__FieldTag::__app_engine_version),
                            "app_engine_version" => Ok(__FieldTag::__app_engine_version),
                            "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                            "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                            "nat" => Ok(__FieldTag::__nat),
                            "proxyConnection" => Ok(__FieldTag::__proxy_connection),
                            "proxy_connection" => Ok(__FieldTag::__proxy_connection),
                            "loadBalancerBackendInfo" => {
                                Ok(__FieldTag::__load_balancer_backend_info)
                            }
                            "load_balancer_backend_info" => {
                                Ok(__FieldTag::__load_balancer_backend_info)
                            }
                            "storageBucket" => Ok(__FieldTag::__storage_bucket),
                            "storage_bucket" => Ok(__FieldTag::__storage_bucket),
                            "serverlessNeg" => Ok(__FieldTag::__serverless_neg),
                            "serverless_neg" => Ok(__FieldTag::__serverless_neg),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Step;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Step")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::step::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__causes_drop => {
                            if !fields.insert(__FieldTag::__causes_drop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for causes_drop",
                                ));
                            }
                            result.causes_drop = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.instance, latest field was instance",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Instance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstanceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__firewall => {
                            if !fields.insert(__FieldTag::__firewall) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.firewall, latest field was firewall",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Firewall(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FirewallInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__route => {
                            if !fields.insert(__FieldTag::__route) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.route, latest field was route",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Route(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RouteInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.endpoint, latest field was endpoint",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Endpoint(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EndpointInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__google_service => {
                            if !fields.insert(__FieldTag::__google_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_service",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.google_service, latest field was googleService",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::GoogleService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GoogleServiceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.forwarding_rule, latest field was forwardingRule",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ForwardingRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ForwardingRuleInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vpn_gateway => {
                            if !fields.insert(__FieldTag::__vpn_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_gateway",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpn_gateway, latest field was vpnGateway",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpnGateway(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpnGatewayInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_tunnel",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::VpnTunnel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpnTunnelInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__vpc_connector => {
                            if !fields.insert(__FieldTag::__vpc_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_connector",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpc_connector, latest field was vpcConnector",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpcConnector(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpcConnectorInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__direct_vpc_egress_connection => {
                            if !fields.insert(__FieldTag::__direct_vpc_egress_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direct_vpc_egress_connection",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.direct_vpc_egress_connection, latest field was directVpcEgressConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::DirectVpcEgressConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::DirectVpcEgressConnectionInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__serverless_external_connection => {
                            if !fields.insert(__FieldTag::__serverless_external_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serverless_external_connection",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.serverless_external_connection, latest field was serverlessExternalConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ServerlessExternalConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::ServerlessExternalConnectionInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deliver => {
                            if !fields.insert(__FieldTag::__deliver) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deliver",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.deliver, latest field was deliver",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Deliver(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeliverInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__forward => {
                            if !fields.insert(__FieldTag::__forward) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forward",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.forward, latest field was forward",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Forward(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ForwardInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__abort => {
                            if !fields.insert(__FieldTag::__abort) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abort",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.abort, latest field was abort",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Abort(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AbortInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__drop => {
                            if !fields.insert(__FieldTag::__drop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for drop",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.drop, latest field was drop",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Drop(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DropInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__load_balancer => {
                            if !fields.insert(__FieldTag::__load_balancer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.load_balancer, latest field was loadBalancer",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::LoadBalancer(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LoadBalancerInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.network, latest field was network",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Network(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::NetworkInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__gke_master => {
                            if !fields.insert(__FieldTag::__gke_master) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_master",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.gke_master, latest field was gkeMaster",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::GkeMaster(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GKEMasterInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_instance",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_sql_instance, latest field was cloudSqlInstance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudSqlInstance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSQLInstanceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__redis_instance => {
                            if !fields.insert(__FieldTag::__redis_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_instance",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.redis_instance, latest field was redisInstance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::RedisInstance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RedisInstanceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__redis_cluster => {
                            if !fields.insert(__FieldTag::__redis_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_cluster",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.redis_cluster, latest field was redisCluster",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::RedisCluster(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RedisClusterInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_function",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_function, latest field was cloudFunction",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudFunction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudFunctionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__app_engine_version => {
                            if !fields.insert(__FieldTag::__app_engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_version",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.app_engine_version, latest field was appEngineVersion",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::AppEngineVersion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AppEngineVersionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_run_revision => {
                            if !fields.insert(__FieldTag::__cloud_run_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run_revision",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_run_revision, latest field was cloudRunRevision",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudRunRevision(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRunRevisionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__nat => {
                            if !fields.insert(__FieldTag::__nat) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nat",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.nat, latest field was nat",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(
                                    crate::model::step::StepInfo::Nat(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::NatInfo>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__proxy_connection => {
                            if !fields.insert(__FieldTag::__proxy_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_connection",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.proxy_connection, latest field was proxyConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ProxyConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProxyConnectionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__load_balancer_backend_info => {
                            if !fields.insert(__FieldTag::__load_balancer_backend_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_backend_info",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.load_balancer_backend_info, latest field was loadBalancerBackendInfo",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::LoadBalancerBackendInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LoadBalancerBackendInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__storage_bucket => {
                            if !fields.insert(__FieldTag::__storage_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_bucket",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.storage_bucket, latest field was storageBucket",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::StorageBucket(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageBucketInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__serverless_neg => {
                            if !fields.insert(__FieldTag::__serverless_neg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serverless_neg",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.serverless_neg, latest field was serverlessNeg",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ServerlessNeg(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ServerlessNegInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Step {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.causes_drop) {
            state.serialize_entry("causesDrop", &self.causes_drop)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if let Some(value) = self.instance() {
            state.serialize_entry("instance", value)?;
        }
        if let Some(value) = self.firewall() {
            state.serialize_entry("firewall", value)?;
        }
        if let Some(value) = self.route() {
            state.serialize_entry("route", value)?;
        }
        if let Some(value) = self.endpoint() {
            state.serialize_entry("endpoint", value)?;
        }
        if let Some(value) = self.google_service() {
            state.serialize_entry("googleService", value)?;
        }
        if let Some(value) = self.forwarding_rule() {
            state.serialize_entry("forwardingRule", value)?;
        }
        if let Some(value) = self.vpn_gateway() {
            state.serialize_entry("vpnGateway", value)?;
        }
        if let Some(value) = self.vpn_tunnel() {
            state.serialize_entry("vpnTunnel", value)?;
        }
        if let Some(value) = self.vpc_connector() {
            state.serialize_entry("vpcConnector", value)?;
        }
        if let Some(value) = self.direct_vpc_egress_connection() {
            state.serialize_entry("directVpcEgressConnection", value)?;
        }
        if let Some(value) = self.serverless_external_connection() {
            state.serialize_entry("serverlessExternalConnection", value)?;
        }
        if let Some(value) = self.deliver() {
            state.serialize_entry("deliver", value)?;
        }
        if let Some(value) = self.forward() {
            state.serialize_entry("forward", value)?;
        }
        if let Some(value) = self.abort() {
            state.serialize_entry("abort", value)?;
        }
        if let Some(value) = self.drop() {
            state.serialize_entry("drop", value)?;
        }
        if let Some(value) = self.load_balancer() {
            state.serialize_entry("loadBalancer", value)?;
        }
        if let Some(value) = self.network() {
            state.serialize_entry("network", value)?;
        }
        if let Some(value) = self.gke_master() {
            state.serialize_entry("gkeMaster", value)?;
        }
        if let Some(value) = self.cloud_sql_instance() {
            state.serialize_entry("cloudSqlInstance", value)?;
        }
        if let Some(value) = self.redis_instance() {
            state.serialize_entry("redisInstance", value)?;
        }
        if let Some(value) = self.redis_cluster() {
            state.serialize_entry("redisCluster", value)?;
        }
        if let Some(value) = self.cloud_function() {
            state.serialize_entry("cloudFunction", value)?;
        }
        if let Some(value) = self.app_engine_version() {
            state.serialize_entry("appEngineVersion", value)?;
        }
        if let Some(value) = self.cloud_run_revision() {
            state.serialize_entry("cloudRunRevision", value)?;
        }
        if let Some(value) = self.nat() {
            state.serialize_entry("nat", value)?;
        }
        if let Some(value) = self.proxy_connection() {
            state.serialize_entry("proxyConnection", value)?;
        }
        if let Some(value) = self.load_balancer_backend_info() {
            state.serialize_entry("loadBalancerBackendInfo", value)?;
        }
        if let Some(value) = self.storage_bucket() {
            state.serialize_entry("storageBucket", value)?;
        }
        if let Some(value) = self.serverless_neg() {
            state.serialize_entry("serverlessNeg", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Step {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Step");
        debug_struct.field("description", &self.description);
        debug_struct.field("state", &self.state);
        debug_struct.field("causes_drop", &self.causes_drop);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("step_info", &self.step_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Step].
pub mod step {
    #[allow(unused_imports)]
    use super::*;

    /// Type of states that are defined in the network state machine.
    /// Each step in the packet trace is in a specific state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Initial state: packet originating from a Compute Engine instance.
        /// An InstanceInfo is populated with starting instance information.
        StartFromInstance,
        /// Initial state: packet originating from the internet.
        /// The endpoint information is populated.
        StartFromInternet,
        /// Initial state: packet originating from a Google service.
        /// The google_service information is populated.
        StartFromGoogleService,
        /// Initial state: packet originating from a VPC or on-premises network
        /// with internal source IP.
        /// If the source is a VPC network visible to the user, a NetworkInfo
        /// is populated with details of the network.
        StartFromPrivateNetwork,
        /// Initial state: packet originating from a Google Kubernetes Engine cluster
        /// master. A GKEMasterInfo is populated with starting instance information.
        StartFromGkeMaster,
        /// Initial state: packet originating from a Cloud SQL instance.
        /// A CloudSQLInstanceInfo is populated with starting instance information.
        StartFromCloudSqlInstance,
        /// Initial state: packet originating from a Redis instance.
        /// A RedisInstanceInfo is populated with starting instance information.
        StartFromRedisInstance,
        /// Initial state: packet originating from a Redis Cluster.
        /// A RedisClusterInfo is populated with starting Cluster information.
        StartFromRedisCluster,
        /// Initial state: packet originating from a Cloud Function.
        /// A CloudFunctionInfo is populated with starting function information.
        StartFromCloudFunction,
        /// Initial state: packet originating from an App Engine service version.
        /// An AppEngineVersionInfo is populated with starting version information.
        StartFromAppEngineVersion,
        /// Initial state: packet originating from a Cloud Run revision.
        /// A CloudRunRevisionInfo is populated with starting revision information.
        StartFromCloudRunRevision,
        /// Initial state: packet originating from a Storage Bucket. Used only for
        /// return traces.
        /// The storage_bucket information is populated.
        StartFromStorageBucket,
        /// Initial state: packet originating from a published service that uses
        /// Private Service Connect. Used only for return traces.
        StartFromPscPublishedService,
        /// Initial state: packet originating from a serverless network endpoint
        /// group backend. Used only for return traces.
        /// The serverless_neg information is populated.
        StartFromServerlessNeg,
        /// Config checking state: verify ingress firewall rule.
        ApplyIngressFirewallRule,
        /// Config checking state: verify egress firewall rule.
        ApplyEgressFirewallRule,
        /// Config checking state: verify route.
        ApplyRoute,
        /// Config checking state: match forwarding rule.
        ApplyForwardingRule,
        /// Config checking state: verify load balancer backend configuration.
        AnalyzeLoadBalancerBackend,
        /// Config checking state: packet sent or received under foreign IP
        /// address and allowed.
        SpoofingApproved,
        /// Forwarding state: arriving at a Compute Engine instance.
        ArriveAtInstance,
        /// Forwarding state: arriving at a Compute Engine internal load balancer.
        /// Deprecated in favor of the `ANALYZE_LOAD_BALANCER_BACKEND` state, not
        /// used in new tests.
        #[deprecated]
        ArriveAtInternalLoadBalancer,
        /// Forwarding state: arriving at a Compute Engine external load balancer.
        /// Deprecated in favor of the `ANALYZE_LOAD_BALANCER_BACKEND` state, not
        /// used in new tests.
        #[deprecated]
        ArriveAtExternalLoadBalancer,
        /// Forwarding state: arriving at a Cloud VPN gateway.
        ArriveAtVpnGateway,
        /// Forwarding state: arriving at a Cloud VPN tunnel.
        ArriveAtVpnTunnel,
        /// Forwarding state: arriving at a VPC connector.
        ArriveAtVpcConnector,
        /// Forwarding state: for packets originating from a serverless endpoint
        /// forwarded through Direct VPC egress.
        DirectVpcEgressConnection,
        /// Forwarding state: for packets originating from a serverless endpoint
        /// forwarded through public (external) connectivity.
        ServerlessExternalConnection,
        /// Transition state: packet header translated.
        Nat,
        /// Transition state: original connection is terminated and a new proxied
        /// connection is initiated.
        ProxyConnection,
        /// Final state: packet could be delivered.
        Deliver,
        /// Final state: packet could be dropped.
        Drop,
        /// Final state: packet could be forwarded to a network with an unknown
        /// configuration.
        Forward,
        /// Final state: analysis is aborted.
        Abort,
        /// Special state: viewer of the test result does not have permission to
        /// see the configuration in this step.
        ViewerPermissionMissing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StartFromInstance => std::option::Option::Some(1),
                Self::StartFromInternet => std::option::Option::Some(2),
                Self::StartFromGoogleService => std::option::Option::Some(27),
                Self::StartFromPrivateNetwork => std::option::Option::Some(3),
                Self::StartFromGkeMaster => std::option::Option::Some(21),
                Self::StartFromCloudSqlInstance => std::option::Option::Some(22),
                Self::StartFromRedisInstance => std::option::Option::Some(32),
                Self::StartFromRedisCluster => std::option::Option::Some(33),
                Self::StartFromCloudFunction => std::option::Option::Some(23),
                Self::StartFromAppEngineVersion => std::option::Option::Some(25),
                Self::StartFromCloudRunRevision => std::option::Option::Some(26),
                Self::StartFromStorageBucket => std::option::Option::Some(29),
                Self::StartFromPscPublishedService => std::option::Option::Some(30),
                Self::StartFromServerlessNeg => std::option::Option::Some(31),
                Self::ApplyIngressFirewallRule => std::option::Option::Some(4),
                Self::ApplyEgressFirewallRule => std::option::Option::Some(5),
                Self::ApplyRoute => std::option::Option::Some(6),
                Self::ApplyForwardingRule => std::option::Option::Some(7),
                Self::AnalyzeLoadBalancerBackend => std::option::Option::Some(28),
                Self::SpoofingApproved => std::option::Option::Some(8),
                Self::ArriveAtInstance => std::option::Option::Some(9),
                Self::ArriveAtInternalLoadBalancer => std::option::Option::Some(10),
                Self::ArriveAtExternalLoadBalancer => std::option::Option::Some(11),
                Self::ArriveAtVpnGateway => std::option::Option::Some(12),
                Self::ArriveAtVpnTunnel => std::option::Option::Some(13),
                Self::ArriveAtVpcConnector => std::option::Option::Some(24),
                Self::DirectVpcEgressConnection => std::option::Option::Some(35),
                Self::ServerlessExternalConnection => std::option::Option::Some(36),
                Self::Nat => std::option::Option::Some(14),
                Self::ProxyConnection => std::option::Option::Some(15),
                Self::Deliver => std::option::Option::Some(16),
                Self::Drop => std::option::Option::Some(17),
                Self::Forward => std::option::Option::Some(18),
                Self::Abort => std::option::Option::Some(19),
                Self::ViewerPermissionMissing => std::option::Option::Some(20),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::StartFromInstance => std::option::Option::Some("START_FROM_INSTANCE"),
                Self::StartFromInternet => std::option::Option::Some("START_FROM_INTERNET"),
                Self::StartFromGoogleService => {
                    std::option::Option::Some("START_FROM_GOOGLE_SERVICE")
                }
                Self::StartFromPrivateNetwork => {
                    std::option::Option::Some("START_FROM_PRIVATE_NETWORK")
                }
                Self::StartFromGkeMaster => std::option::Option::Some("START_FROM_GKE_MASTER"),
                Self::StartFromCloudSqlInstance => {
                    std::option::Option::Some("START_FROM_CLOUD_SQL_INSTANCE")
                }
                Self::StartFromRedisInstance => {
                    std::option::Option::Some("START_FROM_REDIS_INSTANCE")
                }
                Self::StartFromRedisCluster => {
                    std::option::Option::Some("START_FROM_REDIS_CLUSTER")
                }
                Self::StartFromCloudFunction => {
                    std::option::Option::Some("START_FROM_CLOUD_FUNCTION")
                }
                Self::StartFromAppEngineVersion => {
                    std::option::Option::Some("START_FROM_APP_ENGINE_VERSION")
                }
                Self::StartFromCloudRunRevision => {
                    std::option::Option::Some("START_FROM_CLOUD_RUN_REVISION")
                }
                Self::StartFromStorageBucket => {
                    std::option::Option::Some("START_FROM_STORAGE_BUCKET")
                }
                Self::StartFromPscPublishedService => {
                    std::option::Option::Some("START_FROM_PSC_PUBLISHED_SERVICE")
                }
                Self::StartFromServerlessNeg => {
                    std::option::Option::Some("START_FROM_SERVERLESS_NEG")
                }
                Self::ApplyIngressFirewallRule => {
                    std::option::Option::Some("APPLY_INGRESS_FIREWALL_RULE")
                }
                Self::ApplyEgressFirewallRule => {
                    std::option::Option::Some("APPLY_EGRESS_FIREWALL_RULE")
                }
                Self::ApplyRoute => std::option::Option::Some("APPLY_ROUTE"),
                Self::ApplyForwardingRule => std::option::Option::Some("APPLY_FORWARDING_RULE"),
                Self::AnalyzeLoadBalancerBackend => {
                    std::option::Option::Some("ANALYZE_LOAD_BALANCER_BACKEND")
                }
                Self::SpoofingApproved => std::option::Option::Some("SPOOFING_APPROVED"),
                Self::ArriveAtInstance => std::option::Option::Some("ARRIVE_AT_INSTANCE"),
                Self::ArriveAtInternalLoadBalancer => {
                    std::option::Option::Some("ARRIVE_AT_INTERNAL_LOAD_BALANCER")
                }
                Self::ArriveAtExternalLoadBalancer => {
                    std::option::Option::Some("ARRIVE_AT_EXTERNAL_LOAD_BALANCER")
                }
                Self::ArriveAtVpnGateway => std::option::Option::Some("ARRIVE_AT_VPN_GATEWAY"),
                Self::ArriveAtVpnTunnel => std::option::Option::Some("ARRIVE_AT_VPN_TUNNEL"),
                Self::ArriveAtVpcConnector => std::option::Option::Some("ARRIVE_AT_VPC_CONNECTOR"),
                Self::DirectVpcEgressConnection => {
                    std::option::Option::Some("DIRECT_VPC_EGRESS_CONNECTION")
                }
                Self::ServerlessExternalConnection => {
                    std::option::Option::Some("SERVERLESS_EXTERNAL_CONNECTION")
                }
                Self::Nat => std::option::Option::Some("NAT"),
                Self::ProxyConnection => std::option::Option::Some("PROXY_CONNECTION"),
                Self::Deliver => std::option::Option::Some("DELIVER"),
                Self::Drop => std::option::Option::Some("DROP"),
                Self::Forward => std::option::Option::Some("FORWARD"),
                Self::Abort => std::option::Option::Some("ABORT"),
                Self::ViewerPermissionMissing => {
                    std::option::Option::Some("VIEWER_PERMISSION_MISSING")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StartFromInstance,
                2 => Self::StartFromInternet,
                3 => Self::StartFromPrivateNetwork,
                4 => Self::ApplyIngressFirewallRule,
                5 => Self::ApplyEgressFirewallRule,
                6 => Self::ApplyRoute,
                7 => Self::ApplyForwardingRule,
                8 => Self::SpoofingApproved,
                9 => Self::ArriveAtInstance,
                10 => Self::ArriveAtInternalLoadBalancer,
                11 => Self::ArriveAtExternalLoadBalancer,
                12 => Self::ArriveAtVpnGateway,
                13 => Self::ArriveAtVpnTunnel,
                14 => Self::Nat,
                15 => Self::ProxyConnection,
                16 => Self::Deliver,
                17 => Self::Drop,
                18 => Self::Forward,
                19 => Self::Abort,
                20 => Self::ViewerPermissionMissing,
                21 => Self::StartFromGkeMaster,
                22 => Self::StartFromCloudSqlInstance,
                23 => Self::StartFromCloudFunction,
                24 => Self::ArriveAtVpcConnector,
                25 => Self::StartFromAppEngineVersion,
                26 => Self::StartFromCloudRunRevision,
                27 => Self::StartFromGoogleService,
                28 => Self::AnalyzeLoadBalancerBackend,
                29 => Self::StartFromStorageBucket,
                30 => Self::StartFromPscPublishedService,
                31 => Self::StartFromServerlessNeg,
                32 => Self::StartFromRedisInstance,
                33 => Self::StartFromRedisCluster,
                35 => Self::DirectVpcEgressConnection,
                36 => Self::ServerlessExternalConnection,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "START_FROM_INSTANCE" => Self::StartFromInstance,
                "START_FROM_INTERNET" => Self::StartFromInternet,
                "START_FROM_GOOGLE_SERVICE" => Self::StartFromGoogleService,
                "START_FROM_PRIVATE_NETWORK" => Self::StartFromPrivateNetwork,
                "START_FROM_GKE_MASTER" => Self::StartFromGkeMaster,
                "START_FROM_CLOUD_SQL_INSTANCE" => Self::StartFromCloudSqlInstance,
                "START_FROM_REDIS_INSTANCE" => Self::StartFromRedisInstance,
                "START_FROM_REDIS_CLUSTER" => Self::StartFromRedisCluster,
                "START_FROM_CLOUD_FUNCTION" => Self::StartFromCloudFunction,
                "START_FROM_APP_ENGINE_VERSION" => Self::StartFromAppEngineVersion,
                "START_FROM_CLOUD_RUN_REVISION" => Self::StartFromCloudRunRevision,
                "START_FROM_STORAGE_BUCKET" => Self::StartFromStorageBucket,
                "START_FROM_PSC_PUBLISHED_SERVICE" => Self::StartFromPscPublishedService,
                "START_FROM_SERVERLESS_NEG" => Self::StartFromServerlessNeg,
                "APPLY_INGRESS_FIREWALL_RULE" => Self::ApplyIngressFirewallRule,
                "APPLY_EGRESS_FIREWALL_RULE" => Self::ApplyEgressFirewallRule,
                "APPLY_ROUTE" => Self::ApplyRoute,
                "APPLY_FORWARDING_RULE" => Self::ApplyForwardingRule,
                "ANALYZE_LOAD_BALANCER_BACKEND" => Self::AnalyzeLoadBalancerBackend,
                "SPOOFING_APPROVED" => Self::SpoofingApproved,
                "ARRIVE_AT_INSTANCE" => Self::ArriveAtInstance,
                "ARRIVE_AT_INTERNAL_LOAD_BALANCER" => Self::ArriveAtInternalLoadBalancer,
                "ARRIVE_AT_EXTERNAL_LOAD_BALANCER" => Self::ArriveAtExternalLoadBalancer,
                "ARRIVE_AT_VPN_GATEWAY" => Self::ArriveAtVpnGateway,
                "ARRIVE_AT_VPN_TUNNEL" => Self::ArriveAtVpnTunnel,
                "ARRIVE_AT_VPC_CONNECTOR" => Self::ArriveAtVpcConnector,
                "DIRECT_VPC_EGRESS_CONNECTION" => Self::DirectVpcEgressConnection,
                "SERVERLESS_EXTERNAL_CONNECTION" => Self::ServerlessExternalConnection,
                "NAT" => Self::Nat,
                "PROXY_CONNECTION" => Self::ProxyConnection,
                "DELIVER" => Self::Deliver,
                "DROP" => Self::Drop,
                "FORWARD" => Self::Forward,
                "ABORT" => Self::Abort,
                "VIEWER_PERMISSION_MISSING" => Self::ViewerPermissionMissing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StartFromInstance => serializer.serialize_i32(1),
                Self::StartFromInternet => serializer.serialize_i32(2),
                Self::StartFromGoogleService => serializer.serialize_i32(27),
                Self::StartFromPrivateNetwork => serializer.serialize_i32(3),
                Self::StartFromGkeMaster => serializer.serialize_i32(21),
                Self::StartFromCloudSqlInstance => serializer.serialize_i32(22),
                Self::StartFromRedisInstance => serializer.serialize_i32(32),
                Self::StartFromRedisCluster => serializer.serialize_i32(33),
                Self::StartFromCloudFunction => serializer.serialize_i32(23),
                Self::StartFromAppEngineVersion => serializer.serialize_i32(25),
                Self::StartFromCloudRunRevision => serializer.serialize_i32(26),
                Self::StartFromStorageBucket => serializer.serialize_i32(29),
                Self::StartFromPscPublishedService => serializer.serialize_i32(30),
                Self::StartFromServerlessNeg => serializer.serialize_i32(31),
                Self::ApplyIngressFirewallRule => serializer.serialize_i32(4),
                Self::ApplyEgressFirewallRule => serializer.serialize_i32(5),
                Self::ApplyRoute => serializer.serialize_i32(6),
                Self::ApplyForwardingRule => serializer.serialize_i32(7),
                Self::AnalyzeLoadBalancerBackend => serializer.serialize_i32(28),
                Self::SpoofingApproved => serializer.serialize_i32(8),
                Self::ArriveAtInstance => serializer.serialize_i32(9),
                Self::ArriveAtInternalLoadBalancer => serializer.serialize_i32(10),
                Self::ArriveAtExternalLoadBalancer => serializer.serialize_i32(11),
                Self::ArriveAtVpnGateway => serializer.serialize_i32(12),
                Self::ArriveAtVpnTunnel => serializer.serialize_i32(13),
                Self::ArriveAtVpcConnector => serializer.serialize_i32(24),
                Self::DirectVpcEgressConnection => serializer.serialize_i32(35),
                Self::ServerlessExternalConnection => serializer.serialize_i32(36),
                Self::Nat => serializer.serialize_i32(14),
                Self::ProxyConnection => serializer.serialize_i32(15),
                Self::Deliver => serializer.serialize_i32(16),
                Self::Drop => serializer.serialize_i32(17),
                Self::Forward => serializer.serialize_i32(18),
                Self::Abort => serializer.serialize_i32(19),
                Self::ViewerPermissionMissing => serializer.serialize_i32(20),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.networkmanagement.v1.Step.State",
            ))
        }
    }

    /// Configuration or metadata associated with each step.
    /// The configuration is filtered based on viewer's permission. If a viewer
    /// has no permission to view the configuration in this step, for non-final
    /// states a special state is populated (VIEWER_PERMISSION_MISSING), and for
    /// final state the configuration is cleared.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StepInfo {
        /// Display information of a Compute Engine instance.
        Instance(std::boxed::Box<crate::model::InstanceInfo>),
        /// Display information of a Compute Engine firewall rule.
        Firewall(std::boxed::Box<crate::model::FirewallInfo>),
        /// Display information of a Compute Engine route.
        Route(std::boxed::Box<crate::model::RouteInfo>),
        /// Display information of the source and destination under analysis.
        /// The endpoint information in an intermediate state may differ with the
        /// initial input, as it might be modified by state like NAT,
        /// or Connection Proxy.
        Endpoint(std::boxed::Box<crate::model::EndpointInfo>),
        /// Display information of a Google service
        GoogleService(std::boxed::Box<crate::model::GoogleServiceInfo>),
        /// Display information of a Compute Engine forwarding rule.
        ForwardingRule(std::boxed::Box<crate::model::ForwardingRuleInfo>),
        /// Display information of a Compute Engine VPN gateway.
        VpnGateway(std::boxed::Box<crate::model::VpnGatewayInfo>),
        /// Display information of a Compute Engine VPN tunnel.
        VpnTunnel(std::boxed::Box<crate::model::VpnTunnelInfo>),
        /// Display information of a VPC connector.
        VpcConnector(std::boxed::Box<crate::model::VpcConnectorInfo>),
        /// Display information of a serverless direct VPC egress connection.
        DirectVpcEgressConnection(std::boxed::Box<crate::model::DirectVpcEgressConnectionInfo>),
        /// Display information of a serverless public (external) connection.
        ServerlessExternalConnection(
            std::boxed::Box<crate::model::ServerlessExternalConnectionInfo>,
        ),
        /// Display information of the final state "deliver" and reason.
        Deliver(std::boxed::Box<crate::model::DeliverInfo>),
        /// Display information of the final state "forward" and reason.
        Forward(std::boxed::Box<crate::model::ForwardInfo>),
        /// Display information of the final state "abort" and reason.
        Abort(std::boxed::Box<crate::model::AbortInfo>),
        /// Display information of the final state "drop" and reason.
        Drop(std::boxed::Box<crate::model::DropInfo>),
        /// Display information of the load balancers. Deprecated in favor of the
        /// `load_balancer_backend_info` field, not used in new tests.
        #[deprecated]
        LoadBalancer(std::boxed::Box<crate::model::LoadBalancerInfo>),
        /// Display information of a Google Cloud network.
        Network(std::boxed::Box<crate::model::NetworkInfo>),
        /// Display information of a Google Kubernetes Engine cluster master.
        GkeMaster(std::boxed::Box<crate::model::GKEMasterInfo>),
        /// Display information of a Cloud SQL instance.
        CloudSqlInstance(std::boxed::Box<crate::model::CloudSQLInstanceInfo>),
        /// Display information of a Redis Instance.
        RedisInstance(std::boxed::Box<crate::model::RedisInstanceInfo>),
        /// Display information of a Redis Cluster.
        RedisCluster(std::boxed::Box<crate::model::RedisClusterInfo>),
        /// Display information of a Cloud Function.
        CloudFunction(std::boxed::Box<crate::model::CloudFunctionInfo>),
        /// Display information of an App Engine service version.
        AppEngineVersion(std::boxed::Box<crate::model::AppEngineVersionInfo>),
        /// Display information of a Cloud Run revision.
        CloudRunRevision(std::boxed::Box<crate::model::CloudRunRevisionInfo>),
        /// Display information of a NAT.
        Nat(std::boxed::Box<crate::model::NatInfo>),
        /// Display information of a ProxyConnection.
        ProxyConnection(std::boxed::Box<crate::model::ProxyConnectionInfo>),
        /// Display information of a specific load balancer backend.
        LoadBalancerBackendInfo(std::boxed::Box<crate::model::LoadBalancerBackendInfo>),
        /// Display information of a Storage Bucket. Used only for return traces.
        StorageBucket(std::boxed::Box<crate::model::StorageBucketInfo>),
        /// Display information of a Serverless network endpoint group backend. Used
        /// only for return traces.
        ServerlessNeg(std::boxed::Box<crate::model::ServerlessNegInfo>),
    }
}

/// For display only. Metadata associated with a Compute Engine instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceInfo {
    /// Name of a Compute Engine instance.
    pub display_name: std::string::String,

    /// URI of a Compute Engine instance.
    pub uri: std::string::String,

    /// Name of the network interface of a Compute Engine instance.
    pub interface: std::string::String,

    /// URI of a Compute Engine network.
    pub network_uri: std::string::String,

    /// Internal IP address of the network interface.
    pub internal_ip: std::string::String,

    /// External IP address of the network interface.
    pub external_ip: std::string::String,

    /// Network tags configured on the instance.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Service account authorized for the instance.
    #[deprecated]
    pub service_account: std::string::String,

    /// URI of the PSC network attachment the NIC is attached to (if relevant).
    pub psc_network_attachment_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::InstanceInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::InstanceInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [interface][crate::model::InstanceInfo::interface].
    pub fn set_interface<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.interface = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::InstanceInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::InstanceInfo::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::InstanceInfo::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::InstanceInfo::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::InstanceInfo::service_account].
    #[deprecated]
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [psc_network_attachment_uri][crate::model::InstanceInfo::psc_network_attachment_uri].
    pub fn set_psc_network_attachment_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_network_attachment_uri = v.into();
        self
    }
}

impl wkt::message::Message for InstanceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.InstanceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __interface,
            __network_uri,
            __internal_ip,
            __external_ip,
            __network_tags,
            __service_account,
            __psc_network_attachment_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "interface" => Ok(__FieldTag::__interface),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "pscNetworkAttachmentUri" => {
                                Ok(__FieldTag::__psc_network_attachment_uri)
                            }
                            "psc_network_attachment_uri" => {
                                Ok(__FieldTag::__psc_network_attachment_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interface => {
                            if !fields.insert(__FieldTag::__interface) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interface",
                                ));
                            }
                            result.interface = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_network_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_network_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_network_attachment_uri",
                                ));
                            }
                            result.psc_network_attachment_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.interface.is_empty() {
            state.serialize_entry("interface", &self.interface)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.psc_network_attachment_uri.is_empty() {
            state.serialize_entry("pscNetworkAttachmentUri", &self.psc_network_attachment_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InstanceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("interface", &self.interface);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("internal_ip", &self.internal_ip);
        debug_struct.field("external_ip", &self.external_ip);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field(
            "psc_network_attachment_uri",
            &self.psc_network_attachment_uri,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Compute Engine network.
/// Next ID: 7
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInfo {
    /// Name of a Compute Engine network.
    pub display_name: std::string::String,

    /// URI of a Compute Engine network.
    pub uri: std::string::String,

    /// URI of the subnet matching the source IP address of the test.
    pub matched_subnet_uri: std::string::String,

    /// The IP range of the subnet matching the source IP address of the test.
    pub matched_ip_range: std::string::String,

    /// The region of the subnet matching the source IP address of the test.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::NetworkInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::NetworkInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [matched_subnet_uri][crate::model::NetworkInfo::matched_subnet_uri].
    pub fn set_matched_subnet_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_subnet_uri = v.into();
        self
    }

    /// Sets the value of [matched_ip_range][crate::model::NetworkInfo::matched_ip_range].
    pub fn set_matched_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_ip_range = v.into();
        self
    }

    /// Sets the value of [region][crate::model::NetworkInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.NetworkInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __matched_subnet_uri,
            __matched_ip_range,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "matchedSubnetUri" => Ok(__FieldTag::__matched_subnet_uri),
                            "matched_subnet_uri" => Ok(__FieldTag::__matched_subnet_uri),
                            "matchedIpRange" => Ok(__FieldTag::__matched_ip_range),
                            "matched_ip_range" => Ok(__FieldTag::__matched_ip_range),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_subnet_uri => {
                            if !fields.insert(__FieldTag::__matched_subnet_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_subnet_uri",
                                ));
                            }
                            result.matched_subnet_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_ip_range => {
                            if !fields.insert(__FieldTag::__matched_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_ip_range",
                                ));
                            }
                            result.matched_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.matched_subnet_uri.is_empty() {
            state.serialize_entry("matchedSubnetUri", &self.matched_subnet_uri)?;
        }
        if !self.matched_ip_range.is_empty() {
            state.serialize_entry("matchedIpRange", &self.matched_ip_range)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("matched_subnet_uri", &self.matched_subnet_uri);
        debug_struct.field("matched_ip_range", &self.matched_ip_range);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a VPC firewall rule, an implied
/// VPC firewall rule, or a firewall policy rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallInfo {
    /// The display name of the firewall rule. This field might be empty for
    /// firewall policy rules.
    pub display_name: std::string::String,

    /// The URI of the firewall rule. This field is not applicable to implied
    /// VPC firewall rules.
    pub uri: std::string::String,

    /// Possible values: INGRESS, EGRESS
    pub direction: std::string::String,

    /// Possible values: ALLOW, DENY, APPLY_SECURITY_PROFILE_GROUP
    pub action: std::string::String,

    /// The priority of the firewall rule.
    pub priority: i32,

    /// The URI of the VPC network that the firewall rule is associated with.
    /// This field is not applicable to hierarchical firewall policy rules.
    pub network_uri: std::string::String,

    /// The target tags defined by the VPC firewall rule. This field is not
    /// applicable to firewall policy rules.
    pub target_tags: std::vec::Vec<std::string::String>,

    /// The target service accounts specified by the firewall rule.
    pub target_service_accounts: std::vec::Vec<std::string::String>,

    /// The name of the firewall policy that this rule is associated with.
    /// This field is not applicable to VPC firewall rules and implied VPC firewall
    /// rules.
    pub policy: std::string::String,

    /// The URI of the firewall policy that this rule is associated with.
    /// This field is not applicable to VPC firewall rules and implied VPC firewall
    /// rules.
    pub policy_uri: std::string::String,

    /// The firewall rule's type.
    pub firewall_rule_type: crate::model::firewall_info::FirewallRuleType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::FirewallInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::FirewallInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [direction][crate::model::FirewallInfo::direction].
    pub fn set_direction<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [action][crate::model::FirewallInfo::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::FirewallInfo::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::FirewallInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [target_tags][crate::model::FirewallInfo::target_tags].
    pub fn set_target_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_service_accounts][crate::model::FirewallInfo::target_service_accounts].
    pub fn set_target_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [policy][crate::model::FirewallInfo::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [policy_uri][crate::model::FirewallInfo::policy_uri].
    pub fn set_policy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_uri = v.into();
        self
    }

    /// Sets the value of [firewall_rule_type][crate::model::FirewallInfo::firewall_rule_type].
    pub fn set_firewall_rule_type<
        T: std::convert::Into<crate::model::firewall_info::FirewallRuleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_rule_type = v.into();
        self
    }
}

impl wkt::message::Message for FirewallInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.FirewallInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FirewallInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __direction,
            __action,
            __priority,
            __network_uri,
            __target_tags,
            __target_service_accounts,
            __policy,
            __policy_uri,
            __firewall_rule_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "direction" => Ok(__FieldTag::__direction),
                            "action" => Ok(__FieldTag::__action),
                            "priority" => Ok(__FieldTag::__priority),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "targetTags" => Ok(__FieldTag::__target_tags),
                            "target_tags" => Ok(__FieldTag::__target_tags),
                            "targetServiceAccounts" => Ok(__FieldTag::__target_service_accounts),
                            "target_service_accounts" => Ok(__FieldTag::__target_service_accounts),
                            "policy" => Ok(__FieldTag::__policy),
                            "policyUri" => Ok(__FieldTag::__policy_uri),
                            "policy_uri" => Ok(__FieldTag::__policy_uri),
                            "firewallRuleType" => Ok(__FieldTag::__firewall_rule_type),
                            "firewall_rule_type" => Ok(__FieldTag::__firewall_rule_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FirewallInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_tags => {
                            if !fields.insert(__FieldTag::__target_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_tags",
                                ));
                            }
                            result.target_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__target_service_accounts => {
                            if !fields.insert(__FieldTag::__target_service_accounts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_service_accounts",
                                ));
                            }
                            result.target_service_accounts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_uri => {
                            if !fields.insert(__FieldTag::__policy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_uri",
                                ));
                            }
                            result.policy_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__firewall_rule_type => {
                            if !fields.insert(__FieldTag::__firewall_rule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_rule_type",
                                ));
                            }
                            result.firewall_rule_type =
                                map.next_value::<std::option::Option<
                                    crate::model::firewall_info::FirewallRuleType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FirewallInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.direction.is_empty() {
            state.serialize_entry("direction", &self.direction)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.target_tags.is_empty() {
            state.serialize_entry("targetTags", &self.target_tags)?;
        }
        if !self.target_service_accounts.is_empty() {
            state.serialize_entry("targetServiceAccounts", &self.target_service_accounts)?;
        }
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self.policy_uri.is_empty() {
            state.serialize_entry("policyUri", &self.policy_uri)?;
        }
        if !wkt::internal::is_default(&self.firewall_rule_type) {
            state.serialize_entry("firewallRuleType", &self.firewall_rule_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FirewallInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FirewallInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("direction", &self.direction);
        debug_struct.field("action", &self.action);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("target_tags", &self.target_tags);
        debug_struct.field("target_service_accounts", &self.target_service_accounts);
        debug_struct.field("policy", &self.policy);
        debug_struct.field("policy_uri", &self.policy_uri);
        debug_struct.field("firewall_rule_type", &self.firewall_rule_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FirewallInfo].
pub mod firewall_info {
    #[allow(unused_imports)]
    use super::*;

    /// The firewall rule's type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FirewallRuleType {
        /// Unspecified type.
        Unspecified,
        /// Hierarchical firewall policy rule. For details, see
        /// [Hierarchical firewall policies
        /// overview](https://cloud.google.com/vpc/docs/firewall-policies).
        HierarchicalFirewallPolicyRule,
        /// VPC firewall rule. For details, see
        /// [VPC firewall rules
        /// overview](https://cloud.google.com/vpc/docs/firewalls).
        VpcFirewallRule,
        /// Implied VPC firewall rule. For details, see
        /// [Implied
        /// rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
        ImpliedVpcFirewallRule,
        /// Implicit firewall rules that are managed by serverless VPC access to
        /// allow ingress access. They are not visible in the Google Cloud console.
        /// For details, see [VPC connector's implicit
        /// rules](https://cloud.google.com/functions/docs/networking/connecting-vpc#restrict-access).
        ServerlessVpcAccessManagedFirewallRule,
        /// Global network firewall policy rule.
        /// For details, see [Network firewall
        /// policies](https://cloud.google.com/vpc/docs/network-firewall-policies).
        NetworkFirewallPolicyRule,
        /// Regional network firewall policy rule.
        /// For details, see [Regional network firewall
        /// policies](https://cloud.google.com/firewall/docs/regional-firewall-policies).
        NetworkRegionalFirewallPolicyRule,
        /// Firewall policy rule containing attributes not yet supported in
        /// Connectivity tests. Firewall analysis is skipped if such a rule can
        /// potentially be matched. Please see the [list of unsupported
        /// configurations](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs).
        UnsupportedFirewallPolicyRule,
        /// Tracking state for response traffic created when request traffic goes
        /// through allow firewall rule.
        /// For details, see [firewall rules
        /// specifications](https://cloud.google.com/firewall/docs/firewalls#specifications)
        TrackingState,
        /// Firewall analysis was skipped due to executing Connectivity Test in the
        /// BypassFirewallChecks mode
        AnalysisSkipped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FirewallRuleType::value] or
        /// [FirewallRuleType::name].
        UnknownValue(firewall_rule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firewall_rule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FirewallRuleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HierarchicalFirewallPolicyRule => std::option::Option::Some(1),
                Self::VpcFirewallRule => std::option::Option::Some(2),
                Self::ImpliedVpcFirewallRule => std::option::Option::Some(3),
                Self::ServerlessVpcAccessManagedFirewallRule => std::option::Option::Some(4),
                Self::NetworkFirewallPolicyRule => std::option::Option::Some(5),
                Self::NetworkRegionalFirewallPolicyRule => std::option::Option::Some(6),
                Self::UnsupportedFirewallPolicyRule => std::option::Option::Some(100),
                Self::TrackingState => std::option::Option::Some(101),
                Self::AnalysisSkipped => std::option::Option::Some(102),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIREWALL_RULE_TYPE_UNSPECIFIED"),
                Self::HierarchicalFirewallPolicyRule => {
                    std::option::Option::Some("HIERARCHICAL_FIREWALL_POLICY_RULE")
                }
                Self::VpcFirewallRule => std::option::Option::Some("VPC_FIREWALL_RULE"),
                Self::ImpliedVpcFirewallRule => {
                    std::option::Option::Some("IMPLIED_VPC_FIREWALL_RULE")
                }
                Self::ServerlessVpcAccessManagedFirewallRule => {
                    std::option::Option::Some("SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE")
                }
                Self::NetworkFirewallPolicyRule => {
                    std::option::Option::Some("NETWORK_FIREWALL_POLICY_RULE")
                }
                Self::NetworkRegionalFirewallPolicyRule => {
                    std::option::Option::Some("NETWORK_REGIONAL_FIREWALL_POLICY_RULE")
                }
                Self::UnsupportedFirewallPolicyRule => {
                    std::option::Option::Some("UNSUPPORTED_FIREWALL_POLICY_RULE")
                }
                Self::TrackingState => std::option::Option::Some("TRACKING_STATE"),
                Self::AnalysisSkipped => std::option::Option::Some("ANALYSIS_SKIPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FirewallRuleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FirewallRuleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FirewallRuleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HierarchicalFirewallPolicyRule,
                2 => Self::VpcFirewallRule,
                3 => Self::ImpliedVpcFirewallRule,
                4 => Self::ServerlessVpcAccessManagedFirewallRule,
                5 => Self::NetworkFirewallPolicyRule,
                6 => Self::NetworkRegionalFirewallPolicyRule,
                100 => Self::UnsupportedFirewallPolicyRule,
                101 => Self::TrackingState,
                102 => Self::AnalysisSkipped,
                _ => Self::UnknownValue(firewall_rule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FirewallRuleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIREWALL_RULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HIERARCHICAL_FIREWALL_POLICY_RULE" => Self::HierarchicalFirewallPolicyRule,
                "VPC_FIREWALL_RULE" => Self::VpcFirewallRule,
                "IMPLIED_VPC_FIREWALL_RULE" => Self::ImpliedVpcFirewallRule,
                "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE" => {
                    Self::ServerlessVpcAccessManagedFirewallRule
                }
                "NETWORK_FIREWALL_POLICY_RULE" => Self::NetworkFirewallPolicyRule,
                "NETWORK_REGIONAL_FIREWALL_POLICY_RULE" => Self::NetworkRegionalFirewallPolicyRule,
                "UNSUPPORTED_FIREWALL_POLICY_RULE" => Self::UnsupportedFirewallPolicyRule,
                "TRACKING_STATE" => Self::TrackingState,
                "ANALYSIS_SKIPPED" => Self::AnalysisSkipped,
                _ => Self::UnknownValue(firewall_rule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FirewallRuleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HierarchicalFirewallPolicyRule => serializer.serialize_i32(1),
                Self::VpcFirewallRule => serializer.serialize_i32(2),
                Self::ImpliedVpcFirewallRule => serializer.serialize_i32(3),
                Self::ServerlessVpcAccessManagedFirewallRule => serializer.serialize_i32(4),
                Self::NetworkFirewallPolicyRule => serializer.serialize_i32(5),
                Self::NetworkRegionalFirewallPolicyRule => serializer.serialize_i32(6),
                Self::UnsupportedFirewallPolicyRule => serializer.serialize_i32(100),
                Self::TrackingState => serializer.serialize_i32(101),
                Self::AnalysisSkipped => serializer.serialize_i32(102),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FirewallRuleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FirewallRuleType>::new(
                ".google.cloud.networkmanagement.v1.FirewallInfo.FirewallRuleType",
            ))
        }
    }
}

/// For display only. Metadata associated with a Compute Engine route.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RouteInfo {
    /// Type of route.
    pub route_type: crate::model::route_info::RouteType,

    /// Type of next hop.
    pub next_hop_type: crate::model::route_info::NextHopType,

    /// Indicates where route is applicable. Deprecated, routes with NCC_HUB scope
    /// are not included in the trace in new tests.
    #[deprecated]
    pub route_scope: crate::model::route_info::RouteScope,

    /// Name of a route.
    pub display_name: std::string::String,

    /// URI of a route. SUBNET, STATIC, PEERING_SUBNET (only for peering network)
    /// and POLICY_BASED routes only.
    pub uri: std::string::String,

    /// Region of the route. DYNAMIC, PEERING_DYNAMIC, POLICY_BASED and ADVERTISED
    /// routes only. If set for POLICY_BASED route, this is a region of VLAN
    /// attachments for Cloud Interconnect the route applies to.
    pub region: std::string::String,

    /// Destination IP range of the route.
    pub dest_ip_range: std::string::String,

    /// String type of the next hop of the route (for example, "VPN tunnel").
    /// Deprecated in favor of the next_hop_type and next_hop_uri fields, not used
    /// in new tests.
    #[deprecated]
    pub next_hop: std::string::String,

    /// URI of a VPC network where route is located.
    pub network_uri: std::string::String,

    /// Priority of the route.
    pub priority: i32,

    /// Instance tags of the route.
    pub instance_tags: std::vec::Vec<std::string::String>,

    /// Source IP address range of the route. POLICY_BASED routes only.
    pub src_ip_range: std::string::String,

    /// Destination port ranges of the route. POLICY_BASED routes only.
    pub dest_port_ranges: std::vec::Vec<std::string::String>,

    /// Source port ranges of the route. POLICY_BASED routes only.
    pub src_port_ranges: std::vec::Vec<std::string::String>,

    /// Protocols of the route. POLICY_BASED routes only.
    pub protocols: std::vec::Vec<std::string::String>,

    /// URI of the NCC Hub the route is advertised by. PEERING_SUBNET and
    /// PEERING_DYNAMIC routes that are advertised by NCC Hub only.
    pub ncc_hub_uri: std::option::Option<std::string::String>,

    /// URI of the destination NCC Spoke. PEERING_SUBNET and PEERING_DYNAMIC routes
    /// that are advertised by NCC Hub only.
    pub ncc_spoke_uri: std::option::Option<std::string::String>,

    /// For ADVERTISED dynamic routes, the URI of the Cloud Router that advertised
    /// the corresponding IP prefix.
    pub advertised_route_source_router_uri: std::option::Option<std::string::String>,

    /// For ADVERTISED routes, the URI of their next hop, i.e. the URI of the
    /// hybrid endpoint (VPN tunnel, Interconnect attachment, NCC router appliance)
    /// the advertised prefix is advertised through, or URI of the source peered
    /// network. Deprecated in favor of the next_hop_uri field, not used in new
    /// tests.
    #[deprecated]
    pub advertised_route_next_hop_uri: std::option::Option<std::string::String>,

    /// URI of the next hop resource.
    pub next_hop_uri: std::string::String,

    /// URI of a VPC network where the next hop resource is located.
    pub next_hop_network_uri: std::string::String,

    /// For PEERING_SUBNET and PEERING_STATIC routes, the URI of the originating
    /// SUBNET/STATIC route.
    pub originating_route_uri: std::string::String,

    /// For PEERING_SUBNET, PEERING_STATIC and PEERING_DYNAMIC routes, the name of
    /// the originating SUBNET/STATIC/DYNAMIC route.
    pub originating_route_display_name: std::string::String,

    /// For PEERING_SUBNET and PEERING_DYNAMIC routes that are advertised by NCC
    /// Hub, the URI of the corresponding route in NCC Hub's routing table.
    pub ncc_hub_route_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RouteInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [route_type][crate::model::RouteInfo::route_type].
    pub fn set_route_type<T: std::convert::Into<crate::model::route_info::RouteType>>(
        mut self,
        v: T,
    ) -> Self {
        self.route_type = v.into();
        self
    }

    /// Sets the value of [next_hop_type][crate::model::RouteInfo::next_hop_type].
    pub fn set_next_hop_type<T: std::convert::Into<crate::model::route_info::NextHopType>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_hop_type = v.into();
        self
    }

    /// Sets the value of [route_scope][crate::model::RouteInfo::route_scope].
    #[deprecated]
    pub fn set_route_scope<T: std::convert::Into<crate::model::route_info::RouteScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.route_scope = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RouteInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::RouteInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::RouteInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [dest_ip_range][crate::model::RouteInfo::dest_ip_range].
    pub fn set_dest_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dest_ip_range = v.into();
        self
    }

    /// Sets the value of [next_hop][crate::model::RouteInfo::next_hop].
    #[deprecated]
    pub fn set_next_hop<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_hop = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::RouteInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::RouteInfo::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [instance_tags][crate::model::RouteInfo::instance_tags].
    pub fn set_instance_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_ip_range][crate::model::RouteInfo::src_ip_range].
    pub fn set_src_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.src_ip_range = v.into();
        self
    }

    /// Sets the value of [dest_port_ranges][crate::model::RouteInfo::dest_port_ranges].
    pub fn set_dest_port_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_port_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_port_ranges][crate::model::RouteInfo::src_port_ranges].
    pub fn set_src_port_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_port_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [protocols][crate::model::RouteInfo::protocols].
    pub fn set_protocols<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.protocols = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ncc_hub_uri][crate::model::RouteInfo::ncc_hub_uri].
    pub fn set_ncc_hub_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ncc_hub_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ncc_hub_uri][crate::model::RouteInfo::ncc_hub_uri].
    pub fn set_or_clear_ncc_hub_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ncc_hub_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ncc_spoke_uri][crate::model::RouteInfo::ncc_spoke_uri].
    pub fn set_ncc_spoke_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ncc_spoke_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ncc_spoke_uri][crate::model::RouteInfo::ncc_spoke_uri].
    pub fn set_or_clear_ncc_spoke_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ncc_spoke_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advertised_route_source_router_uri][crate::model::RouteInfo::advertised_route_source_router_uri].
    pub fn set_advertised_route_source_router_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.advertised_route_source_router_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advertised_route_source_router_uri][crate::model::RouteInfo::advertised_route_source_router_uri].
    pub fn set_or_clear_advertised_route_source_router_uri<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.advertised_route_source_router_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advertised_route_next_hop_uri][crate::model::RouteInfo::advertised_route_next_hop_uri].
    #[deprecated]
    pub fn set_advertised_route_next_hop_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.advertised_route_next_hop_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advertised_route_next_hop_uri][crate::model::RouteInfo::advertised_route_next_hop_uri].
    #[deprecated]
    pub fn set_or_clear_advertised_route_next_hop_uri<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.advertised_route_next_hop_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_hop_uri][crate::model::RouteInfo::next_hop_uri].
    pub fn set_next_hop_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_hop_uri = v.into();
        self
    }

    /// Sets the value of [next_hop_network_uri][crate::model::RouteInfo::next_hop_network_uri].
    pub fn set_next_hop_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_hop_network_uri = v.into();
        self
    }

    /// Sets the value of [originating_route_uri][crate::model::RouteInfo::originating_route_uri].
    pub fn set_originating_route_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.originating_route_uri = v.into();
        self
    }

    /// Sets the value of [originating_route_display_name][crate::model::RouteInfo::originating_route_display_name].
    pub fn set_originating_route_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.originating_route_display_name = v.into();
        self
    }

    /// Sets the value of [ncc_hub_route_uri][crate::model::RouteInfo::ncc_hub_route_uri].
    pub fn set_ncc_hub_route_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ncc_hub_route_uri = v.into();
        self
    }
}

impl wkt::message::Message for RouteInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RouteInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RouteInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __route_type,
            __next_hop_type,
            __route_scope,
            __display_name,
            __uri,
            __region,
            __dest_ip_range,
            __next_hop,
            __network_uri,
            __priority,
            __instance_tags,
            __src_ip_range,
            __dest_port_ranges,
            __src_port_ranges,
            __protocols,
            __ncc_hub_uri,
            __ncc_spoke_uri,
            __advertised_route_source_router_uri,
            __advertised_route_next_hop_uri,
            __next_hop_uri,
            __next_hop_network_uri,
            __originating_route_uri,
            __originating_route_display_name,
            __ncc_hub_route_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RouteInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routeType" => Ok(__FieldTag::__route_type),
                            "route_type" => Ok(__FieldTag::__route_type),
                            "nextHopType" => Ok(__FieldTag::__next_hop_type),
                            "next_hop_type" => Ok(__FieldTag::__next_hop_type),
                            "routeScope" => Ok(__FieldTag::__route_scope),
                            "route_scope" => Ok(__FieldTag::__route_scope),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "region" => Ok(__FieldTag::__region),
                            "destIpRange" => Ok(__FieldTag::__dest_ip_range),
                            "dest_ip_range" => Ok(__FieldTag::__dest_ip_range),
                            "nextHop" => Ok(__FieldTag::__next_hop),
                            "next_hop" => Ok(__FieldTag::__next_hop),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "priority" => Ok(__FieldTag::__priority),
                            "instanceTags" => Ok(__FieldTag::__instance_tags),
                            "instance_tags" => Ok(__FieldTag::__instance_tags),
                            "srcIpRange" => Ok(__FieldTag::__src_ip_range),
                            "src_ip_range" => Ok(__FieldTag::__src_ip_range),
                            "destPortRanges" => Ok(__FieldTag::__dest_port_ranges),
                            "dest_port_ranges" => Ok(__FieldTag::__dest_port_ranges),
                            "srcPortRanges" => Ok(__FieldTag::__src_port_ranges),
                            "src_port_ranges" => Ok(__FieldTag::__src_port_ranges),
                            "protocols" => Ok(__FieldTag::__protocols),
                            "nccHubUri" => Ok(__FieldTag::__ncc_hub_uri),
                            "ncc_hub_uri" => Ok(__FieldTag::__ncc_hub_uri),
                            "nccSpokeUri" => Ok(__FieldTag::__ncc_spoke_uri),
                            "ncc_spoke_uri" => Ok(__FieldTag::__ncc_spoke_uri),
                            "advertisedRouteSourceRouterUri" => {
                                Ok(__FieldTag::__advertised_route_source_router_uri)
                            }
                            "advertised_route_source_router_uri" => {
                                Ok(__FieldTag::__advertised_route_source_router_uri)
                            }
                            "advertisedRouteNextHopUri" => {
                                Ok(__FieldTag::__advertised_route_next_hop_uri)
                            }
                            "advertised_route_next_hop_uri" => {
                                Ok(__FieldTag::__advertised_route_next_hop_uri)
                            }
                            "nextHopUri" => Ok(__FieldTag::__next_hop_uri),
                            "next_hop_uri" => Ok(__FieldTag::__next_hop_uri),
                            "nextHopNetworkUri" => Ok(__FieldTag::__next_hop_network_uri),
                            "next_hop_network_uri" => Ok(__FieldTag::__next_hop_network_uri),
                            "originatingRouteUri" => Ok(__FieldTag::__originating_route_uri),
                            "originating_route_uri" => Ok(__FieldTag::__originating_route_uri),
                            "originatingRouteDisplayName" => {
                                Ok(__FieldTag::__originating_route_display_name)
                            }
                            "originating_route_display_name" => {
                                Ok(__FieldTag::__originating_route_display_name)
                            }
                            "nccHubRouteUri" => Ok(__FieldTag::__ncc_hub_route_uri),
                            "ncc_hub_route_uri" => Ok(__FieldTag::__ncc_hub_route_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RouteInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RouteInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__route_type => {
                            if !fields.insert(__FieldTag::__route_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_type",
                                ));
                            }
                            result.route_type = map.next_value::<std::option::Option<crate::model::route_info::RouteType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_hop_type => {
                            if !fields.insert(__FieldTag::__next_hop_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop_type",
                                ));
                            }
                            result.next_hop_type = map.next_value::<std::option::Option<crate::model::route_info::NextHopType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__route_scope => {
                            if !fields.insert(__FieldTag::__route_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_scope",
                                ));
                            }
                            result.route_scope = map.next_value::<std::option::Option<crate::model::route_info::RouteScope>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dest_ip_range => {
                            if !fields.insert(__FieldTag::__dest_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dest_ip_range",
                                ));
                            }
                            result.dest_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_hop => {
                            if !fields.insert(__FieldTag::__next_hop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop",
                                ));
                            }
                            result.next_hop = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance_tags => {
                            if !fields.insert(__FieldTag::__instance_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_tags",
                                ));
                            }
                            result.instance_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__src_ip_range => {
                            if !fields.insert(__FieldTag::__src_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for src_ip_range",
                                ));
                            }
                            result.src_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dest_port_ranges => {
                            if !fields.insert(__FieldTag::__dest_port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dest_port_ranges",
                                ));
                            }
                            result.dest_port_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__src_port_ranges => {
                            if !fields.insert(__FieldTag::__src_port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for src_port_ranges",
                                ));
                            }
                            result.src_port_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__protocols => {
                            if !fields.insert(__FieldTag::__protocols) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocols",
                                ));
                            }
                            result.protocols = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ncc_hub_uri => {
                            if !fields.insert(__FieldTag::__ncc_hub_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ncc_hub_uri",
                                ));
                            }
                            result.ncc_hub_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ncc_spoke_uri => {
                            if !fields.insert(__FieldTag::__ncc_spoke_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ncc_spoke_uri",
                                ));
                            }
                            result.ncc_spoke_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__advertised_route_source_router_uri => {
                            if !fields.insert(__FieldTag::__advertised_route_source_router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advertised_route_source_router_uri",
                                ));
                            }
                            result.advertised_route_source_router_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__advertised_route_next_hop_uri => {
                            if !fields.insert(__FieldTag::__advertised_route_next_hop_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advertised_route_next_hop_uri",
                                ));
                            }
                            result.advertised_route_next_hop_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_hop_uri => {
                            if !fields.insert(__FieldTag::__next_hop_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop_uri",
                                ));
                            }
                            result.next_hop_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_hop_network_uri => {
                            if !fields.insert(__FieldTag::__next_hop_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop_network_uri",
                                ));
                            }
                            result.next_hop_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__originating_route_uri => {
                            if !fields.insert(__FieldTag::__originating_route_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for originating_route_uri",
                                ));
                            }
                            result.originating_route_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__originating_route_display_name => {
                            if !fields.insert(__FieldTag::__originating_route_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for originating_route_display_name",
                                ));
                            }
                            result.originating_route_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ncc_hub_route_uri => {
                            if !fields.insert(__FieldTag::__ncc_hub_route_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ncc_hub_route_uri",
                                ));
                            }
                            result.ncc_hub_route_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RouteInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.route_type) {
            state.serialize_entry("routeType", &self.route_type)?;
        }
        if !wkt::internal::is_default(&self.next_hop_type) {
            state.serialize_entry("nextHopType", &self.next_hop_type)?;
        }
        if !wkt::internal::is_default(&self.route_scope) {
            state.serialize_entry("routeScope", &self.route_scope)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.dest_ip_range.is_empty() {
            state.serialize_entry("destIpRange", &self.dest_ip_range)?;
        }
        if !self.next_hop.is_empty() {
            state.serialize_entry("nextHop", &self.next_hop)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.instance_tags.is_empty() {
            state.serialize_entry("instanceTags", &self.instance_tags)?;
        }
        if !self.src_ip_range.is_empty() {
            state.serialize_entry("srcIpRange", &self.src_ip_range)?;
        }
        if !self.dest_port_ranges.is_empty() {
            state.serialize_entry("destPortRanges", &self.dest_port_ranges)?;
        }
        if !self.src_port_ranges.is_empty() {
            state.serialize_entry("srcPortRanges", &self.src_port_ranges)?;
        }
        if !self.protocols.is_empty() {
            state.serialize_entry("protocols", &self.protocols)?;
        }
        if self.ncc_hub_uri.is_some() {
            state.serialize_entry("nccHubUri", &self.ncc_hub_uri)?;
        }
        if self.ncc_spoke_uri.is_some() {
            state.serialize_entry("nccSpokeUri", &self.ncc_spoke_uri)?;
        }
        if self.advertised_route_source_router_uri.is_some() {
            state.serialize_entry(
                "advertisedRouteSourceRouterUri",
                &self.advertised_route_source_router_uri,
            )?;
        }
        if self.advertised_route_next_hop_uri.is_some() {
            state.serialize_entry(
                "advertisedRouteNextHopUri",
                &self.advertised_route_next_hop_uri,
            )?;
        }
        if !self.next_hop_uri.is_empty() {
            state.serialize_entry("nextHopUri", &self.next_hop_uri)?;
        }
        if !self.next_hop_network_uri.is_empty() {
            state.serialize_entry("nextHopNetworkUri", &self.next_hop_network_uri)?;
        }
        if !self.originating_route_uri.is_empty() {
            state.serialize_entry("originatingRouteUri", &self.originating_route_uri)?;
        }
        if !self.originating_route_display_name.is_empty() {
            state.serialize_entry(
                "originatingRouteDisplayName",
                &self.originating_route_display_name,
            )?;
        }
        if !self.ncc_hub_route_uri.is_empty() {
            state.serialize_entry("nccHubRouteUri", &self.ncc_hub_route_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RouteInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RouteInfo");
        debug_struct.field("route_type", &self.route_type);
        debug_struct.field("next_hop_type", &self.next_hop_type);
        debug_struct.field("route_scope", &self.route_scope);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("region", &self.region);
        debug_struct.field("dest_ip_range", &self.dest_ip_range);
        debug_struct.field("next_hop", &self.next_hop);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("instance_tags", &self.instance_tags);
        debug_struct.field("src_ip_range", &self.src_ip_range);
        debug_struct.field("dest_port_ranges", &self.dest_port_ranges);
        debug_struct.field("src_port_ranges", &self.src_port_ranges);
        debug_struct.field("protocols", &self.protocols);
        debug_struct.field("ncc_hub_uri", &self.ncc_hub_uri);
        debug_struct.field("ncc_spoke_uri", &self.ncc_spoke_uri);
        debug_struct.field(
            "advertised_route_source_router_uri",
            &self.advertised_route_source_router_uri,
        );
        debug_struct.field(
            "advertised_route_next_hop_uri",
            &self.advertised_route_next_hop_uri,
        );
        debug_struct.field("next_hop_uri", &self.next_hop_uri);
        debug_struct.field("next_hop_network_uri", &self.next_hop_network_uri);
        debug_struct.field("originating_route_uri", &self.originating_route_uri);
        debug_struct.field(
            "originating_route_display_name",
            &self.originating_route_display_name,
        );
        debug_struct.field("ncc_hub_route_uri", &self.ncc_hub_route_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RouteInfo].
pub mod route_info {
    #[allow(unused_imports)]
    use super::*;

    /// Type of route:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RouteType {
        /// Unspecified type. Default value.
        Unspecified,
        /// Route is a subnet route automatically created by the system.
        Subnet,
        /// Static route created by the user, including the default route to the
        /// internet.
        Static,
        /// Dynamic route exchanged between BGP peers.
        Dynamic,
        /// A subnet route received from peering network or NCC Hub.
        PeeringSubnet,
        /// A static route received from peering network.
        PeeringStatic,
        /// A dynamic route received from peering network or NCC Hub.
        PeeringDynamic,
        /// Policy based route.
        PolicyBased,
        /// Advertised route. Synthetic route which is used to transition from the
        /// StartFromPrivateNetwork state in Connectivity tests.
        Advertised,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RouteType::value] or
        /// [RouteType::name].
        UnknownValue(route_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod route_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RouteType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Subnet => std::option::Option::Some(1),
                Self::Static => std::option::Option::Some(2),
                Self::Dynamic => std::option::Option::Some(3),
                Self::PeeringSubnet => std::option::Option::Some(4),
                Self::PeeringStatic => std::option::Option::Some(5),
                Self::PeeringDynamic => std::option::Option::Some(6),
                Self::PolicyBased => std::option::Option::Some(7),
                Self::Advertised => std::option::Option::Some(101),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTE_TYPE_UNSPECIFIED"),
                Self::Subnet => std::option::Option::Some("SUBNET"),
                Self::Static => std::option::Option::Some("STATIC"),
                Self::Dynamic => std::option::Option::Some("DYNAMIC"),
                Self::PeeringSubnet => std::option::Option::Some("PEERING_SUBNET"),
                Self::PeeringStatic => std::option::Option::Some("PEERING_STATIC"),
                Self::PeeringDynamic => std::option::Option::Some("PEERING_DYNAMIC"),
                Self::PolicyBased => std::option::Option::Some("POLICY_BASED"),
                Self::Advertised => std::option::Option::Some("ADVERTISED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RouteType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RouteType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RouteType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Subnet,
                2 => Self::Static,
                3 => Self::Dynamic,
                4 => Self::PeeringSubnet,
                5 => Self::PeeringStatic,
                6 => Self::PeeringDynamic,
                7 => Self::PolicyBased,
                101 => Self::Advertised,
                _ => Self::UnknownValue(route_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RouteType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SUBNET" => Self::Subnet,
                "STATIC" => Self::Static,
                "DYNAMIC" => Self::Dynamic,
                "PEERING_SUBNET" => Self::PeeringSubnet,
                "PEERING_STATIC" => Self::PeeringStatic,
                "PEERING_DYNAMIC" => Self::PeeringDynamic,
                "POLICY_BASED" => Self::PolicyBased,
                "ADVERTISED" => Self::Advertised,
                _ => Self::UnknownValue(route_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RouteType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Subnet => serializer.serialize_i32(1),
                Self::Static => serializer.serialize_i32(2),
                Self::Dynamic => serializer.serialize_i32(3),
                Self::PeeringSubnet => serializer.serialize_i32(4),
                Self::PeeringStatic => serializer.serialize_i32(5),
                Self::PeeringDynamic => serializer.serialize_i32(6),
                Self::PolicyBased => serializer.serialize_i32(7),
                Self::Advertised => serializer.serialize_i32(101),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RouteType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RouteType>::new(
                ".google.cloud.networkmanagement.v1.RouteInfo.RouteType",
            ))
        }
    }

    /// Type of next hop:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NextHopType {
        /// Unspecified type. Default value.
        Unspecified,
        /// Next hop is an IP address.
        NextHopIp,
        /// Next hop is a Compute Engine instance.
        NextHopInstance,
        /// Next hop is a VPC network gateway.
        NextHopNetwork,
        /// Next hop is a peering VPC. This scenario only happens when the user
        /// doesn't have permissions to the project where the next hop resource is
        /// located.
        NextHopPeering,
        /// Next hop is an interconnect.
        NextHopInterconnect,
        /// Next hop is a VPN tunnel.
        NextHopVpnTunnel,
        /// Next hop is a VPN gateway. This scenario only happens when tracing
        /// connectivity from an on-premises network to Google Cloud through a VPN.
        /// The analysis simulates a packet departing from the on-premises network
        /// through a VPN tunnel and arriving at a Cloud VPN gateway.
        NextHopVpnGateway,
        /// Next hop is an internet gateway.
        NextHopInternetGateway,
        /// Next hop is blackhole; that is, the next hop either does not exist or is
        /// unusable.
        NextHopBlackhole,
        /// Next hop is the forwarding rule of an Internal Load Balancer.
        NextHopIlb,
        /// Next hop is a
        /// [router appliance
        /// instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
        NextHopRouterAppliance,
        /// Next hop is an NCC hub. This scenario only happens when the user doesn't
        /// have permissions to the project where the next hop resource is located.
        NextHopNccHub,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NextHopType::value] or
        /// [NextHopType::name].
        UnknownValue(next_hop_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod next_hop_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NextHopType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NextHopIp => std::option::Option::Some(1),
                Self::NextHopInstance => std::option::Option::Some(2),
                Self::NextHopNetwork => std::option::Option::Some(3),
                Self::NextHopPeering => std::option::Option::Some(4),
                Self::NextHopInterconnect => std::option::Option::Some(5),
                Self::NextHopVpnTunnel => std::option::Option::Some(6),
                Self::NextHopVpnGateway => std::option::Option::Some(7),
                Self::NextHopInternetGateway => std::option::Option::Some(8),
                Self::NextHopBlackhole => std::option::Option::Some(9),
                Self::NextHopIlb => std::option::Option::Some(10),
                Self::NextHopRouterAppliance => std::option::Option::Some(11),
                Self::NextHopNccHub => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NEXT_HOP_TYPE_UNSPECIFIED"),
                Self::NextHopIp => std::option::Option::Some("NEXT_HOP_IP"),
                Self::NextHopInstance => std::option::Option::Some("NEXT_HOP_INSTANCE"),
                Self::NextHopNetwork => std::option::Option::Some("NEXT_HOP_NETWORK"),
                Self::NextHopPeering => std::option::Option::Some("NEXT_HOP_PEERING"),
                Self::NextHopInterconnect => std::option::Option::Some("NEXT_HOP_INTERCONNECT"),
                Self::NextHopVpnTunnel => std::option::Option::Some("NEXT_HOP_VPN_TUNNEL"),
                Self::NextHopVpnGateway => std::option::Option::Some("NEXT_HOP_VPN_GATEWAY"),
                Self::NextHopInternetGateway => {
                    std::option::Option::Some("NEXT_HOP_INTERNET_GATEWAY")
                }
                Self::NextHopBlackhole => std::option::Option::Some("NEXT_HOP_BLACKHOLE"),
                Self::NextHopIlb => std::option::Option::Some("NEXT_HOP_ILB"),
                Self::NextHopRouterAppliance => {
                    std::option::Option::Some("NEXT_HOP_ROUTER_APPLIANCE")
                }
                Self::NextHopNccHub => std::option::Option::Some("NEXT_HOP_NCC_HUB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NextHopType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NextHopType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NextHopType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NextHopIp,
                2 => Self::NextHopInstance,
                3 => Self::NextHopNetwork,
                4 => Self::NextHopPeering,
                5 => Self::NextHopInterconnect,
                6 => Self::NextHopVpnTunnel,
                7 => Self::NextHopVpnGateway,
                8 => Self::NextHopInternetGateway,
                9 => Self::NextHopBlackhole,
                10 => Self::NextHopIlb,
                11 => Self::NextHopRouterAppliance,
                12 => Self::NextHopNccHub,
                _ => Self::UnknownValue(next_hop_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NextHopType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NEXT_HOP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NEXT_HOP_IP" => Self::NextHopIp,
                "NEXT_HOP_INSTANCE" => Self::NextHopInstance,
                "NEXT_HOP_NETWORK" => Self::NextHopNetwork,
                "NEXT_HOP_PEERING" => Self::NextHopPeering,
                "NEXT_HOP_INTERCONNECT" => Self::NextHopInterconnect,
                "NEXT_HOP_VPN_TUNNEL" => Self::NextHopVpnTunnel,
                "NEXT_HOP_VPN_GATEWAY" => Self::NextHopVpnGateway,
                "NEXT_HOP_INTERNET_GATEWAY" => Self::NextHopInternetGateway,
                "NEXT_HOP_BLACKHOLE" => Self::NextHopBlackhole,
                "NEXT_HOP_ILB" => Self::NextHopIlb,
                "NEXT_HOP_ROUTER_APPLIANCE" => Self::NextHopRouterAppliance,
                "NEXT_HOP_NCC_HUB" => Self::NextHopNccHub,
                _ => Self::UnknownValue(next_hop_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NextHopType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NextHopIp => serializer.serialize_i32(1),
                Self::NextHopInstance => serializer.serialize_i32(2),
                Self::NextHopNetwork => serializer.serialize_i32(3),
                Self::NextHopPeering => serializer.serialize_i32(4),
                Self::NextHopInterconnect => serializer.serialize_i32(5),
                Self::NextHopVpnTunnel => serializer.serialize_i32(6),
                Self::NextHopVpnGateway => serializer.serialize_i32(7),
                Self::NextHopInternetGateway => serializer.serialize_i32(8),
                Self::NextHopBlackhole => serializer.serialize_i32(9),
                Self::NextHopIlb => serializer.serialize_i32(10),
                Self::NextHopRouterAppliance => serializer.serialize_i32(11),
                Self::NextHopNccHub => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NextHopType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NextHopType>::new(
                ".google.cloud.networkmanagement.v1.RouteInfo.NextHopType",
            ))
        }
    }

    /// Indicates where routes are applicable.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RouteScope {
        /// Unspecified scope. Default value.
        Unspecified,
        /// Route is applicable to packets in Network.
        Network,
        /// Route is applicable to packets using NCC Hub's routing table.
        NccHub,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RouteScope::value] or
        /// [RouteScope::name].
        UnknownValue(route_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod route_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RouteScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::NccHub => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTE_SCOPE_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("NETWORK"),
                Self::NccHub => std::option::Option::Some("NCC_HUB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RouteScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RouteScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RouteScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::NccHub,
                _ => Self::UnknownValue(route_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RouteScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTE_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "NETWORK" => Self::Network,
                "NCC_HUB" => Self::NccHub,
                _ => Self::UnknownValue(route_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RouteScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::NccHub => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RouteScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RouteScope>::new(
                ".google.cloud.networkmanagement.v1.RouteInfo.RouteScope",
            ))
        }
    }
}

/// For display only. Details of a Google Service sending packets to a
/// VPC network. Although the source IP might be a publicly routable address,
/// some Google Services use special routes within Google production
/// infrastructure to reach Compute Engine Instances.
/// <https://cloud.google.com/vpc/docs/routes#special_return_paths>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleServiceInfo {
    /// Source IP address.
    pub source_ip: std::string::String,

    /// Recognized type of a Google Service.
    pub google_service_type: crate::model::google_service_info::GoogleServiceType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleServiceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_ip][crate::model::GoogleServiceInfo::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [google_service_type][crate::model::GoogleServiceInfo::google_service_type].
    pub fn set_google_service_type<
        T: std::convert::Into<crate::model::google_service_info::GoogleServiceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_service_type = v.into();
        self
    }
}

impl wkt::message::Message for GoogleServiceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GoogleServiceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleServiceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_ip,
            __google_service_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleServiceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "googleServiceType" => Ok(__FieldTag::__google_service_type),
                            "google_service_type" => Ok(__FieldTag::__google_service_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleServiceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleServiceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_service_type => {
                            if !fields.insert(__FieldTag::__google_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_service_type",
                                ));
                            }
                            result.google_service_type = map
                                .next_value::<std::option::Option<
                                    crate::model::google_service_info::GoogleServiceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleServiceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !wkt::internal::is_default(&self.google_service_type) {
            state.serialize_entry("googleServiceType", &self.google_service_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GoogleServiceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleServiceInfo");
        debug_struct.field("source_ip", &self.source_ip);
        debug_struct.field("google_service_type", &self.google_service_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GoogleServiceInfo].
pub mod google_service_info {
    #[allow(unused_imports)]
    use super::*;

    /// Recognized type of a Google Service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GoogleServiceType {
        /// Unspecified Google Service.
        Unspecified,
        /// Identity aware proxy.
        /// <https://cloud.google.com/iap/docs/using-tcp-forwarding>
        Iap,
        /// One of two services sharing IP ranges:
        ///
        /// * Load Balancer proxy
        /// * Centralized Health Check prober
        ///   <https://cloud.google.com/load-balancing/docs/firewall-rules>
        GfeProxyOrHealthCheckProber,
        /// Connectivity from Cloud DNS to forwarding targets or alternate name
        /// servers that use private routing.
        /// <https://cloud.google.com/dns/docs/zones/forwarding-zones#firewall-rules>
        /// <https://cloud.google.com/dns/docs/policies#firewall-rules>
        CloudDns,
        /// private.googleapis.com and restricted.googleapis.com
        GoogleApi,
        /// Google API via Private Service Connect.
        /// <https://cloud.google.com/vpc/docs/configure-private-service-connect-apis>
        GoogleApiPsc,
        /// Google API via VPC Service Controls.
        /// <https://cloud.google.com/vpc/docs/configure-private-service-connect-apis>
        GoogleApiVpcSc,
        /// Google API via Serverless VPC Access.
        /// <https://cloud.google.com/vpc/docs/serverless-vpc-access>
        ServerlessVpcAccess,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GoogleServiceType::value] or
        /// [GoogleServiceType::name].
        UnknownValue(google_service_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod google_service_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GoogleServiceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Iap => std::option::Option::Some(1),
                Self::GfeProxyOrHealthCheckProber => std::option::Option::Some(2),
                Self::CloudDns => std::option::Option::Some(3),
                Self::GoogleApi => std::option::Option::Some(4),
                Self::GoogleApiPsc => std::option::Option::Some(5),
                Self::GoogleApiVpcSc => std::option::Option::Some(6),
                Self::ServerlessVpcAccess => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GOOGLE_SERVICE_TYPE_UNSPECIFIED"),
                Self::Iap => std::option::Option::Some("IAP"),
                Self::GfeProxyOrHealthCheckProber => {
                    std::option::Option::Some("GFE_PROXY_OR_HEALTH_CHECK_PROBER")
                }
                Self::CloudDns => std::option::Option::Some("CLOUD_DNS"),
                Self::GoogleApi => std::option::Option::Some("GOOGLE_API"),
                Self::GoogleApiPsc => std::option::Option::Some("GOOGLE_API_PSC"),
                Self::GoogleApiVpcSc => std::option::Option::Some("GOOGLE_API_VPC_SC"),
                Self::ServerlessVpcAccess => std::option::Option::Some("SERVERLESS_VPC_ACCESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GoogleServiceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GoogleServiceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GoogleServiceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Iap,
                2 => Self::GfeProxyOrHealthCheckProber,
                3 => Self::CloudDns,
                4 => Self::GoogleApi,
                5 => Self::GoogleApiPsc,
                6 => Self::GoogleApiVpcSc,
                7 => Self::ServerlessVpcAccess,
                _ => Self::UnknownValue(google_service_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GoogleServiceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GOOGLE_SERVICE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IAP" => Self::Iap,
                "GFE_PROXY_OR_HEALTH_CHECK_PROBER" => Self::GfeProxyOrHealthCheckProber,
                "CLOUD_DNS" => Self::CloudDns,
                "GOOGLE_API" => Self::GoogleApi,
                "GOOGLE_API_PSC" => Self::GoogleApiPsc,
                "GOOGLE_API_VPC_SC" => Self::GoogleApiVpcSc,
                "SERVERLESS_VPC_ACCESS" => Self::ServerlessVpcAccess,
                _ => Self::UnknownValue(google_service_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GoogleServiceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Iap => serializer.serialize_i32(1),
                Self::GfeProxyOrHealthCheckProber => serializer.serialize_i32(2),
                Self::CloudDns => serializer.serialize_i32(3),
                Self::GoogleApi => serializer.serialize_i32(4),
                Self::GoogleApiPsc => serializer.serialize_i32(5),
                Self::GoogleApiVpcSc => serializer.serialize_i32(6),
                Self::ServerlessVpcAccess => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GoogleServiceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GoogleServiceType>::new(
                ".google.cloud.networkmanagement.v1.GoogleServiceInfo.GoogleServiceType",
            ))
        }
    }
}

/// For display only. Metadata associated with a Compute Engine forwarding rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ForwardingRuleInfo {
    /// Name of the forwarding rule.
    pub display_name: std::string::String,

    /// URI of the forwarding rule.
    pub uri: std::string::String,

    /// Protocol defined in the forwarding rule that matches the packet.
    pub matched_protocol: std::string::String,

    /// Port range defined in the forwarding rule that matches the packet.
    pub matched_port_range: std::string::String,

    /// VIP of the forwarding rule.
    pub vip: std::string::String,

    /// Target type of the forwarding rule.
    pub target: std::string::String,

    /// Network URI.
    pub network_uri: std::string::String,

    /// Region of the forwarding rule. Set only for regional forwarding rules.
    pub region: std::string::String,

    /// Name of the load balancer the forwarding rule belongs to. Empty for
    /// forwarding rules not related to load balancers (like PSC forwarding rules).
    pub load_balancer_name: std::string::String,

    /// URI of the PSC service attachment this forwarding rule targets (if
    /// applicable).
    pub psc_service_attachment_uri: std::string::String,

    /// PSC Google API target this forwarding rule targets (if applicable).
    pub psc_google_api_target: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForwardingRuleInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::ForwardingRuleInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ForwardingRuleInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [matched_protocol][crate::model::ForwardingRuleInfo::matched_protocol].
    pub fn set_matched_protocol<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_protocol = v.into();
        self
    }

    /// Sets the value of [matched_port_range][crate::model::ForwardingRuleInfo::matched_port_range].
    pub fn set_matched_port_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.matched_port_range = v.into();
        self
    }

    /// Sets the value of [vip][crate::model::ForwardingRuleInfo::vip].
    pub fn set_vip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vip = v.into();
        self
    }

    /// Sets the value of [target][crate::model::ForwardingRuleInfo::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::ForwardingRuleInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ForwardingRuleInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [load_balancer_name][crate::model::ForwardingRuleInfo::load_balancer_name].
    pub fn set_load_balancer_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_name = v.into();
        self
    }

    /// Sets the value of [psc_service_attachment_uri][crate::model::ForwardingRuleInfo::psc_service_attachment_uri].
    pub fn set_psc_service_attachment_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_service_attachment_uri = v.into();
        self
    }

    /// Sets the value of [psc_google_api_target][crate::model::ForwardingRuleInfo::psc_google_api_target].
    pub fn set_psc_google_api_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_google_api_target = v.into();
        self
    }
}

impl wkt::message::Message for ForwardingRuleInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ForwardingRuleInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForwardingRuleInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __matched_protocol,
            __matched_port_range,
            __vip,
            __target,
            __network_uri,
            __region,
            __load_balancer_name,
            __psc_service_attachment_uri,
            __psc_google_api_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardingRuleInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "matchedProtocol" => Ok(__FieldTag::__matched_protocol),
                            "matched_protocol" => Ok(__FieldTag::__matched_protocol),
                            "matchedPortRange" => Ok(__FieldTag::__matched_port_range),
                            "matched_port_range" => Ok(__FieldTag::__matched_port_range),
                            "vip" => Ok(__FieldTag::__vip),
                            "target" => Ok(__FieldTag::__target),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "region" => Ok(__FieldTag::__region),
                            "loadBalancerName" => Ok(__FieldTag::__load_balancer_name),
                            "load_balancer_name" => Ok(__FieldTag::__load_balancer_name),
                            "pscServiceAttachmentUri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "psc_service_attachment_uri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForwardingRuleInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardingRuleInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_protocol => {
                            if !fields.insert(__FieldTag::__matched_protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_protocol",
                                ));
                            }
                            result.matched_protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_port_range => {
                            if !fields.insert(__FieldTag::__matched_port_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_port_range",
                                ));
                            }
                            result.matched_port_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vip => {
                            if !fields.insert(__FieldTag::__vip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vip",
                                ));
                            }
                            result.vip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__load_balancer_name => {
                            if !fields.insert(__FieldTag::__load_balancer_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_name",
                                ));
                            }
                            result.load_balancer_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_service_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_service_attachment_uri",
                                ));
                            }
                            result.psc_service_attachment_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_google_api_target",
                                ));
                            }
                            result.psc_google_api_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForwardingRuleInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.matched_protocol.is_empty() {
            state.serialize_entry("matchedProtocol", &self.matched_protocol)?;
        }
        if !self.matched_port_range.is_empty() {
            state.serialize_entry("matchedPortRange", &self.matched_port_range)?;
        }
        if !self.vip.is_empty() {
            state.serialize_entry("vip", &self.vip)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.load_balancer_name.is_empty() {
            state.serialize_entry("loadBalancerName", &self.load_balancer_name)?;
        }
        if !self.psc_service_attachment_uri.is_empty() {
            state.serialize_entry("pscServiceAttachmentUri", &self.psc_service_attachment_uri)?;
        }
        if !self.psc_google_api_target.is_empty() {
            state.serialize_entry("pscGoogleApiTarget", &self.psc_google_api_target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ForwardingRuleInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForwardingRuleInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("matched_protocol", &self.matched_protocol);
        debug_struct.field("matched_port_range", &self.matched_port_range);
        debug_struct.field("vip", &self.vip);
        debug_struct.field("target", &self.target);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("region", &self.region);
        debug_struct.field("load_balancer_name", &self.load_balancer_name);
        debug_struct.field(
            "psc_service_attachment_uri",
            &self.psc_service_attachment_uri,
        );
        debug_struct.field("psc_google_api_target", &self.psc_google_api_target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a load balancer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadBalancerInfo {
    /// Type of the load balancer.
    pub load_balancer_type: crate::model::load_balancer_info::LoadBalancerType,

    /// URI of the health check for the load balancer. Deprecated and no longer
    /// populated as different load balancer backends might have different health
    /// checks.
    #[deprecated]
    pub health_check_uri: std::string::String,

    /// Information for the loadbalancer backends.
    pub backends: std::vec::Vec<crate::model::LoadBalancerBackend>,

    /// Type of load balancer's backend configuration.
    pub backend_type: crate::model::load_balancer_info::BackendType,

    /// Backend configuration URI.
    pub backend_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadBalancerInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [load_balancer_type][crate::model::LoadBalancerInfo::load_balancer_type].
    pub fn set_load_balancer_type<
        T: std::convert::Into<crate::model::load_balancer_info::LoadBalancerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_type = v.into();
        self
    }

    /// Sets the value of [health_check_uri][crate::model::LoadBalancerInfo::health_check_uri].
    #[deprecated]
    pub fn set_health_check_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_uri = v.into();
        self
    }

    /// Sets the value of [backends][crate::model::LoadBalancerInfo::backends].
    pub fn set_backends<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LoadBalancerBackend>,
    {
        use std::iter::Iterator;
        self.backends = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backend_type][crate::model::LoadBalancerInfo::backend_type].
    pub fn set_backend_type<
        T: std::convert::Into<crate::model::load_balancer_info::BackendType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [backend_uri][crate::model::LoadBalancerInfo::backend_uri].
    pub fn set_backend_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backend_uri = v.into();
        self
    }
}

impl wkt::message::Message for LoadBalancerInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LoadBalancerInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadBalancerInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __load_balancer_type,
            __health_check_uri,
            __backends,
            __backend_type,
            __backend_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            "healthCheckUri" => Ok(__FieldTag::__health_check_uri),
                            "health_check_uri" => Ok(__FieldTag::__health_check_uri),
                            "backends" => Ok(__FieldTag::__backends),
                            "backendType" => Ok(__FieldTag::__backend_type),
                            "backend_type" => Ok(__FieldTag::__backend_type),
                            "backendUri" => Ok(__FieldTag::__backend_uri),
                            "backend_uri" => Ok(__FieldTag::__backend_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadBalancerInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map
                                .next_value::<std::option::Option<
                                    crate::model::load_balancer_info::LoadBalancerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_uri => {
                            if !fields.insert(__FieldTag::__health_check_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_uri",
                                ));
                            }
                            result.health_check_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backends => {
                            if !fields.insert(__FieldTag::__backends) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backends",
                                ));
                            }
                            result.backends = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LoadBalancerBackend>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_type => {
                            if !fields.insert(__FieldTag::__backend_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_type",
                                ));
                            }
                            result.backend_type =
                                map.next_value::<std::option::Option<
                                    crate::model::load_balancer_info::BackendType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_uri => {
                            if !fields.insert(__FieldTag::__backend_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_uri",
                                ));
                            }
                            result.backend_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadBalancerInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.load_balancer_type) {
            state.serialize_entry("loadBalancerType", &self.load_balancer_type)?;
        }
        if !self.health_check_uri.is_empty() {
            state.serialize_entry("healthCheckUri", &self.health_check_uri)?;
        }
        if !self.backends.is_empty() {
            state.serialize_entry("backends", &self.backends)?;
        }
        if !wkt::internal::is_default(&self.backend_type) {
            state.serialize_entry("backendType", &self.backend_type)?;
        }
        if !self.backend_uri.is_empty() {
            state.serialize_entry("backendUri", &self.backend_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadBalancerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadBalancerInfo");
        debug_struct.field("load_balancer_type", &self.load_balancer_type);
        debug_struct.field("health_check_uri", &self.health_check_uri);
        debug_struct.field("backends", &self.backends);
        debug_struct.field("backend_type", &self.backend_type);
        debug_struct.field("backend_uri", &self.backend_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LoadBalancerInfo].
pub mod load_balancer_info {
    #[allow(unused_imports)]
    use super::*;

    /// The type definition for a load balancer:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoadBalancerType {
        /// Type is unspecified.
        Unspecified,
        /// Internal TCP/UDP load balancer.
        InternalTcpUdp,
        /// Network TCP/UDP load balancer.
        NetworkTcpUdp,
        /// HTTP(S) proxy load balancer.
        HttpProxy,
        /// TCP proxy load balancer.
        TcpProxy,
        /// SSL proxy load balancer.
        SslProxy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoadBalancerType::value] or
        /// [LoadBalancerType::name].
        UnknownValue(load_balancer_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod load_balancer_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoadBalancerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InternalTcpUdp => std::option::Option::Some(1),
                Self::NetworkTcpUdp => std::option::Option::Some(2),
                Self::HttpProxy => std::option::Option::Some(3),
                Self::TcpProxy => std::option::Option::Some(4),
                Self::SslProxy => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOAD_BALANCER_TYPE_UNSPECIFIED"),
                Self::InternalTcpUdp => std::option::Option::Some("INTERNAL_TCP_UDP"),
                Self::NetworkTcpUdp => std::option::Option::Some("NETWORK_TCP_UDP"),
                Self::HttpProxy => std::option::Option::Some("HTTP_PROXY"),
                Self::TcpProxy => std::option::Option::Some("TCP_PROXY"),
                Self::SslProxy => std::option::Option::Some("SSL_PROXY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoadBalancerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoadBalancerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoadBalancerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InternalTcpUdp,
                2 => Self::NetworkTcpUdp,
                3 => Self::HttpProxy,
                4 => Self::TcpProxy,
                5 => Self::SslProxy,
                _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoadBalancerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOAD_BALANCER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INTERNAL_TCP_UDP" => Self::InternalTcpUdp,
                "NETWORK_TCP_UDP" => Self::NetworkTcpUdp,
                "HTTP_PROXY" => Self::HttpProxy,
                "TCP_PROXY" => Self::TcpProxy,
                "SSL_PROXY" => Self::SslProxy,
                _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoadBalancerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InternalTcpUdp => serializer.serialize_i32(1),
                Self::NetworkTcpUdp => serializer.serialize_i32(2),
                Self::HttpProxy => serializer.serialize_i32(3),
                Self::TcpProxy => serializer.serialize_i32(4),
                Self::SslProxy => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoadBalancerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoadBalancerType>::new(
                ".google.cloud.networkmanagement.v1.LoadBalancerInfo.LoadBalancerType",
            ))
        }
    }

    /// The type definition for a load balancer backend configuration:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackendType {
        /// Type is unspecified.
        Unspecified,
        /// Backend Service as the load balancer's backend.
        BackendService,
        /// Target Pool as the load balancer's backend.
        TargetPool,
        /// Target Instance as the load balancer's backend.
        TargetInstance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackendType::value] or
        /// [BackendType::name].
        UnknownValue(backend_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backend_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackendType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BackendService => std::option::Option::Some(1),
                Self::TargetPool => std::option::Option::Some(2),
                Self::TargetInstance => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKEND_TYPE_UNSPECIFIED"),
                Self::BackendService => std::option::Option::Some("BACKEND_SERVICE"),
                Self::TargetPool => std::option::Option::Some("TARGET_POOL"),
                Self::TargetInstance => std::option::Option::Some("TARGET_INSTANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackendType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackendType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackendType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BackendService,
                2 => Self::TargetPool,
                3 => Self::TargetInstance,
                _ => Self::UnknownValue(backend_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackendType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKEND_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BACKEND_SERVICE" => Self::BackendService,
                "TARGET_POOL" => Self::TargetPool,
                "TARGET_INSTANCE" => Self::TargetInstance,
                _ => Self::UnknownValue(backend_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackendType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BackendService => serializer.serialize_i32(1),
                Self::TargetPool => serializer.serialize_i32(2),
                Self::TargetInstance => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackendType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackendType>::new(
                ".google.cloud.networkmanagement.v1.LoadBalancerInfo.BackendType",
            ))
        }
    }
}

/// For display only. Metadata associated with a specific load balancer backend.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadBalancerBackend {
    /// Name of a Compute Engine instance or network endpoint.
    pub display_name: std::string::String,

    /// URI of a Compute Engine instance or network endpoint.
    pub uri: std::string::String,

    /// State of the health check firewall configuration.
    pub health_check_firewall_state: crate::model::load_balancer_backend::HealthCheckFirewallState,

    /// A list of firewall rule URIs allowing probes from health check IP ranges.
    pub health_check_allowing_firewall_rules: std::vec::Vec<std::string::String>,

    /// A list of firewall rule URIs blocking probes from health check IP ranges.
    pub health_check_blocking_firewall_rules: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadBalancerBackend {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::LoadBalancerBackend::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::LoadBalancerBackend::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [health_check_firewall_state][crate::model::LoadBalancerBackend::health_check_firewall_state].
    pub fn set_health_check_firewall_state<
        T: std::convert::Into<crate::model::load_balancer_backend::HealthCheckFirewallState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_firewall_state = v.into();
        self
    }

    /// Sets the value of [health_check_allowing_firewall_rules][crate::model::LoadBalancerBackend::health_check_allowing_firewall_rules].
    pub fn set_health_check_allowing_firewall_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.health_check_allowing_firewall_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [health_check_blocking_firewall_rules][crate::model::LoadBalancerBackend::health_check_blocking_firewall_rules].
    pub fn set_health_check_blocking_firewall_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.health_check_blocking_firewall_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoadBalancerBackend {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LoadBalancerBackend"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadBalancerBackend {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __health_check_firewall_state,
            __health_check_allowing_firewall_rules,
            __health_check_blocking_firewall_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerBackend")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "healthCheckFirewallState" => {
                                Ok(__FieldTag::__health_check_firewall_state)
                            }
                            "health_check_firewall_state" => {
                                Ok(__FieldTag::__health_check_firewall_state)
                            }
                            "healthCheckAllowingFirewallRules" => {
                                Ok(__FieldTag::__health_check_allowing_firewall_rules)
                            }
                            "health_check_allowing_firewall_rules" => {
                                Ok(__FieldTag::__health_check_allowing_firewall_rules)
                            }
                            "healthCheckBlockingFirewallRules" => {
                                Ok(__FieldTag::__health_check_blocking_firewall_rules)
                            }
                            "health_check_blocking_firewall_rules" => {
                                Ok(__FieldTag::__health_check_blocking_firewall_rules)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadBalancerBackend;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerBackend")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_firewall_state => {
                            if !fields.insert(__FieldTag::__health_check_firewall_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_firewall_state",
                                ));
                            }
                            result.health_check_firewall_state = map
                                .next_value::<std::option::Option<
                                    crate::model::load_balancer_backend::HealthCheckFirewallState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_allowing_firewall_rules => {
                            if !fields.insert(__FieldTag::__health_check_allowing_firewall_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_allowing_firewall_rules",
                                ));
                            }
                            result.health_check_allowing_firewall_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__health_check_blocking_firewall_rules => {
                            if !fields.insert(__FieldTag::__health_check_blocking_firewall_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_blocking_firewall_rules",
                                ));
                            }
                            result.health_check_blocking_firewall_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadBalancerBackend {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.health_check_firewall_state) {
            state.serialize_entry(
                "healthCheckFirewallState",
                &self.health_check_firewall_state,
            )?;
        }
        if !self.health_check_allowing_firewall_rules.is_empty() {
            state.serialize_entry(
                "healthCheckAllowingFirewallRules",
                &self.health_check_allowing_firewall_rules,
            )?;
        }
        if !self.health_check_blocking_firewall_rules.is_empty() {
            state.serialize_entry(
                "healthCheckBlockingFirewallRules",
                &self.health_check_blocking_firewall_rules,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadBalancerBackend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadBalancerBackend");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field(
            "health_check_firewall_state",
            &self.health_check_firewall_state,
        );
        debug_struct.field(
            "health_check_allowing_firewall_rules",
            &self.health_check_allowing_firewall_rules,
        );
        debug_struct.field(
            "health_check_blocking_firewall_rules",
            &self.health_check_blocking_firewall_rules,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LoadBalancerBackend].
pub mod load_balancer_backend {
    #[allow(unused_imports)]
    use super::*;

    /// State of a health check firewall configuration:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HealthCheckFirewallState {
        /// State is unspecified. Default state if not populated.
        Unspecified,
        /// There are configured firewall rules to allow health check probes to the
        /// backend.
        Configured,
        /// There are firewall rules configured to allow partial health check ranges
        /// or block all health check ranges.
        /// If a health check probe is sent from denied IP ranges,
        /// the health check to the backend will fail. Then, the backend will be
        /// marked unhealthy and will not receive traffic sent to the load balancer.
        Misconfigured,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HealthCheckFirewallState::value] or
        /// [HealthCheckFirewallState::name].
        UnknownValue(health_check_firewall_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod health_check_firewall_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HealthCheckFirewallState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Configured => std::option::Option::Some(1),
                Self::Misconfigured => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED")
                }
                Self::Configured => std::option::Option::Some("CONFIGURED"),
                Self::Misconfigured => std::option::Option::Some("MISCONFIGURED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HealthCheckFirewallState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HealthCheckFirewallState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HealthCheckFirewallState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Configured,
                2 => Self::Misconfigured,
                _ => Self::UnknownValue(health_check_firewall_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HealthCheckFirewallState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED" => Self::Unspecified,
                "CONFIGURED" => Self::Configured,
                "MISCONFIGURED" => Self::Misconfigured,
                _ => Self::UnknownValue(health_check_firewall_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HealthCheckFirewallState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Configured => serializer.serialize_i32(1),
                Self::Misconfigured => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HealthCheckFirewallState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HealthCheckFirewallState>::new(
                ".google.cloud.networkmanagement.v1.LoadBalancerBackend.HealthCheckFirewallState"))
        }
    }
}

/// For display only. Metadata associated with a Compute Engine VPN gateway.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpnGatewayInfo {
    /// Name of a VPN gateway.
    pub display_name: std::string::String,

    /// URI of a VPN gateway.
    pub uri: std::string::String,

    /// URI of a Compute Engine network where the VPN gateway is configured.
    pub network_uri: std::string::String,

    /// IP address of the VPN gateway.
    pub ip_address: std::string::String,

    /// A VPN tunnel that is associated with this VPN gateway.
    /// There may be multiple VPN tunnels configured on a VPN gateway, and only
    /// the one relevant to the test is displayed.
    pub vpn_tunnel_uri: std::string::String,

    /// Name of a Google Cloud region where this VPN gateway is configured.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpnGatewayInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::VpnGatewayInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::VpnGatewayInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::VpnGatewayInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::VpnGatewayInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [vpn_tunnel_uri][crate::model::VpnGatewayInfo::vpn_tunnel_uri].
    pub fn set_vpn_tunnel_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpn_tunnel_uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::VpnGatewayInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for VpnGatewayInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpnGatewayInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpnGatewayInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __ip_address,
            __vpn_tunnel_uri,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnGatewayInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "vpnTunnelUri" => Ok(__FieldTag::__vpn_tunnel_uri),
                            "vpn_tunnel_uri" => Ok(__FieldTag::__vpn_tunnel_uri),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpnGatewayInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnGatewayInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpn_tunnel_uri => {
                            if !fields.insert(__FieldTag::__vpn_tunnel_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_tunnel_uri",
                                ));
                            }
                            result.vpn_tunnel_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpnGatewayInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.vpn_tunnel_uri.is_empty() {
            state.serialize_entry("vpnTunnelUri", &self.vpn_tunnel_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpnGatewayInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpnGatewayInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("vpn_tunnel_uri", &self.vpn_tunnel_uri);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Compute Engine VPN tunnel.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpnTunnelInfo {
    /// Name of a VPN tunnel.
    pub display_name: std::string::String,

    /// URI of a VPN tunnel.
    pub uri: std::string::String,

    /// URI of the VPN gateway at local end of the tunnel.
    pub source_gateway: std::string::String,

    /// URI of a VPN gateway at remote end of the tunnel.
    pub remote_gateway: std::string::String,

    /// Remote VPN gateway's IP address.
    pub remote_gateway_ip: std::string::String,

    /// Local VPN gateway's IP address.
    pub source_gateway_ip: std::string::String,

    /// URI of a Compute Engine network where the VPN tunnel is configured.
    pub network_uri: std::string::String,

    /// Name of a Google Cloud region where this VPN tunnel is configured.
    pub region: std::string::String,

    /// Type of the routing policy.
    pub routing_type: crate::model::vpn_tunnel_info::RoutingType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpnTunnelInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::VpnTunnelInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::VpnTunnelInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [source_gateway][crate::model::VpnTunnelInfo::source_gateway].
    pub fn set_source_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_gateway = v.into();
        self
    }

    /// Sets the value of [remote_gateway][crate::model::VpnTunnelInfo::remote_gateway].
    pub fn set_remote_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_gateway = v.into();
        self
    }

    /// Sets the value of [remote_gateway_ip][crate::model::VpnTunnelInfo::remote_gateway_ip].
    pub fn set_remote_gateway_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remote_gateway_ip = v.into();
        self
    }

    /// Sets the value of [source_gateway_ip][crate::model::VpnTunnelInfo::source_gateway_ip].
    pub fn set_source_gateway_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_gateway_ip = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::VpnTunnelInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [region][crate::model::VpnTunnelInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [routing_type][crate::model::VpnTunnelInfo::routing_type].
    pub fn set_routing_type<T: std::convert::Into<crate::model::vpn_tunnel_info::RoutingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.routing_type = v.into();
        self
    }
}

impl wkt::message::Message for VpnTunnelInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpnTunnelInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpnTunnelInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __source_gateway,
            __remote_gateway,
            __remote_gateway_ip,
            __source_gateway_ip,
            __network_uri,
            __region,
            __routing_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnTunnelInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "sourceGateway" => Ok(__FieldTag::__source_gateway),
                            "source_gateway" => Ok(__FieldTag::__source_gateway),
                            "remoteGateway" => Ok(__FieldTag::__remote_gateway),
                            "remote_gateway" => Ok(__FieldTag::__remote_gateway),
                            "remoteGatewayIp" => Ok(__FieldTag::__remote_gateway_ip),
                            "remote_gateway_ip" => Ok(__FieldTag::__remote_gateway_ip),
                            "sourceGatewayIp" => Ok(__FieldTag::__source_gateway_ip),
                            "source_gateway_ip" => Ok(__FieldTag::__source_gateway_ip),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "region" => Ok(__FieldTag::__region),
                            "routingType" => Ok(__FieldTag::__routing_type),
                            "routing_type" => Ok(__FieldTag::__routing_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpnTunnelInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnTunnelInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_gateway => {
                            if !fields.insert(__FieldTag::__source_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_gateway",
                                ));
                            }
                            result.source_gateway = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_gateway => {
                            if !fields.insert(__FieldTag::__remote_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_gateway",
                                ));
                            }
                            result.remote_gateway = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_gateway_ip => {
                            if !fields.insert(__FieldTag::__remote_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_gateway_ip",
                                ));
                            }
                            result.remote_gateway_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_gateway_ip => {
                            if !fields.insert(__FieldTag::__source_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_gateway_ip",
                                ));
                            }
                            result.source_gateway_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routing_type => {
                            if !fields.insert(__FieldTag::__routing_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routing_type",
                                ));
                            }
                            result.routing_type = map.next_value::<std::option::Option<crate::model::vpn_tunnel_info::RoutingType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpnTunnelInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.source_gateway.is_empty() {
            state.serialize_entry("sourceGateway", &self.source_gateway)?;
        }
        if !self.remote_gateway.is_empty() {
            state.serialize_entry("remoteGateway", &self.remote_gateway)?;
        }
        if !self.remote_gateway_ip.is_empty() {
            state.serialize_entry("remoteGatewayIp", &self.remote_gateway_ip)?;
        }
        if !self.source_gateway_ip.is_empty() {
            state.serialize_entry("sourceGatewayIp", &self.source_gateway_ip)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !wkt::internal::is_default(&self.routing_type) {
            state.serialize_entry("routingType", &self.routing_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpnTunnelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpnTunnelInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("source_gateway", &self.source_gateway);
        debug_struct.field("remote_gateway", &self.remote_gateway);
        debug_struct.field("remote_gateway_ip", &self.remote_gateway_ip);
        debug_struct.field("source_gateway_ip", &self.source_gateway_ip);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("region", &self.region);
        debug_struct.field("routing_type", &self.routing_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VpnTunnelInfo].
pub mod vpn_tunnel_info {
    #[allow(unused_imports)]
    use super::*;

    /// Types of VPN routing policy. For details, refer to [Networks and Tunnel
    /// routing](https://cloud.google.com/network-connectivity/docs/vpn/concepts/choosing-networks-routing/).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoutingType {
        /// Unspecified type. Default value.
        Unspecified,
        /// Route based VPN.
        RouteBased,
        /// Policy based routing.
        PolicyBased,
        /// Dynamic (BGP) routing.
        Dynamic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoutingType::value] or
        /// [RoutingType::name].
        UnknownValue(routing_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod routing_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoutingType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RouteBased => std::option::Option::Some(1),
                Self::PolicyBased => std::option::Option::Some(2),
                Self::Dynamic => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTING_TYPE_UNSPECIFIED"),
                Self::RouteBased => std::option::Option::Some("ROUTE_BASED"),
                Self::PolicyBased => std::option::Option::Some("POLICY_BASED"),
                Self::Dynamic => std::option::Option::Some("DYNAMIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoutingType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoutingType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoutingType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RouteBased,
                2 => Self::PolicyBased,
                3 => Self::Dynamic,
                _ => Self::UnknownValue(routing_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RoutingType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTING_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ROUTE_BASED" => Self::RouteBased,
                "POLICY_BASED" => Self::PolicyBased,
                "DYNAMIC" => Self::Dynamic,
                _ => Self::UnknownValue(routing_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RoutingType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RouteBased => serializer.serialize_i32(1),
                Self::PolicyBased => serializer.serialize_i32(2),
                Self::Dynamic => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoutingType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoutingType>::new(
                ".google.cloud.networkmanagement.v1.VpnTunnelInfo.RoutingType",
            ))
        }
    }
}

/// For display only. The specification of the endpoints for the test.
/// EndpointInfo is derived from source and destination Endpoint and validated
/// by the backend data plane model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EndpointInfo {
    /// Source IP address.
    pub source_ip: std::string::String,

    /// Destination IP address.
    pub destination_ip: std::string::String,

    /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
    pub protocol: std::string::String,

    /// Source port. Only valid when protocol is TCP or UDP.
    pub source_port: i32,

    /// Destination port. Only valid when protocol is TCP or UDP.
    pub destination_port: i32,

    /// URI of the network where this packet originates from.
    pub source_network_uri: std::string::String,

    /// URI of the network where this packet is sent to.
    pub destination_network_uri: std::string::String,

    /// URI of the source telemetry agent this packet originates from.
    pub source_agent_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_ip][crate::model::EndpointInfo::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [destination_ip][crate::model::EndpointInfo::destination_ip].
    pub fn set_destination_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_ip = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::EndpointInfo::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [source_port][crate::model::EndpointInfo::source_port].
    pub fn set_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_port = v.into();
        self
    }

    /// Sets the value of [destination_port][crate::model::EndpointInfo::destination_port].
    pub fn set_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.destination_port = v.into();
        self
    }

    /// Sets the value of [source_network_uri][crate::model::EndpointInfo::source_network_uri].
    pub fn set_source_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_network_uri = v.into();
        self
    }

    /// Sets the value of [destination_network_uri][crate::model::EndpointInfo::destination_network_uri].
    pub fn set_destination_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_network_uri = v.into();
        self
    }

    /// Sets the value of [source_agent_uri][crate::model::EndpointInfo::source_agent_uri].
    pub fn set_source_agent_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_agent_uri = v.into();
        self
    }
}

impl wkt::message::Message for EndpointInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.EndpointInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EndpointInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_ip,
            __destination_ip,
            __protocol,
            __source_port,
            __destination_port,
            __source_network_uri,
            __destination_network_uri,
            __source_agent_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EndpointInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "sourcePort" => Ok(__FieldTag::__source_port),
                            "source_port" => Ok(__FieldTag::__source_port),
                            "destinationPort" => Ok(__FieldTag::__destination_port),
                            "destination_port" => Ok(__FieldTag::__destination_port),
                            "sourceNetworkUri" => Ok(__FieldTag::__source_network_uri),
                            "source_network_uri" => Ok(__FieldTag::__source_network_uri),
                            "destinationNetworkUri" => Ok(__FieldTag::__destination_network_uri),
                            "destination_network_uri" => Ok(__FieldTag::__destination_network_uri),
                            "sourceAgentUri" => Ok(__FieldTag::__source_agent_uri),
                            "source_agent_uri" => Ok(__FieldTag::__source_agent_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EndpointInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EndpointInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_ip",
                                ));
                            }
                            result.destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_port => {
                            if !fields.insert(__FieldTag::__source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__destination_port => {
                            if !fields.insert(__FieldTag::__destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_network_uri => {
                            if !fields.insert(__FieldTag::__source_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_network_uri",
                                ));
                            }
                            result.source_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_network_uri => {
                            if !fields.insert(__FieldTag::__destination_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_network_uri",
                                ));
                            }
                            result.destination_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_agent_uri => {
                            if !fields.insert(__FieldTag::__source_agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_agent_uri",
                                ));
                            }
                            result.source_agent_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EndpointInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !self.destination_ip.is_empty() {
            state.serialize_entry("destinationIp", &self.destination_ip)?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !wkt::internal::is_default(&self.source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourcePort", &__With(&self.source_port))?;
        }
        if !wkt::internal::is_default(&self.destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("destinationPort", &__With(&self.destination_port))?;
        }
        if !self.source_network_uri.is_empty() {
            state.serialize_entry("sourceNetworkUri", &self.source_network_uri)?;
        }
        if !self.destination_network_uri.is_empty() {
            state.serialize_entry("destinationNetworkUri", &self.destination_network_uri)?;
        }
        if !self.source_agent_uri.is_empty() {
            state.serialize_entry("sourceAgentUri", &self.source_agent_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EndpointInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EndpointInfo");
        debug_struct.field("source_ip", &self.source_ip);
        debug_struct.field("destination_ip", &self.destination_ip);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("source_port", &self.source_port);
        debug_struct.field("destination_port", &self.destination_port);
        debug_struct.field("source_network_uri", &self.source_network_uri);
        debug_struct.field("destination_network_uri", &self.destination_network_uri);
        debug_struct.field("source_agent_uri", &self.source_agent_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of the final state "deliver" and associated resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeliverInfo {
    /// Target type where the packet is delivered to.
    pub target: crate::model::deliver_info::Target,

    /// URI of the resource that the packet is delivered to.
    pub resource_uri: std::string::String,

    /// IP address of the target (if applicable).
    pub ip_address: std::string::String,

    /// Name of the Cloud Storage Bucket the packet is delivered to (if
    /// applicable).
    pub storage_bucket: std::string::String,

    /// PSC Google API target the packet is delivered to (if applicable).
    pub psc_google_api_target: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliverInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::DeliverInfo::target].
    pub fn set_target<T: std::convert::Into<crate::model::deliver_info::Target>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DeliverInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::DeliverInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [storage_bucket][crate::model::DeliverInfo::storage_bucket].
    pub fn set_storage_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_bucket = v.into();
        self
    }

    /// Sets the value of [psc_google_api_target][crate::model::DeliverInfo::psc_google_api_target].
    pub fn set_psc_google_api_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_google_api_target = v.into();
        self
    }
}

impl wkt::message::Message for DeliverInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DeliverInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeliverInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target,
            __resource_uri,
            __ip_address,
            __storage_bucket,
            __psc_google_api_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeliverInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "target" => Ok(__FieldTag::__target),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "storageBucket" => Ok(__FieldTag::__storage_bucket),
                            "storage_bucket" => Ok(__FieldTag::__storage_bucket),
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeliverInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeliverInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map.next_value::<std::option::Option<crate::model::deliver_info::Target>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_bucket => {
                            if !fields.insert(__FieldTag::__storage_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_bucket",
                                ));
                            }
                            result.storage_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_google_api_target",
                                ));
                            }
                            result.psc_google_api_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeliverInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target) {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.storage_bucket.is_empty() {
            state.serialize_entry("storageBucket", &self.storage_bucket)?;
        }
        if !self.psc_google_api_target.is_empty() {
            state.serialize_entry("pscGoogleApiTarget", &self.psc_google_api_target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeliverInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeliverInfo");
        debug_struct.field("target", &self.target);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("storage_bucket", &self.storage_bucket);
        debug_struct.field("psc_google_api_target", &self.psc_google_api_target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DeliverInfo].
pub mod deliver_info {
    #[allow(unused_imports)]
    use super::*;

    /// Deliver target types:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Target not specified.
        Unspecified,
        /// Target is a Compute Engine instance.
        Instance,
        /// Target is the internet.
        Internet,
        /// Target is a Google API.
        GoogleApi,
        /// Target is a Google Kubernetes Engine cluster master.
        GkeMaster,
        /// Target is a Cloud SQL instance.
        CloudSqlInstance,
        /// Target is a published service that uses [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
        PscPublishedService,
        /// Target is Google APIs that use [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
        PscGoogleApi,
        /// Target is a VPC-SC that uses [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
        PscVpcSc,
        /// Target is a serverless network endpoint group.
        ServerlessNeg,
        /// Target is a Cloud Storage bucket.
        StorageBucket,
        /// Target is a private network. Used only for return traces.
        PrivateNetwork,
        /// Target is a Cloud Function. Used only for return traces.
        CloudFunction,
        /// Target is a App Engine service version. Used only for return traces.
        AppEngineVersion,
        /// Target is a Cloud Run revision. Used only for return traces.
        CloudRunRevision,
        /// Target is a Google-managed service. Used only for return traces.
        GoogleManagedService,
        /// Target is a Redis Instance.
        RedisInstance,
        /// Target is a Redis Cluster.
        RedisCluster,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Target::value] or
        /// [Target::name].
        UnknownValue(target::UnknownValue),
    }

    #[doc(hidden)]
    pub mod target {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Target {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Instance => std::option::Option::Some(1),
                Self::Internet => std::option::Option::Some(2),
                Self::GoogleApi => std::option::Option::Some(3),
                Self::GkeMaster => std::option::Option::Some(4),
                Self::CloudSqlInstance => std::option::Option::Some(5),
                Self::PscPublishedService => std::option::Option::Some(6),
                Self::PscGoogleApi => std::option::Option::Some(7),
                Self::PscVpcSc => std::option::Option::Some(8),
                Self::ServerlessNeg => std::option::Option::Some(9),
                Self::StorageBucket => std::option::Option::Some(10),
                Self::PrivateNetwork => std::option::Option::Some(11),
                Self::CloudFunction => std::option::Option::Some(12),
                Self::AppEngineVersion => std::option::Option::Some(13),
                Self::CloudRunRevision => std::option::Option::Some(14),
                Self::GoogleManagedService => std::option::Option::Some(15),
                Self::RedisInstance => std::option::Option::Some(16),
                Self::RedisCluster => std::option::Option::Some(17),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARGET_UNSPECIFIED"),
                Self::Instance => std::option::Option::Some("INSTANCE"),
                Self::Internet => std::option::Option::Some("INTERNET"),
                Self::GoogleApi => std::option::Option::Some("GOOGLE_API"),
                Self::GkeMaster => std::option::Option::Some("GKE_MASTER"),
                Self::CloudSqlInstance => std::option::Option::Some("CLOUD_SQL_INSTANCE"),
                Self::PscPublishedService => std::option::Option::Some("PSC_PUBLISHED_SERVICE"),
                Self::PscGoogleApi => std::option::Option::Some("PSC_GOOGLE_API"),
                Self::PscVpcSc => std::option::Option::Some("PSC_VPC_SC"),
                Self::ServerlessNeg => std::option::Option::Some("SERVERLESS_NEG"),
                Self::StorageBucket => std::option::Option::Some("STORAGE_BUCKET"),
                Self::PrivateNetwork => std::option::Option::Some("PRIVATE_NETWORK"),
                Self::CloudFunction => std::option::Option::Some("CLOUD_FUNCTION"),
                Self::AppEngineVersion => std::option::Option::Some("APP_ENGINE_VERSION"),
                Self::CloudRunRevision => std::option::Option::Some("CLOUD_RUN_REVISION"),
                Self::GoogleManagedService => std::option::Option::Some("GOOGLE_MANAGED_SERVICE"),
                Self::RedisInstance => std::option::Option::Some("REDIS_INSTANCE"),
                Self::RedisCluster => std::option::Option::Some("REDIS_CLUSTER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Target {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Target {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Target {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Instance,
                2 => Self::Internet,
                3 => Self::GoogleApi,
                4 => Self::GkeMaster,
                5 => Self::CloudSqlInstance,
                6 => Self::PscPublishedService,
                7 => Self::PscGoogleApi,
                8 => Self::PscVpcSc,
                9 => Self::ServerlessNeg,
                10 => Self::StorageBucket,
                11 => Self::PrivateNetwork,
                12 => Self::CloudFunction,
                13 => Self::AppEngineVersion,
                14 => Self::CloudRunRevision,
                15 => Self::GoogleManagedService,
                16 => Self::RedisInstance,
                17 => Self::RedisCluster,
                _ => Self::UnknownValue(target::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Target {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARGET_UNSPECIFIED" => Self::Unspecified,
                "INSTANCE" => Self::Instance,
                "INTERNET" => Self::Internet,
                "GOOGLE_API" => Self::GoogleApi,
                "GKE_MASTER" => Self::GkeMaster,
                "CLOUD_SQL_INSTANCE" => Self::CloudSqlInstance,
                "PSC_PUBLISHED_SERVICE" => Self::PscPublishedService,
                "PSC_GOOGLE_API" => Self::PscGoogleApi,
                "PSC_VPC_SC" => Self::PscVpcSc,
                "SERVERLESS_NEG" => Self::ServerlessNeg,
                "STORAGE_BUCKET" => Self::StorageBucket,
                "PRIVATE_NETWORK" => Self::PrivateNetwork,
                "CLOUD_FUNCTION" => Self::CloudFunction,
                "APP_ENGINE_VERSION" => Self::AppEngineVersion,
                "CLOUD_RUN_REVISION" => Self::CloudRunRevision,
                "GOOGLE_MANAGED_SERVICE" => Self::GoogleManagedService,
                "REDIS_INSTANCE" => Self::RedisInstance,
                "REDIS_CLUSTER" => Self::RedisCluster,
                _ => Self::UnknownValue(target::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Target {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Instance => serializer.serialize_i32(1),
                Self::Internet => serializer.serialize_i32(2),
                Self::GoogleApi => serializer.serialize_i32(3),
                Self::GkeMaster => serializer.serialize_i32(4),
                Self::CloudSqlInstance => serializer.serialize_i32(5),
                Self::PscPublishedService => serializer.serialize_i32(6),
                Self::PscGoogleApi => serializer.serialize_i32(7),
                Self::PscVpcSc => serializer.serialize_i32(8),
                Self::ServerlessNeg => serializer.serialize_i32(9),
                Self::StorageBucket => serializer.serialize_i32(10),
                Self::PrivateNetwork => serializer.serialize_i32(11),
                Self::CloudFunction => serializer.serialize_i32(12),
                Self::AppEngineVersion => serializer.serialize_i32(13),
                Self::CloudRunRevision => serializer.serialize_i32(14),
                Self::GoogleManagedService => serializer.serialize_i32(15),
                Self::RedisInstance => serializer.serialize_i32(16),
                Self::RedisCluster => serializer.serialize_i32(17),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Target {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Target>::new(
                ".google.cloud.networkmanagement.v1.DeliverInfo.Target",
            ))
        }
    }
}

/// Details of the final state "forward" and associated resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ForwardInfo {
    /// Target type where this packet is forwarded to.
    pub target: crate::model::forward_info::Target,

    /// URI of the resource that the packet is forwarded to.
    pub resource_uri: std::string::String,

    /// IP address of the target (if applicable).
    pub ip_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForwardInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::ForwardInfo::target].
    pub fn set_target<T: std::convert::Into<crate::model::forward_info::Target>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::ForwardInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::ForwardInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for ForwardInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ForwardInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForwardInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target,
            __resource_uri,
            __ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "target" => Ok(__FieldTag::__target),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForwardInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map.next_value::<std::option::Option<crate::model::forward_info::Target>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForwardInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target) {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ForwardInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForwardInfo");
        debug_struct.field("target", &self.target);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("ip_address", &self.ip_address);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ForwardInfo].
pub mod forward_info {
    #[allow(unused_imports)]
    use super::*;

    /// Forward target types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Target not specified.
        Unspecified,
        /// Forwarded to a VPC peering network.
        PeeringVpc,
        /// Forwarded to a Cloud VPN gateway.
        VpnGateway,
        /// Forwarded to a Cloud Interconnect connection.
        Interconnect,
        /// Forwarded to a Google Kubernetes Engine Container cluster master.
        #[deprecated]
        GkeMaster,
        /// Forwarded to the next hop of a custom route imported from a peering VPC.
        ImportedCustomRouteNextHop,
        /// Forwarded to a Cloud SQL instance.
        #[deprecated]
        CloudSqlInstance,
        /// Forwarded to a VPC network in another project.
        AnotherProject,
        /// Forwarded to an NCC Hub.
        NccHub,
        /// Forwarded to a router appliance.
        RouterAppliance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Target::value] or
        /// [Target::name].
        UnknownValue(target::UnknownValue),
    }

    #[doc(hidden)]
    pub mod target {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Target {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PeeringVpc => std::option::Option::Some(1),
                Self::VpnGateway => std::option::Option::Some(2),
                Self::Interconnect => std::option::Option::Some(3),
                Self::GkeMaster => std::option::Option::Some(4),
                Self::ImportedCustomRouteNextHop => std::option::Option::Some(5),
                Self::CloudSqlInstance => std::option::Option::Some(6),
                Self::AnotherProject => std::option::Option::Some(7),
                Self::NccHub => std::option::Option::Some(8),
                Self::RouterAppliance => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARGET_UNSPECIFIED"),
                Self::PeeringVpc => std::option::Option::Some("PEERING_VPC"),
                Self::VpnGateway => std::option::Option::Some("VPN_GATEWAY"),
                Self::Interconnect => std::option::Option::Some("INTERCONNECT"),
                Self::GkeMaster => std::option::Option::Some("GKE_MASTER"),
                Self::ImportedCustomRouteNextHop => {
                    std::option::Option::Some("IMPORTED_CUSTOM_ROUTE_NEXT_HOP")
                }
                Self::CloudSqlInstance => std::option::Option::Some("CLOUD_SQL_INSTANCE"),
                Self::AnotherProject => std::option::Option::Some("ANOTHER_PROJECT"),
                Self::NccHub => std::option::Option::Some("NCC_HUB"),
                Self::RouterAppliance => std::option::Option::Some("ROUTER_APPLIANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Target {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Target {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Target {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PeeringVpc,
                2 => Self::VpnGateway,
                3 => Self::Interconnect,
                4 => Self::GkeMaster,
                5 => Self::ImportedCustomRouteNextHop,
                6 => Self::CloudSqlInstance,
                7 => Self::AnotherProject,
                8 => Self::NccHub,
                9 => Self::RouterAppliance,
                _ => Self::UnknownValue(target::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Target {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARGET_UNSPECIFIED" => Self::Unspecified,
                "PEERING_VPC" => Self::PeeringVpc,
                "VPN_GATEWAY" => Self::VpnGateway,
                "INTERCONNECT" => Self::Interconnect,
                "GKE_MASTER" => Self::GkeMaster,
                "IMPORTED_CUSTOM_ROUTE_NEXT_HOP" => Self::ImportedCustomRouteNextHop,
                "CLOUD_SQL_INSTANCE" => Self::CloudSqlInstance,
                "ANOTHER_PROJECT" => Self::AnotherProject,
                "NCC_HUB" => Self::NccHub,
                "ROUTER_APPLIANCE" => Self::RouterAppliance,
                _ => Self::UnknownValue(target::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Target {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PeeringVpc => serializer.serialize_i32(1),
                Self::VpnGateway => serializer.serialize_i32(2),
                Self::Interconnect => serializer.serialize_i32(3),
                Self::GkeMaster => serializer.serialize_i32(4),
                Self::ImportedCustomRouteNextHop => serializer.serialize_i32(5),
                Self::CloudSqlInstance => serializer.serialize_i32(6),
                Self::AnotherProject => serializer.serialize_i32(7),
                Self::NccHub => serializer.serialize_i32(8),
                Self::RouterAppliance => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Target {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Target>::new(
                ".google.cloud.networkmanagement.v1.ForwardInfo.Target",
            ))
        }
    }
}

/// Details of the final state "abort" and associated resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AbortInfo {
    /// Causes that the analysis is aborted.
    pub cause: crate::model::abort_info::Cause,

    /// URI of the resource that caused the abort.
    pub resource_uri: std::string::String,

    /// IP address that caused the abort.
    pub ip_address: std::string::String,

    /// List of project IDs the user specified in the request but lacks access to.
    /// In this case, analysis is aborted with the PERMISSION_DENIED cause.
    pub projects_missing_permission: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AbortInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cause][crate::model::AbortInfo::cause].
    pub fn set_cause<T: std::convert::Into<crate::model::abort_info::Cause>>(
        mut self,
        v: T,
    ) -> Self {
        self.cause = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::AbortInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::AbortInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [projects_missing_permission][crate::model::AbortInfo::projects_missing_permission].
    pub fn set_projects_missing_permission<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.projects_missing_permission = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AbortInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.AbortInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AbortInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cause,
            __resource_uri,
            __ip_address,
            __projects_missing_permission,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AbortInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cause" => Ok(__FieldTag::__cause),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "projectsMissingPermission" => {
                                Ok(__FieldTag::__projects_missing_permission)
                            }
                            "projects_missing_permission" => {
                                Ok(__FieldTag::__projects_missing_permission)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AbortInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AbortInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cause",
                                ));
                            }
                            result.cause = map
                                .next_value::<std::option::Option<crate::model::abort_info::Cause>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__projects_missing_permission => {
                            if !fields.insert(__FieldTag::__projects_missing_permission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for projects_missing_permission",
                                ));
                            }
                            result.projects_missing_permission = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AbortInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cause) {
            state.serialize_entry("cause", &self.cause)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.projects_missing_permission.is_empty() {
            state.serialize_entry(
                "projectsMissingPermission",
                &self.projects_missing_permission,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AbortInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AbortInfo");
        debug_struct.field("cause", &self.cause);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field(
            "projects_missing_permission",
            &self.projects_missing_permission,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AbortInfo].
pub mod abort_info {
    #[allow(unused_imports)]
    use super::*;

    /// Abort cause types:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cause {
        /// Cause is unspecified.
        Unspecified,
        /// Aborted due to unknown network. Deprecated, not used in the new tests.
        #[deprecated]
        UnknownNetwork,
        /// Aborted because no project information can be derived from the test
        /// input. Deprecated, not used in the new tests.
        #[deprecated]
        UnknownProject,
        /// Aborted because traffic is sent from a public IP to an instance without
        /// an external IP. Deprecated, not used in the new tests.
        #[deprecated]
        NoExternalIp,
        /// Aborted because none of the traces matches destination information
        /// specified in the input test request. Deprecated, not used in the new
        /// tests.
        #[deprecated]
        UnintendedDestination,
        /// Aborted because the source endpoint could not be found. Deprecated, not
        /// used in the new tests.
        #[deprecated]
        SourceEndpointNotFound,
        /// Aborted because the source network does not match the source endpoint.
        /// Deprecated, not used in the new tests.
        #[deprecated]
        MismatchedSourceNetwork,
        /// Aborted because the destination endpoint could not be found. Deprecated,
        /// not used in the new tests.
        #[deprecated]
        DestinationEndpointNotFound,
        /// Aborted because the destination network does not match the destination
        /// endpoint. Deprecated, not used in the new tests.
        #[deprecated]
        MismatchedDestinationNetwork,
        /// Aborted because no endpoint with the packet's destination IP address is
        /// found.
        UnknownIp,
        /// Aborted because no endpoint with the packet's destination IP is found in
        /// the Google-managed project.
        GoogleManagedServiceUnknownIp,
        /// Aborted because the source IP address doesn't belong to any of the
        /// subnets of the source VPC network.
        SourceIpAddressNotInSourceNetwork,
        /// Aborted because user lacks permission to access all or part of the
        /// network configurations required to run the test.
        PermissionDenied,
        /// Aborted because user lacks permission to access Cloud NAT configs
        /// required to run the test.
        PermissionDeniedNoCloudNatConfigs,
        /// Aborted because user lacks permission to access Network endpoint group
        /// endpoint configs required to run the test.
        PermissionDeniedNoNegEndpointConfigs,
        /// Aborted because user lacks permission to access Cloud Router configs
        /// required to run the test.
        PermissionDeniedNoCloudRouterConfigs,
        /// Aborted because no valid source or destination endpoint is derived from
        /// the input test request.
        NoSourceLocation,
        /// Aborted because the source or destination endpoint specified in
        /// the request is invalid. Some examples:
        ///
        /// - The request might contain malformed resource URI, project ID, or IP
        ///   address.
        /// - The request might contain inconsistent information (for example, the
        ///   request might include both the instance and the network, but the instance
        ///   might not have a NIC in that network).
        InvalidArgument,
        /// Aborted because the number of steps in the trace exceeds a certain
        /// limit. It might be caused by a routing loop.
        TraceTooLong,
        /// Aborted due to internal server error.
        InternalError,
        /// Aborted because the test scenario is not supported.
        Unsupported,
        /// Aborted because the source and destination resources have no common IP
        /// version.
        MismatchedIpVersion,
        /// Aborted because the connection between the control plane and the node of
        /// the source cluster is initiated by the node and managed by the
        /// Konnectivity proxy.
        GkeKonnectivityProxyUnsupported,
        /// Aborted because expected resource configuration was missing.
        ResourceConfigNotFound,
        /// Aborted because expected VM instance configuration was missing.
        VmInstanceConfigNotFound,
        /// Aborted because expected network configuration was missing.
        NetworkConfigNotFound,
        /// Aborted because expected firewall configuration was missing.
        FirewallConfigNotFound,
        /// Aborted because expected route configuration was missing.
        RouteConfigNotFound,
        /// Aborted because a PSC endpoint selection for the Google-managed service
        /// is ambiguous (several PSC endpoints satisfy test input).
        GoogleManagedServiceAmbiguousPscEndpoint,
        /// Aborted because tests with a PSC-based Cloud SQL instance as a source are
        /// not supported.
        SourcePscCloudSqlUnsupported,
        /// Aborted because tests with a Redis Cluster as a source are not supported.
        SourceRedisClusterUnsupported,
        /// Aborted because tests with a Redis Instance as a source are not
        /// supported.
        SourceRedisInstanceUnsupported,
        /// Aborted because tests with a forwarding rule as a source are not
        /// supported.
        SourceForwardingRuleUnsupported,
        /// Aborted because one of the endpoints is a non-routable IP address
        /// (loopback, link-local, etc).
        NonRoutableIpAddress,
        /// Aborted due to an unknown issue in the Google-managed project.
        UnknownIssueInGoogleManagedProject,
        /// Aborted due to an unsupported configuration of the Google-managed
        /// project.
        UnsupportedGoogleManagedProjectConfig,
        /// Aborted because the source endpoint is a Cloud Run revision with direct
        /// VPC access enabled, but there are no reserved serverless IP ranges.
        NoServerlessIpRanges,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Cause::value] or
        /// [Cause::name].
        UnknownValue(cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Cause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownNetwork => std::option::Option::Some(1),
                Self::UnknownProject => std::option::Option::Some(3),
                Self::NoExternalIp => std::option::Option::Some(7),
                Self::UnintendedDestination => std::option::Option::Some(8),
                Self::SourceEndpointNotFound => std::option::Option::Some(11),
                Self::MismatchedSourceNetwork => std::option::Option::Some(12),
                Self::DestinationEndpointNotFound => std::option::Option::Some(13),
                Self::MismatchedDestinationNetwork => std::option::Option::Some(14),
                Self::UnknownIp => std::option::Option::Some(2),
                Self::GoogleManagedServiceUnknownIp => std::option::Option::Some(32),
                Self::SourceIpAddressNotInSourceNetwork => std::option::Option::Some(23),
                Self::PermissionDenied => std::option::Option::Some(4),
                Self::PermissionDeniedNoCloudNatConfigs => std::option::Option::Some(28),
                Self::PermissionDeniedNoNegEndpointConfigs => std::option::Option::Some(29),
                Self::PermissionDeniedNoCloudRouterConfigs => std::option::Option::Some(36),
                Self::NoSourceLocation => std::option::Option::Some(5),
                Self::InvalidArgument => std::option::Option::Some(6),
                Self::TraceTooLong => std::option::Option::Some(9),
                Self::InternalError => std::option::Option::Some(10),
                Self::Unsupported => std::option::Option::Some(15),
                Self::MismatchedIpVersion => std::option::Option::Some(16),
                Self::GkeKonnectivityProxyUnsupported => std::option::Option::Some(17),
                Self::ResourceConfigNotFound => std::option::Option::Some(18),
                Self::VmInstanceConfigNotFound => std::option::Option::Some(24),
                Self::NetworkConfigNotFound => std::option::Option::Some(25),
                Self::FirewallConfigNotFound => std::option::Option::Some(26),
                Self::RouteConfigNotFound => std::option::Option::Some(27),
                Self::GoogleManagedServiceAmbiguousPscEndpoint => std::option::Option::Some(19),
                Self::SourcePscCloudSqlUnsupported => std::option::Option::Some(20),
                Self::SourceRedisClusterUnsupported => std::option::Option::Some(34),
                Self::SourceRedisInstanceUnsupported => std::option::Option::Some(35),
                Self::SourceForwardingRuleUnsupported => std::option::Option::Some(21),
                Self::NonRoutableIpAddress => std::option::Option::Some(22),
                Self::UnknownIssueInGoogleManagedProject => std::option::Option::Some(30),
                Self::UnsupportedGoogleManagedProjectConfig => std::option::Option::Some(31),
                Self::NoServerlessIpRanges => std::option::Option::Some(37),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CAUSE_UNSPECIFIED"),
                Self::UnknownNetwork => std::option::Option::Some("UNKNOWN_NETWORK"),
                Self::UnknownProject => std::option::Option::Some("UNKNOWN_PROJECT"),
                Self::NoExternalIp => std::option::Option::Some("NO_EXTERNAL_IP"),
                Self::UnintendedDestination => std::option::Option::Some("UNINTENDED_DESTINATION"),
                Self::SourceEndpointNotFound => {
                    std::option::Option::Some("SOURCE_ENDPOINT_NOT_FOUND")
                }
                Self::MismatchedSourceNetwork => {
                    std::option::Option::Some("MISMATCHED_SOURCE_NETWORK")
                }
                Self::DestinationEndpointNotFound => {
                    std::option::Option::Some("DESTINATION_ENDPOINT_NOT_FOUND")
                }
                Self::MismatchedDestinationNetwork => {
                    std::option::Option::Some("MISMATCHED_DESTINATION_NETWORK")
                }
                Self::UnknownIp => std::option::Option::Some("UNKNOWN_IP"),
                Self::GoogleManagedServiceUnknownIp => {
                    std::option::Option::Some("GOOGLE_MANAGED_SERVICE_UNKNOWN_IP")
                }
                Self::SourceIpAddressNotInSourceNetwork => {
                    std::option::Option::Some("SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK")
                }
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::PermissionDeniedNoCloudNatConfigs => {
                    std::option::Option::Some("PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS")
                }
                Self::PermissionDeniedNoNegEndpointConfigs => {
                    std::option::Option::Some("PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS")
                }
                Self::PermissionDeniedNoCloudRouterConfigs => {
                    std::option::Option::Some("PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS")
                }
                Self::NoSourceLocation => std::option::Option::Some("NO_SOURCE_LOCATION"),
                Self::InvalidArgument => std::option::Option::Some("INVALID_ARGUMENT"),
                Self::TraceTooLong => std::option::Option::Some("TRACE_TOO_LONG"),
                Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                Self::Unsupported => std::option::Option::Some("UNSUPPORTED"),
                Self::MismatchedIpVersion => std::option::Option::Some("MISMATCHED_IP_VERSION"),
                Self::GkeKonnectivityProxyUnsupported => {
                    std::option::Option::Some("GKE_KONNECTIVITY_PROXY_UNSUPPORTED")
                }
                Self::ResourceConfigNotFound => {
                    std::option::Option::Some("RESOURCE_CONFIG_NOT_FOUND")
                }
                Self::VmInstanceConfigNotFound => {
                    std::option::Option::Some("VM_INSTANCE_CONFIG_NOT_FOUND")
                }
                Self::NetworkConfigNotFound => {
                    std::option::Option::Some("NETWORK_CONFIG_NOT_FOUND")
                }
                Self::FirewallConfigNotFound => {
                    std::option::Option::Some("FIREWALL_CONFIG_NOT_FOUND")
                }
                Self::RouteConfigNotFound => std::option::Option::Some("ROUTE_CONFIG_NOT_FOUND"),
                Self::GoogleManagedServiceAmbiguousPscEndpoint => {
                    std::option::Option::Some("GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT")
                }
                Self::SourcePscCloudSqlUnsupported => {
                    std::option::Option::Some("SOURCE_PSC_CLOUD_SQL_UNSUPPORTED")
                }
                Self::SourceRedisClusterUnsupported => {
                    std::option::Option::Some("SOURCE_REDIS_CLUSTER_UNSUPPORTED")
                }
                Self::SourceRedisInstanceUnsupported => {
                    std::option::Option::Some("SOURCE_REDIS_INSTANCE_UNSUPPORTED")
                }
                Self::SourceForwardingRuleUnsupported => {
                    std::option::Option::Some("SOURCE_FORWARDING_RULE_UNSUPPORTED")
                }
                Self::NonRoutableIpAddress => std::option::Option::Some("NON_ROUTABLE_IP_ADDRESS"),
                Self::UnknownIssueInGoogleManagedProject => {
                    std::option::Option::Some("UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT")
                }
                Self::UnsupportedGoogleManagedProjectConfig => {
                    std::option::Option::Some("UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG")
                }
                Self::NoServerlessIpRanges => std::option::Option::Some("NO_SERVERLESS_IP_RANGES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Cause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Cause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Cause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownNetwork,
                2 => Self::UnknownIp,
                3 => Self::UnknownProject,
                4 => Self::PermissionDenied,
                5 => Self::NoSourceLocation,
                6 => Self::InvalidArgument,
                7 => Self::NoExternalIp,
                8 => Self::UnintendedDestination,
                9 => Self::TraceTooLong,
                10 => Self::InternalError,
                11 => Self::SourceEndpointNotFound,
                12 => Self::MismatchedSourceNetwork,
                13 => Self::DestinationEndpointNotFound,
                14 => Self::MismatchedDestinationNetwork,
                15 => Self::Unsupported,
                16 => Self::MismatchedIpVersion,
                17 => Self::GkeKonnectivityProxyUnsupported,
                18 => Self::ResourceConfigNotFound,
                19 => Self::GoogleManagedServiceAmbiguousPscEndpoint,
                20 => Self::SourcePscCloudSqlUnsupported,
                21 => Self::SourceForwardingRuleUnsupported,
                22 => Self::NonRoutableIpAddress,
                23 => Self::SourceIpAddressNotInSourceNetwork,
                24 => Self::VmInstanceConfigNotFound,
                25 => Self::NetworkConfigNotFound,
                26 => Self::FirewallConfigNotFound,
                27 => Self::RouteConfigNotFound,
                28 => Self::PermissionDeniedNoCloudNatConfigs,
                29 => Self::PermissionDeniedNoNegEndpointConfigs,
                30 => Self::UnknownIssueInGoogleManagedProject,
                31 => Self::UnsupportedGoogleManagedProjectConfig,
                32 => Self::GoogleManagedServiceUnknownIp,
                34 => Self::SourceRedisClusterUnsupported,
                35 => Self::SourceRedisInstanceUnsupported,
                36 => Self::PermissionDeniedNoCloudRouterConfigs,
                37 => Self::NoServerlessIpRanges,
                _ => Self::UnknownValue(cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Cause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CAUSE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_NETWORK" => Self::UnknownNetwork,
                "UNKNOWN_PROJECT" => Self::UnknownProject,
                "NO_EXTERNAL_IP" => Self::NoExternalIp,
                "UNINTENDED_DESTINATION" => Self::UnintendedDestination,
                "SOURCE_ENDPOINT_NOT_FOUND" => Self::SourceEndpointNotFound,
                "MISMATCHED_SOURCE_NETWORK" => Self::MismatchedSourceNetwork,
                "DESTINATION_ENDPOINT_NOT_FOUND" => Self::DestinationEndpointNotFound,
                "MISMATCHED_DESTINATION_NETWORK" => Self::MismatchedDestinationNetwork,
                "UNKNOWN_IP" => Self::UnknownIp,
                "GOOGLE_MANAGED_SERVICE_UNKNOWN_IP" => Self::GoogleManagedServiceUnknownIp,
                "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK" => {
                    Self::SourceIpAddressNotInSourceNetwork
                }
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS" => Self::PermissionDeniedNoCloudNatConfigs,
                "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS" => {
                    Self::PermissionDeniedNoNegEndpointConfigs
                }
                "PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS" => {
                    Self::PermissionDeniedNoCloudRouterConfigs
                }
                "NO_SOURCE_LOCATION" => Self::NoSourceLocation,
                "INVALID_ARGUMENT" => Self::InvalidArgument,
                "TRACE_TOO_LONG" => Self::TraceTooLong,
                "INTERNAL_ERROR" => Self::InternalError,
                "UNSUPPORTED" => Self::Unsupported,
                "MISMATCHED_IP_VERSION" => Self::MismatchedIpVersion,
                "GKE_KONNECTIVITY_PROXY_UNSUPPORTED" => Self::GkeKonnectivityProxyUnsupported,
                "RESOURCE_CONFIG_NOT_FOUND" => Self::ResourceConfigNotFound,
                "VM_INSTANCE_CONFIG_NOT_FOUND" => Self::VmInstanceConfigNotFound,
                "NETWORK_CONFIG_NOT_FOUND" => Self::NetworkConfigNotFound,
                "FIREWALL_CONFIG_NOT_FOUND" => Self::FirewallConfigNotFound,
                "ROUTE_CONFIG_NOT_FOUND" => Self::RouteConfigNotFound,
                "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT" => {
                    Self::GoogleManagedServiceAmbiguousPscEndpoint
                }
                "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED" => Self::SourcePscCloudSqlUnsupported,
                "SOURCE_REDIS_CLUSTER_UNSUPPORTED" => Self::SourceRedisClusterUnsupported,
                "SOURCE_REDIS_INSTANCE_UNSUPPORTED" => Self::SourceRedisInstanceUnsupported,
                "SOURCE_FORWARDING_RULE_UNSUPPORTED" => Self::SourceForwardingRuleUnsupported,
                "NON_ROUTABLE_IP_ADDRESS" => Self::NonRoutableIpAddress,
                "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT" => {
                    Self::UnknownIssueInGoogleManagedProject
                }
                "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG" => {
                    Self::UnsupportedGoogleManagedProjectConfig
                }
                "NO_SERVERLESS_IP_RANGES" => Self::NoServerlessIpRanges,
                _ => Self::UnknownValue(cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Cause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownNetwork => serializer.serialize_i32(1),
                Self::UnknownProject => serializer.serialize_i32(3),
                Self::NoExternalIp => serializer.serialize_i32(7),
                Self::UnintendedDestination => serializer.serialize_i32(8),
                Self::SourceEndpointNotFound => serializer.serialize_i32(11),
                Self::MismatchedSourceNetwork => serializer.serialize_i32(12),
                Self::DestinationEndpointNotFound => serializer.serialize_i32(13),
                Self::MismatchedDestinationNetwork => serializer.serialize_i32(14),
                Self::UnknownIp => serializer.serialize_i32(2),
                Self::GoogleManagedServiceUnknownIp => serializer.serialize_i32(32),
                Self::SourceIpAddressNotInSourceNetwork => serializer.serialize_i32(23),
                Self::PermissionDenied => serializer.serialize_i32(4),
                Self::PermissionDeniedNoCloudNatConfigs => serializer.serialize_i32(28),
                Self::PermissionDeniedNoNegEndpointConfigs => serializer.serialize_i32(29),
                Self::PermissionDeniedNoCloudRouterConfigs => serializer.serialize_i32(36),
                Self::NoSourceLocation => serializer.serialize_i32(5),
                Self::InvalidArgument => serializer.serialize_i32(6),
                Self::TraceTooLong => serializer.serialize_i32(9),
                Self::InternalError => serializer.serialize_i32(10),
                Self::Unsupported => serializer.serialize_i32(15),
                Self::MismatchedIpVersion => serializer.serialize_i32(16),
                Self::GkeKonnectivityProxyUnsupported => serializer.serialize_i32(17),
                Self::ResourceConfigNotFound => serializer.serialize_i32(18),
                Self::VmInstanceConfigNotFound => serializer.serialize_i32(24),
                Self::NetworkConfigNotFound => serializer.serialize_i32(25),
                Self::FirewallConfigNotFound => serializer.serialize_i32(26),
                Self::RouteConfigNotFound => serializer.serialize_i32(27),
                Self::GoogleManagedServiceAmbiguousPscEndpoint => serializer.serialize_i32(19),
                Self::SourcePscCloudSqlUnsupported => serializer.serialize_i32(20),
                Self::SourceRedisClusterUnsupported => serializer.serialize_i32(34),
                Self::SourceRedisInstanceUnsupported => serializer.serialize_i32(35),
                Self::SourceForwardingRuleUnsupported => serializer.serialize_i32(21),
                Self::NonRoutableIpAddress => serializer.serialize_i32(22),
                Self::UnknownIssueInGoogleManagedProject => serializer.serialize_i32(30),
                Self::UnsupportedGoogleManagedProjectConfig => serializer.serialize_i32(31),
                Self::NoServerlessIpRanges => serializer.serialize_i32(37),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Cause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Cause>::new(
                ".google.cloud.networkmanagement.v1.AbortInfo.Cause",
            ))
        }
    }
}

/// Details of the final state "drop" and associated resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DropInfo {
    /// Cause that the packet is dropped.
    pub cause: crate::model::drop_info::Cause,

    /// URI of the resource that caused the drop.
    pub resource_uri: std::string::String,

    /// Source IP address of the dropped packet (if relevant).
    pub source_ip: std::string::String,

    /// Destination IP address of the dropped packet (if relevant).
    pub destination_ip: std::string::String,

    /// Region of the dropped packet (if relevant).
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DropInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cause][crate::model::DropInfo::cause].
    pub fn set_cause<T: std::convert::Into<crate::model::drop_info::Cause>>(
        mut self,
        v: T,
    ) -> Self {
        self.cause = v.into();
        self
    }

    /// Sets the value of [resource_uri][crate::model::DropInfo::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [source_ip][crate::model::DropInfo::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [destination_ip][crate::model::DropInfo::destination_ip].
    pub fn set_destination_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_ip = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DropInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for DropInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DropInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DropInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cause,
            __resource_uri,
            __source_ip,
            __destination_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DropInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cause" => Ok(__FieldTag::__cause),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DropInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DropInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cause",
                                ));
                            }
                            result.cause = map
                                .next_value::<std::option::Option<crate::model::drop_info::Cause>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_ip",
                                ));
                            }
                            result.destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DropInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cause) {
            state.serialize_entry("cause", &self.cause)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !self.destination_ip.is_empty() {
            state.serialize_entry("destinationIp", &self.destination_ip)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DropInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DropInfo");
        debug_struct.field("cause", &self.cause);
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("source_ip", &self.source_ip);
        debug_struct.field("destination_ip", &self.destination_ip);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DropInfo].
pub mod drop_info {
    #[allow(unused_imports)]
    use super::*;

    /// Drop cause types:
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Cause {
        /// Cause is unspecified.
        Unspecified,
        /// Destination external address cannot be resolved to a known target. If
        /// the address is used in a Google Cloud project, provide the project ID
        /// as test input.
        UnknownExternalAddress,
        /// A Compute Engine instance can only send or receive a packet with a
        /// foreign IP address if ip_forward is enabled.
        ForeignIpDisallowed,
        /// Dropped due to a firewall rule, unless allowed due to connection
        /// tracking.
        FirewallRule,
        /// Dropped due to no matching routes.
        NoRoute,
        /// Dropped due to invalid route. Route's next hop is a blackhole.
        RouteBlackhole,
        /// Packet is sent to a wrong (unintended) network. Example: you trace a
        /// packet from VM1:Network1 to VM2:Network2, however, the route configured
        /// in Network1 sends the packet destined for VM2's IP address to Network3.
        RouteWrongNetwork,
        /// Route's next hop IP address cannot be resolved to a GCP resource.
        RouteNextHopIpAddressNotResolved,
        /// Route's next hop resource is not found.
        RouteNextHopResourceNotFound,
        /// Route's next hop instance doesn't have a NIC in the route's network.
        RouteNextHopInstanceWrongNetwork,
        /// Route's next hop IP address is not a primary IP address of the next hop
        /// instance.
        RouteNextHopInstanceNonPrimaryIp,
        /// Route's next hop forwarding rule doesn't match next hop IP address.
        RouteNextHopForwardingRuleIpMismatch,
        /// Route's next hop VPN tunnel is down (does not have valid IKE SAs).
        RouteNextHopVpnTunnelNotEstablished,
        /// Route's next hop forwarding rule type is invalid (it's not a forwarding
        /// rule of the internal passthrough load balancer).
        RouteNextHopForwardingRuleTypeInvalid,
        /// Packet is sent from the Internet to the private IPv6 address.
        NoRouteFromInternetToPrivateIpv6Address,
        /// The packet does not match a policy-based VPN tunnel local selector.
        VpnTunnelLocalSelectorMismatch,
        /// The packet does not match a policy-based VPN tunnel remote selector.
        VpnTunnelRemoteSelectorMismatch,
        /// Packet with internal destination address sent to the internet gateway.
        PrivateTrafficToInternet,
        /// Instance with only an internal IP address tries to access Google API and
        /// services, but private Google access is not enabled in the subnet.
        PrivateGoogleAccessDisallowed,
        /// Source endpoint tries to access Google API and services through the VPN
        /// tunnel to another network, but Private Google Access needs to be enabled
        /// in the source endpoint network.
        PrivateGoogleAccessViaVpnTunnelUnsupported,
        /// Instance with only an internal IP address tries to access external hosts,
        /// but Cloud NAT is not enabled in the subnet, unless special configurations
        /// on a VM allow this connection.
        NoExternalAddress,
        /// Destination internal address cannot be resolved to a known target. If
        /// this is a shared VPC scenario, verify if the service project ID is
        /// provided as test input. Otherwise, verify if the IP address is being
        /// used in the project.
        UnknownInternalAddress,
        /// Forwarding rule's protocol and ports do not match the packet header.
        ForwardingRuleMismatch,
        /// Forwarding rule does not have backends configured.
        ForwardingRuleNoInstances,
        /// Firewalls block the health check probes to the backends and cause
        /// the backends to be unavailable for traffic from the load balancer.
        /// For more details, see [Health check firewall
        /// rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
        FirewallBlockingLoadBalancerBackendHealthCheck,
        /// Matching ingress firewall rules by network tags for packets sent via
        /// serverless VPC direct egress is unsupported. Behavior is undefined.
        /// <https://cloud.google.com/run/docs/configuring/vpc-direct-vpc#limitations>
        IngressFirewallTagsUnsupportedByDirectVpcEgress,
        /// Packet is sent from or to a Compute Engine instance that is not in a
        /// running state.
        InstanceNotRunning,
        /// Packet sent from or to a GKE cluster that is not in running state.
        GkeClusterNotRunning,
        /// Packet sent from or to a Cloud SQL instance that is not in running state.
        CloudSqlInstanceNotRunning,
        /// Packet sent from or to a Redis Instance that is not in running state.
        RedisInstanceNotRunning,
        /// Packet sent from or to a Redis Cluster that is not in running state.
        RedisClusterNotRunning,
        /// The type of traffic is blocked and the user cannot configure a firewall
        /// rule to enable it. See [Always blocked
        /// traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic) for
        /// more details.
        TrafficTypeBlocked,
        /// Access to Google Kubernetes Engine cluster master's endpoint is not
        /// authorized. See [Access to the cluster
        /// endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
        /// for more details.
        GkeMasterUnauthorizedAccess,
        /// Access to the Cloud SQL instance endpoint is not authorized.
        /// See [Authorizing with authorized
        /// networks](https://cloud.google.com/sql/docs/mysql/authorize-networks) for
        /// more details.
        CloudSqlInstanceUnauthorizedAccess,
        /// Packet was dropped inside Google Kubernetes Engine Service.
        DroppedInsideGkeService,
        /// Packet was dropped inside Cloud SQL Service.
        DroppedInsideCloudSqlService,
        /// Packet was dropped because there is no peering between the originating
        /// network and the Google Managed Services Network.
        GoogleManagedServiceNoPeering,
        /// Packet was dropped because the Google-managed service uses Private
        /// Service Connect (PSC), but the PSC endpoint is not found in the project.
        GoogleManagedServiceNoPscEndpoint,
        /// Packet was dropped because the GKE cluster uses Private Service Connect
        /// (PSC), but the PSC endpoint is not found in the project.
        GkePscEndpointMissing,
        /// Packet was dropped because the Cloud SQL instance has neither a private
        /// nor a public IP address.
        CloudSqlInstanceNoIpAddress,
        /// Packet was dropped because a GKE cluster private endpoint is
        /// unreachable from a region different from the cluster's region.
        GkeControlPlaneRegionMismatch,
        /// Packet sent from a public GKE cluster control plane to a private
        /// IP address.
        PublicGkeControlPlaneToPrivateDestination,
        /// Packet was dropped because there is no route from a GKE cluster
        /// control plane to a destination network.
        GkeControlPlaneNoRoute,
        /// Packet sent from a Cloud SQL instance to an external IP address is not
        /// allowed. The Cloud SQL instance is not configured to send packets to
        /// external IP addresses.
        CloudSqlInstanceNotConfiguredForExternalTraffic,
        /// Packet sent from a Cloud SQL instance with only a public IP address to a
        /// private IP address.
        PublicCloudSqlInstanceToPrivateDestination,
        /// Packet was dropped because there is no route from a Cloud SQL
        /// instance to a destination network.
        CloudSqlInstanceNoRoute,
        /// Packet was dropped because the Cloud SQL instance requires all
        /// connections to use Cloud SQL connectors and to target the Cloud SQL proxy
        /// port (3307).
        CloudSqlConnectorRequired,
        /// Packet could be dropped because the Cloud Function is not in an active
        /// status.
        CloudFunctionNotActive,
        /// Packet could be dropped because no VPC connector is set.
        VpcConnectorNotSet,
        /// Packet could be dropped because the VPC connector is not in a running
        /// state.
        VpcConnectorNotRunning,
        /// Packet could be dropped because the traffic from the serverless service
        /// to the VPC connector is not allowed.
        VpcConnectorServerlessTrafficBlocked,
        /// Packet could be dropped because the health check traffic to the VPC
        /// connector is not allowed.
        VpcConnectorHealthCheckTrafficBlocked,
        /// Packet could be dropped because it was sent from a different region
        /// to a regional forwarding without global access.
        ForwardingRuleRegionMismatch,
        /// The Private Service Connect endpoint is in a project that is not approved
        /// to connect to the service.
        PscConnectionNotAccepted,
        /// The packet is sent to the Private Service Connect endpoint over the
        /// peering, but [it's not
        /// supported](https://cloud.google.com/vpc/docs/configure-private-service-connect-services#on-premises).
        PscEndpointAccessedFromPeeredNetwork,
        /// The packet is sent to the Private Service Connect backend (network
        /// endpoint group), but the producer PSC forwarding rule does not have
        /// global access enabled.
        PscNegProducerEndpointNoGlobalAccess,
        /// The packet is sent to the Private Service Connect backend (network
        /// endpoint group), but the producer PSC forwarding rule has multiple ports
        /// specified.
        PscNegProducerForwardingRuleMultiplePorts,
        /// The packet is sent to the Private Service Connect backend (network
        /// endpoint group) targeting a Cloud SQL service attachment, but this
        /// configuration is not supported.
        CloudSqlPscNegUnsupported,
        /// No NAT subnets are defined for the PSC service attachment.
        NoNatSubnetsForPscServiceAttachment,
        /// PSC endpoint is accessed via NCC, but PSC transitivity configuration is
        /// not yet propagated.
        PscTransitivityNotPropagated,
        /// The packet sent from the hybrid NEG proxy matches a non-dynamic route,
        /// but such a configuration is not supported.
        HybridNegNonDynamicRouteMatched,
        /// The packet sent from the hybrid NEG proxy matches a dynamic route with a
        /// next hop in a different region, but such a configuration is not
        /// supported.
        HybridNegNonLocalDynamicRouteMatched,
        /// Packet sent from a Cloud Run revision that is not ready.
        CloudRunRevisionNotReady,
        /// Packet was dropped inside Private Service Connect service producer.
        DroppedInsidePscServiceProducer,
        /// Packet sent to a load balancer, which requires a proxy-only subnet and
        /// the subnet is not found.
        LoadBalancerHasNoProxySubnet,
        /// Packet sent to Cloud Nat without active NAT IPs.
        CloudNatNoAddresses,
        /// Packet is stuck in a routing loop.
        RoutingLoop,
        /// Packet is dropped inside a Google-managed service due to being delivered
        /// in return trace to an endpoint that doesn't match the endpoint the packet
        /// was sent from in forward trace. Used only for return traces.
        DroppedInsideGoogleManagedService,
        /// Packet is dropped due to a load balancer backend instance not having a
        /// network interface in the network expected by the load balancer.
        LoadBalancerBackendInvalidNetwork,
        /// Packet is dropped due to a backend service named port not being defined
        /// on the instance group level.
        BackendServiceNamedPortNotDefined,
        /// Packet is dropped due to a destination IP range being part of a Private
        /// NAT IP range.
        DestinationIsPrivateNatIpRange,
        /// Generic drop cause for a packet being dropped inside a Redis Instance
        /// service project.
        DroppedInsideRedisInstanceService,
        /// Packet is dropped due to an unsupported port being used to connect to a
        /// Redis Instance. Port 6379 should be used to connect to a Redis Instance.
        RedisInstanceUnsupportedPort,
        /// Packet is dropped due to connecting from PUPI address to a PSA based
        /// Redis Instance.
        RedisInstanceConnectingFromPupiAddress,
        /// Packet is dropped due to no route to the destination network.
        RedisInstanceNoRouteToDestinationNetwork,
        /// Redis Instance does not have an external IP address.
        RedisInstanceNoExternalIp,
        /// Packet is dropped due to an unsupported protocol being used to connect to
        /// a Redis Instance. Only TCP connections are accepted by a Redis Instance.
        RedisInstanceUnsupportedProtocol,
        /// Generic drop cause for a packet being dropped inside a Redis Cluster
        /// service project.
        DroppedInsideRedisClusterService,
        /// Packet is dropped due to an unsupported port being used to connect to a
        /// Redis Cluster. Ports 6379 and 11000 to 13047 should be used to connect to
        /// a Redis Cluster.
        RedisClusterUnsupportedPort,
        /// Redis Cluster does not have an external IP address.
        RedisClusterNoExternalIp,
        /// Packet is dropped due to an unsupported protocol being used to connect to
        /// a Redis Cluster. Only TCP connections are accepted by a Redis Cluster.
        RedisClusterUnsupportedProtocol,
        /// Packet from the non-GCP (on-prem) or unknown GCP network is dropped due
        /// to the destination IP address not belonging to any IP prefix advertised
        /// via BGP by the Cloud Router.
        NoAdvertisedRouteToGcpDestination,
        /// Packet from the non-GCP (on-prem) or unknown GCP network is dropped due
        /// to the destination IP address not belonging to any IP prefix included to
        /// the local traffic selector of the VPN tunnel.
        NoTrafficSelectorToGcpDestination,
        /// Packet from the unknown peered network is dropped due to no known route
        /// from the source network to the destination IP address.
        NoKnownRouteFromPeeredNetworkToDestination,
        /// Sending packets processed by the Private NAT Gateways to the Private
        /// Service Connect endpoints is not supported.
        PrivateNatToPscEndpointUnsupported,
        /// Packet is sent to the PSC port mapping service, but its destination port
        /// does not match any port mapping rules.
        PscPortMappingPortMismatch,
        /// Sending packets directly to the PSC port mapping service without going
        /// through the PSC connection is not supported.
        PscPortMappingWithoutPscConnectionUnsupported,
        /// Packet with destination IP address within the reserved NAT64 range is
        /// dropped due to matching a route of an unsupported type.
        UnsupportedRouteMatchedForNat64Destination,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Cause::value] or
        /// [Cause::name].
        UnknownValue(cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Cause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownExternalAddress => std::option::Option::Some(1),
                Self::ForeignIpDisallowed => std::option::Option::Some(2),
                Self::FirewallRule => std::option::Option::Some(3),
                Self::NoRoute => std::option::Option::Some(4),
                Self::RouteBlackhole => std::option::Option::Some(5),
                Self::RouteWrongNetwork => std::option::Option::Some(6),
                Self::RouteNextHopIpAddressNotResolved => std::option::Option::Some(42),
                Self::RouteNextHopResourceNotFound => std::option::Option::Some(43),
                Self::RouteNextHopInstanceWrongNetwork => std::option::Option::Some(49),
                Self::RouteNextHopInstanceNonPrimaryIp => std::option::Option::Some(50),
                Self::RouteNextHopForwardingRuleIpMismatch => std::option::Option::Some(51),
                Self::RouteNextHopVpnTunnelNotEstablished => std::option::Option::Some(52),
                Self::RouteNextHopForwardingRuleTypeInvalid => std::option::Option::Some(53),
                Self::NoRouteFromInternetToPrivateIpv6Address => std::option::Option::Some(44),
                Self::VpnTunnelLocalSelectorMismatch => std::option::Option::Some(45),
                Self::VpnTunnelRemoteSelectorMismatch => std::option::Option::Some(46),
                Self::PrivateTrafficToInternet => std::option::Option::Some(7),
                Self::PrivateGoogleAccessDisallowed => std::option::Option::Some(8),
                Self::PrivateGoogleAccessViaVpnTunnelUnsupported => std::option::Option::Some(47),
                Self::NoExternalAddress => std::option::Option::Some(9),
                Self::UnknownInternalAddress => std::option::Option::Some(10),
                Self::ForwardingRuleMismatch => std::option::Option::Some(11),
                Self::ForwardingRuleNoInstances => std::option::Option::Some(12),
                Self::FirewallBlockingLoadBalancerBackendHealthCheck => {
                    std::option::Option::Some(13)
                }
                Self::IngressFirewallTagsUnsupportedByDirectVpcEgress => {
                    std::option::Option::Some(85)
                }
                Self::InstanceNotRunning => std::option::Option::Some(14),
                Self::GkeClusterNotRunning => std::option::Option::Some(27),
                Self::CloudSqlInstanceNotRunning => std::option::Option::Some(28),
                Self::RedisInstanceNotRunning => std::option::Option::Some(68),
                Self::RedisClusterNotRunning => std::option::Option::Some(69),
                Self::TrafficTypeBlocked => std::option::Option::Some(15),
                Self::GkeMasterUnauthorizedAccess => std::option::Option::Some(16),
                Self::CloudSqlInstanceUnauthorizedAccess => std::option::Option::Some(17),
                Self::DroppedInsideGkeService => std::option::Option::Some(18),
                Self::DroppedInsideCloudSqlService => std::option::Option::Some(19),
                Self::GoogleManagedServiceNoPeering => std::option::Option::Some(20),
                Self::GoogleManagedServiceNoPscEndpoint => std::option::Option::Some(38),
                Self::GkePscEndpointMissing => std::option::Option::Some(36),
                Self::CloudSqlInstanceNoIpAddress => std::option::Option::Some(21),
                Self::GkeControlPlaneRegionMismatch => std::option::Option::Some(30),
                Self::PublicGkeControlPlaneToPrivateDestination => std::option::Option::Some(31),
                Self::GkeControlPlaneNoRoute => std::option::Option::Some(32),
                Self::CloudSqlInstanceNotConfiguredForExternalTraffic => {
                    std::option::Option::Some(33)
                }
                Self::PublicCloudSqlInstanceToPrivateDestination => std::option::Option::Some(34),
                Self::CloudSqlInstanceNoRoute => std::option::Option::Some(35),
                Self::CloudSqlConnectorRequired => std::option::Option::Some(63),
                Self::CloudFunctionNotActive => std::option::Option::Some(22),
                Self::VpcConnectorNotSet => std::option::Option::Some(23),
                Self::VpcConnectorNotRunning => std::option::Option::Some(24),
                Self::VpcConnectorServerlessTrafficBlocked => std::option::Option::Some(60),
                Self::VpcConnectorHealthCheckTrafficBlocked => std::option::Option::Some(61),
                Self::ForwardingRuleRegionMismatch => std::option::Option::Some(25),
                Self::PscConnectionNotAccepted => std::option::Option::Some(26),
                Self::PscEndpointAccessedFromPeeredNetwork => std::option::Option::Some(41),
                Self::PscNegProducerEndpointNoGlobalAccess => std::option::Option::Some(48),
                Self::PscNegProducerForwardingRuleMultiplePorts => std::option::Option::Some(54),
                Self::CloudSqlPscNegUnsupported => std::option::Option::Some(58),
                Self::NoNatSubnetsForPscServiceAttachment => std::option::Option::Some(57),
                Self::PscTransitivityNotPropagated => std::option::Option::Some(64),
                Self::HybridNegNonDynamicRouteMatched => std::option::Option::Some(55),
                Self::HybridNegNonLocalDynamicRouteMatched => std::option::Option::Some(56),
                Self::CloudRunRevisionNotReady => std::option::Option::Some(29),
                Self::DroppedInsidePscServiceProducer => std::option::Option::Some(37),
                Self::LoadBalancerHasNoProxySubnet => std::option::Option::Some(39),
                Self::CloudNatNoAddresses => std::option::Option::Some(40),
                Self::RoutingLoop => std::option::Option::Some(59),
                Self::DroppedInsideGoogleManagedService => std::option::Option::Some(62),
                Self::LoadBalancerBackendInvalidNetwork => std::option::Option::Some(65),
                Self::BackendServiceNamedPortNotDefined => std::option::Option::Some(66),
                Self::DestinationIsPrivateNatIpRange => std::option::Option::Some(67),
                Self::DroppedInsideRedisInstanceService => std::option::Option::Some(70),
                Self::RedisInstanceUnsupportedPort => std::option::Option::Some(71),
                Self::RedisInstanceConnectingFromPupiAddress => std::option::Option::Some(72),
                Self::RedisInstanceNoRouteToDestinationNetwork => std::option::Option::Some(73),
                Self::RedisInstanceNoExternalIp => std::option::Option::Some(74),
                Self::RedisInstanceUnsupportedProtocol => std::option::Option::Some(78),
                Self::DroppedInsideRedisClusterService => std::option::Option::Some(75),
                Self::RedisClusterUnsupportedPort => std::option::Option::Some(76),
                Self::RedisClusterNoExternalIp => std::option::Option::Some(77),
                Self::RedisClusterUnsupportedProtocol => std::option::Option::Some(79),
                Self::NoAdvertisedRouteToGcpDestination => std::option::Option::Some(80),
                Self::NoTrafficSelectorToGcpDestination => std::option::Option::Some(81),
                Self::NoKnownRouteFromPeeredNetworkToDestination => std::option::Option::Some(82),
                Self::PrivateNatToPscEndpointUnsupported => std::option::Option::Some(83),
                Self::PscPortMappingPortMismatch => std::option::Option::Some(86),
                Self::PscPortMappingWithoutPscConnectionUnsupported => {
                    std::option::Option::Some(87)
                }
                Self::UnsupportedRouteMatchedForNat64Destination => std::option::Option::Some(88),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CAUSE_UNSPECIFIED"),
                Self::UnknownExternalAddress => {
                    std::option::Option::Some("UNKNOWN_EXTERNAL_ADDRESS")
                }
                Self::ForeignIpDisallowed => std::option::Option::Some("FOREIGN_IP_DISALLOWED"),
                Self::FirewallRule => std::option::Option::Some("FIREWALL_RULE"),
                Self::NoRoute => std::option::Option::Some("NO_ROUTE"),
                Self::RouteBlackhole => std::option::Option::Some("ROUTE_BLACKHOLE"),
                Self::RouteWrongNetwork => std::option::Option::Some("ROUTE_WRONG_NETWORK"),
                Self::RouteNextHopIpAddressNotResolved => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED")
                }
                Self::RouteNextHopResourceNotFound => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND")
                }
                Self::RouteNextHopInstanceWrongNetwork => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK")
                }
                Self::RouteNextHopInstanceNonPrimaryIp => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP")
                }
                Self::RouteNextHopForwardingRuleIpMismatch => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH")
                }
                Self::RouteNextHopVpnTunnelNotEstablished => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED")
                }
                Self::RouteNextHopForwardingRuleTypeInvalid => {
                    std::option::Option::Some("ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID")
                }
                Self::NoRouteFromInternetToPrivateIpv6Address => {
                    std::option::Option::Some("NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS")
                }
                Self::VpnTunnelLocalSelectorMismatch => {
                    std::option::Option::Some("VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH")
                }
                Self::VpnTunnelRemoteSelectorMismatch => {
                    std::option::Option::Some("VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH")
                }
                Self::PrivateTrafficToInternet => {
                    std::option::Option::Some("PRIVATE_TRAFFIC_TO_INTERNET")
                }
                Self::PrivateGoogleAccessDisallowed => {
                    std::option::Option::Some("PRIVATE_GOOGLE_ACCESS_DISALLOWED")
                }
                Self::PrivateGoogleAccessViaVpnTunnelUnsupported => {
                    std::option::Option::Some("PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED")
                }
                Self::NoExternalAddress => std::option::Option::Some("NO_EXTERNAL_ADDRESS"),
                Self::UnknownInternalAddress => {
                    std::option::Option::Some("UNKNOWN_INTERNAL_ADDRESS")
                }
                Self::ForwardingRuleMismatch => {
                    std::option::Option::Some("FORWARDING_RULE_MISMATCH")
                }
                Self::ForwardingRuleNoInstances => {
                    std::option::Option::Some("FORWARDING_RULE_NO_INSTANCES")
                }
                Self::FirewallBlockingLoadBalancerBackendHealthCheck => std::option::Option::Some(
                    "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK",
                ),
                Self::IngressFirewallTagsUnsupportedByDirectVpcEgress => std::option::Option::Some(
                    "INGRESS_FIREWALL_TAGS_UNSUPPORTED_BY_DIRECT_VPC_EGRESS",
                ),
                Self::InstanceNotRunning => std::option::Option::Some("INSTANCE_NOT_RUNNING"),
                Self::GkeClusterNotRunning => std::option::Option::Some("GKE_CLUSTER_NOT_RUNNING"),
                Self::CloudSqlInstanceNotRunning => {
                    std::option::Option::Some("CLOUD_SQL_INSTANCE_NOT_RUNNING")
                }
                Self::RedisInstanceNotRunning => {
                    std::option::Option::Some("REDIS_INSTANCE_NOT_RUNNING")
                }
                Self::RedisClusterNotRunning => {
                    std::option::Option::Some("REDIS_CLUSTER_NOT_RUNNING")
                }
                Self::TrafficTypeBlocked => std::option::Option::Some("TRAFFIC_TYPE_BLOCKED"),
                Self::GkeMasterUnauthorizedAccess => {
                    std::option::Option::Some("GKE_MASTER_UNAUTHORIZED_ACCESS")
                }
                Self::CloudSqlInstanceUnauthorizedAccess => {
                    std::option::Option::Some("CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS")
                }
                Self::DroppedInsideGkeService => {
                    std::option::Option::Some("DROPPED_INSIDE_GKE_SERVICE")
                }
                Self::DroppedInsideCloudSqlService => {
                    std::option::Option::Some("DROPPED_INSIDE_CLOUD_SQL_SERVICE")
                }
                Self::GoogleManagedServiceNoPeering => {
                    std::option::Option::Some("GOOGLE_MANAGED_SERVICE_NO_PEERING")
                }
                Self::GoogleManagedServiceNoPscEndpoint => {
                    std::option::Option::Some("GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT")
                }
                Self::GkePscEndpointMissing => {
                    std::option::Option::Some("GKE_PSC_ENDPOINT_MISSING")
                }
                Self::CloudSqlInstanceNoIpAddress => {
                    std::option::Option::Some("CLOUD_SQL_INSTANCE_NO_IP_ADDRESS")
                }
                Self::GkeControlPlaneRegionMismatch => {
                    std::option::Option::Some("GKE_CONTROL_PLANE_REGION_MISMATCH")
                }
                Self::PublicGkeControlPlaneToPrivateDestination => {
                    std::option::Option::Some("PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION")
                }
                Self::GkeControlPlaneNoRoute => {
                    std::option::Option::Some("GKE_CONTROL_PLANE_NO_ROUTE")
                }
                Self::CloudSqlInstanceNotConfiguredForExternalTraffic => std::option::Option::Some(
                    "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC",
                ),
                Self::PublicCloudSqlInstanceToPrivateDestination => {
                    std::option::Option::Some("PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION")
                }
                Self::CloudSqlInstanceNoRoute => {
                    std::option::Option::Some("CLOUD_SQL_INSTANCE_NO_ROUTE")
                }
                Self::CloudSqlConnectorRequired => {
                    std::option::Option::Some("CLOUD_SQL_CONNECTOR_REQUIRED")
                }
                Self::CloudFunctionNotActive => {
                    std::option::Option::Some("CLOUD_FUNCTION_NOT_ACTIVE")
                }
                Self::VpcConnectorNotSet => std::option::Option::Some("VPC_CONNECTOR_NOT_SET"),
                Self::VpcConnectorNotRunning => {
                    std::option::Option::Some("VPC_CONNECTOR_NOT_RUNNING")
                }
                Self::VpcConnectorServerlessTrafficBlocked => {
                    std::option::Option::Some("VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED")
                }
                Self::VpcConnectorHealthCheckTrafficBlocked => {
                    std::option::Option::Some("VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED")
                }
                Self::ForwardingRuleRegionMismatch => {
                    std::option::Option::Some("FORWARDING_RULE_REGION_MISMATCH")
                }
                Self::PscConnectionNotAccepted => {
                    std::option::Option::Some("PSC_CONNECTION_NOT_ACCEPTED")
                }
                Self::PscEndpointAccessedFromPeeredNetwork => {
                    std::option::Option::Some("PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK")
                }
                Self::PscNegProducerEndpointNoGlobalAccess => {
                    std::option::Option::Some("PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS")
                }
                Self::PscNegProducerForwardingRuleMultiplePorts => {
                    std::option::Option::Some("PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS")
                }
                Self::CloudSqlPscNegUnsupported => {
                    std::option::Option::Some("CLOUD_SQL_PSC_NEG_UNSUPPORTED")
                }
                Self::NoNatSubnetsForPscServiceAttachment => {
                    std::option::Option::Some("NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT")
                }
                Self::PscTransitivityNotPropagated => {
                    std::option::Option::Some("PSC_TRANSITIVITY_NOT_PROPAGATED")
                }
                Self::HybridNegNonDynamicRouteMatched => {
                    std::option::Option::Some("HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED")
                }
                Self::HybridNegNonLocalDynamicRouteMatched => {
                    std::option::Option::Some("HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED")
                }
                Self::CloudRunRevisionNotReady => {
                    std::option::Option::Some("CLOUD_RUN_REVISION_NOT_READY")
                }
                Self::DroppedInsidePscServiceProducer => {
                    std::option::Option::Some("DROPPED_INSIDE_PSC_SERVICE_PRODUCER")
                }
                Self::LoadBalancerHasNoProxySubnet => {
                    std::option::Option::Some("LOAD_BALANCER_HAS_NO_PROXY_SUBNET")
                }
                Self::CloudNatNoAddresses => std::option::Option::Some("CLOUD_NAT_NO_ADDRESSES"),
                Self::RoutingLoop => std::option::Option::Some("ROUTING_LOOP"),
                Self::DroppedInsideGoogleManagedService => {
                    std::option::Option::Some("DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE")
                }
                Self::LoadBalancerBackendInvalidNetwork => {
                    std::option::Option::Some("LOAD_BALANCER_BACKEND_INVALID_NETWORK")
                }
                Self::BackendServiceNamedPortNotDefined => {
                    std::option::Option::Some("BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED")
                }
                Self::DestinationIsPrivateNatIpRange => {
                    std::option::Option::Some("DESTINATION_IS_PRIVATE_NAT_IP_RANGE")
                }
                Self::DroppedInsideRedisInstanceService => {
                    std::option::Option::Some("DROPPED_INSIDE_REDIS_INSTANCE_SERVICE")
                }
                Self::RedisInstanceUnsupportedPort => {
                    std::option::Option::Some("REDIS_INSTANCE_UNSUPPORTED_PORT")
                }
                Self::RedisInstanceConnectingFromPupiAddress => {
                    std::option::Option::Some("REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS")
                }
                Self::RedisInstanceNoRouteToDestinationNetwork => {
                    std::option::Option::Some("REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK")
                }
                Self::RedisInstanceNoExternalIp => {
                    std::option::Option::Some("REDIS_INSTANCE_NO_EXTERNAL_IP")
                }
                Self::RedisInstanceUnsupportedProtocol => {
                    std::option::Option::Some("REDIS_INSTANCE_UNSUPPORTED_PROTOCOL")
                }
                Self::DroppedInsideRedisClusterService => {
                    std::option::Option::Some("DROPPED_INSIDE_REDIS_CLUSTER_SERVICE")
                }
                Self::RedisClusterUnsupportedPort => {
                    std::option::Option::Some("REDIS_CLUSTER_UNSUPPORTED_PORT")
                }
                Self::RedisClusterNoExternalIp => {
                    std::option::Option::Some("REDIS_CLUSTER_NO_EXTERNAL_IP")
                }
                Self::RedisClusterUnsupportedProtocol => {
                    std::option::Option::Some("REDIS_CLUSTER_UNSUPPORTED_PROTOCOL")
                }
                Self::NoAdvertisedRouteToGcpDestination => {
                    std::option::Option::Some("NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION")
                }
                Self::NoTrafficSelectorToGcpDestination => {
                    std::option::Option::Some("NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION")
                }
                Self::NoKnownRouteFromPeeredNetworkToDestination => {
                    std::option::Option::Some("NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION")
                }
                Self::PrivateNatToPscEndpointUnsupported => {
                    std::option::Option::Some("PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED")
                }
                Self::PscPortMappingPortMismatch => {
                    std::option::Option::Some("PSC_PORT_MAPPING_PORT_MISMATCH")
                }
                Self::PscPortMappingWithoutPscConnectionUnsupported => {
                    std::option::Option::Some("PSC_PORT_MAPPING_WITHOUT_PSC_CONNECTION_UNSUPPORTED")
                }
                Self::UnsupportedRouteMatchedForNat64Destination => {
                    std::option::Option::Some("UNSUPPORTED_ROUTE_MATCHED_FOR_NAT64_DESTINATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Cause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Cause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Cause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownExternalAddress,
                2 => Self::ForeignIpDisallowed,
                3 => Self::FirewallRule,
                4 => Self::NoRoute,
                5 => Self::RouteBlackhole,
                6 => Self::RouteWrongNetwork,
                7 => Self::PrivateTrafficToInternet,
                8 => Self::PrivateGoogleAccessDisallowed,
                9 => Self::NoExternalAddress,
                10 => Self::UnknownInternalAddress,
                11 => Self::ForwardingRuleMismatch,
                12 => Self::ForwardingRuleNoInstances,
                13 => Self::FirewallBlockingLoadBalancerBackendHealthCheck,
                14 => Self::InstanceNotRunning,
                15 => Self::TrafficTypeBlocked,
                16 => Self::GkeMasterUnauthorizedAccess,
                17 => Self::CloudSqlInstanceUnauthorizedAccess,
                18 => Self::DroppedInsideGkeService,
                19 => Self::DroppedInsideCloudSqlService,
                20 => Self::GoogleManagedServiceNoPeering,
                21 => Self::CloudSqlInstanceNoIpAddress,
                22 => Self::CloudFunctionNotActive,
                23 => Self::VpcConnectorNotSet,
                24 => Self::VpcConnectorNotRunning,
                25 => Self::ForwardingRuleRegionMismatch,
                26 => Self::PscConnectionNotAccepted,
                27 => Self::GkeClusterNotRunning,
                28 => Self::CloudSqlInstanceNotRunning,
                29 => Self::CloudRunRevisionNotReady,
                30 => Self::GkeControlPlaneRegionMismatch,
                31 => Self::PublicGkeControlPlaneToPrivateDestination,
                32 => Self::GkeControlPlaneNoRoute,
                33 => Self::CloudSqlInstanceNotConfiguredForExternalTraffic,
                34 => Self::PublicCloudSqlInstanceToPrivateDestination,
                35 => Self::CloudSqlInstanceNoRoute,
                36 => Self::GkePscEndpointMissing,
                37 => Self::DroppedInsidePscServiceProducer,
                38 => Self::GoogleManagedServiceNoPscEndpoint,
                39 => Self::LoadBalancerHasNoProxySubnet,
                40 => Self::CloudNatNoAddresses,
                41 => Self::PscEndpointAccessedFromPeeredNetwork,
                42 => Self::RouteNextHopIpAddressNotResolved,
                43 => Self::RouteNextHopResourceNotFound,
                44 => Self::NoRouteFromInternetToPrivateIpv6Address,
                45 => Self::VpnTunnelLocalSelectorMismatch,
                46 => Self::VpnTunnelRemoteSelectorMismatch,
                47 => Self::PrivateGoogleAccessViaVpnTunnelUnsupported,
                48 => Self::PscNegProducerEndpointNoGlobalAccess,
                49 => Self::RouteNextHopInstanceWrongNetwork,
                50 => Self::RouteNextHopInstanceNonPrimaryIp,
                51 => Self::RouteNextHopForwardingRuleIpMismatch,
                52 => Self::RouteNextHopVpnTunnelNotEstablished,
                53 => Self::RouteNextHopForwardingRuleTypeInvalid,
                54 => Self::PscNegProducerForwardingRuleMultiplePorts,
                55 => Self::HybridNegNonDynamicRouteMatched,
                56 => Self::HybridNegNonLocalDynamicRouteMatched,
                57 => Self::NoNatSubnetsForPscServiceAttachment,
                58 => Self::CloudSqlPscNegUnsupported,
                59 => Self::RoutingLoop,
                60 => Self::VpcConnectorServerlessTrafficBlocked,
                61 => Self::VpcConnectorHealthCheckTrafficBlocked,
                62 => Self::DroppedInsideGoogleManagedService,
                63 => Self::CloudSqlConnectorRequired,
                64 => Self::PscTransitivityNotPropagated,
                65 => Self::LoadBalancerBackendInvalidNetwork,
                66 => Self::BackendServiceNamedPortNotDefined,
                67 => Self::DestinationIsPrivateNatIpRange,
                68 => Self::RedisInstanceNotRunning,
                69 => Self::RedisClusterNotRunning,
                70 => Self::DroppedInsideRedisInstanceService,
                71 => Self::RedisInstanceUnsupportedPort,
                72 => Self::RedisInstanceConnectingFromPupiAddress,
                73 => Self::RedisInstanceNoRouteToDestinationNetwork,
                74 => Self::RedisInstanceNoExternalIp,
                75 => Self::DroppedInsideRedisClusterService,
                76 => Self::RedisClusterUnsupportedPort,
                77 => Self::RedisClusterNoExternalIp,
                78 => Self::RedisInstanceUnsupportedProtocol,
                79 => Self::RedisClusterUnsupportedProtocol,
                80 => Self::NoAdvertisedRouteToGcpDestination,
                81 => Self::NoTrafficSelectorToGcpDestination,
                82 => Self::NoKnownRouteFromPeeredNetworkToDestination,
                83 => Self::PrivateNatToPscEndpointUnsupported,
                85 => Self::IngressFirewallTagsUnsupportedByDirectVpcEgress,
                86 => Self::PscPortMappingPortMismatch,
                87 => Self::PscPortMappingWithoutPscConnectionUnsupported,
                88 => Self::UnsupportedRouteMatchedForNat64Destination,
                _ => Self::UnknownValue(cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Cause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CAUSE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_EXTERNAL_ADDRESS" => Self::UnknownExternalAddress,
                "FOREIGN_IP_DISALLOWED" => Self::ForeignIpDisallowed,
                "FIREWALL_RULE" => Self::FirewallRule,
                "NO_ROUTE" => Self::NoRoute,
                "ROUTE_BLACKHOLE" => Self::RouteBlackhole,
                "ROUTE_WRONG_NETWORK" => Self::RouteWrongNetwork,
                "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED" => Self::RouteNextHopIpAddressNotResolved,
                "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND" => Self::RouteNextHopResourceNotFound,
                "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK" => Self::RouteNextHopInstanceWrongNetwork,
                "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP" => Self::RouteNextHopInstanceNonPrimaryIp,
                "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH" => {
                    Self::RouteNextHopForwardingRuleIpMismatch
                }
                "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED" => {
                    Self::RouteNextHopVpnTunnelNotEstablished
                }
                "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID" => {
                    Self::RouteNextHopForwardingRuleTypeInvalid
                }
                "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS" => {
                    Self::NoRouteFromInternetToPrivateIpv6Address
                }
                "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH" => Self::VpnTunnelLocalSelectorMismatch,
                "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH" => Self::VpnTunnelRemoteSelectorMismatch,
                "PRIVATE_TRAFFIC_TO_INTERNET" => Self::PrivateTrafficToInternet,
                "PRIVATE_GOOGLE_ACCESS_DISALLOWED" => Self::PrivateGoogleAccessDisallowed,
                "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED" => {
                    Self::PrivateGoogleAccessViaVpnTunnelUnsupported
                }
                "NO_EXTERNAL_ADDRESS" => Self::NoExternalAddress,
                "UNKNOWN_INTERNAL_ADDRESS" => Self::UnknownInternalAddress,
                "FORWARDING_RULE_MISMATCH" => Self::ForwardingRuleMismatch,
                "FORWARDING_RULE_NO_INSTANCES" => Self::ForwardingRuleNoInstances,
                "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK" => {
                    Self::FirewallBlockingLoadBalancerBackendHealthCheck
                }
                "INGRESS_FIREWALL_TAGS_UNSUPPORTED_BY_DIRECT_VPC_EGRESS" => {
                    Self::IngressFirewallTagsUnsupportedByDirectVpcEgress
                }
                "INSTANCE_NOT_RUNNING" => Self::InstanceNotRunning,
                "GKE_CLUSTER_NOT_RUNNING" => Self::GkeClusterNotRunning,
                "CLOUD_SQL_INSTANCE_NOT_RUNNING" => Self::CloudSqlInstanceNotRunning,
                "REDIS_INSTANCE_NOT_RUNNING" => Self::RedisInstanceNotRunning,
                "REDIS_CLUSTER_NOT_RUNNING" => Self::RedisClusterNotRunning,
                "TRAFFIC_TYPE_BLOCKED" => Self::TrafficTypeBlocked,
                "GKE_MASTER_UNAUTHORIZED_ACCESS" => Self::GkeMasterUnauthorizedAccess,
                "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS" => {
                    Self::CloudSqlInstanceUnauthorizedAccess
                }
                "DROPPED_INSIDE_GKE_SERVICE" => Self::DroppedInsideGkeService,
                "DROPPED_INSIDE_CLOUD_SQL_SERVICE" => Self::DroppedInsideCloudSqlService,
                "GOOGLE_MANAGED_SERVICE_NO_PEERING" => Self::GoogleManagedServiceNoPeering,
                "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT" => Self::GoogleManagedServiceNoPscEndpoint,
                "GKE_PSC_ENDPOINT_MISSING" => Self::GkePscEndpointMissing,
                "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS" => Self::CloudSqlInstanceNoIpAddress,
                "GKE_CONTROL_PLANE_REGION_MISMATCH" => Self::GkeControlPlaneRegionMismatch,
                "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION" => {
                    Self::PublicGkeControlPlaneToPrivateDestination
                }
                "GKE_CONTROL_PLANE_NO_ROUTE" => Self::GkeControlPlaneNoRoute,
                "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC" => {
                    Self::CloudSqlInstanceNotConfiguredForExternalTraffic
                }
                "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION" => {
                    Self::PublicCloudSqlInstanceToPrivateDestination
                }
                "CLOUD_SQL_INSTANCE_NO_ROUTE" => Self::CloudSqlInstanceNoRoute,
                "CLOUD_SQL_CONNECTOR_REQUIRED" => Self::CloudSqlConnectorRequired,
                "CLOUD_FUNCTION_NOT_ACTIVE" => Self::CloudFunctionNotActive,
                "VPC_CONNECTOR_NOT_SET" => Self::VpcConnectorNotSet,
                "VPC_CONNECTOR_NOT_RUNNING" => Self::VpcConnectorNotRunning,
                "VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED" => {
                    Self::VpcConnectorServerlessTrafficBlocked
                }
                "VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED" => {
                    Self::VpcConnectorHealthCheckTrafficBlocked
                }
                "FORWARDING_RULE_REGION_MISMATCH" => Self::ForwardingRuleRegionMismatch,
                "PSC_CONNECTION_NOT_ACCEPTED" => Self::PscConnectionNotAccepted,
                "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK" => {
                    Self::PscEndpointAccessedFromPeeredNetwork
                }
                "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS" => {
                    Self::PscNegProducerEndpointNoGlobalAccess
                }
                "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS" => {
                    Self::PscNegProducerForwardingRuleMultiplePorts
                }
                "CLOUD_SQL_PSC_NEG_UNSUPPORTED" => Self::CloudSqlPscNegUnsupported,
                "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT" => {
                    Self::NoNatSubnetsForPscServiceAttachment
                }
                "PSC_TRANSITIVITY_NOT_PROPAGATED" => Self::PscTransitivityNotPropagated,
                "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED" => Self::HybridNegNonDynamicRouteMatched,
                "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED" => {
                    Self::HybridNegNonLocalDynamicRouteMatched
                }
                "CLOUD_RUN_REVISION_NOT_READY" => Self::CloudRunRevisionNotReady,
                "DROPPED_INSIDE_PSC_SERVICE_PRODUCER" => Self::DroppedInsidePscServiceProducer,
                "LOAD_BALANCER_HAS_NO_PROXY_SUBNET" => Self::LoadBalancerHasNoProxySubnet,
                "CLOUD_NAT_NO_ADDRESSES" => Self::CloudNatNoAddresses,
                "ROUTING_LOOP" => Self::RoutingLoop,
                "DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE" => Self::DroppedInsideGoogleManagedService,
                "LOAD_BALANCER_BACKEND_INVALID_NETWORK" => Self::LoadBalancerBackendInvalidNetwork,
                "BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED" => Self::BackendServiceNamedPortNotDefined,
                "DESTINATION_IS_PRIVATE_NAT_IP_RANGE" => Self::DestinationIsPrivateNatIpRange,
                "DROPPED_INSIDE_REDIS_INSTANCE_SERVICE" => Self::DroppedInsideRedisInstanceService,
                "REDIS_INSTANCE_UNSUPPORTED_PORT" => Self::RedisInstanceUnsupportedPort,
                "REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS" => {
                    Self::RedisInstanceConnectingFromPupiAddress
                }
                "REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK" => {
                    Self::RedisInstanceNoRouteToDestinationNetwork
                }
                "REDIS_INSTANCE_NO_EXTERNAL_IP" => Self::RedisInstanceNoExternalIp,
                "REDIS_INSTANCE_UNSUPPORTED_PROTOCOL" => Self::RedisInstanceUnsupportedProtocol,
                "DROPPED_INSIDE_REDIS_CLUSTER_SERVICE" => Self::DroppedInsideRedisClusterService,
                "REDIS_CLUSTER_UNSUPPORTED_PORT" => Self::RedisClusterUnsupportedPort,
                "REDIS_CLUSTER_NO_EXTERNAL_IP" => Self::RedisClusterNoExternalIp,
                "REDIS_CLUSTER_UNSUPPORTED_PROTOCOL" => Self::RedisClusterUnsupportedProtocol,
                "NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION" => Self::NoAdvertisedRouteToGcpDestination,
                "NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION" => Self::NoTrafficSelectorToGcpDestination,
                "NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION" => {
                    Self::NoKnownRouteFromPeeredNetworkToDestination
                }
                "PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED" => {
                    Self::PrivateNatToPscEndpointUnsupported
                }
                "PSC_PORT_MAPPING_PORT_MISMATCH" => Self::PscPortMappingPortMismatch,
                "PSC_PORT_MAPPING_WITHOUT_PSC_CONNECTION_UNSUPPORTED" => {
                    Self::PscPortMappingWithoutPscConnectionUnsupported
                }
                "UNSUPPORTED_ROUTE_MATCHED_FOR_NAT64_DESTINATION" => {
                    Self::UnsupportedRouteMatchedForNat64Destination
                }
                _ => Self::UnknownValue(cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Cause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownExternalAddress => serializer.serialize_i32(1),
                Self::ForeignIpDisallowed => serializer.serialize_i32(2),
                Self::FirewallRule => serializer.serialize_i32(3),
                Self::NoRoute => serializer.serialize_i32(4),
                Self::RouteBlackhole => serializer.serialize_i32(5),
                Self::RouteWrongNetwork => serializer.serialize_i32(6),
                Self::RouteNextHopIpAddressNotResolved => serializer.serialize_i32(42),
                Self::RouteNextHopResourceNotFound => serializer.serialize_i32(43),
                Self::RouteNextHopInstanceWrongNetwork => serializer.serialize_i32(49),
                Self::RouteNextHopInstanceNonPrimaryIp => serializer.serialize_i32(50),
                Self::RouteNextHopForwardingRuleIpMismatch => serializer.serialize_i32(51),
                Self::RouteNextHopVpnTunnelNotEstablished => serializer.serialize_i32(52),
                Self::RouteNextHopForwardingRuleTypeInvalid => serializer.serialize_i32(53),
                Self::NoRouteFromInternetToPrivateIpv6Address => serializer.serialize_i32(44),
                Self::VpnTunnelLocalSelectorMismatch => serializer.serialize_i32(45),
                Self::VpnTunnelRemoteSelectorMismatch => serializer.serialize_i32(46),
                Self::PrivateTrafficToInternet => serializer.serialize_i32(7),
                Self::PrivateGoogleAccessDisallowed => serializer.serialize_i32(8),
                Self::PrivateGoogleAccessViaVpnTunnelUnsupported => serializer.serialize_i32(47),
                Self::NoExternalAddress => serializer.serialize_i32(9),
                Self::UnknownInternalAddress => serializer.serialize_i32(10),
                Self::ForwardingRuleMismatch => serializer.serialize_i32(11),
                Self::ForwardingRuleNoInstances => serializer.serialize_i32(12),
                Self::FirewallBlockingLoadBalancerBackendHealthCheck => {
                    serializer.serialize_i32(13)
                }
                Self::IngressFirewallTagsUnsupportedByDirectVpcEgress => {
                    serializer.serialize_i32(85)
                }
                Self::InstanceNotRunning => serializer.serialize_i32(14),
                Self::GkeClusterNotRunning => serializer.serialize_i32(27),
                Self::CloudSqlInstanceNotRunning => serializer.serialize_i32(28),
                Self::RedisInstanceNotRunning => serializer.serialize_i32(68),
                Self::RedisClusterNotRunning => serializer.serialize_i32(69),
                Self::TrafficTypeBlocked => serializer.serialize_i32(15),
                Self::GkeMasterUnauthorizedAccess => serializer.serialize_i32(16),
                Self::CloudSqlInstanceUnauthorizedAccess => serializer.serialize_i32(17),
                Self::DroppedInsideGkeService => serializer.serialize_i32(18),
                Self::DroppedInsideCloudSqlService => serializer.serialize_i32(19),
                Self::GoogleManagedServiceNoPeering => serializer.serialize_i32(20),
                Self::GoogleManagedServiceNoPscEndpoint => serializer.serialize_i32(38),
                Self::GkePscEndpointMissing => serializer.serialize_i32(36),
                Self::CloudSqlInstanceNoIpAddress => serializer.serialize_i32(21),
                Self::GkeControlPlaneRegionMismatch => serializer.serialize_i32(30),
                Self::PublicGkeControlPlaneToPrivateDestination => serializer.serialize_i32(31),
                Self::GkeControlPlaneNoRoute => serializer.serialize_i32(32),
                Self::CloudSqlInstanceNotConfiguredForExternalTraffic => {
                    serializer.serialize_i32(33)
                }
                Self::PublicCloudSqlInstanceToPrivateDestination => serializer.serialize_i32(34),
                Self::CloudSqlInstanceNoRoute => serializer.serialize_i32(35),
                Self::CloudSqlConnectorRequired => serializer.serialize_i32(63),
                Self::CloudFunctionNotActive => serializer.serialize_i32(22),
                Self::VpcConnectorNotSet => serializer.serialize_i32(23),
                Self::VpcConnectorNotRunning => serializer.serialize_i32(24),
                Self::VpcConnectorServerlessTrafficBlocked => serializer.serialize_i32(60),
                Self::VpcConnectorHealthCheckTrafficBlocked => serializer.serialize_i32(61),
                Self::ForwardingRuleRegionMismatch => serializer.serialize_i32(25),
                Self::PscConnectionNotAccepted => serializer.serialize_i32(26),
                Self::PscEndpointAccessedFromPeeredNetwork => serializer.serialize_i32(41),
                Self::PscNegProducerEndpointNoGlobalAccess => serializer.serialize_i32(48),
                Self::PscNegProducerForwardingRuleMultiplePorts => serializer.serialize_i32(54),
                Self::CloudSqlPscNegUnsupported => serializer.serialize_i32(58),
                Self::NoNatSubnetsForPscServiceAttachment => serializer.serialize_i32(57),
                Self::PscTransitivityNotPropagated => serializer.serialize_i32(64),
                Self::HybridNegNonDynamicRouteMatched => serializer.serialize_i32(55),
                Self::HybridNegNonLocalDynamicRouteMatched => serializer.serialize_i32(56),
                Self::CloudRunRevisionNotReady => serializer.serialize_i32(29),
                Self::DroppedInsidePscServiceProducer => serializer.serialize_i32(37),
                Self::LoadBalancerHasNoProxySubnet => serializer.serialize_i32(39),
                Self::CloudNatNoAddresses => serializer.serialize_i32(40),
                Self::RoutingLoop => serializer.serialize_i32(59),
                Self::DroppedInsideGoogleManagedService => serializer.serialize_i32(62),
                Self::LoadBalancerBackendInvalidNetwork => serializer.serialize_i32(65),
                Self::BackendServiceNamedPortNotDefined => serializer.serialize_i32(66),
                Self::DestinationIsPrivateNatIpRange => serializer.serialize_i32(67),
                Self::DroppedInsideRedisInstanceService => serializer.serialize_i32(70),
                Self::RedisInstanceUnsupportedPort => serializer.serialize_i32(71),
                Self::RedisInstanceConnectingFromPupiAddress => serializer.serialize_i32(72),
                Self::RedisInstanceNoRouteToDestinationNetwork => serializer.serialize_i32(73),
                Self::RedisInstanceNoExternalIp => serializer.serialize_i32(74),
                Self::RedisInstanceUnsupportedProtocol => serializer.serialize_i32(78),
                Self::DroppedInsideRedisClusterService => serializer.serialize_i32(75),
                Self::RedisClusterUnsupportedPort => serializer.serialize_i32(76),
                Self::RedisClusterNoExternalIp => serializer.serialize_i32(77),
                Self::RedisClusterUnsupportedProtocol => serializer.serialize_i32(79),
                Self::NoAdvertisedRouteToGcpDestination => serializer.serialize_i32(80),
                Self::NoTrafficSelectorToGcpDestination => serializer.serialize_i32(81),
                Self::NoKnownRouteFromPeeredNetworkToDestination => serializer.serialize_i32(82),
                Self::PrivateNatToPscEndpointUnsupported => serializer.serialize_i32(83),
                Self::PscPortMappingPortMismatch => serializer.serialize_i32(86),
                Self::PscPortMappingWithoutPscConnectionUnsupported => serializer.serialize_i32(87),
                Self::UnsupportedRouteMatchedForNat64Destination => serializer.serialize_i32(88),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Cause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Cause>::new(
                ".google.cloud.networkmanagement.v1.DropInfo.Cause",
            ))
        }
    }
}

/// For display only. Metadata associated with a Google Kubernetes Engine (GKE)
/// cluster master.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GKEMasterInfo {
    /// URI of a GKE cluster.
    pub cluster_uri: std::string::String,

    /// URI of a GKE cluster network.
    pub cluster_network_uri: std::string::String,

    /// Internal IP address of a GKE cluster control plane.
    pub internal_ip: std::string::String,

    /// External IP address of a GKE cluster control plane.
    pub external_ip: std::string::String,

    /// DNS endpoint of a GKE cluster control plane.
    pub dns_endpoint: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GKEMasterInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_uri][crate::model::GKEMasterInfo::cluster_uri].
    pub fn set_cluster_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uri = v.into();
        self
    }

    /// Sets the value of [cluster_network_uri][crate::model::GKEMasterInfo::cluster_network_uri].
    pub fn set_cluster_network_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_network_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::GKEMasterInfo::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::GKEMasterInfo::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [dns_endpoint][crate::model::GKEMasterInfo::dns_endpoint].
    pub fn set_dns_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_endpoint = v.into();
        self
    }
}

impl wkt::message::Message for GKEMasterInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GKEMasterInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GKEMasterInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_uri,
            __cluster_network_uri,
            __internal_ip,
            __external_ip,
            __dns_endpoint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GKEMasterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterUri" => Ok(__FieldTag::__cluster_uri),
                            "cluster_uri" => Ok(__FieldTag::__cluster_uri),
                            "clusterNetworkUri" => Ok(__FieldTag::__cluster_network_uri),
                            "cluster_network_uri" => Ok(__FieldTag::__cluster_network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "dnsEndpoint" => Ok(__FieldTag::__dns_endpoint),
                            "dns_endpoint" => Ok(__FieldTag::__dns_endpoint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GKEMasterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GKEMasterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_uri => {
                            if !fields.insert(__FieldTag::__cluster_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uri",
                                ));
                            }
                            result.cluster_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_network_uri => {
                            if !fields.insert(__FieldTag::__cluster_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_network_uri",
                                ));
                            }
                            result.cluster_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns_endpoint => {
                            if !fields.insert(__FieldTag::__dns_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_endpoint",
                                ));
                            }
                            result.dns_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GKEMasterInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_uri.is_empty() {
            state.serialize_entry("clusterUri", &self.cluster_uri)?;
        }
        if !self.cluster_network_uri.is_empty() {
            state.serialize_entry("clusterNetworkUri", &self.cluster_network_uri)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self.dns_endpoint.is_empty() {
            state.serialize_entry("dnsEndpoint", &self.dns_endpoint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GKEMasterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GKEMasterInfo");
        debug_struct.field("cluster_uri", &self.cluster_uri);
        debug_struct.field("cluster_network_uri", &self.cluster_network_uri);
        debug_struct.field("internal_ip", &self.internal_ip);
        debug_struct.field("external_ip", &self.external_ip);
        debug_struct.field("dns_endpoint", &self.dns_endpoint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Cloud SQL instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSQLInstanceInfo {
    /// Name of a Cloud SQL instance.
    pub display_name: std::string::String,

    /// URI of a Cloud SQL instance.
    pub uri: std::string::String,

    /// URI of a Cloud SQL instance network or empty string if the instance does
    /// not have one.
    pub network_uri: std::string::String,

    /// Internal IP address of a Cloud SQL instance.
    pub internal_ip: std::string::String,

    /// External IP address of a Cloud SQL instance.
    pub external_ip: std::string::String,

    /// Region in which the Cloud SQL instance is running.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSQLInstanceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::CloudSQLInstanceInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CloudSQLInstanceInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::CloudSQLInstanceInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::CloudSQLInstanceInfo::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::CloudSQLInstanceInfo::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CloudSQLInstanceInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for CloudSQLInstanceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CloudSQLInstanceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSQLInstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __internal_ip,
            __external_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSQLInstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSQLInstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSQLInstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSQLInstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudSQLInstanceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSQLInstanceInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("internal_ip", &self.internal_ip);
        debug_struct.field("external_ip", &self.external_ip);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Cloud Redis Instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RedisInstanceInfo {
    /// Name of a Cloud Redis Instance.
    pub display_name: std::string::String,

    /// URI of a Cloud Redis Instance.
    pub uri: std::string::String,

    /// URI of a Cloud Redis Instance network.
    pub network_uri: std::string::String,

    /// Primary endpoint IP address of a Cloud Redis Instance.
    pub primary_endpoint_ip: std::string::String,

    /// Read endpoint IP address of a Cloud Redis Instance (if applicable).
    pub read_endpoint_ip: std::string::String,

    /// Region in which the Cloud Redis Instance is defined.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedisInstanceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::RedisInstanceInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::RedisInstanceInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::RedisInstanceInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [primary_endpoint_ip][crate::model::RedisInstanceInfo::primary_endpoint_ip].
    pub fn set_primary_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [read_endpoint_ip][crate::model::RedisInstanceInfo::read_endpoint_ip].
    pub fn set_read_endpoint_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_endpoint_ip = v.into();
        self
    }

    /// Sets the value of [region][crate::model::RedisInstanceInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for RedisInstanceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RedisInstanceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedisInstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __primary_endpoint_ip,
            __read_endpoint_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedisInstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "primaryEndpointIp" => Ok(__FieldTag::__primary_endpoint_ip),
                            "primary_endpoint_ip" => Ok(__FieldTag::__primary_endpoint_ip),
                            "readEndpointIp" => Ok(__FieldTag::__read_endpoint_ip),
                            "read_endpoint_ip" => Ok(__FieldTag::__read_endpoint_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedisInstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedisInstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_endpoint_ip => {
                            if !fields.insert(__FieldTag::__primary_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_endpoint_ip",
                                ));
                            }
                            result.primary_endpoint_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_endpoint_ip => {
                            if !fields.insert(__FieldTag::__read_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_endpoint_ip",
                                ));
                            }
                            result.read_endpoint_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedisInstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.primary_endpoint_ip.is_empty() {
            state.serialize_entry("primaryEndpointIp", &self.primary_endpoint_ip)?;
        }
        if !self.read_endpoint_ip.is_empty() {
            state.serialize_entry("readEndpointIp", &self.read_endpoint_ip)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RedisInstanceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RedisInstanceInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("primary_endpoint_ip", &self.primary_endpoint_ip);
        debug_struct.field("read_endpoint_ip", &self.read_endpoint_ip);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Redis Cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RedisClusterInfo {
    /// Name of a Redis Cluster.
    pub display_name: std::string::String,

    /// URI of a Redis Cluster in format
    /// "projects/{project_id}/locations/{location}/clusters/{cluster_id}"
    pub uri: std::string::String,

    /// URI of the network containing the Redis Cluster endpoints in format
    /// "projects/{project_id}/global/networks/{network_id}".
    pub network_uri: std::string::String,

    /// Discovery endpoint IP address of a Redis Cluster.
    pub discovery_endpoint_ip_address: std::string::String,

    /// Secondary endpoint IP address of a Redis Cluster.
    pub secondary_endpoint_ip_address: std::string::String,

    /// Name of the region in which the Redis Cluster is defined. For example,
    /// "us-central1".
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedisClusterInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::RedisClusterInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::RedisClusterInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::RedisClusterInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [discovery_endpoint_ip_address][crate::model::RedisClusterInfo::discovery_endpoint_ip_address].
    pub fn set_discovery_endpoint_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_endpoint_ip_address = v.into();
        self
    }

    /// Sets the value of [secondary_endpoint_ip_address][crate::model::RedisClusterInfo::secondary_endpoint_ip_address].
    pub fn set_secondary_endpoint_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_endpoint_ip_address = v.into();
        self
    }

    /// Sets the value of [location][crate::model::RedisClusterInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for RedisClusterInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.RedisClusterInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedisClusterInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __discovery_endpoint_ip_address,
            __secondary_endpoint_ip_address,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedisClusterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "discoveryEndpointIpAddress" => {
                                Ok(__FieldTag::__discovery_endpoint_ip_address)
                            }
                            "discovery_endpoint_ip_address" => {
                                Ok(__FieldTag::__discovery_endpoint_ip_address)
                            }
                            "secondaryEndpointIpAddress" => {
                                Ok(__FieldTag::__secondary_endpoint_ip_address)
                            }
                            "secondary_endpoint_ip_address" => {
                                Ok(__FieldTag::__secondary_endpoint_ip_address)
                            }
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedisClusterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedisClusterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_endpoint_ip_address => {
                            if !fields.insert(__FieldTag::__discovery_endpoint_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_endpoint_ip_address",
                                ));
                            }
                            result.discovery_endpoint_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_endpoint_ip_address => {
                            if !fields.insert(__FieldTag::__secondary_endpoint_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_endpoint_ip_address",
                                ));
                            }
                            result.secondary_endpoint_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedisClusterInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.discovery_endpoint_ip_address.is_empty() {
            state.serialize_entry(
                "discoveryEndpointIpAddress",
                &self.discovery_endpoint_ip_address,
            )?;
        }
        if !self.secondary_endpoint_ip_address.is_empty() {
            state.serialize_entry(
                "secondaryEndpointIpAddress",
                &self.secondary_endpoint_ip_address,
            )?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RedisClusterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RedisClusterInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field(
            "discovery_endpoint_ip_address",
            &self.discovery_endpoint_ip_address,
        );
        debug_struct.field(
            "secondary_endpoint_ip_address",
            &self.secondary_endpoint_ip_address,
        );
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Cloud Function.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudFunctionInfo {
    /// Name of a Cloud Function.
    pub display_name: std::string::String,

    /// URI of a Cloud Function.
    pub uri: std::string::String,

    /// Location in which the Cloud Function is deployed.
    pub location: std::string::String,

    /// Latest successfully deployed version id of the Cloud Function.
    pub version_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudFunctionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::CloudFunctionInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CloudFunctionInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [location][crate::model::CloudFunctionInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::CloudFunctionInfo::version_id].
    pub fn set_version_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudFunctionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CloudFunctionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudFunctionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            __version_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudFunctionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            "versionId" => Ok(__FieldTag::__version_id),
                            "version_id" => Ok(__FieldTag::__version_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudFunctionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudFunctionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_id => {
                            if !fields.insert(__FieldTag::__version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudFunctionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.version_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("versionId", &__With(&self.version_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudFunctionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudFunctionInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("location", &self.location);
        debug_struct.field("version_id", &self.version_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a Cloud Run revision.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRunRevisionInfo {
    /// Name of a Cloud Run revision.
    pub display_name: std::string::String,

    /// URI of a Cloud Run revision.
    pub uri: std::string::String,

    /// Location in which this revision is deployed.
    pub location: std::string::String,

    /// URI of Cloud Run service this revision belongs to.
    pub service_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunRevisionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::CloudRunRevisionInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CloudRunRevisionInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [location][crate::model::CloudRunRevisionInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [service_uri][crate::model::CloudRunRevisionInfo::service_uri].
    pub fn set_service_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_uri = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunRevisionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CloudRunRevisionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRunRevisionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            __service_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunRevisionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            "serviceUri" => Ok(__FieldTag::__service_uri),
                            "service_uri" => Ok(__FieldTag::__service_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRunRevisionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunRevisionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_uri => {
                            if !fields.insert(__FieldTag::__service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_uri",
                                ));
                            }
                            result.service_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRunRevisionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.service_uri.is_empty() {
            state.serialize_entry("serviceUri", &self.service_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudRunRevisionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunRevisionInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("location", &self.location);
        debug_struct.field("service_uri", &self.service_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with an App Engine version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppEngineVersionInfo {
    /// Name of an App Engine version.
    pub display_name: std::string::String,

    /// URI of an App Engine version.
    pub uri: std::string::String,

    /// Runtime of the App Engine version.
    pub runtime: std::string::String,

    /// App Engine execution environment for a version.
    pub environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppEngineVersionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::AppEngineVersionInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::AppEngineVersionInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [runtime][crate::model::AppEngineVersionInfo::runtime].
    pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::AppEngineVersionInfo::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineVersionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.AppEngineVersionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppEngineVersionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __runtime,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineVersionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "runtime" => Ok(__FieldTag::__runtime),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppEngineVersionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineVersionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime => {
                            if !fields.insert(__FieldTag::__runtime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime",
                                ));
                            }
                            result.runtime = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppEngineVersionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.runtime.is_empty() {
            state.serialize_entry("runtime", &self.runtime)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AppEngineVersionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AppEngineVersionInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("runtime", &self.runtime);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a VPC connector.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcConnectorInfo {
    /// Name of a VPC connector.
    pub display_name: std::string::String,

    /// URI of a VPC connector.
    pub uri: std::string::String,

    /// Location in which the VPC connector is deployed.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcConnectorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::VpcConnectorInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::VpcConnectorInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [location][crate::model::VpcConnectorInfo::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for VpcConnectorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpcConnectorInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcConnectorInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcConnectorInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcConnectorInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcConnectorInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcConnectorInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpcConnectorInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcConnectorInfo");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a serverless direct VPC egress
/// connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DirectVpcEgressConnectionInfo {
    /// URI of direct access network.
    pub network_uri: std::string::String,

    /// URI of direct access subnetwork.
    pub subnetwork_uri: std::string::String,

    /// Selected IP range.
    pub selected_ip_range: std::string::String,

    /// Selected starting IP address, from the selected IP range.
    pub selected_ip_address: std::string::String,

    /// Region in which the Direct VPC egress is deployed.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DirectVpcEgressConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_uri][crate::model::DirectVpcEgressConnectionInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [subnetwork_uri][crate::model::DirectVpcEgressConnectionInfo::subnetwork_uri].
    pub fn set_subnetwork_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_uri = v.into();
        self
    }

    /// Sets the value of [selected_ip_range][crate::model::DirectVpcEgressConnectionInfo::selected_ip_range].
    pub fn set_selected_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_ip_range = v.into();
        self
    }

    /// Sets the value of [selected_ip_address][crate::model::DirectVpcEgressConnectionInfo::selected_ip_address].
    pub fn set_selected_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_ip_address = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DirectVpcEgressConnectionInfo::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for DirectVpcEgressConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DirectVpcEgressConnectionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DirectVpcEgressConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_uri,
            __subnetwork_uri,
            __selected_ip_range,
            __selected_ip_address,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DirectVpcEgressConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "subnetworkUri" => Ok(__FieldTag::__subnetwork_uri),
                            "subnetwork_uri" => Ok(__FieldTag::__subnetwork_uri),
                            "selectedIpRange" => Ok(__FieldTag::__selected_ip_range),
                            "selected_ip_range" => Ok(__FieldTag::__selected_ip_range),
                            "selectedIpAddress" => Ok(__FieldTag::__selected_ip_address),
                            "selected_ip_address" => Ok(__FieldTag::__selected_ip_address),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DirectVpcEgressConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DirectVpcEgressConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork_uri => {
                            if !fields.insert(__FieldTag::__subnetwork_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_uri",
                                ));
                            }
                            result.subnetwork_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_ip_range => {
                            if !fields.insert(__FieldTag::__selected_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_ip_range",
                                ));
                            }
                            result.selected_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_ip_address => {
                            if !fields.insert(__FieldTag::__selected_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_ip_address",
                                ));
                            }
                            result.selected_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DirectVpcEgressConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.subnetwork_uri.is_empty() {
            state.serialize_entry("subnetworkUri", &self.subnetwork_uri)?;
        }
        if !self.selected_ip_range.is_empty() {
            state.serialize_entry("selectedIpRange", &self.selected_ip_range)?;
        }
        if !self.selected_ip_address.is_empty() {
            state.serialize_entry("selectedIpAddress", &self.selected_ip_address)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DirectVpcEgressConnectionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DirectVpcEgressConnectionInfo");
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("subnetwork_uri", &self.subnetwork_uri);
        debug_struct.field("selected_ip_range", &self.selected_ip_range);
        debug_struct.field("selected_ip_address", &self.selected_ip_address);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with a serverless public connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerlessExternalConnectionInfo {
    /// Selected starting IP address, from the Google dynamic address pool.
    pub selected_ip_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerlessExternalConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [selected_ip_address][crate::model::ServerlessExternalConnectionInfo::selected_ip_address].
    pub fn set_selected_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_ip_address = v.into();
        self
    }
}

impl wkt::message::Message for ServerlessExternalConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ServerlessExternalConnectionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServerlessExternalConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __selected_ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerlessExternalConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "selectedIpAddress" => Ok(__FieldTag::__selected_ip_address),
                            "selected_ip_address" => Ok(__FieldTag::__selected_ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServerlessExternalConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerlessExternalConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__selected_ip_address => {
                            if !fields.insert(__FieldTag::__selected_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_ip_address",
                                ));
                            }
                            result.selected_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServerlessExternalConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.selected_ip_address.is_empty() {
            state.serialize_entry("selectedIpAddress", &self.selected_ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServerlessExternalConnectionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServerlessExternalConnectionInfo");
        debug_struct.field("selected_ip_address", &self.selected_ip_address);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with NAT.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NatInfo {
    /// Type of NAT.
    pub r#type: crate::model::nat_info::Type,

    /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
    pub protocol: std::string::String,

    /// URI of the network where NAT translation takes place.
    pub network_uri: std::string::String,

    /// Source IP address before NAT translation.
    pub old_source_ip: std::string::String,

    /// Source IP address after NAT translation.
    pub new_source_ip: std::string::String,

    /// Destination IP address before NAT translation.
    pub old_destination_ip: std::string::String,

    /// Destination IP address after NAT translation.
    pub new_destination_ip: std::string::String,

    /// Source port before NAT translation. Only valid when protocol is TCP or UDP.
    pub old_source_port: i32,

    /// Source port after NAT translation. Only valid when protocol is TCP or UDP.
    pub new_source_port: i32,

    /// Destination port before NAT translation. Only valid when protocol is TCP or
    /// UDP.
    pub old_destination_port: i32,

    /// Destination port after NAT translation. Only valid when protocol is TCP or
    /// UDP.
    pub new_destination_port: i32,

    /// Uri of the Cloud Router. Only valid when type is CLOUD_NAT.
    pub router_uri: std::string::String,

    /// The name of Cloud NAT Gateway. Only valid when type is CLOUD_NAT.
    pub nat_gateway_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NatInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::NatInfo::type].
    pub fn set_type<T: std::convert::Into<crate::model::nat_info::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::NatInfo::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::NatInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [old_source_ip][crate::model::NatInfo::old_source_ip].
    pub fn set_old_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.old_source_ip = v.into();
        self
    }

    /// Sets the value of [new_source_ip][crate::model::NatInfo::new_source_ip].
    pub fn set_new_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_source_ip = v.into();
        self
    }

    /// Sets the value of [old_destination_ip][crate::model::NatInfo::old_destination_ip].
    pub fn set_old_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.old_destination_ip = v.into();
        self
    }

    /// Sets the value of [new_destination_ip][crate::model::NatInfo::new_destination_ip].
    pub fn set_new_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_destination_ip = v.into();
        self
    }

    /// Sets the value of [old_source_port][crate::model::NatInfo::old_source_port].
    pub fn set_old_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_source_port = v.into();
        self
    }

    /// Sets the value of [new_source_port][crate::model::NatInfo::new_source_port].
    pub fn set_new_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_source_port = v.into();
        self
    }

    /// Sets the value of [old_destination_port][crate::model::NatInfo::old_destination_port].
    pub fn set_old_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_destination_port = v.into();
        self
    }

    /// Sets the value of [new_destination_port][crate::model::NatInfo::new_destination_port].
    pub fn set_new_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_destination_port = v.into();
        self
    }

    /// Sets the value of [router_uri][crate::model::NatInfo::router_uri].
    pub fn set_router_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.router_uri = v.into();
        self
    }

    /// Sets the value of [nat_gateway_name][crate::model::NatInfo::nat_gateway_name].
    pub fn set_nat_gateway_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nat_gateway_name = v.into();
        self
    }
}

impl wkt::message::Message for NatInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.NatInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NatInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __protocol,
            __network_uri,
            __old_source_ip,
            __new_source_ip,
            __old_destination_ip,
            __new_destination_ip,
            __old_source_port,
            __new_source_port,
            __old_destination_port,
            __new_destination_port,
            __router_uri,
            __nat_gateway_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NatInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "oldSourceIp" => Ok(__FieldTag::__old_source_ip),
                            "old_source_ip" => Ok(__FieldTag::__old_source_ip),
                            "newSourceIp" => Ok(__FieldTag::__new_source_ip),
                            "new_source_ip" => Ok(__FieldTag::__new_source_ip),
                            "oldDestinationIp" => Ok(__FieldTag::__old_destination_ip),
                            "old_destination_ip" => Ok(__FieldTag::__old_destination_ip),
                            "newDestinationIp" => Ok(__FieldTag::__new_destination_ip),
                            "new_destination_ip" => Ok(__FieldTag::__new_destination_ip),
                            "oldSourcePort" => Ok(__FieldTag::__old_source_port),
                            "old_source_port" => Ok(__FieldTag::__old_source_port),
                            "newSourcePort" => Ok(__FieldTag::__new_source_port),
                            "new_source_port" => Ok(__FieldTag::__new_source_port),
                            "oldDestinationPort" => Ok(__FieldTag::__old_destination_port),
                            "old_destination_port" => Ok(__FieldTag::__old_destination_port),
                            "newDestinationPort" => Ok(__FieldTag::__new_destination_port),
                            "new_destination_port" => Ok(__FieldTag::__new_destination_port),
                            "routerUri" => Ok(__FieldTag::__router_uri),
                            "router_uri" => Ok(__FieldTag::__router_uri),
                            "natGatewayName" => Ok(__FieldTag::__nat_gateway_name),
                            "nat_gateway_name" => Ok(__FieldTag::__nat_gateway_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NatInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NatInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::nat_info::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_ip => {
                            if !fields.insert(__FieldTag::__old_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_ip",
                                ));
                            }
                            result.old_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_source_ip => {
                            if !fields.insert(__FieldTag::__new_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_ip",
                                ));
                            }
                            result.new_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_destination_ip => {
                            if !fields.insert(__FieldTag::__old_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_ip",
                                ));
                            }
                            result.old_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_destination_ip => {
                            if !fields.insert(__FieldTag::__new_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_ip",
                                ));
                            }
                            result.new_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_port => {
                            if !fields.insert(__FieldTag::__old_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_source_port => {
                            if !fields.insert(__FieldTag::__new_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__old_destination_port => {
                            if !fields.insert(__FieldTag::__old_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_destination_port => {
                            if !fields.insert(__FieldTag::__new_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__router_uri => {
                            if !fields.insert(__FieldTag::__router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for router_uri",
                                ));
                            }
                            result.router_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nat_gateway_name => {
                            if !fields.insert(__FieldTag::__nat_gateway_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nat_gateway_name",
                                ));
                            }
                            result.nat_gateway_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NatInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.old_source_ip.is_empty() {
            state.serialize_entry("oldSourceIp", &self.old_source_ip)?;
        }
        if !self.new_source_ip.is_empty() {
            state.serialize_entry("newSourceIp", &self.new_source_ip)?;
        }
        if !self.old_destination_ip.is_empty() {
            state.serialize_entry("oldDestinationIp", &self.old_destination_ip)?;
        }
        if !self.new_destination_ip.is_empty() {
            state.serialize_entry("newDestinationIp", &self.new_destination_ip)?;
        }
        if !wkt::internal::is_default(&self.old_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldSourcePort", &__With(&self.old_source_port))?;
        }
        if !wkt::internal::is_default(&self.new_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newSourcePort", &__With(&self.new_source_port))?;
        }
        if !wkt::internal::is_default(&self.old_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldDestinationPort", &__With(&self.old_destination_port))?;
        }
        if !wkt::internal::is_default(&self.new_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newDestinationPort", &__With(&self.new_destination_port))?;
        }
        if !self.router_uri.is_empty() {
            state.serialize_entry("routerUri", &self.router_uri)?;
        }
        if !self.nat_gateway_name.is_empty() {
            state.serialize_entry("natGatewayName", &self.nat_gateway_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NatInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NatInfo");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("old_source_ip", &self.old_source_ip);
        debug_struct.field("new_source_ip", &self.new_source_ip);
        debug_struct.field("old_destination_ip", &self.old_destination_ip);
        debug_struct.field("new_destination_ip", &self.new_destination_ip);
        debug_struct.field("old_source_port", &self.old_source_port);
        debug_struct.field("new_source_port", &self.new_source_port);
        debug_struct.field("old_destination_port", &self.old_destination_port);
        debug_struct.field("new_destination_port", &self.new_destination_port);
        debug_struct.field("router_uri", &self.router_uri);
        debug_struct.field("nat_gateway_name", &self.nat_gateway_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NatInfo].
pub mod nat_info {
    #[allow(unused_imports)]
    use super::*;

    /// Types of NAT.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Type is unspecified.
        Unspecified,
        /// From Compute Engine instance's internal address to external address.
        InternalToExternal,
        /// From Compute Engine instance's external address to internal address.
        ExternalToInternal,
        /// Cloud NAT Gateway.
        CloudNat,
        /// Private service connect NAT.
        PrivateServiceConnect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InternalToExternal => std::option::Option::Some(1),
                Self::ExternalToInternal => std::option::Option::Some(2),
                Self::CloudNat => std::option::Option::Some(3),
                Self::PrivateServiceConnect => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::InternalToExternal => std::option::Option::Some("INTERNAL_TO_EXTERNAL"),
                Self::ExternalToInternal => std::option::Option::Some("EXTERNAL_TO_INTERNAL"),
                Self::CloudNat => std::option::Option::Some("CLOUD_NAT"),
                Self::PrivateServiceConnect => std::option::Option::Some("PRIVATE_SERVICE_CONNECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InternalToExternal,
                2 => Self::ExternalToInternal,
                3 => Self::CloudNat,
                4 => Self::PrivateServiceConnect,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INTERNAL_TO_EXTERNAL" => Self::InternalToExternal,
                "EXTERNAL_TO_INTERNAL" => Self::ExternalToInternal,
                "CLOUD_NAT" => Self::CloudNat,
                "PRIVATE_SERVICE_CONNECT" => Self::PrivateServiceConnect,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InternalToExternal => serializer.serialize_i32(1),
                Self::ExternalToInternal => serializer.serialize_i32(2),
                Self::CloudNat => serializer.serialize_i32(3),
                Self::PrivateServiceConnect => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.networkmanagement.v1.NatInfo.Type",
            ))
        }
    }
}

/// For display only. Metadata associated with ProxyConnection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProxyConnectionInfo {
    /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
    pub protocol: std::string::String,

    /// Source IP address of an original connection.
    pub old_source_ip: std::string::String,

    /// Source IP address of a new connection.
    pub new_source_ip: std::string::String,

    /// Destination IP address of an original connection
    pub old_destination_ip: std::string::String,

    /// Destination IP address of a new connection.
    pub new_destination_ip: std::string::String,

    /// Source port of an original connection. Only valid when protocol is TCP or
    /// UDP.
    pub old_source_port: i32,

    /// Source port of a new connection. Only valid when protocol is TCP or UDP.
    pub new_source_port: i32,

    /// Destination port of an original connection. Only valid when protocol is TCP
    /// or UDP.
    pub old_destination_port: i32,

    /// Destination port of a new connection. Only valid when protocol is TCP or
    /// UDP.
    pub new_destination_port: i32,

    /// Uri of proxy subnet.
    pub subnet_uri: std::string::String,

    /// URI of the network where connection is proxied.
    pub network_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProxyConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protocol][crate::model::ProxyConnectionInfo::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [old_source_ip][crate::model::ProxyConnectionInfo::old_source_ip].
    pub fn set_old_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.old_source_ip = v.into();
        self
    }

    /// Sets the value of [new_source_ip][crate::model::ProxyConnectionInfo::new_source_ip].
    pub fn set_new_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_source_ip = v.into();
        self
    }

    /// Sets the value of [old_destination_ip][crate::model::ProxyConnectionInfo::old_destination_ip].
    pub fn set_old_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.old_destination_ip = v.into();
        self
    }

    /// Sets the value of [new_destination_ip][crate::model::ProxyConnectionInfo::new_destination_ip].
    pub fn set_new_destination_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_destination_ip = v.into();
        self
    }

    /// Sets the value of [old_source_port][crate::model::ProxyConnectionInfo::old_source_port].
    pub fn set_old_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_source_port = v.into();
        self
    }

    /// Sets the value of [new_source_port][crate::model::ProxyConnectionInfo::new_source_port].
    pub fn set_new_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_source_port = v.into();
        self
    }

    /// Sets the value of [old_destination_port][crate::model::ProxyConnectionInfo::old_destination_port].
    pub fn set_old_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.old_destination_port = v.into();
        self
    }

    /// Sets the value of [new_destination_port][crate::model::ProxyConnectionInfo::new_destination_port].
    pub fn set_new_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.new_destination_port = v.into();
        self
    }

    /// Sets the value of [subnet_uri][crate::model::ProxyConnectionInfo::subnet_uri].
    pub fn set_subnet_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::ProxyConnectionInfo::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }
}

impl wkt::message::Message for ProxyConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ProxyConnectionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProxyConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protocol,
            __old_source_ip,
            __new_source_ip,
            __old_destination_ip,
            __new_destination_ip,
            __old_source_port,
            __new_source_port,
            __old_destination_port,
            __new_destination_port,
            __subnet_uri,
            __network_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProxyConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protocol" => Ok(__FieldTag::__protocol),
                            "oldSourceIp" => Ok(__FieldTag::__old_source_ip),
                            "old_source_ip" => Ok(__FieldTag::__old_source_ip),
                            "newSourceIp" => Ok(__FieldTag::__new_source_ip),
                            "new_source_ip" => Ok(__FieldTag::__new_source_ip),
                            "oldDestinationIp" => Ok(__FieldTag::__old_destination_ip),
                            "old_destination_ip" => Ok(__FieldTag::__old_destination_ip),
                            "newDestinationIp" => Ok(__FieldTag::__new_destination_ip),
                            "new_destination_ip" => Ok(__FieldTag::__new_destination_ip),
                            "oldSourcePort" => Ok(__FieldTag::__old_source_port),
                            "old_source_port" => Ok(__FieldTag::__old_source_port),
                            "newSourcePort" => Ok(__FieldTag::__new_source_port),
                            "new_source_port" => Ok(__FieldTag::__new_source_port),
                            "oldDestinationPort" => Ok(__FieldTag::__old_destination_port),
                            "old_destination_port" => Ok(__FieldTag::__old_destination_port),
                            "newDestinationPort" => Ok(__FieldTag::__new_destination_port),
                            "new_destination_port" => Ok(__FieldTag::__new_destination_port),
                            "subnetUri" => Ok(__FieldTag::__subnet_uri),
                            "subnet_uri" => Ok(__FieldTag::__subnet_uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProxyConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProxyConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_ip => {
                            if !fields.insert(__FieldTag::__old_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_ip",
                                ));
                            }
                            result.old_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_source_ip => {
                            if !fields.insert(__FieldTag::__new_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_ip",
                                ));
                            }
                            result.new_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_destination_ip => {
                            if !fields.insert(__FieldTag::__old_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_ip",
                                ));
                            }
                            result.old_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_destination_ip => {
                            if !fields.insert(__FieldTag::__new_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_ip",
                                ));
                            }
                            result.new_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_port => {
                            if !fields.insert(__FieldTag::__old_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_source_port => {
                            if !fields.insert(__FieldTag::__new_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__old_destination_port => {
                            if !fields.insert(__FieldTag::__old_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_destination_port => {
                            if !fields.insert(__FieldTag::__new_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__subnet_uri => {
                            if !fields.insert(__FieldTag::__subnet_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_uri",
                                ));
                            }
                            result.subnet_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProxyConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.old_source_ip.is_empty() {
            state.serialize_entry("oldSourceIp", &self.old_source_ip)?;
        }
        if !self.new_source_ip.is_empty() {
            state.serialize_entry("newSourceIp", &self.new_source_ip)?;
        }
        if !self.old_destination_ip.is_empty() {
            state.serialize_entry("oldDestinationIp", &self.old_destination_ip)?;
        }
        if !self.new_destination_ip.is_empty() {
            state.serialize_entry("newDestinationIp", &self.new_destination_ip)?;
        }
        if !wkt::internal::is_default(&self.old_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldSourcePort", &__With(&self.old_source_port))?;
        }
        if !wkt::internal::is_default(&self.new_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newSourcePort", &__With(&self.new_source_port))?;
        }
        if !wkt::internal::is_default(&self.old_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldDestinationPort", &__With(&self.old_destination_port))?;
        }
        if !wkt::internal::is_default(&self.new_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newDestinationPort", &__With(&self.new_destination_port))?;
        }
        if !self.subnet_uri.is_empty() {
            state.serialize_entry("subnetUri", &self.subnet_uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProxyConnectionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProxyConnectionInfo");
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("old_source_ip", &self.old_source_ip);
        debug_struct.field("new_source_ip", &self.new_source_ip);
        debug_struct.field("old_destination_ip", &self.old_destination_ip);
        debug_struct.field("new_destination_ip", &self.new_destination_ip);
        debug_struct.field("old_source_port", &self.old_source_port);
        debug_struct.field("new_source_port", &self.new_source_port);
        debug_struct.field("old_destination_port", &self.old_destination_port);
        debug_struct.field("new_destination_port", &self.new_destination_port);
        debug_struct.field("subnet_uri", &self.subnet_uri);
        debug_struct.field("network_uri", &self.network_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with the load balancer backend.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadBalancerBackendInfo {
    /// Display name of the backend. For example, it might be an instance name for
    /// the instance group backends, or an IP address and port for zonal network
    /// endpoint group backends.
    pub name: std::string::String,

    /// URI of the backend instance (if applicable). Populated for instance group
    /// backends, and zonal NEG backends.
    pub instance_uri: std::string::String,

    /// URI of the backend service this backend belongs to (if applicable).
    pub backend_service_uri: std::string::String,

    /// URI of the instance group this backend belongs to (if applicable).
    pub instance_group_uri: std::string::String,

    /// URI of the network endpoint group this backend belongs to (if applicable).
    pub network_endpoint_group_uri: std::string::String,

    /// URI of the backend bucket this backend targets (if applicable).
    pub backend_bucket_uri: std::string::String,

    /// URI of the PSC service attachment this PSC NEG backend targets (if
    /// applicable).
    pub psc_service_attachment_uri: std::string::String,

    /// PSC Google API target this PSC NEG backend targets (if applicable).
    pub psc_google_api_target: std::string::String,

    /// URI of the health check attached to this backend (if applicable).
    pub health_check_uri: std::string::String,

    /// Output only. Health check firewalls configuration state for the backend.
    /// This is a result of the static firewall analysis (verifying that health
    /// check traffic from required IP ranges to the backend is allowed or not).
    /// The backend might still be unhealthy even if these firewalls are
    /// configured. Please refer to the documentation for more information:
    /// <https://cloud.google.com/load-balancing/docs/firewall-rules>
    pub health_check_firewalls_config_state:
        crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadBalancerBackendInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LoadBalancerBackendInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_uri][crate::model::LoadBalancerBackendInfo::instance_uri].
    pub fn set_instance_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uri = v.into();
        self
    }

    /// Sets the value of [backend_service_uri][crate::model::LoadBalancerBackendInfo::backend_service_uri].
    pub fn set_backend_service_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backend_service_uri = v.into();
        self
    }

    /// Sets the value of [instance_group_uri][crate::model::LoadBalancerBackendInfo::instance_group_uri].
    pub fn set_instance_group_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_group_uri = v.into();
        self
    }

    /// Sets the value of [network_endpoint_group_uri][crate::model::LoadBalancerBackendInfo::network_endpoint_group_uri].
    pub fn set_network_endpoint_group_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_endpoint_group_uri = v.into();
        self
    }

    /// Sets the value of [backend_bucket_uri][crate::model::LoadBalancerBackendInfo::backend_bucket_uri].
    pub fn set_backend_bucket_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backend_bucket_uri = v.into();
        self
    }

    /// Sets the value of [psc_service_attachment_uri][crate::model::LoadBalancerBackendInfo::psc_service_attachment_uri].
    pub fn set_psc_service_attachment_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_service_attachment_uri = v.into();
        self
    }

    /// Sets the value of [psc_google_api_target][crate::model::LoadBalancerBackendInfo::psc_google_api_target].
    pub fn set_psc_google_api_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_google_api_target = v.into();
        self
    }

    /// Sets the value of [health_check_uri][crate::model::LoadBalancerBackendInfo::health_check_uri].
    pub fn set_health_check_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_uri = v.into();
        self
    }

    /// Sets the value of [health_check_firewalls_config_state][crate::model::LoadBalancerBackendInfo::health_check_firewalls_config_state].
    pub fn set_health_check_firewalls_config_state<
        T: std::convert::Into<
                crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.health_check_firewalls_config_state = v.into();
        self
    }
}

impl wkt::message::Message for LoadBalancerBackendInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.LoadBalancerBackendInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadBalancerBackendInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance_uri,
            __backend_service_uri,
            __instance_group_uri,
            __network_endpoint_group_uri,
            __backend_bucket_uri,
            __psc_service_attachment_uri,
            __psc_google_api_target,
            __health_check_uri,
            __health_check_firewalls_config_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerBackendInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instanceUri" => Ok(__FieldTag::__instance_uri),
                            "instance_uri" => Ok(__FieldTag::__instance_uri),
                            "backendServiceUri" => Ok(__FieldTag::__backend_service_uri),
                            "backend_service_uri" => Ok(__FieldTag::__backend_service_uri),
                            "instanceGroupUri" => Ok(__FieldTag::__instance_group_uri),
                            "instance_group_uri" => Ok(__FieldTag::__instance_group_uri),
                            "networkEndpointGroupUri" => {
                                Ok(__FieldTag::__network_endpoint_group_uri)
                            }
                            "network_endpoint_group_uri" => {
                                Ok(__FieldTag::__network_endpoint_group_uri)
                            }
                            "backendBucketUri" => Ok(__FieldTag::__backend_bucket_uri),
                            "backend_bucket_uri" => Ok(__FieldTag::__backend_bucket_uri),
                            "pscServiceAttachmentUri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "psc_service_attachment_uri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            "healthCheckUri" => Ok(__FieldTag::__health_check_uri),
                            "health_check_uri" => Ok(__FieldTag::__health_check_uri),
                            "healthCheckFirewallsConfigState" => {
                                Ok(__FieldTag::__health_check_firewalls_config_state)
                            }
                            "health_check_firewalls_config_state" => {
                                Ok(__FieldTag::__health_check_firewalls_config_state)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadBalancerBackendInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerBackendInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_uri => {
                            if !fields.insert(__FieldTag::__instance_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_uri",
                                ));
                            }
                            result.instance_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_service_uri => {
                            if !fields.insert(__FieldTag::__backend_service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_service_uri",
                                ));
                            }
                            result.backend_service_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_uri => {
                            if !fields.insert(__FieldTag::__instance_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_uri",
                                ));
                            }
                            result.instance_group_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_endpoint_group_uri => {
                            if !fields.insert(__FieldTag::__network_endpoint_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_endpoint_group_uri",
                                ));
                            }
                            result.network_endpoint_group_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_bucket_uri => {
                            if !fields.insert(__FieldTag::__backend_bucket_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_bucket_uri",
                                ));
                            }
                            result.backend_bucket_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_service_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_service_attachment_uri",
                                ));
                            }
                            result.psc_service_attachment_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_google_api_target",
                                ));
                            }
                            result.psc_google_api_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_uri => {
                            if !fields.insert(__FieldTag::__health_check_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_uri",
                                ));
                            }
                            result.health_check_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_firewalls_config_state => {
                            if !fields.insert(__FieldTag::__health_check_firewalls_config_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_firewalls_config_state",
                                ));
                            }
                            result.health_check_firewalls_config_state = map.next_value::<std::option::Option<crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadBalancerBackendInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instance_uri.is_empty() {
            state.serialize_entry("instanceUri", &self.instance_uri)?;
        }
        if !self.backend_service_uri.is_empty() {
            state.serialize_entry("backendServiceUri", &self.backend_service_uri)?;
        }
        if !self.instance_group_uri.is_empty() {
            state.serialize_entry("instanceGroupUri", &self.instance_group_uri)?;
        }
        if !self.network_endpoint_group_uri.is_empty() {
            state.serialize_entry("networkEndpointGroupUri", &self.network_endpoint_group_uri)?;
        }
        if !self.backend_bucket_uri.is_empty() {
            state.serialize_entry("backendBucketUri", &self.backend_bucket_uri)?;
        }
        if !self.psc_service_attachment_uri.is_empty() {
            state.serialize_entry("pscServiceAttachmentUri", &self.psc_service_attachment_uri)?;
        }
        if !self.psc_google_api_target.is_empty() {
            state.serialize_entry("pscGoogleApiTarget", &self.psc_google_api_target)?;
        }
        if !self.health_check_uri.is_empty() {
            state.serialize_entry("healthCheckUri", &self.health_check_uri)?;
        }
        if !wkt::internal::is_default(&self.health_check_firewalls_config_state) {
            state.serialize_entry(
                "healthCheckFirewallsConfigState",
                &self.health_check_firewalls_config_state,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadBalancerBackendInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadBalancerBackendInfo");
        debug_struct.field("name", &self.name);
        debug_struct.field("instance_uri", &self.instance_uri);
        debug_struct.field("backend_service_uri", &self.backend_service_uri);
        debug_struct.field("instance_group_uri", &self.instance_group_uri);
        debug_struct.field(
            "network_endpoint_group_uri",
            &self.network_endpoint_group_uri,
        );
        debug_struct.field("backend_bucket_uri", &self.backend_bucket_uri);
        debug_struct.field(
            "psc_service_attachment_uri",
            &self.psc_service_attachment_uri,
        );
        debug_struct.field("psc_google_api_target", &self.psc_google_api_target);
        debug_struct.field("health_check_uri", &self.health_check_uri);
        debug_struct.field(
            "health_check_firewalls_config_state",
            &self.health_check_firewalls_config_state,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LoadBalancerBackendInfo].
pub mod load_balancer_backend_info {
    #[allow(unused_imports)]
    use super::*;

    /// Health check firewalls configuration state enum.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HealthCheckFirewallsConfigState {
        /// Configuration state unspecified. It usually means that the backend has
        /// no health check attached, or there was an unexpected configuration error
        /// preventing Connectivity tests from verifying health check configuration.
        Unspecified,
        /// Firewall rules (policies) allowing health check traffic from all required
        /// IP ranges to the backend are configured.
        FirewallsConfigured,
        /// Firewall rules (policies) allow health check traffic only from a part of
        /// required IP ranges.
        FirewallsPartiallyConfigured,
        /// Firewall rules (policies) deny health check traffic from all required
        /// IP ranges to the backend.
        FirewallsNotConfigured,
        /// The network contains firewall rules of unsupported types, so Connectivity
        /// tests were not able to verify health check configuration status. Please
        /// refer to the documentation for the list of unsupported configurations:
        /// <https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs>
        FirewallsUnsupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HealthCheckFirewallsConfigState::value] or
        /// [HealthCheckFirewallsConfigState::name].
        UnknownValue(health_check_firewalls_config_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod health_check_firewalls_config_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HealthCheckFirewallsConfigState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FirewallsConfigured => std::option::Option::Some(1),
                Self::FirewallsPartiallyConfigured => std::option::Option::Some(2),
                Self::FirewallsNotConfigured => std::option::Option::Some(3),
                Self::FirewallsUnsupported => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED")
                }
                Self::FirewallsConfigured => std::option::Option::Some("FIREWALLS_CONFIGURED"),
                Self::FirewallsPartiallyConfigured => {
                    std::option::Option::Some("FIREWALLS_PARTIALLY_CONFIGURED")
                }
                Self::FirewallsNotConfigured => {
                    std::option::Option::Some("FIREWALLS_NOT_CONFIGURED")
                }
                Self::FirewallsUnsupported => std::option::Option::Some("FIREWALLS_UNSUPPORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HealthCheckFirewallsConfigState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HealthCheckFirewallsConfigState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HealthCheckFirewallsConfigState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FirewallsConfigured,
                2 => Self::FirewallsPartiallyConfigured,
                3 => Self::FirewallsNotConfigured,
                4 => Self::FirewallsUnsupported,
                _ => Self::UnknownValue(health_check_firewalls_config_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HealthCheckFirewallsConfigState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED" => Self::Unspecified,
                "FIREWALLS_CONFIGURED" => Self::FirewallsConfigured,
                "FIREWALLS_PARTIALLY_CONFIGURED" => Self::FirewallsPartiallyConfigured,
                "FIREWALLS_NOT_CONFIGURED" => Self::FirewallsNotConfigured,
                "FIREWALLS_UNSUPPORTED" => Self::FirewallsUnsupported,
                _ => Self::UnknownValue(health_check_firewalls_config_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HealthCheckFirewallsConfigState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FirewallsConfigured => serializer.serialize_i32(1),
                Self::FirewallsPartiallyConfigured => serializer.serialize_i32(2),
                Self::FirewallsNotConfigured => serializer.serialize_i32(3),
                Self::FirewallsUnsupported => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HealthCheckFirewallsConfigState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HealthCheckFirewallsConfigState>::new(
                ".google.cloud.networkmanagement.v1.LoadBalancerBackendInfo.HealthCheckFirewallsConfigState"))
        }
    }
}

/// For display only. Metadata associated with Storage Bucket.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageBucketInfo {
    /// Cloud Storage Bucket name.
    pub bucket: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageBucketInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageBucketInfo::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }
}

impl wkt::message::Message for StorageBucketInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.StorageBucketInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageBucketInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageBucketInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageBucketInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageBucketInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageBucketInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StorageBucketInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageBucketInfo");
        debug_struct.field("bucket", &self.bucket);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// For display only. Metadata associated with the serverless network endpoint
/// group backend.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerlessNegInfo {
    /// URI of the serverless network endpoint group.
    pub neg_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerlessNegInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [neg_uri][crate::model::ServerlessNegInfo::neg_uri].
    pub fn set_neg_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.neg_uri = v.into();
        self
    }
}

impl wkt::message::Message for ServerlessNegInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ServerlessNegInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServerlessNegInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __neg_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerlessNegInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "negUri" => Ok(__FieldTag::__neg_uri),
                            "neg_uri" => Ok(__FieldTag::__neg_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServerlessNegInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerlessNegInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__neg_uri => {
                            if !fields.insert(__FieldTag::__neg_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for neg_uri",
                                ));
                            }
                            result.neg_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServerlessNegInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.neg_uri.is_empty() {
            state.serialize_entry("negUri", &self.neg_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServerlessNegInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServerlessNegInfo");
        debug_struct.field("neg_uri", &self.neg_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListVpcFlowLogsConfigs` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVpcFlowLogsConfigsRequest {
    /// Required. The parent resource of the VpcFlowLogsConfig:
    /// `projects/{project_id}/locations/global`
    pub parent: std::string::String,

    /// Optional. Number of `VpcFlowLogsConfigs` to return.
    pub page_size: i32,

    /// Optional. Page token from an earlier query, as returned in
    /// `next_page_token`.
    pub page_token: std::string::String,

    /// Optional. Lists the `VpcFlowLogsConfigs` that match the filter expression.
    /// A filter expression must use the supported [CEL logic operators]
    /// (<https://cloud.google.com/vpc/docs/about-flow-logs-records#supported_cel_logic_operators>).
    pub filter: std::string::String,

    /// Optional. Field to use to sort the list.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVpcFlowLogsConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVpcFlowLogsConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVpcFlowLogsConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVpcFlowLogsConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVpcFlowLogsConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVpcFlowLogsConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVpcFlowLogsConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListVpcFlowLogsConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVpcFlowLogsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpcFlowLogsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVpcFlowLogsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpcFlowLogsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVpcFlowLogsConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVpcFlowLogsConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVpcFlowLogsConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListVpcFlowLogsConfigs` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVpcFlowLogsConfigsResponse {
    /// List of VPC Flow Log configurations.
    pub vpc_flow_logs_configs: std::vec::Vec<crate::model::VpcFlowLogsConfig>,

    /// Page token to fetch the next set of configurations.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached (when querying all locations with `-`).
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVpcFlowLogsConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc_flow_logs_configs][crate::model::ListVpcFlowLogsConfigsResponse::vpc_flow_logs_configs].
    pub fn set_vpc_flow_logs_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VpcFlowLogsConfig>,
    {
        use std::iter::Iterator;
        self.vpc_flow_logs_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVpcFlowLogsConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVpcFlowLogsConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVpcFlowLogsConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.ListVpcFlowLogsConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVpcFlowLogsConfigsResponse {
    type PageItem = crate::model::VpcFlowLogsConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vpc_flow_logs_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVpcFlowLogsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc_flow_logs_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpcFlowLogsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpcFlowLogsConfigs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "vpc_flow_logs_configs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVpcFlowLogsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpcFlowLogsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc_flow_logs_configs => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_configs",
                                ));
                            }
                            result.vpc_flow_logs_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VpcFlowLogsConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVpcFlowLogsConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc_flow_logs_configs.is_empty() {
            state.serialize_entry("vpcFlowLogsConfigs", &self.vpc_flow_logs_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVpcFlowLogsConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVpcFlowLogsConfigsResponse");
        debug_struct.field("vpc_flow_logs_configs", &self.vpc_flow_logs_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `GetVpcFlowLogsConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVpcFlowLogsConfigRequest {
    /// Required. `VpcFlowLogsConfig` resource name using the form:
    /// `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVpcFlowLogsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.GetVpcFlowLogsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVpcFlowLogsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVpcFlowLogsConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `CreateVpcFlowLogsConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVpcFlowLogsConfigRequest {
    /// Required. The parent resource of the VPC Flow Logs configuration to create:
    /// `projects/{project_id}/locations/global`
    pub parent: std::string::String,

    /// Required. ID of the `VpcFlowLogsConfig`.
    pub vpc_flow_logs_config_id: std::string::String,

    /// Required. A `VpcFlowLogsConfig` resource
    pub vpc_flow_logs_config: std::option::Option<crate::model::VpcFlowLogsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVpcFlowLogsConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vpc_flow_logs_config_id][crate::model::CreateVpcFlowLogsConfigRequest::vpc_flow_logs_config_id].
    pub fn set_vpc_flow_logs_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_flow_logs_config_id = v.into();
        self
    }

    /// Sets the value of [vpc_flow_logs_config][crate::model::CreateVpcFlowLogsConfigRequest::vpc_flow_logs_config].
    pub fn set_vpc_flow_logs_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcFlowLogsConfig>,
    {
        self.vpc_flow_logs_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_flow_logs_config][crate::model::CreateVpcFlowLogsConfigRequest::vpc_flow_logs_config].
    pub fn set_or_clear_vpc_flow_logs_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcFlowLogsConfig>,
    {
        self.vpc_flow_logs_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.CreateVpcFlowLogsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __vpc_flow_logs_config_id,
            __vpc_flow_logs_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "vpcFlowLogsConfigId" => Ok(__FieldTag::__vpc_flow_logs_config_id),
                            "vpc_flow_logs_config_id" => Ok(__FieldTag::__vpc_flow_logs_config_id),
                            "vpcFlowLogsConfig" => Ok(__FieldTag::__vpc_flow_logs_config),
                            "vpc_flow_logs_config" => Ok(__FieldTag::__vpc_flow_logs_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_flow_logs_config_id => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_config_id",
                                ));
                            }
                            result.vpc_flow_logs_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_flow_logs_config => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_config",
                                ));
                            }
                            result.vpc_flow_logs_config = map
                                .next_value::<std::option::Option<crate::model::VpcFlowLogsConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.vpc_flow_logs_config_id.is_empty() {
            state.serialize_entry("vpcFlowLogsConfigId", &self.vpc_flow_logs_config_id)?;
        }
        if self.vpc_flow_logs_config.is_some() {
            state.serialize_entry("vpcFlowLogsConfig", &self.vpc_flow_logs_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVpcFlowLogsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVpcFlowLogsConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("vpc_flow_logs_config_id", &self.vpc_flow_logs_config_id);
        debug_struct.field("vpc_flow_logs_config", &self.vpc_flow_logs_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `UpdateVpcFlowLogsConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVpcFlowLogsConfigRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in update_mask are updated.
    pub vpc_flow_logs_config: std::option::Option<crate::model::VpcFlowLogsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateVpcFlowLogsConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVpcFlowLogsConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_flow_logs_config][crate::model::UpdateVpcFlowLogsConfigRequest::vpc_flow_logs_config].
    pub fn set_vpc_flow_logs_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcFlowLogsConfig>,
    {
        self.vpc_flow_logs_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_flow_logs_config][crate::model::UpdateVpcFlowLogsConfigRequest::vpc_flow_logs_config].
    pub fn set_or_clear_vpc_flow_logs_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcFlowLogsConfig>,
    {
        self.vpc_flow_logs_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.UpdateVpcFlowLogsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __vpc_flow_logs_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "vpcFlowLogsConfig" => Ok(__FieldTag::__vpc_flow_logs_config),
                            "vpc_flow_logs_config" => Ok(__FieldTag::__vpc_flow_logs_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__vpc_flow_logs_config => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_config",
                                ));
                            }
                            result.vpc_flow_logs_config = map
                                .next_value::<std::option::Option<crate::model::VpcFlowLogsConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.vpc_flow_logs_config.is_some() {
            state.serialize_entry("vpcFlowLogsConfig", &self.vpc_flow_logs_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateVpcFlowLogsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateVpcFlowLogsConfigRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("vpc_flow_logs_config", &self.vpc_flow_logs_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `DeleteVpcFlowLogsConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVpcFlowLogsConfigRequest {
    /// Required. `VpcFlowLogsConfig` resource name using the form:
    /// `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVpcFlowLogsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVpcFlowLogsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVpcFlowLogsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.DeleteVpcFlowLogsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteVpcFlowLogsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVpcFlowLogsConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A configuration to generate VPC Flow Logs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcFlowLogsConfig {
    /// Identifier. Unique name of the configuration using the form:
    /// `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config_id}`
    pub name: std::string::String,

    /// Optional. The user-supplied description of the VPC Flow Logs configuration.
    /// Maximum of 512 characters.
    pub description: std::option::Option<std::string::String>,

    /// Optional. The state of the VPC Flow Log configuration. Default value is
    /// ENABLED. When creating a new configuration, it must be enabled.
    pub state: std::option::Option<crate::model::vpc_flow_logs_config::State>,

    /// Optional. The aggregation interval for the logs. Default value is
    /// INTERVAL_5_SEC.
    pub aggregation_interval:
        std::option::Option<crate::model::vpc_flow_logs_config::AggregationInterval>,

    /// Optional. The value of the field must be in (0, 1]. The sampling rate of
    /// VPC Flow Logs where 1.0 means all collected logs are reported. Setting the
    /// sampling rate to 0.0 is not allowed. If you want to disable VPC Flow Logs,
    /// use the state field instead. Default value is 1.0.
    pub flow_sampling: std::option::Option<f32>,

    /// Optional. Configures whether all, none or a subset of metadata fields
    /// should be added to the reported VPC flow logs. Default value is
    /// INCLUDE_ALL_METADATA.
    pub metadata: std::option::Option<crate::model::vpc_flow_logs_config::Metadata>,

    /// Optional. Custom metadata fields to include in the reported VPC flow logs.
    /// Can only be specified if "metadata" was set to CUSTOM_METADATA.
    pub metadata_fields: std::vec::Vec<std::string::String>,

    /// Optional. Export filter used to define which VPC Flow Logs should be
    /// logged.
    pub filter_expr: std::option::Option<std::string::String>,

    /// Output only. A diagnostic bit - describes the state of the configured
    /// target resource for diagnostic purposes.
    pub target_resource_state:
        std::option::Option<crate::model::vpc_flow_logs_config::TargetResourceState>,

    /// Optional. Resource labels to represent user-provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The time the config was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the config was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Reference to the resource of the config scope. That is, the scope from
    /// which traffic is logged. The target resource must belong to the same
    /// project as the configuration.
    pub target_resource: std::option::Option<crate::model::vpc_flow_logs_config::TargetResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcFlowLogsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpcFlowLogsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VpcFlowLogsConfig::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::VpcFlowLogsConfig::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::VpcFlowLogsConfig::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::State>,
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::VpcFlowLogsConfig::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::State>,
    {
        self.state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aggregation_interval][crate::model::VpcFlowLogsConfig::aggregation_interval].
    pub fn set_aggregation_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::AggregationInterval>,
    {
        self.aggregation_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregation_interval][crate::model::VpcFlowLogsConfig::aggregation_interval].
    pub fn set_or_clear_aggregation_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::AggregationInterval>,
    {
        self.aggregation_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [flow_sampling][crate::model::VpcFlowLogsConfig::flow_sampling].
    pub fn set_flow_sampling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.flow_sampling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flow_sampling][crate::model::VpcFlowLogsConfig::flow_sampling].
    pub fn set_or_clear_flow_sampling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.flow_sampling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::VpcFlowLogsConfig::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::VpcFlowLogsConfig::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata_fields][crate::model::VpcFlowLogsConfig::metadata_fields].
    pub fn set_metadata_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter_expr][crate::model::VpcFlowLogsConfig::filter_expr].
    pub fn set_filter_expr<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.filter_expr = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter_expr][crate::model::VpcFlowLogsConfig::filter_expr].
    pub fn set_or_clear_filter_expr<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.filter_expr = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_resource_state][crate::model::VpcFlowLogsConfig::target_resource_state].
    pub fn set_target_resource_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::TargetResourceState>,
    {
        self.target_resource_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_resource_state][crate::model::VpcFlowLogsConfig::target_resource_state].
    pub fn set_or_clear_target_resource_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vpc_flow_logs_config::TargetResourceState>,
    {
        self.target_resource_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::VpcFlowLogsConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::VpcFlowLogsConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VpcFlowLogsConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::VpcFlowLogsConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VpcFlowLogsConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource].
    ///
    /// Note that all the setters affecting `target_resource` are mutually
    /// exclusive.
    pub fn set_target_resource<
        T: std::convert::Into<std::option::Option<crate::model::vpc_flow_logs_config::TargetResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource = v.into();
        self
    }

    /// The value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// if it holds a `InterconnectAttachment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn interconnect_attachment(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_resource.as_ref().and_then(|v| match v {
            crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// to hold a `InterconnectAttachment`.
    ///
    /// Note that all the setters affecting `target_resource` are
    /// mutually exclusive.
    pub fn set_interconnect_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource = std::option::Option::Some(
            crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(v.into()),
        );
        self
    }

    /// The value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// if it holds a `VpnTunnel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpn_tunnel(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_resource.as_ref().and_then(|v| match v {
            crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_resource][crate::model::VpcFlowLogsConfig::target_resource]
    /// to hold a `VpnTunnel`.
    ///
    /// Note that all the setters affecting `target_resource` are
    /// mutually exclusive.
    pub fn set_vpn_tunnel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_resource = std::option::Option::Some(
            crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VpcFlowLogsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.networkmanagement.v1.VpcFlowLogsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcFlowLogsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __state,
            __aggregation_interval,
            __flow_sampling,
            __metadata,
            __metadata_fields,
            __filter_expr,
            __target_resource_state,
            __interconnect_attachment,
            __vpn_tunnel,
            __labels,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcFlowLogsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "aggregationInterval" => Ok(__FieldTag::__aggregation_interval),
                            "aggregation_interval" => Ok(__FieldTag::__aggregation_interval),
                            "flowSampling" => Ok(__FieldTag::__flow_sampling),
                            "flow_sampling" => Ok(__FieldTag::__flow_sampling),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "metadataFields" => Ok(__FieldTag::__metadata_fields),
                            "metadata_fields" => Ok(__FieldTag::__metadata_fields),
                            "filterExpr" => Ok(__FieldTag::__filter_expr),
                            "filter_expr" => Ok(__FieldTag::__filter_expr),
                            "targetResourceState" => Ok(__FieldTag::__target_resource_state),
                            "target_resource_state" => Ok(__FieldTag::__target_resource_state),
                            "interconnectAttachment" => Ok(__FieldTag::__interconnect_attachment),
                            "interconnect_attachment" => Ok(__FieldTag::__interconnect_attachment),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcFlowLogsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcFlowLogsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::State>>()?
                                ;
                        }
                        __FieldTag::__aggregation_interval => {
                            if !fields.insert(__FieldTag::__aggregation_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_interval",
                                ));
                            }
                            result.aggregation_interval = map.next_value::<std::option::Option<
                                crate::model::vpc_flow_logs_config::AggregationInterval,
                            >>()?;
                        }
                        __FieldTag::__flow_sampling => {
                            if !fields.insert(__FieldTag::__flow_sampling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_sampling",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.flow_sampling = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::vpc_flow_logs_config::Metadata,
                                >>()?;
                        }
                        __FieldTag::__metadata_fields => {
                            if !fields.insert(__FieldTag::__metadata_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_fields",
                                ));
                            }
                            result.metadata_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter_expr => {
                            if !fields.insert(__FieldTag::__filter_expr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_expr",
                                ));
                            }
                            result.filter_expr =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__target_resource_state => {
                            if !fields.insert(__FieldTag::__target_resource_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_state",
                                ));
                            }
                            result.target_resource_state = map.next_value::<std::option::Option<
                                crate::model::vpc_flow_logs_config::TargetResourceState,
                            >>()?;
                        }
                        __FieldTag::__interconnect_attachment => {
                            if !fields.insert(__FieldTag::__interconnect_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interconnect_attachment",
                                ));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.interconnect_attachment, latest field was interconnectAttachment",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_tunnel",
                                ));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcFlowLogsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.aggregation_interval.is_some() {
            state.serialize_entry("aggregationInterval", &self.aggregation_interval)?;
        }
        if self.flow_sampling.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("flowSampling", &__With(&self.flow_sampling))?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.metadata_fields.is_empty() {
            state.serialize_entry("metadataFields", &self.metadata_fields)?;
        }
        if self.filter_expr.is_some() {
            state.serialize_entry("filterExpr", &self.filter_expr)?;
        }
        if self.target_resource_state.is_some() {
            state.serialize_entry("targetResourceState", &self.target_resource_state)?;
        }
        if let Some(value) = self.interconnect_attachment() {
            state.serialize_entry("interconnectAttachment", value)?;
        }
        if let Some(value) = self.vpn_tunnel() {
            state.serialize_entry("vpnTunnel", value)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpcFlowLogsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcFlowLogsConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("state", &self.state);
        debug_struct.field("aggregation_interval", &self.aggregation_interval);
        debug_struct.field("flow_sampling", &self.flow_sampling);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("metadata_fields", &self.metadata_fields);
        debug_struct.field("filter_expr", &self.filter_expr);
        debug_struct.field("target_resource_state", &self.target_resource_state);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("target_resource", &self.target_resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VpcFlowLogsConfig].
pub mod vpc_flow_logs_config {
    #[allow(unused_imports)]
    use super::*;

    /// Determines whether this configuration will be generating logs.
    /// Setting state=DISABLED will pause the log generation for this config.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// If not specified, will default to ENABLED.
        Unspecified,
        /// When ENABLED, this configuration will generate logs.
        Enabled,
        /// When DISABLED, this configuration will not generate logs.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.networkmanagement.v1.VpcFlowLogsConfig.State",
            ))
        }
    }

    /// Toggles the aggregation interval for collecting flow logs by 5-tuple.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregationInterval {
        /// If not specified, will default to INTERVAL_5_SEC.
        Unspecified,
        /// Aggregate logs in 5s intervals.
        Interval5Sec,
        /// Aggregate logs in 30s intervals.
        Interval30Sec,
        /// Aggregate logs in 1m intervals.
        Interval1Min,
        /// Aggregate logs in 5m intervals.
        Interval5Min,
        /// Aggregate logs in 10m intervals.
        Interval10Min,
        /// Aggregate logs in 15m intervals.
        Interval15Min,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AggregationInterval::value] or
        /// [AggregationInterval::name].
        UnknownValue(aggregation_interval::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aggregation_interval {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AggregationInterval {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Interval5Sec => std::option::Option::Some(1),
                Self::Interval30Sec => std::option::Option::Some(2),
                Self::Interval1Min => std::option::Option::Some(3),
                Self::Interval5Min => std::option::Option::Some(4),
                Self::Interval10Min => std::option::Option::Some(5),
                Self::Interval15Min => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AGGREGATION_INTERVAL_UNSPECIFIED"),
                Self::Interval5Sec => std::option::Option::Some("INTERVAL_5_SEC"),
                Self::Interval30Sec => std::option::Option::Some("INTERVAL_30_SEC"),
                Self::Interval1Min => std::option::Option::Some("INTERVAL_1_MIN"),
                Self::Interval5Min => std::option::Option::Some("INTERVAL_5_MIN"),
                Self::Interval10Min => std::option::Option::Some("INTERVAL_10_MIN"),
                Self::Interval15Min => std::option::Option::Some("INTERVAL_15_MIN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AggregationInterval {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AggregationInterval {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AggregationInterval {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Interval5Sec,
                2 => Self::Interval30Sec,
                3 => Self::Interval1Min,
                4 => Self::Interval5Min,
                5 => Self::Interval10Min,
                6 => Self::Interval15Min,
                _ => Self::UnknownValue(aggregation_interval::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AggregationInterval {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AGGREGATION_INTERVAL_UNSPECIFIED" => Self::Unspecified,
                "INTERVAL_5_SEC" => Self::Interval5Sec,
                "INTERVAL_30_SEC" => Self::Interval30Sec,
                "INTERVAL_1_MIN" => Self::Interval1Min,
                "INTERVAL_5_MIN" => Self::Interval5Min,
                "INTERVAL_10_MIN" => Self::Interval10Min,
                "INTERVAL_15_MIN" => Self::Interval15Min,
                _ => Self::UnknownValue(aggregation_interval::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AggregationInterval {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Interval5Sec => serializer.serialize_i32(1),
                Self::Interval30Sec => serializer.serialize_i32(2),
                Self::Interval1Min => serializer.serialize_i32(3),
                Self::Interval5Min => serializer.serialize_i32(4),
                Self::Interval10Min => serializer.serialize_i32(5),
                Self::Interval15Min => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AggregationInterval {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AggregationInterval>::new(
                ".google.cloud.networkmanagement.v1.VpcFlowLogsConfig.AggregationInterval",
            ))
        }
    }

    /// Configures which log fields would be included.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metadata {
        /// If not specified, will default to INCLUDE_ALL_METADATA.
        Unspecified,
        /// Include all metadata fields.
        IncludeAllMetadata,
        /// Exclude all metadata fields.
        ExcludeAllMetadata,
        /// Include only custom fields (specified in metadata_fields).
        CustomMetadata,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Metadata::value] or
        /// [Metadata::name].
        UnknownValue(metadata::UnknownValue),
    }

    #[doc(hidden)]
    pub mod metadata {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Metadata {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::IncludeAllMetadata => std::option::Option::Some(1),
                Self::ExcludeAllMetadata => std::option::Option::Some(2),
                Self::CustomMetadata => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METADATA_UNSPECIFIED"),
                Self::IncludeAllMetadata => std::option::Option::Some("INCLUDE_ALL_METADATA"),
                Self::ExcludeAllMetadata => std::option::Option::Some("EXCLUDE_ALL_METADATA"),
                Self::CustomMetadata => std::option::Option::Some("CUSTOM_METADATA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Metadata {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Metadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Metadata {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::IncludeAllMetadata,
                2 => Self::ExcludeAllMetadata,
                3 => Self::CustomMetadata,
                _ => Self::UnknownValue(metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Metadata {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METADATA_UNSPECIFIED" => Self::Unspecified,
                "INCLUDE_ALL_METADATA" => Self::IncludeAllMetadata,
                "EXCLUDE_ALL_METADATA" => Self::ExcludeAllMetadata,
                "CUSTOM_METADATA" => Self::CustomMetadata,
                _ => Self::UnknownValue(metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Metadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::IncludeAllMetadata => serializer.serialize_i32(1),
                Self::ExcludeAllMetadata => serializer.serialize_i32(2),
                Self::CustomMetadata => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Metadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Metadata>::new(
                ".google.cloud.networkmanagement.v1.VpcFlowLogsConfig.Metadata",
            ))
        }
    }

    /// Optional states of the target resource that are used as part of the
    /// diagnostic bit.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetResourceState {
        /// Unspecified target resource state.
        Unspecified,
        /// Indicates that the target resource exists.
        TargetResourceExists,
        /// Indicates that the target resource does not exist.
        TargetResourceDoesNotExist,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetResourceState::value] or
        /// [TargetResourceState::name].
        UnknownValue(target_resource_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod target_resource_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TargetResourceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TargetResourceExists => std::option::Option::Some(1),
                Self::TargetResourceDoesNotExist => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARGET_RESOURCE_STATE_UNSPECIFIED"),
                Self::TargetResourceExists => std::option::Option::Some("TARGET_RESOURCE_EXISTS"),
                Self::TargetResourceDoesNotExist => {
                    std::option::Option::Some("TARGET_RESOURCE_DOES_NOT_EXIST")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TargetResourceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TargetResourceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TargetResourceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TargetResourceExists,
                2 => Self::TargetResourceDoesNotExist,
                _ => Self::UnknownValue(target_resource_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TargetResourceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARGET_RESOURCE_STATE_UNSPECIFIED" => Self::Unspecified,
                "TARGET_RESOURCE_EXISTS" => Self::TargetResourceExists,
                "TARGET_RESOURCE_DOES_NOT_EXIST" => Self::TargetResourceDoesNotExist,
                _ => Self::UnknownValue(target_resource_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TargetResourceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TargetResourceExists => serializer.serialize_i32(1),
                Self::TargetResourceDoesNotExist => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TargetResourceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetResourceState>::new(
                ".google.cloud.networkmanagement.v1.VpcFlowLogsConfig.TargetResourceState",
            ))
        }
    }

    /// Reference to the resource of the config scope. That is, the scope from
    /// which traffic is logged. The target resource must belong to the same
    /// project as the configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetResource {
        /// Traffic will be logged from the Interconnect Attachment.
        /// Format:
        /// projects/{project_id}/regions/{region}/interconnectAttachments/{name}
        InterconnectAttachment(std::string::String),
        /// Traffic will be logged from the VPN Tunnel.
        /// Format: projects/{project_id}/regions/{region}/vpnTunnels/{name}
        VpnTunnel(std::string::String),
    }
}

/// Type of a load balancer. For more information, see [Summary of Google Cloud
/// load
/// balancers](https://cloud.google.com/load-balancing/docs/load-balancing-overview#summary-of-google-cloud-load-balancers).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LoadBalancerType {
    /// Forwarding rule points to a different target than a load balancer or a
    /// load balancer type is unknown.
    Unspecified,
    /// Global external HTTP(S) load balancer.
    HttpsAdvancedLoadBalancer,
    /// Global external HTTP(S) load balancer (classic)
    HttpsLoadBalancer,
    /// Regional external HTTP(S) load balancer.
    RegionalHttpsLoadBalancer,
    /// Internal HTTP(S) load balancer.
    InternalHttpsLoadBalancer,
    /// External SSL proxy load balancer.
    SslProxyLoadBalancer,
    /// External TCP proxy load balancer.
    TcpProxyLoadBalancer,
    /// Internal regional TCP proxy load balancer.
    InternalTcpProxyLoadBalancer,
    /// External TCP/UDP Network load balancer.
    NetworkLoadBalancer,
    /// Target-pool based external TCP/UDP Network load balancer.
    LegacyNetworkLoadBalancer,
    /// Internal TCP/UDP load balancer.
    TcpUdpInternalLoadBalancer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LoadBalancerType::value] or
    /// [LoadBalancerType::name].
    UnknownValue(load_balancer_type::UnknownValue),
}

#[doc(hidden)]
pub mod load_balancer_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LoadBalancerType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::HttpsAdvancedLoadBalancer => std::option::Option::Some(1),
            Self::HttpsLoadBalancer => std::option::Option::Some(2),
            Self::RegionalHttpsLoadBalancer => std::option::Option::Some(3),
            Self::InternalHttpsLoadBalancer => std::option::Option::Some(4),
            Self::SslProxyLoadBalancer => std::option::Option::Some(5),
            Self::TcpProxyLoadBalancer => std::option::Option::Some(6),
            Self::InternalTcpProxyLoadBalancer => std::option::Option::Some(7),
            Self::NetworkLoadBalancer => std::option::Option::Some(8),
            Self::LegacyNetworkLoadBalancer => std::option::Option::Some(9),
            Self::TcpUdpInternalLoadBalancer => std::option::Option::Some(10),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LOAD_BALANCER_TYPE_UNSPECIFIED"),
            Self::HttpsAdvancedLoadBalancer => {
                std::option::Option::Some("HTTPS_ADVANCED_LOAD_BALANCER")
            }
            Self::HttpsLoadBalancer => std::option::Option::Some("HTTPS_LOAD_BALANCER"),
            Self::RegionalHttpsLoadBalancer => {
                std::option::Option::Some("REGIONAL_HTTPS_LOAD_BALANCER")
            }
            Self::InternalHttpsLoadBalancer => {
                std::option::Option::Some("INTERNAL_HTTPS_LOAD_BALANCER")
            }
            Self::SslProxyLoadBalancer => std::option::Option::Some("SSL_PROXY_LOAD_BALANCER"),
            Self::TcpProxyLoadBalancer => std::option::Option::Some("TCP_PROXY_LOAD_BALANCER"),
            Self::InternalTcpProxyLoadBalancer => {
                std::option::Option::Some("INTERNAL_TCP_PROXY_LOAD_BALANCER")
            }
            Self::NetworkLoadBalancer => std::option::Option::Some("NETWORK_LOAD_BALANCER"),
            Self::LegacyNetworkLoadBalancer => {
                std::option::Option::Some("LEGACY_NETWORK_LOAD_BALANCER")
            }
            Self::TcpUdpInternalLoadBalancer => {
                std::option::Option::Some("TCP_UDP_INTERNAL_LOAD_BALANCER")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LoadBalancerType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LoadBalancerType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LoadBalancerType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::HttpsAdvancedLoadBalancer,
            2 => Self::HttpsLoadBalancer,
            3 => Self::RegionalHttpsLoadBalancer,
            4 => Self::InternalHttpsLoadBalancer,
            5 => Self::SslProxyLoadBalancer,
            6 => Self::TcpProxyLoadBalancer,
            7 => Self::InternalTcpProxyLoadBalancer,
            8 => Self::NetworkLoadBalancer,
            9 => Self::LegacyNetworkLoadBalancer,
            10 => Self::TcpUdpInternalLoadBalancer,
            _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LoadBalancerType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LOAD_BALANCER_TYPE_UNSPECIFIED" => Self::Unspecified,
            "HTTPS_ADVANCED_LOAD_BALANCER" => Self::HttpsAdvancedLoadBalancer,
            "HTTPS_LOAD_BALANCER" => Self::HttpsLoadBalancer,
            "REGIONAL_HTTPS_LOAD_BALANCER" => Self::RegionalHttpsLoadBalancer,
            "INTERNAL_HTTPS_LOAD_BALANCER" => Self::InternalHttpsLoadBalancer,
            "SSL_PROXY_LOAD_BALANCER" => Self::SslProxyLoadBalancer,
            "TCP_PROXY_LOAD_BALANCER" => Self::TcpProxyLoadBalancer,
            "INTERNAL_TCP_PROXY_LOAD_BALANCER" => Self::InternalTcpProxyLoadBalancer,
            "NETWORK_LOAD_BALANCER" => Self::NetworkLoadBalancer,
            "LEGACY_NETWORK_LOAD_BALANCER" => Self::LegacyNetworkLoadBalancer,
            "TCP_UDP_INTERNAL_LOAD_BALANCER" => Self::TcpUdpInternalLoadBalancer,
            _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LoadBalancerType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::HttpsAdvancedLoadBalancer => serializer.serialize_i32(1),
            Self::HttpsLoadBalancer => serializer.serialize_i32(2),
            Self::RegionalHttpsLoadBalancer => serializer.serialize_i32(3),
            Self::InternalHttpsLoadBalancer => serializer.serialize_i32(4),
            Self::SslProxyLoadBalancer => serializer.serialize_i32(5),
            Self::TcpProxyLoadBalancer => serializer.serialize_i32(6),
            Self::InternalTcpProxyLoadBalancer => serializer.serialize_i32(7),
            Self::NetworkLoadBalancer => serializer.serialize_i32(8),
            Self::LegacyNetworkLoadBalancer => serializer.serialize_i32(9),
            Self::TcpUdpInternalLoadBalancer => serializer.serialize_i32(10),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LoadBalancerType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoadBalancerType>::new(
            ".google.cloud.networkmanagement.v1.LoadBalancerType",
        ))
    }
}
