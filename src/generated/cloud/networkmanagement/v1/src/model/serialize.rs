// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::ConnectivityTest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.related_projects.is_empty() {
            state.serialize_entry("relatedProjects", &self.related_projects)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.reachability_details.is_some() {
            state.serialize_entry("reachabilityDetails", &self.reachability_details)?;
        }
        if self.probing_details.is_some() {
            state.serialize_entry("probingDetails", &self.probing_details)?;
        }
        if !wkt::internal::is_default(&self.round_trip) {
            state.serialize_entry("roundTrip", &self.round_trip)?;
        }
        if self.return_reachability_details.is_some() {
            state.serialize_entry("returnReachabilityDetails", &self.return_reachability_details)?;
        }
        if !wkt::internal::is_default(&self.bypass_firewall_checks) {
            state.serialize_entry("bypassFirewallChecks", &self.bypass_firewall_checks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Endpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.forwarding_rule.is_empty() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if self.forwarding_rule_target.is_some() {
            state.serialize_entry("forwardingRuleTarget", &self.forwarding_rule_target)?;
        }
        if self.load_balancer_id.is_some() {
            state.serialize_entry("loadBalancerId", &self.load_balancer_id)?;
        }
        if self.load_balancer_type.is_some() {
            state.serialize_entry("loadBalancerType", &self.load_balancer_type)?;
        }
        if !self.gke_master_cluster.is_empty() {
            state.serialize_entry("gkeMasterCluster", &self.gke_master_cluster)?;
        }
        if !self.fqdn.is_empty() {
            state.serialize_entry("fqdn", &self.fqdn)?;
        }
        if !self.cloud_sql_instance.is_empty() {
            state.serialize_entry("cloudSqlInstance", &self.cloud_sql_instance)?;
        }
        if !self.redis_instance.is_empty() {
            state.serialize_entry("redisInstance", &self.redis_instance)?;
        }
        if !self.redis_cluster.is_empty() {
            state.serialize_entry("redisCluster", &self.redis_cluster)?;
        }
        if self.cloud_function.is_some() {
            state.serialize_entry("cloudFunction", &self.cloud_function)?;
        }
        if self.app_engine_version.is_some() {
            state.serialize_entry("appEngineVersion", &self.app_engine_version)?;
        }
        if self.cloud_run_revision.is_some() {
            state.serialize_entry("cloudRunRevision", &self.cloud_run_revision)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !wkt::internal::is_default(&self.network_type) {
            state.serialize_entry("networkType", &self.network_type)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::endpoint::CloudFunctionEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::endpoint::AppEngineVersionEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::endpoint::CloudRunRevisionEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.service_uri.is_empty() {
            state.serialize_entry("serviceUri", &self.service_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ReachabilityDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if self.verify_time.is_some() {
            state.serialize_entry("verifyTime", &self.verify_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.traces.is_empty() {
            state.serialize_entry("traces", &self.traces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LatencyPercentile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percent", &__With(&self.percent))?;
        }
        if !wkt::internal::is_default(&self.latency_micros) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("latencyMicros", &__With(&self.latency_micros))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LatencyDistribution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.latency_percentiles.is_empty() {
            state.serialize_entry("latencyPercentiles", &self.latency_percentiles)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ProbingDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if self.verify_time.is_some() {
            state.serialize_entry("verifyTime", &self.verify_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !wkt::internal::is_default(&self.abort_cause) {
            state.serialize_entry("abortCause", &self.abort_cause)?;
        }
        if !wkt::internal::is_default(&self.sent_probe_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sentProbeCount", &__With(&self.sent_probe_count))?;
        }
        if !wkt::internal::is_default(&self.successful_probe_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successfulProbeCount", &__With(&self.successful_probe_count))?;
        }
        if self.endpoint_info.is_some() {
            state.serialize_entry("endpointInfo", &self.endpoint_info)?;
        }
        if self.probing_latency.is_some() {
            state.serialize_entry("probingLatency", &self.probing_latency)?;
        }
        if self.destination_egress_location.is_some() {
            state.serialize_entry("destinationEgressLocation", &self.destination_egress_location)?;
        }
        if !self.edge_responses.is_empty() {
            state.serialize_entry("edgeResponses", &self.edge_responses)?;
        }
        if !wkt::internal::is_default(&self.probed_all_devices) {
            state.serialize_entry("probedAllDevices", &self.probed_all_devices)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::probing_details::EdgeLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metropolitan_area.is_empty() {
            state.serialize_entry("metropolitanArea", &self.metropolitan_area)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::probing_details::SingleEdgeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if !wkt::internal::is_default(&self.sent_probe_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sentProbeCount", &__With(&self.sent_probe_count))?;
        }
        if !wkt::internal::is_default(&self.successful_probe_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successfulProbeCount", &__With(&self.successful_probe_count))?;
        }
        if self.probing_latency.is_some() {
            state.serialize_entry("probingLatency", &self.probing_latency)?;
        }
        if self.destination_egress_location.is_some() {
            state.serialize_entry("destinationEgressLocation", &self.destination_egress_location)?;
        }
        if !self.destination_router.is_empty() {
            state.serialize_entry("destinationRouter", &self.destination_router)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListConnectivityTestsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListConnectivityTestsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.test_id.is_empty() {
            state.serialize_entry("testId", &self.test_id)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RerunConnectivityTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_detail.is_empty() {
            state.serialize_entry("statusDetail", &self.status_detail)?;
        }
        if !wkt::internal::is_default(&self.cancel_requested) {
            state.serialize_entry("cancelRequested", &self.cancel_requested)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Trace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.endpoint_info.is_some() {
            state.serialize_entry("endpointInfo", &self.endpoint_info)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !wkt::internal::is_default(&self.forward_trace_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("forwardTraceId", &__With(&self.forward_trace_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Step {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.causes_drop) {
            state.serialize_entry("causesDrop", &self.causes_drop)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if let Some(value) = self.instance() {
            state.serialize_entry("instance", value)?;
        }
        if let Some(value) = self.firewall() {
            state.serialize_entry("firewall", value)?;
        }
        if let Some(value) = self.route() {
            state.serialize_entry("route", value)?;
        }
        if let Some(value) = self.endpoint() {
            state.serialize_entry("endpoint", value)?;
        }
        if let Some(value) = self.google_service() {
            state.serialize_entry("googleService", value)?;
        }
        if let Some(value) = self.forwarding_rule() {
            state.serialize_entry("forwardingRule", value)?;
        }
        if let Some(value) = self.hybrid_subnet() {
            state.serialize_entry("hybridSubnet", value)?;
        }
        if let Some(value) = self.vpn_gateway() {
            state.serialize_entry("vpnGateway", value)?;
        }
        if let Some(value) = self.vpn_tunnel() {
            state.serialize_entry("vpnTunnel", value)?;
        }
        if let Some(value) = self.interconnect_attachment() {
            state.serialize_entry("interconnectAttachment", value)?;
        }
        if let Some(value) = self.vpc_connector() {
            state.serialize_entry("vpcConnector", value)?;
        }
        if let Some(value) = self.direct_vpc_egress_connection() {
            state.serialize_entry("directVpcEgressConnection", value)?;
        }
        if let Some(value) = self.serverless_external_connection() {
            state.serialize_entry("serverlessExternalConnection", value)?;
        }
        if let Some(value) = self.deliver() {
            state.serialize_entry("deliver", value)?;
        }
        if let Some(value) = self.forward() {
            state.serialize_entry("forward", value)?;
        }
        if let Some(value) = self.abort() {
            state.serialize_entry("abort", value)?;
        }
        if let Some(value) = self.drop() {
            state.serialize_entry("drop", value)?;
        }
        if let Some(value) = self.load_balancer() {
            state.serialize_entry("loadBalancer", value)?;
        }
        if let Some(value) = self.network() {
            state.serialize_entry("network", value)?;
        }
        if let Some(value) = self.gke_master() {
            state.serialize_entry("gkeMaster", value)?;
        }
        if let Some(value) = self.cloud_sql_instance() {
            state.serialize_entry("cloudSqlInstance", value)?;
        }
        if let Some(value) = self.redis_instance() {
            state.serialize_entry("redisInstance", value)?;
        }
        if let Some(value) = self.redis_cluster() {
            state.serialize_entry("redisCluster", value)?;
        }
        if let Some(value) = self.cloud_function() {
            state.serialize_entry("cloudFunction", value)?;
        }
        if let Some(value) = self.app_engine_version() {
            state.serialize_entry("appEngineVersion", value)?;
        }
        if let Some(value) = self.cloud_run_revision() {
            state.serialize_entry("cloudRunRevision", value)?;
        }
        if let Some(value) = self.nat() {
            state.serialize_entry("nat", value)?;
        }
        if let Some(value) = self.proxy_connection() {
            state.serialize_entry("proxyConnection", value)?;
        }
        if let Some(value) = self.load_balancer_backend_info() {
            state.serialize_entry("loadBalancerBackendInfo", value)?;
        }
        if let Some(value) = self.storage_bucket() {
            state.serialize_entry("storageBucket", value)?;
        }
        if let Some(value) = self.serverless_neg() {
            state.serialize_entry("serverlessNeg", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.interface.is_empty() {
            state.serialize_entry("interface", &self.interface)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.psc_network_attachment_uri.is_empty() {
            state.serialize_entry("pscNetworkAttachmentUri", &self.psc_network_attachment_uri)?;
        }
        if !wkt::internal::is_default(&self.running) {
            state.serialize_entry("running", &self.running)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.matched_subnet_uri.is_empty() {
            state.serialize_entry("matchedSubnetUri", &self.matched_subnet_uri)?;
        }
        if !self.matched_ip_range.is_empty() {
            state.serialize_entry("matchedIpRange", &self.matched_ip_range)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.direction.is_empty() {
            state.serialize_entry("direction", &self.direction)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.target_tags.is_empty() {
            state.serialize_entry("targetTags", &self.target_tags)?;
        }
        if !self.target_service_accounts.is_empty() {
            state.serialize_entry("targetServiceAccounts", &self.target_service_accounts)?;
        }
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self.policy_uri.is_empty() {
            state.serialize_entry("policyUri", &self.policy_uri)?;
        }
        if !wkt::internal::is_default(&self.firewall_rule_type) {
            state.serialize_entry("firewallRuleType", &self.firewall_rule_type)?;
        }
        if !wkt::internal::is_default(&self.policy_priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("policyPriority", &__With(&self.policy_priority))?;
        }
        if !wkt::internal::is_default(&self.target_type) {
            state.serialize_entry("targetType", &self.target_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RouteInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.route_type) {
            state.serialize_entry("routeType", &self.route_type)?;
        }
        if !wkt::internal::is_default(&self.next_hop_type) {
            state.serialize_entry("nextHopType", &self.next_hop_type)?;
        }
        if !wkt::internal::is_default(&self.route_scope) {
            state.serialize_entry("routeScope", &self.route_scope)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.dest_ip_range.is_empty() {
            state.serialize_entry("destIpRange", &self.dest_ip_range)?;
        }
        if !self.next_hop.is_empty() {
            state.serialize_entry("nextHop", &self.next_hop)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.instance_tags.is_empty() {
            state.serialize_entry("instanceTags", &self.instance_tags)?;
        }
        if !self.src_ip_range.is_empty() {
            state.serialize_entry("srcIpRange", &self.src_ip_range)?;
        }
        if !self.dest_port_ranges.is_empty() {
            state.serialize_entry("destPortRanges", &self.dest_port_ranges)?;
        }
        if !self.src_port_ranges.is_empty() {
            state.serialize_entry("srcPortRanges", &self.src_port_ranges)?;
        }
        if !self.protocols.is_empty() {
            state.serialize_entry("protocols", &self.protocols)?;
        }
        if self.ncc_hub_uri.is_some() {
            state.serialize_entry("nccHubUri", &self.ncc_hub_uri)?;
        }
        if self.ncc_spoke_uri.is_some() {
            state.serialize_entry("nccSpokeUri", &self.ncc_spoke_uri)?;
        }
        if self.advertised_route_source_router_uri.is_some() {
            state.serialize_entry("advertisedRouteSourceRouterUri", &self.advertised_route_source_router_uri)?;
        }
        if self.advertised_route_next_hop_uri.is_some() {
            state.serialize_entry("advertisedRouteNextHopUri", &self.advertised_route_next_hop_uri)?;
        }
        if !self.next_hop_uri.is_empty() {
            state.serialize_entry("nextHopUri", &self.next_hop_uri)?;
        }
        if !self.next_hop_network_uri.is_empty() {
            state.serialize_entry("nextHopNetworkUri", &self.next_hop_network_uri)?;
        }
        if !self.originating_route_uri.is_empty() {
            state.serialize_entry("originatingRouteUri", &self.originating_route_uri)?;
        }
        if !self.originating_route_display_name.is_empty() {
            state.serialize_entry("originatingRouteDisplayName", &self.originating_route_display_name)?;
        }
        if !self.ncc_hub_route_uri.is_empty() {
            state.serialize_entry("nccHubRouteUri", &self.ncc_hub_route_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GoogleServiceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !wkt::internal::is_default(&self.google_service_type) {
            state.serialize_entry("googleServiceType", &self.google_service_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRuleInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.matched_protocol.is_empty() {
            state.serialize_entry("matchedProtocol", &self.matched_protocol)?;
        }
        if !self.matched_port_range.is_empty() {
            state.serialize_entry("matchedPortRange", &self.matched_port_range)?;
        }
        if !self.vip.is_empty() {
            state.serialize_entry("vip", &self.vip)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.load_balancer_name.is_empty() {
            state.serialize_entry("loadBalancerName", &self.load_balancer_name)?;
        }
        if !self.psc_service_attachment_uri.is_empty() {
            state.serialize_entry("pscServiceAttachmentUri", &self.psc_service_attachment_uri)?;
        }
        if !self.psc_google_api_target.is_empty() {
            state.serialize_entry("pscGoogleApiTarget", &self.psc_google_api_target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LoadBalancerInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.load_balancer_type) {
            state.serialize_entry("loadBalancerType", &self.load_balancer_type)?;
        }
        if !self.health_check_uri.is_empty() {
            state.serialize_entry("healthCheckUri", &self.health_check_uri)?;
        }
        if !self.backends.is_empty() {
            state.serialize_entry("backends", &self.backends)?;
        }
        if !wkt::internal::is_default(&self.backend_type) {
            state.serialize_entry("backendType", &self.backend_type)?;
        }
        if !self.backend_uri.is_empty() {
            state.serialize_entry("backendUri", &self.backend_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LoadBalancerBackend {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.health_check_firewall_state) {
            state.serialize_entry("healthCheckFirewallState", &self.health_check_firewall_state)?;
        }
        if !self.health_check_allowing_firewall_rules.is_empty() {
            state.serialize_entry("healthCheckAllowingFirewallRules", &self.health_check_allowing_firewall_rules)?;
        }
        if !self.health_check_blocking_firewall_rules.is_empty() {
            state.serialize_entry("healthCheckBlockingFirewallRules", &self.health_check_blocking_firewall_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HybridSubnetInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.vpn_tunnel_uri.is_empty() {
            state.serialize_entry("vpnTunnelUri", &self.vpn_tunnel_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.source_gateway.is_empty() {
            state.serialize_entry("sourceGateway", &self.source_gateway)?;
        }
        if !self.remote_gateway.is_empty() {
            state.serialize_entry("remoteGateway", &self.remote_gateway)?;
        }
        if !self.remote_gateway_ip.is_empty() {
            state.serialize_entry("remoteGatewayIp", &self.remote_gateway_ip)?;
        }
        if !self.source_gateway_ip.is_empty() {
            state.serialize_entry("sourceGatewayIp", &self.source_gateway_ip)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !wkt::internal::is_default(&self.routing_type) {
            state.serialize_entry("routingType", &self.routing_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.interconnect_uri.is_empty() {
            state.serialize_entry("interconnectUri", &self.interconnect_uri)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cloud_router_uri.is_empty() {
            state.serialize_entry("cloudRouterUri", &self.cloud_router_uri)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.l2_attachment_matched_ip_address.is_empty() {
            state.serialize_entry("l2AttachmentMatchedIpAddress", &self.l2_attachment_matched_ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EndpointInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !self.destination_ip.is_empty() {
            state.serialize_entry("destinationIp", &self.destination_ip)?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !wkt::internal::is_default(&self.source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourcePort", &__With(&self.source_port))?;
        }
        if !wkt::internal::is_default(&self.destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("destinationPort", &__With(&self.destination_port))?;
        }
        if !self.source_network_uri.is_empty() {
            state.serialize_entry("sourceNetworkUri", &self.source_network_uri)?;
        }
        if !self.destination_network_uri.is_empty() {
            state.serialize_entry("destinationNetworkUri", &self.destination_network_uri)?;
        }
        if !self.source_agent_uri.is_empty() {
            state.serialize_entry("sourceAgentUri", &self.source_agent_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DeliverInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target) {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.storage_bucket.is_empty() {
            state.serialize_entry("storageBucket", &self.storage_bucket)?;
        }
        if !self.psc_google_api_target.is_empty() {
            state.serialize_entry("pscGoogleApiTarget", &self.psc_google_api_target)?;
        }
        if !wkt::internal::is_default(&self.google_service_type) {
            state.serialize_entry("googleServiceType", &self.google_service_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target) {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AbortInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cause) {
            state.serialize_entry("cause", &self.cause)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.projects_missing_permission.is_empty() {
            state.serialize_entry("projectsMissingPermission", &self.projects_missing_permission)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DropInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cause) {
            state.serialize_entry("cause", &self.cause)?;
        }
        if !self.resource_uri.is_empty() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !self.destination_ip.is_empty() {
            state.serialize_entry("destinationIp", &self.destination_ip)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.source_geolocation_code.is_empty() {
            state.serialize_entry("sourceGeolocationCode", &self.source_geolocation_code)?;
        }
        if !self.destination_geolocation_code.is_empty() {
            state.serialize_entry("destinationGeolocationCode", &self.destination_geolocation_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GKEMasterInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_uri.is_empty() {
            state.serialize_entry("clusterUri", &self.cluster_uri)?;
        }
        if !self.cluster_network_uri.is_empty() {
            state.serialize_entry("clusterNetworkUri", &self.cluster_network_uri)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self.dns_endpoint.is_empty() {
            state.serialize_entry("dnsEndpoint", &self.dns_endpoint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CloudSQLInstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RedisInstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.primary_endpoint_ip.is_empty() {
            state.serialize_entry("primaryEndpointIp", &self.primary_endpoint_ip)?;
        }
        if !self.read_endpoint_ip.is_empty() {
            state.serialize_entry("readEndpointIp", &self.read_endpoint_ip)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RedisClusterInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.discovery_endpoint_ip_address.is_empty() {
            state.serialize_entry("discoveryEndpointIpAddress", &self.discovery_endpoint_ip_address)?;
        }
        if !self.secondary_endpoint_ip_address.is_empty() {
            state.serialize_entry("secondaryEndpointIpAddress", &self.secondary_endpoint_ip_address)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CloudFunctionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.version_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("versionId", &__With(&self.version_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CloudRunRevisionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.service_uri.is_empty() {
            state.serialize_entry("serviceUri", &self.service_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AppEngineVersionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.runtime.is_empty() {
            state.serialize_entry("runtime", &self.runtime)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::VpcConnectorInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DirectVpcEgressConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.subnetwork_uri.is_empty() {
            state.serialize_entry("subnetworkUri", &self.subnetwork_uri)?;
        }
        if !self.selected_ip_range.is_empty() {
            state.serialize_entry("selectedIpRange", &self.selected_ip_range)?;
        }
        if !self.selected_ip_address.is_empty() {
            state.serialize_entry("selectedIpAddress", &self.selected_ip_address)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ServerlessExternalConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.selected_ip_address.is_empty() {
            state.serialize_entry("selectedIpAddress", &self.selected_ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NatInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.old_source_ip.is_empty() {
            state.serialize_entry("oldSourceIp", &self.old_source_ip)?;
        }
        if !self.new_source_ip.is_empty() {
            state.serialize_entry("newSourceIp", &self.new_source_ip)?;
        }
        if !self.old_destination_ip.is_empty() {
            state.serialize_entry("oldDestinationIp", &self.old_destination_ip)?;
        }
        if !self.new_destination_ip.is_empty() {
            state.serialize_entry("newDestinationIp", &self.new_destination_ip)?;
        }
        if !wkt::internal::is_default(&self.old_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldSourcePort", &__With(&self.old_source_port))?;
        }
        if !wkt::internal::is_default(&self.new_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newSourcePort", &__With(&self.new_source_port))?;
        }
        if !wkt::internal::is_default(&self.old_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldDestinationPort", &__With(&self.old_destination_port))?;
        }
        if !wkt::internal::is_default(&self.new_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newDestinationPort", &__With(&self.new_destination_port))?;
        }
        if !self.router_uri.is_empty() {
            state.serialize_entry("routerUri", &self.router_uri)?;
        }
        if !self.nat_gateway_name.is_empty() {
            state.serialize_entry("natGatewayName", &self.nat_gateway_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ProxyConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.old_source_ip.is_empty() {
            state.serialize_entry("oldSourceIp", &self.old_source_ip)?;
        }
        if !self.new_source_ip.is_empty() {
            state.serialize_entry("newSourceIp", &self.new_source_ip)?;
        }
        if !self.old_destination_ip.is_empty() {
            state.serialize_entry("oldDestinationIp", &self.old_destination_ip)?;
        }
        if !self.new_destination_ip.is_empty() {
            state.serialize_entry("newDestinationIp", &self.new_destination_ip)?;
        }
        if !wkt::internal::is_default(&self.old_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldSourcePort", &__With(&self.old_source_port))?;
        }
        if !wkt::internal::is_default(&self.new_source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newSourcePort", &__With(&self.new_source_port))?;
        }
        if !wkt::internal::is_default(&self.old_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldDestinationPort", &__With(&self.old_destination_port))?;
        }
        if !wkt::internal::is_default(&self.new_destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("newDestinationPort", &__With(&self.new_destination_port))?;
        }
        if !self.subnet_uri.is_empty() {
            state.serialize_entry("subnetUri", &self.subnet_uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LoadBalancerBackendInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instance_uri.is_empty() {
            state.serialize_entry("instanceUri", &self.instance_uri)?;
        }
        if !self.backend_service_uri.is_empty() {
            state.serialize_entry("backendServiceUri", &self.backend_service_uri)?;
        }
        if !self.instance_group_uri.is_empty() {
            state.serialize_entry("instanceGroupUri", &self.instance_group_uri)?;
        }
        if !self.network_endpoint_group_uri.is_empty() {
            state.serialize_entry("networkEndpointGroupUri", &self.network_endpoint_group_uri)?;
        }
        if !self.backend_bucket_uri.is_empty() {
            state.serialize_entry("backendBucketUri", &self.backend_bucket_uri)?;
        }
        if !self.psc_service_attachment_uri.is_empty() {
            state.serialize_entry("pscServiceAttachmentUri", &self.psc_service_attachment_uri)?;
        }
        if !self.psc_google_api_target.is_empty() {
            state.serialize_entry("pscGoogleApiTarget", &self.psc_google_api_target)?;
        }
        if !self.health_check_uri.is_empty() {
            state.serialize_entry("healthCheckUri", &self.health_check_uri)?;
        }
        if !wkt::internal::is_default(&self.health_check_firewalls_config_state) {
            state.serialize_entry("healthCheckFirewallsConfigState", &self.health_check_firewalls_config_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::StorageBucketInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ServerlessNegInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.neg_uri.is_empty() {
            state.serialize_entry("negUri", &self.neg_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListVpcFlowLogsConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListVpcFlowLogsConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc_flow_logs_configs.is_empty() {
            state.serialize_entry("vpcFlowLogsConfigs", &self.vpc_flow_logs_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CreateVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.vpc_flow_logs_config_id.is_empty() {
            state.serialize_entry("vpcFlowLogsConfigId", &self.vpc_flow_logs_config_id)?;
        }
        if self.vpc_flow_logs_config.is_some() {
            state.serialize_entry("vpcFlowLogsConfig", &self.vpc_flow_logs_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.vpc_flow_logs_config.is_some() {
            state.serialize_entry("vpcFlowLogsConfig", &self.vpc_flow_logs_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteVpcFlowLogsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::QueryOrgVpcFlowLogsConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::QueryOrgVpcFlowLogsConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc_flow_logs_configs.is_empty() {
            state.serialize_entry("vpcFlowLogsConfigs", &self.vpc_flow_logs_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShowEffectiveFlowLogsConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShowEffectiveFlowLogsConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.effective_flow_logs_configs.is_empty() {
            state.serialize_entry("effectiveFlowLogsConfigs", &self.effective_flow_logs_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::VpcFlowLogsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.aggregation_interval.is_some() {
            state.serialize_entry("aggregationInterval", &self.aggregation_interval)?;
        }
        if self.flow_sampling.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("flowSampling", &__With(&self.flow_sampling))?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.metadata_fields.is_empty() {
            state.serialize_entry("metadataFields", &self.metadata_fields)?;
        }
        if self.filter_expr.is_some() {
            state.serialize_entry("filterExpr", &self.filter_expr)?;
        }
        if self.cross_project_metadata.is_some() {
            state.serialize_entry("crossProjectMetadata", &self.cross_project_metadata)?;
        }
        if self.target_resource_state.is_some() {
            state.serialize_entry("targetResourceState", &self.target_resource_state)?;
        }
        if let Some(value) = self.network() {
            state.serialize_entry("network", value)?;
        }
        if let Some(value) = self.subnet() {
            state.serialize_entry("subnet", value)?;
        }
        if let Some(value) = self.interconnect_attachment() {
            state.serialize_entry("interconnectAttachment", value)?;
        }
        if let Some(value) = self.vpn_tunnel() {
            state.serialize_entry("vpnTunnel", value)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}


#[doc(hidden)]
impl serde::ser::Serialize for super::EffectiveVpcFlowLogsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.aggregation_interval.is_some() {
            state.serialize_entry("aggregationInterval", &self.aggregation_interval)?;
        }
        if self.flow_sampling.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("flowSampling", &__With(&self.flow_sampling))?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.metadata_fields.is_empty() {
            state.serialize_entry("metadataFields", &self.metadata_fields)?;
        }
        if self.filter_expr.is_some() {
            state.serialize_entry("filterExpr", &self.filter_expr)?;
        }
        if self.cross_project_metadata.is_some() {
            state.serialize_entry("crossProjectMetadata", &self.cross_project_metadata)?;
        }
        if let Some(value) = self.network() {
            state.serialize_entry("network", value)?;
        }
        if let Some(value) = self.subnet() {
            state.serialize_entry("subnet", value)?;
        }
        if let Some(value) = self.interconnect_attachment() {
            state.serialize_entry("interconnectAttachment", value)?;
        }
        if let Some(value) = self.vpn_tunnel() {
            state.serialize_entry("vpnTunnel", value)?;
        }
        if self.scope.is_some() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
