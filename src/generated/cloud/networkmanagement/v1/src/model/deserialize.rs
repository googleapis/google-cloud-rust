// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConnectivityTest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __source,
            __destination,
            __protocol,
            __related_projects,
            __display_name,
            __labels,
            __create_time,
            __update_time,
            __reachability_details,
            __probing_details,
            __round_trip,
            __return_reachability_details,
            __bypass_firewall_checks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectivityTest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "source" => Ok(__FieldTag::__source),
                            "destination" => Ok(__FieldTag::__destination),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "relatedProjects" => Ok(__FieldTag::__related_projects),
                            "related_projects" => Ok(__FieldTag::__related_projects),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "reachabilityDetails" => Ok(__FieldTag::__reachability_details),
                            "reachability_details" => Ok(__FieldTag::__reachability_details),
                            "probingDetails" => Ok(__FieldTag::__probing_details),
                            "probing_details" => Ok(__FieldTag::__probing_details),
                            "roundTrip" => Ok(__FieldTag::__round_trip),
                            "round_trip" => Ok(__FieldTag::__round_trip),
                            "returnReachabilityDetails" => Ok(__FieldTag::__return_reachability_details),
                            "return_reachability_details" => Ok(__FieldTag::__return_reachability_details),
                            "bypassFirewallChecks" => Ok(__FieldTag::__bypass_firewall_checks),
                            "bypass_firewall_checks" => Ok(__FieldTag::__bypass_firewall_checks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConnectivityTest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectivityTest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source"));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::Endpoint>>()?
                                ;
                        },
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination"));
                            }
                            result.destination = map.next_value::<std::option::Option<crate::model::Endpoint>>()?
                                ;
                        },
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protocol"));
                            }
                            result.protocol = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__related_projects => {
                            if !fields.insert(__FieldTag::__related_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for related_projects"));
                            }
                            result.related_projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for labels"));
                            }
                            result.labels = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__reachability_details => {
                            if !fields.insert(__FieldTag::__reachability_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reachability_details"));
                            }
                            result.reachability_details = map.next_value::<std::option::Option<crate::model::ReachabilityDetails>>()?
                                ;
                        },
                        __FieldTag::__probing_details => {
                            if !fields.insert(__FieldTag::__probing_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for probing_details"));
                            }
                            result.probing_details = map.next_value::<std::option::Option<crate::model::ProbingDetails>>()?
                                ;
                        },
                        __FieldTag::__round_trip => {
                            if !fields.insert(__FieldTag::__round_trip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for round_trip"));
                            }
                            result.round_trip = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__return_reachability_details => {
                            if !fields.insert(__FieldTag::__return_reachability_details) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for return_reachability_details"));
                            }
                            result.return_reachability_details = map.next_value::<std::option::Option<crate::model::ReachabilityDetails>>()?
                                ;
                        },
                        __FieldTag::__bypass_firewall_checks => {
                            if !fields.insert(__FieldTag::__bypass_firewall_checks) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bypass_firewall_checks"));
                            }
                            result.bypass_firewall_checks = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Endpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_address,
            __port,
            __instance,
            __forwarding_rule,
            __forwarding_rule_target,
            __load_balancer_id,
            __load_balancer_type,
            __gke_master_cluster,
            __fqdn,
            __cloud_sql_instance,
            __redis_instance,
            __redis_cluster,
            __cloud_function,
            __app_engine_version,
            __cloud_run_revision,
            __network,
            __network_type,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Endpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "port" => Ok(__FieldTag::__port),
                            "instance" => Ok(__FieldTag::__instance),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "forwardingRuleTarget" => Ok(__FieldTag::__forwarding_rule_target),
                            "forwarding_rule_target" => Ok(__FieldTag::__forwarding_rule_target),
                            "loadBalancerId" => Ok(__FieldTag::__load_balancer_id),
                            "load_balancer_id" => Ok(__FieldTag::__load_balancer_id),
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            "gkeMasterCluster" => Ok(__FieldTag::__gke_master_cluster),
                            "gke_master_cluster" => Ok(__FieldTag::__gke_master_cluster),
                            "fqdn" => Ok(__FieldTag::__fqdn),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "redisInstance" => Ok(__FieldTag::__redis_instance),
                            "redis_instance" => Ok(__FieldTag::__redis_instance),
                            "redisCluster" => Ok(__FieldTag::__redis_cluster),
                            "redis_cluster" => Ok(__FieldTag::__redis_cluster),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "appEngineVersion" => Ok(__FieldTag::__app_engine_version),
                            "app_engine_version" => Ok(__FieldTag::__app_engine_version),
                            "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                            "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                            "network" => Ok(__FieldTag::__network),
                            "networkType" => Ok(__FieldTag::__network_type),
                            "network_type" => Ok(__FieldTag::__network_type),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Endpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Endpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ip_address"));
                            }
                            result.ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instance"));
                            }
                            result.instance = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for forwarding_rule"));
                            }
                            result.forwarding_rule = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__forwarding_rule_target => {
                            if !fields.insert(__FieldTag::__forwarding_rule_target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for forwarding_rule_target"));
                            }
                            result.forwarding_rule_target = map.next_value::<std::option::Option<crate::model::endpoint::ForwardingRuleTarget>>()?
                                ;
                        },
                        __FieldTag::__load_balancer_id => {
                            if !fields.insert(__FieldTag::__load_balancer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_balancer_id"));
                            }
                            result.load_balancer_id = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_balancer_type"));
                            }
                            result.load_balancer_type = map.next_value::<std::option::Option<crate::model::LoadBalancerType>>()?
                                ;
                        },
                        __FieldTag::__gke_master_cluster => {
                            if !fields.insert(__FieldTag::__gke_master_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gke_master_cluster"));
                            }
                            result.gke_master_cluster = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__fqdn => {
                            if !fields.insert(__FieldTag::__fqdn) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fqdn"));
                            }
                            result.fqdn = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_sql_instance"));
                            }
                            result.cloud_sql_instance = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__redis_instance => {
                            if !fields.insert(__FieldTag::__redis_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for redis_instance"));
                            }
                            result.redis_instance = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__redis_cluster => {
                            if !fields.insert(__FieldTag::__redis_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for redis_cluster"));
                            }
                            result.redis_cluster = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_function"));
                            }
                            result.cloud_function = map.next_value::<std::option::Option<crate::model::endpoint::CloudFunctionEndpoint>>()?
                                ;
                        },
                        __FieldTag::__app_engine_version => {
                            if !fields.insert(__FieldTag::__app_engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for app_engine_version"));
                            }
                            result.app_engine_version = map.next_value::<std::option::Option<crate::model::endpoint::AppEngineVersionEndpoint>>()?
                                ;
                        },
                        __FieldTag::__cloud_run_revision => {
                            if !fields.insert(__FieldTag::__cloud_run_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_run_revision"));
                            }
                            result.cloud_run_revision = map.next_value::<std::option::Option<crate::model::endpoint::CloudRunRevisionEndpoint>>()?
                                ;
                        },
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network"));
                            }
                            result.network = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_type => {
                            if !fields.insert(__FieldTag::__network_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_type"));
                            }
                            result.network_type = map.next_value::<std::option::Option<crate::model::endpoint::NetworkType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for project_id"));
                            }
                            result.project_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::endpoint::CloudFunctionEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudFunctionEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::endpoint::CloudFunctionEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudFunctionEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::endpoint::AppEngineVersionEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineVersionEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::endpoint::AppEngineVersionEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineVersionEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::endpoint::CloudRunRevisionEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __service_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunRevisionEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "serviceUri" => Ok(__FieldTag::__service_uri),
                            "service_uri" => Ok(__FieldTag::__service_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::endpoint::CloudRunRevisionEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunRevisionEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__service_uri => {
                            if !fields.insert(__FieldTag::__service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_uri"));
                            }
                            result.service_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReachabilityDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __verify_time,
            __error,
            __traces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReachabilityDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "verifyTime" => Ok(__FieldTag::__verify_time),
                            "verify_time" => Ok(__FieldTag::__verify_time),
                            "error" => Ok(__FieldTag::__error),
                            "traces" => Ok(__FieldTag::__traces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReachabilityDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReachabilityDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for result"));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::reachability_details::Result>>()?.unwrap_or_default();
                        },
                        __FieldTag::__verify_time => {
                            if !fields.insert(__FieldTag::__verify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for verify_time"));
                            }
                            result.verify_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error"));
                            }
                            result.error = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::__traces => {
                            if !fields.insert(__FieldTag::__traces) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for traces"));
                            }
                            result.traces = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Trace>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LatencyPercentile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __percent,
            __latency_micros,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatencyPercentile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "percent" => Ok(__FieldTag::__percent),
                            "latencyMicros" => Ok(__FieldTag::__latency_micros),
                            "latency_micros" => Ok(__FieldTag::__latency_micros),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LatencyPercentile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatencyPercentile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for percent"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__latency_micros => {
                            if !fields.insert(__FieldTag::__latency_micros) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latency_micros"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.latency_micros = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LatencyDistribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __latency_percentiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatencyDistribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latencyPercentiles" => Ok(__FieldTag::__latency_percentiles),
                            "latency_percentiles" => Ok(__FieldTag::__latency_percentiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LatencyDistribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatencyDistribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__latency_percentiles => {
                            if !fields.insert(__FieldTag::__latency_percentiles) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latency_percentiles"));
                            }
                            result.latency_percentiles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LatencyPercentile>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ProbingDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __verify_time,
            __error,
            __abort_cause,
            __sent_probe_count,
            __successful_probe_count,
            __endpoint_info,
            __probing_latency,
            __destination_egress_location,
            __edge_responses,
            __probed_all_devices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProbingDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "verifyTime" => Ok(__FieldTag::__verify_time),
                            "verify_time" => Ok(__FieldTag::__verify_time),
                            "error" => Ok(__FieldTag::__error),
                            "abortCause" => Ok(__FieldTag::__abort_cause),
                            "abort_cause" => Ok(__FieldTag::__abort_cause),
                            "sentProbeCount" => Ok(__FieldTag::__sent_probe_count),
                            "sent_probe_count" => Ok(__FieldTag::__sent_probe_count),
                            "successfulProbeCount" => Ok(__FieldTag::__successful_probe_count),
                            "successful_probe_count" => Ok(__FieldTag::__successful_probe_count),
                            "endpointInfo" => Ok(__FieldTag::__endpoint_info),
                            "endpoint_info" => Ok(__FieldTag::__endpoint_info),
                            "probingLatency" => Ok(__FieldTag::__probing_latency),
                            "probing_latency" => Ok(__FieldTag::__probing_latency),
                            "destinationEgressLocation" => Ok(__FieldTag::__destination_egress_location),
                            "destination_egress_location" => Ok(__FieldTag::__destination_egress_location),
                            "edgeResponses" => Ok(__FieldTag::__edge_responses),
                            "edge_responses" => Ok(__FieldTag::__edge_responses),
                            "probedAllDevices" => Ok(__FieldTag::__probed_all_devices),
                            "probed_all_devices" => Ok(__FieldTag::__probed_all_devices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ProbingDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProbingDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for result"));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::probing_details::ProbingResult>>()?.unwrap_or_default();
                        },
                        __FieldTag::__verify_time => {
                            if !fields.insert(__FieldTag::__verify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for verify_time"));
                            }
                            result.verify_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error"));
                            }
                            result.error = map.next_value::<std::option::Option<rpc::model::Status>>()?
                                ;
                        },
                        __FieldTag::__abort_cause => {
                            if !fields.insert(__FieldTag::__abort_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for abort_cause"));
                            }
                            result.abort_cause = map.next_value::<std::option::Option<crate::model::probing_details::ProbingAbortCause>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sent_probe_count => {
                            if !fields.insert(__FieldTag::__sent_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sent_probe_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sent_probe_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__successful_probe_count => {
                            if !fields.insert(__FieldTag::__successful_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for successful_probe_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.successful_probe_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__endpoint_info => {
                            if !fields.insert(__FieldTag::__endpoint_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for endpoint_info"));
                            }
                            result.endpoint_info = map.next_value::<std::option::Option<crate::model::EndpointInfo>>()?
                                ;
                        },
                        __FieldTag::__probing_latency => {
                            if !fields.insert(__FieldTag::__probing_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for probing_latency"));
                            }
                            result.probing_latency = map.next_value::<std::option::Option<crate::model::LatencyDistribution>>()?
                                ;
                        },
                        __FieldTag::__destination_egress_location => {
                            if !fields.insert(__FieldTag::__destination_egress_location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_egress_location"));
                            }
                            result.destination_egress_location = map.next_value::<std::option::Option<crate::model::probing_details::EdgeLocation>>()?
                                ;
                        },
                        __FieldTag::__edge_responses => {
                            if !fields.insert(__FieldTag::__edge_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for edge_responses"));
                            }
                            result.edge_responses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::probing_details::SingleEdgeResponse>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__probed_all_devices => {
                            if !fields.insert(__FieldTag::__probed_all_devices) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for probed_all_devices"));
                            }
                            result.probed_all_devices = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::probing_details::EdgeLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metropolitan_area,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EdgeLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metropolitanArea" => Ok(__FieldTag::__metropolitan_area),
                            "metropolitan_area" => Ok(__FieldTag::__metropolitan_area),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::probing_details::EdgeLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EdgeLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metropolitan_area => {
                            if !fields.insert(__FieldTag::__metropolitan_area) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metropolitan_area"));
                            }
                            result.metropolitan_area = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::probing_details::SingleEdgeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __sent_probe_count,
            __successful_probe_count,
            __probing_latency,
            __destination_egress_location,
            __destination_router,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SingleEdgeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "sentProbeCount" => Ok(__FieldTag::__sent_probe_count),
                            "sent_probe_count" => Ok(__FieldTag::__sent_probe_count),
                            "successfulProbeCount" => Ok(__FieldTag::__successful_probe_count),
                            "successful_probe_count" => Ok(__FieldTag::__successful_probe_count),
                            "probingLatency" => Ok(__FieldTag::__probing_latency),
                            "probing_latency" => Ok(__FieldTag::__probing_latency),
                            "destinationEgressLocation" => Ok(__FieldTag::__destination_egress_location),
                            "destination_egress_location" => Ok(__FieldTag::__destination_egress_location),
                            "destinationRouter" => Ok(__FieldTag::__destination_router),
                            "destination_router" => Ok(__FieldTag::__destination_router),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::probing_details::SingleEdgeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SingleEdgeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for result"));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::probing_details::ProbingResult>>()?.unwrap_or_default();
                        },
                        __FieldTag::__sent_probe_count => {
                            if !fields.insert(__FieldTag::__sent_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for sent_probe_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sent_probe_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__successful_probe_count => {
                            if !fields.insert(__FieldTag::__successful_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for successful_probe_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.successful_probe_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__probing_latency => {
                            if !fields.insert(__FieldTag::__probing_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for probing_latency"));
                            }
                            result.probing_latency = map.next_value::<std::option::Option<crate::model::LatencyDistribution>>()?
                                ;
                        },
                        __FieldTag::__destination_egress_location => {
                            if !fields.insert(__FieldTag::__destination_egress_location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_egress_location"));
                            }
                            result.destination_egress_location = map.next_value::<std::option::Option<crate::model::probing_details::EdgeLocation>>()?
                                ;
                        },
                        __FieldTag::__destination_router => {
                            if !fields.insert(__FieldTag::__destination_router) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_router"));
                            }
                            result.destination_router = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConnectivityTestsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectivityTestsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConnectivityTestsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectivityTestsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for order_by"));
                            }
                            result.order_by = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConnectivityTestsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectivityTestsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resources" => Ok(__FieldTag::__resources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConnectivityTestsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectivityTestsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resources"));
                            }
                            result.resources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ConnectivityTest>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for unreachable"));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __test_id,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "testId" => Ok(__FieldTag::__test_id),
                            "test_id" => Ok(__FieldTag::__test_id),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__test_id => {
                            if !fields.insert(__FieldTag::__test_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for test_id"));
                            }
                            result.test_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource"));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::ConnectivityTest>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource"));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::ConnectivityTest>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RerunConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RerunConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RerunConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RerunConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_detail,
            __cancel_requested,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusDetail" => Ok(__FieldTag::__status_detail),
                            "status_detail" => Ok(__FieldTag::__status_detail),
                            "cancelRequested" => Ok(__FieldTag::__cancel_requested),
                            "cancel_requested" => Ok(__FieldTag::__cancel_requested),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for end_time"));
                            }
                            result.end_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target"));
                            }
                            result.target = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for verb"));
                            }
                            result.verb = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__status_detail => {
                            if !fields.insert(__FieldTag::__status_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status_detail"));
                            }
                            result.status_detail = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cancel_requested => {
                            if !fields.insert(__FieldTag::__cancel_requested) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cancel_requested"));
                            }
                            result.cancel_requested = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for api_version"));
                            }
                            result.api_version = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Trace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint_info,
            __steps,
            __forward_trace_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Trace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpointInfo" => Ok(__FieldTag::__endpoint_info),
                            "endpoint_info" => Ok(__FieldTag::__endpoint_info),
                            "steps" => Ok(__FieldTag::__steps),
                            "forwardTraceId" => Ok(__FieldTag::__forward_trace_id),
                            "forward_trace_id" => Ok(__FieldTag::__forward_trace_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Trace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Trace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint_info => {
                            if !fields.insert(__FieldTag::__endpoint_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for endpoint_info"));
                            }
                            result.endpoint_info = map.next_value::<std::option::Option<crate::model::EndpointInfo>>()?
                                ;
                        },
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for steps"));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Step>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__forward_trace_id => {
                            if !fields.insert(__FieldTag::__forward_trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for forward_trace_id"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.forward_trace_id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Step {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __state,
            __causes_drop,
            __project_id,
            __instance,
            __firewall,
            __route,
            __endpoint,
            __google_service,
            __forwarding_rule,
            __hybrid_subnet,
            __vpn_gateway,
            __vpn_tunnel,
            __interconnect_attachment,
            __vpc_connector,
            __direct_vpc_egress_connection,
            __serverless_external_connection,
            __deliver,
            __forward,
            __abort,
            __drop,
            __load_balancer,
            __network,
            __gke_master,
            __cloud_sql_instance,
            __redis_instance,
            __redis_cluster,
            __cloud_function,
            __app_engine_version,
            __cloud_run_revision,
            __nat,
            __proxy_connection,
            __load_balancer_backend_info,
            __storage_bucket,
            __serverless_neg,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Step")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "causesDrop" => Ok(__FieldTag::__causes_drop),
                            "causes_drop" => Ok(__FieldTag::__causes_drop),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "firewall" => Ok(__FieldTag::__firewall),
                            "route" => Ok(__FieldTag::__route),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "googleService" => Ok(__FieldTag::__google_service),
                            "google_service" => Ok(__FieldTag::__google_service),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "hybridSubnet" => Ok(__FieldTag::__hybrid_subnet),
                            "hybrid_subnet" => Ok(__FieldTag::__hybrid_subnet),
                            "vpnGateway" => Ok(__FieldTag::__vpn_gateway),
                            "vpn_gateway" => Ok(__FieldTag::__vpn_gateway),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "interconnectAttachment" => Ok(__FieldTag::__interconnect_attachment),
                            "interconnect_attachment" => Ok(__FieldTag::__interconnect_attachment),
                            "vpcConnector" => Ok(__FieldTag::__vpc_connector),
                            "vpc_connector" => Ok(__FieldTag::__vpc_connector),
                            "directVpcEgressConnection" => Ok(__FieldTag::__direct_vpc_egress_connection),
                            "direct_vpc_egress_connection" => Ok(__FieldTag::__direct_vpc_egress_connection),
                            "serverlessExternalConnection" => Ok(__FieldTag::__serverless_external_connection),
                            "serverless_external_connection" => Ok(__FieldTag::__serverless_external_connection),
                            "deliver" => Ok(__FieldTag::__deliver),
                            "forward" => Ok(__FieldTag::__forward),
                            "abort" => Ok(__FieldTag::__abort),
                            "drop" => Ok(__FieldTag::__drop),
                            "loadBalancer" => Ok(__FieldTag::__load_balancer),
                            "load_balancer" => Ok(__FieldTag::__load_balancer),
                            "network" => Ok(__FieldTag::__network),
                            "gkeMaster" => Ok(__FieldTag::__gke_master),
                            "gke_master" => Ok(__FieldTag::__gke_master),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "redisInstance" => Ok(__FieldTag::__redis_instance),
                            "redis_instance" => Ok(__FieldTag::__redis_instance),
                            "redisCluster" => Ok(__FieldTag::__redis_cluster),
                            "redis_cluster" => Ok(__FieldTag::__redis_cluster),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "appEngineVersion" => Ok(__FieldTag::__app_engine_version),
                            "app_engine_version" => Ok(__FieldTag::__app_engine_version),
                            "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                            "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                            "nat" => Ok(__FieldTag::__nat),
                            "proxyConnection" => Ok(__FieldTag::__proxy_connection),
                            "proxy_connection" => Ok(__FieldTag::__proxy_connection),
                            "loadBalancerBackendInfo" => Ok(__FieldTag::__load_balancer_backend_info),
                            "load_balancer_backend_info" => Ok(__FieldTag::__load_balancer_backend_info),
                            "storageBucket" => Ok(__FieldTag::__storage_bucket),
                            "storage_bucket" => Ok(__FieldTag::__storage_bucket),
                            "serverlessNeg" => Ok(__FieldTag::__serverless_neg),
                            "serverless_neg" => Ok(__FieldTag::__serverless_neg),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Step;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Step")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::step::State>>()?.unwrap_or_default();
                        },
                        __FieldTag::__causes_drop => {
                            if !fields.insert(__FieldTag::__causes_drop) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for causes_drop"));
                            }
                            result.causes_drop = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for project_id"));
                            }
                            result.project_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instance"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.instance, latest field was instance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Instance(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InstanceInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__firewall => {
                            if !fields.insert(__FieldTag::__firewall) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for firewall"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.firewall, latest field was firewall",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Firewall(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FirewallInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__route => {
                            if !fields.insert(__FieldTag::__route) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for route"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.route, latest field was route",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Route(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RouteInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for endpoint"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.endpoint, latest field was endpoint",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Endpoint(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::EndpointInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__google_service => {
                            if !fields.insert(__FieldTag::__google_service) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for google_service"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.google_service, latest field was googleService",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::GoogleService(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GoogleServiceInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for forwarding_rule"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.forwarding_rule, latest field was forwardingRule",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ForwardingRule(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ForwardingRuleInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__hybrid_subnet => {
                            if !fields.insert(__FieldTag::__hybrid_subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for hybrid_subnet"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.hybrid_subnet, latest field was hybridSubnet",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::HybridSubnet(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::HybridSubnetInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__vpn_gateway => {
                            if !fields.insert(__FieldTag::__vpn_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpn_gateway"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpn_gateway, latest field was vpnGateway",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpnGateway(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VpnGatewayInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpn_tunnel"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpnTunnel(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VpnTunnelInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__interconnect_attachment => {
                            if !fields.insert(__FieldTag::__interconnect_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for interconnect_attachment"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.interconnect_attachment, latest field was interconnectAttachment",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::InterconnectAttachment(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InterconnectAttachmentInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__vpc_connector => {
                            if !fields.insert(__FieldTag::__vpc_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_connector"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpc_connector, latest field was vpcConnector",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpcConnector(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VpcConnectorInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__direct_vpc_egress_connection => {
                            if !fields.insert(__FieldTag::__direct_vpc_egress_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for direct_vpc_egress_connection"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.direct_vpc_egress_connection, latest field was directVpcEgressConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::DirectVpcEgressConnection(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DirectVpcEgressConnectionInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__serverless_external_connection => {
                            if !fields.insert(__FieldTag::__serverless_external_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for serverless_external_connection"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.serverless_external_connection, latest field was serverlessExternalConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ServerlessExternalConnection(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ServerlessExternalConnectionInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__deliver => {
                            if !fields.insert(__FieldTag::__deliver) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for deliver"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.deliver, latest field was deliver",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Deliver(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DeliverInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__forward => {
                            if !fields.insert(__FieldTag::__forward) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for forward"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.forward, latest field was forward",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Forward(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ForwardInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__abort => {
                            if !fields.insert(__FieldTag::__abort) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for abort"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.abort, latest field was abort",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Abort(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AbortInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__drop => {
                            if !fields.insert(__FieldTag::__drop) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for drop"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.drop, latest field was drop",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Drop(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DropInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__load_balancer => {
                            if !fields.insert(__FieldTag::__load_balancer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_balancer"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.load_balancer, latest field was loadBalancer",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::LoadBalancer(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::LoadBalancerInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.network, latest field was network",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Network(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::NetworkInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__gke_master => {
                            if !fields.insert(__FieldTag::__gke_master) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for gke_master"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.gke_master, latest field was gkeMaster",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::GkeMaster(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GKEMasterInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_sql_instance"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_sql_instance, latest field was cloudSqlInstance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudSqlInstance(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudSQLInstanceInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__redis_instance => {
                            if !fields.insert(__FieldTag::__redis_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for redis_instance"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.redis_instance, latest field was redisInstance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::RedisInstance(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RedisInstanceInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__redis_cluster => {
                            if !fields.insert(__FieldTag::__redis_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for redis_cluster"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.redis_cluster, latest field was redisCluster",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::RedisCluster(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::RedisClusterInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_function"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_function, latest field was cloudFunction",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudFunction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudFunctionInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__app_engine_version => {
                            if !fields.insert(__FieldTag::__app_engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for app_engine_version"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.app_engine_version, latest field was appEngineVersion",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::AppEngineVersion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AppEngineVersionInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__cloud_run_revision => {
                            if !fields.insert(__FieldTag::__cloud_run_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_run_revision"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_run_revision, latest field was cloudRunRevision",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudRunRevision(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudRunRevisionInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__nat => {
                            if !fields.insert(__FieldTag::__nat) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for nat"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.nat, latest field was nat",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::Nat(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::NatInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__proxy_connection => {
                            if !fields.insert(__FieldTag::__proxy_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for proxy_connection"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.proxy_connection, latest field was proxyConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ProxyConnection(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ProxyConnectionInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__load_balancer_backend_info => {
                            if !fields.insert(__FieldTag::__load_balancer_backend_info) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_balancer_backend_info"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.load_balancer_backend_info, latest field was loadBalancerBackendInfo",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::LoadBalancerBackendInfo(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::LoadBalancerBackendInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__storage_bucket => {
                            if !fields.insert(__FieldTag::__storage_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for storage_bucket"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.storage_bucket, latest field was storageBucket",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::StorageBucket(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StorageBucketInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__serverless_neg => {
                            if !fields.insert(__FieldTag::__serverless_neg) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for serverless_neg"));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.serverless_neg, latest field was serverlessNeg",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ServerlessNeg(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ServerlessNegInfo>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __interface,
            __network_uri,
            __internal_ip,
            __external_ip,
            __network_tags,
            __service_account,
            __psc_network_attachment_uri,
            __running,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "interface" => Ok(__FieldTag::__interface),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "pscNetworkAttachmentUri" => Ok(__FieldTag::__psc_network_attachment_uri),
                            "psc_network_attachment_uri" => Ok(__FieldTag::__psc_network_attachment_uri),
                            "running" => Ok(__FieldTag::__running),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__interface => {
                            if !fields.insert(__FieldTag::__interface) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for interface"));
                            }
                            result.interface = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for internal_ip"));
                            }
                            result.internal_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for external_ip"));
                            }
                            result.external_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_tags"));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_account"));
                            }
                            result.service_account = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__psc_network_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_network_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for psc_network_attachment_uri"));
                            }
                            result.psc_network_attachment_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__running => {
                            if !fields.insert(__FieldTag::__running) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for running"));
                            }
                            result.running = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status"));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::instance_info::Status>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NetworkInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __matched_subnet_uri,
            __matched_ip_range,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "matchedSubnetUri" => Ok(__FieldTag::__matched_subnet_uri),
                            "matched_subnet_uri" => Ok(__FieldTag::__matched_subnet_uri),
                            "matchedIpRange" => Ok(__FieldTag::__matched_ip_range),
                            "matched_ip_range" => Ok(__FieldTag::__matched_ip_range),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NetworkInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__matched_subnet_uri => {
                            if !fields.insert(__FieldTag::__matched_subnet_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matched_subnet_uri"));
                            }
                            result.matched_subnet_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__matched_ip_range => {
                            if !fields.insert(__FieldTag::__matched_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matched_ip_range"));
                            }
                            result.matched_ip_range = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FirewallInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __direction,
            __action,
            __priority,
            __network_uri,
            __target_tags,
            __target_service_accounts,
            __policy,
            __policy_uri,
            __firewall_rule_type,
            __policy_priority,
            __target_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "direction" => Ok(__FieldTag::__direction),
                            "action" => Ok(__FieldTag::__action),
                            "priority" => Ok(__FieldTag::__priority),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "targetTags" => Ok(__FieldTag::__target_tags),
                            "target_tags" => Ok(__FieldTag::__target_tags),
                            "targetServiceAccounts" => Ok(__FieldTag::__target_service_accounts),
                            "target_service_accounts" => Ok(__FieldTag::__target_service_accounts),
                            "policy" => Ok(__FieldTag::__policy),
                            "policyUri" => Ok(__FieldTag::__policy_uri),
                            "policy_uri" => Ok(__FieldTag::__policy_uri),
                            "firewallRuleType" => Ok(__FieldTag::__firewall_rule_type),
                            "firewall_rule_type" => Ok(__FieldTag::__firewall_rule_type),
                            "policyPriority" => Ok(__FieldTag::__policy_priority),
                            "policy_priority" => Ok(__FieldTag::__policy_priority),
                            "targetType" => Ok(__FieldTag::__target_type),
                            "target_type" => Ok(__FieldTag::__target_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FirewallInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for direction"));
                            }
                            result.direction = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for priority"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__target_tags => {
                            if !fields.insert(__FieldTag::__target_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target_tags"));
                            }
                            result.target_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__target_service_accounts => {
                            if !fields.insert(__FieldTag::__target_service_accounts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target_service_accounts"));
                            }
                            result.target_service_accounts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for policy"));
                            }
                            result.policy = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__policy_uri => {
                            if !fields.insert(__FieldTag::__policy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for policy_uri"));
                            }
                            result.policy_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__firewall_rule_type => {
                            if !fields.insert(__FieldTag::__firewall_rule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for firewall_rule_type"));
                            }
                            result.firewall_rule_type = map.next_value::<std::option::Option<crate::model::firewall_info::FirewallRuleType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__policy_priority => {
                            if !fields.insert(__FieldTag::__policy_priority) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for policy_priority"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.policy_priority = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__target_type => {
                            if !fields.insert(__FieldTag::__target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target_type"));
                            }
                            result.target_type = map.next_value::<std::option::Option<crate::model::firewall_info::TargetType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RouteInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __route_type,
            __next_hop_type,
            __route_scope,
            __display_name,
            __uri,
            __region,
            __dest_ip_range,
            __next_hop,
            __network_uri,
            __priority,
            __instance_tags,
            __src_ip_range,
            __dest_port_ranges,
            __src_port_ranges,
            __protocols,
            __ncc_hub_uri,
            __ncc_spoke_uri,
            __advertised_route_source_router_uri,
            __advertised_route_next_hop_uri,
            __next_hop_uri,
            __next_hop_network_uri,
            __originating_route_uri,
            __originating_route_display_name,
            __ncc_hub_route_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RouteInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routeType" => Ok(__FieldTag::__route_type),
                            "route_type" => Ok(__FieldTag::__route_type),
                            "nextHopType" => Ok(__FieldTag::__next_hop_type),
                            "next_hop_type" => Ok(__FieldTag::__next_hop_type),
                            "routeScope" => Ok(__FieldTag::__route_scope),
                            "route_scope" => Ok(__FieldTag::__route_scope),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "region" => Ok(__FieldTag::__region),
                            "destIpRange" => Ok(__FieldTag::__dest_ip_range),
                            "dest_ip_range" => Ok(__FieldTag::__dest_ip_range),
                            "nextHop" => Ok(__FieldTag::__next_hop),
                            "next_hop" => Ok(__FieldTag::__next_hop),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "priority" => Ok(__FieldTag::__priority),
                            "instanceTags" => Ok(__FieldTag::__instance_tags),
                            "instance_tags" => Ok(__FieldTag::__instance_tags),
                            "srcIpRange" => Ok(__FieldTag::__src_ip_range),
                            "src_ip_range" => Ok(__FieldTag::__src_ip_range),
                            "destPortRanges" => Ok(__FieldTag::__dest_port_ranges),
                            "dest_port_ranges" => Ok(__FieldTag::__dest_port_ranges),
                            "srcPortRanges" => Ok(__FieldTag::__src_port_ranges),
                            "src_port_ranges" => Ok(__FieldTag::__src_port_ranges),
                            "protocols" => Ok(__FieldTag::__protocols),
                            "nccHubUri" => Ok(__FieldTag::__ncc_hub_uri),
                            "ncc_hub_uri" => Ok(__FieldTag::__ncc_hub_uri),
                            "nccSpokeUri" => Ok(__FieldTag::__ncc_spoke_uri),
                            "ncc_spoke_uri" => Ok(__FieldTag::__ncc_spoke_uri),
                            "advertisedRouteSourceRouterUri" => Ok(__FieldTag::__advertised_route_source_router_uri),
                            "advertised_route_source_router_uri" => Ok(__FieldTag::__advertised_route_source_router_uri),
                            "advertisedRouteNextHopUri" => Ok(__FieldTag::__advertised_route_next_hop_uri),
                            "advertised_route_next_hop_uri" => Ok(__FieldTag::__advertised_route_next_hop_uri),
                            "nextHopUri" => Ok(__FieldTag::__next_hop_uri),
                            "next_hop_uri" => Ok(__FieldTag::__next_hop_uri),
                            "nextHopNetworkUri" => Ok(__FieldTag::__next_hop_network_uri),
                            "next_hop_network_uri" => Ok(__FieldTag::__next_hop_network_uri),
                            "originatingRouteUri" => Ok(__FieldTag::__originating_route_uri),
                            "originating_route_uri" => Ok(__FieldTag::__originating_route_uri),
                            "originatingRouteDisplayName" => Ok(__FieldTag::__originating_route_display_name),
                            "originating_route_display_name" => Ok(__FieldTag::__originating_route_display_name),
                            "nccHubRouteUri" => Ok(__FieldTag::__ncc_hub_route_uri),
                            "ncc_hub_route_uri" => Ok(__FieldTag::__ncc_hub_route_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RouteInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RouteInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__route_type => {
                            if !fields.insert(__FieldTag::__route_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for route_type"));
                            }
                            result.route_type = map.next_value::<std::option::Option<crate::model::route_info::RouteType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_hop_type => {
                            if !fields.insert(__FieldTag::__next_hop_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_hop_type"));
                            }
                            result.next_hop_type = map.next_value::<std::option::Option<crate::model::route_info::NextHopType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__route_scope => {
                            if !fields.insert(__FieldTag::__route_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for route_scope"));
                            }
                            result.route_scope = map.next_value::<std::option::Option<crate::model::route_info::RouteScope>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dest_ip_range => {
                            if !fields.insert(__FieldTag::__dest_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dest_ip_range"));
                            }
                            result.dest_ip_range = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_hop => {
                            if !fields.insert(__FieldTag::__next_hop) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_hop"));
                            }
                            result.next_hop = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for priority"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__instance_tags => {
                            if !fields.insert(__FieldTag::__instance_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instance_tags"));
                            }
                            result.instance_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__src_ip_range => {
                            if !fields.insert(__FieldTag::__src_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for src_ip_range"));
                            }
                            result.src_ip_range = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dest_port_ranges => {
                            if !fields.insert(__FieldTag::__dest_port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dest_port_ranges"));
                            }
                            result.dest_port_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__src_port_ranges => {
                            if !fields.insert(__FieldTag::__src_port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for src_port_ranges"));
                            }
                            result.src_port_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__protocols => {
                            if !fields.insert(__FieldTag::__protocols) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protocols"));
                            }
                            result.protocols = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ncc_hub_uri => {
                            if !fields.insert(__FieldTag::__ncc_hub_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ncc_hub_uri"));
                            }
                            result.ncc_hub_uri = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__ncc_spoke_uri => {
                            if !fields.insert(__FieldTag::__ncc_spoke_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ncc_spoke_uri"));
                            }
                            result.ncc_spoke_uri = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__advertised_route_source_router_uri => {
                            if !fields.insert(__FieldTag::__advertised_route_source_router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for advertised_route_source_router_uri"));
                            }
                            result.advertised_route_source_router_uri = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__advertised_route_next_hop_uri => {
                            if !fields.insert(__FieldTag::__advertised_route_next_hop_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for advertised_route_next_hop_uri"));
                            }
                            result.advertised_route_next_hop_uri = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__next_hop_uri => {
                            if !fields.insert(__FieldTag::__next_hop_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_hop_uri"));
                            }
                            result.next_hop_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_hop_network_uri => {
                            if !fields.insert(__FieldTag::__next_hop_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_hop_network_uri"));
                            }
                            result.next_hop_network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__originating_route_uri => {
                            if !fields.insert(__FieldTag::__originating_route_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for originating_route_uri"));
                            }
                            result.originating_route_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__originating_route_display_name => {
                            if !fields.insert(__FieldTag::__originating_route_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for originating_route_display_name"));
                            }
                            result.originating_route_display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ncc_hub_route_uri => {
                            if !fields.insert(__FieldTag::__ncc_hub_route_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ncc_hub_route_uri"));
                            }
                            result.ncc_hub_route_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleServiceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_ip,
            __google_service_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleServiceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "googleServiceType" => Ok(__FieldTag::__google_service_type),
                            "google_service_type" => Ok(__FieldTag::__google_service_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleServiceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleServiceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_ip"));
                            }
                            result.source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__google_service_type => {
                            if !fields.insert(__FieldTag::__google_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for google_service_type"));
                            }
                            result.google_service_type = map.next_value::<std::option::Option<crate::model::google_service_info::GoogleServiceType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForwardingRuleInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __matched_protocol,
            __matched_port_range,
            __vip,
            __target,
            __network_uri,
            __region,
            __load_balancer_name,
            __psc_service_attachment_uri,
            __psc_google_api_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardingRuleInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "matchedProtocol" => Ok(__FieldTag::__matched_protocol),
                            "matched_protocol" => Ok(__FieldTag::__matched_protocol),
                            "matchedPortRange" => Ok(__FieldTag::__matched_port_range),
                            "matched_port_range" => Ok(__FieldTag::__matched_port_range),
                            "vip" => Ok(__FieldTag::__vip),
                            "target" => Ok(__FieldTag::__target),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "region" => Ok(__FieldTag::__region),
                            "loadBalancerName" => Ok(__FieldTag::__load_balancer_name),
                            "load_balancer_name" => Ok(__FieldTag::__load_balancer_name),
                            "pscServiceAttachmentUri" => Ok(__FieldTag::__psc_service_attachment_uri),
                            "psc_service_attachment_uri" => Ok(__FieldTag::__psc_service_attachment_uri),
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForwardingRuleInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardingRuleInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__matched_protocol => {
                            if !fields.insert(__FieldTag::__matched_protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matched_protocol"));
                            }
                            result.matched_protocol = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__matched_port_range => {
                            if !fields.insert(__FieldTag::__matched_port_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matched_port_range"));
                            }
                            result.matched_port_range = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__vip => {
                            if !fields.insert(__FieldTag::__vip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vip"));
                            }
                            result.vip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target"));
                            }
                            result.target = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__load_balancer_name => {
                            if !fields.insert(__FieldTag::__load_balancer_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_balancer_name"));
                            }
                            result.load_balancer_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__psc_service_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for psc_service_attachment_uri"));
                            }
                            result.psc_service_attachment_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for psc_google_api_target"));
                            }
                            result.psc_google_api_target = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadBalancerInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __load_balancer_type,
            __health_check_uri,
            __backends,
            __backend_type,
            __backend_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            "healthCheckUri" => Ok(__FieldTag::__health_check_uri),
                            "health_check_uri" => Ok(__FieldTag::__health_check_uri),
                            "backends" => Ok(__FieldTag::__backends),
                            "backendType" => Ok(__FieldTag::__backend_type),
                            "backend_type" => Ok(__FieldTag::__backend_type),
                            "backendUri" => Ok(__FieldTag::__backend_uri),
                            "backend_uri" => Ok(__FieldTag::__backend_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadBalancerInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for load_balancer_type"));
                            }
                            result.load_balancer_type = map.next_value::<std::option::Option<crate::model::load_balancer_info::LoadBalancerType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__health_check_uri => {
                            if !fields.insert(__FieldTag::__health_check_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for health_check_uri"));
                            }
                            result.health_check_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__backends => {
                            if !fields.insert(__FieldTag::__backends) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for backends"));
                            }
                            result.backends = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LoadBalancerBackend>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__backend_type => {
                            if !fields.insert(__FieldTag::__backend_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for backend_type"));
                            }
                            result.backend_type = map.next_value::<std::option::Option<crate::model::load_balancer_info::BackendType>>()?.unwrap_or_default();
                        },
                        __FieldTag::__backend_uri => {
                            if !fields.insert(__FieldTag::__backend_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for backend_uri"));
                            }
                            result.backend_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadBalancerBackend {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __health_check_firewall_state,
            __health_check_allowing_firewall_rules,
            __health_check_blocking_firewall_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerBackend")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "healthCheckFirewallState" => Ok(__FieldTag::__health_check_firewall_state),
                            "health_check_firewall_state" => Ok(__FieldTag::__health_check_firewall_state),
                            "healthCheckAllowingFirewallRules" => Ok(__FieldTag::__health_check_allowing_firewall_rules),
                            "health_check_allowing_firewall_rules" => Ok(__FieldTag::__health_check_allowing_firewall_rules),
                            "healthCheckBlockingFirewallRules" => Ok(__FieldTag::__health_check_blocking_firewall_rules),
                            "health_check_blocking_firewall_rules" => Ok(__FieldTag::__health_check_blocking_firewall_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadBalancerBackend;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerBackend")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__health_check_firewall_state => {
                            if !fields.insert(__FieldTag::__health_check_firewall_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for health_check_firewall_state"));
                            }
                            result.health_check_firewall_state = map.next_value::<std::option::Option<crate::model::load_balancer_backend::HealthCheckFirewallState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__health_check_allowing_firewall_rules => {
                            if !fields.insert(__FieldTag::__health_check_allowing_firewall_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for health_check_allowing_firewall_rules"));
                            }
                            result.health_check_allowing_firewall_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__health_check_blocking_firewall_rules => {
                            if !fields.insert(__FieldTag::__health_check_blocking_firewall_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for health_check_blocking_firewall_rules"));
                            }
                            result.health_check_blocking_firewall_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HybridSubnetInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridSubnetInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HybridSubnetInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridSubnetInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpnGatewayInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __ip_address,
            __vpn_tunnel_uri,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnGatewayInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "vpnTunnelUri" => Ok(__FieldTag::__vpn_tunnel_uri),
                            "vpn_tunnel_uri" => Ok(__FieldTag::__vpn_tunnel_uri),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpnGatewayInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnGatewayInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ip_address"));
                            }
                            result.ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__vpn_tunnel_uri => {
                            if !fields.insert(__FieldTag::__vpn_tunnel_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpn_tunnel_uri"));
                            }
                            result.vpn_tunnel_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpnTunnelInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __source_gateway,
            __remote_gateway,
            __remote_gateway_ip,
            __source_gateway_ip,
            __network_uri,
            __region,
            __routing_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnTunnelInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "sourceGateway" => Ok(__FieldTag::__source_gateway),
                            "source_gateway" => Ok(__FieldTag::__source_gateway),
                            "remoteGateway" => Ok(__FieldTag::__remote_gateway),
                            "remote_gateway" => Ok(__FieldTag::__remote_gateway),
                            "remoteGatewayIp" => Ok(__FieldTag::__remote_gateway_ip),
                            "remote_gateway_ip" => Ok(__FieldTag::__remote_gateway_ip),
                            "sourceGatewayIp" => Ok(__FieldTag::__source_gateway_ip),
                            "source_gateway_ip" => Ok(__FieldTag::__source_gateway_ip),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "region" => Ok(__FieldTag::__region),
                            "routingType" => Ok(__FieldTag::__routing_type),
                            "routing_type" => Ok(__FieldTag::__routing_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpnTunnelInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnTunnelInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_gateway => {
                            if !fields.insert(__FieldTag::__source_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_gateway"));
                            }
                            result.source_gateway = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__remote_gateway => {
                            if !fields.insert(__FieldTag::__remote_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for remote_gateway"));
                            }
                            result.remote_gateway = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__remote_gateway_ip => {
                            if !fields.insert(__FieldTag::__remote_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for remote_gateway_ip"));
                            }
                            result.remote_gateway_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_gateway_ip => {
                            if !fields.insert(__FieldTag::__source_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_gateway_ip"));
                            }
                            result.source_gateway_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__routing_type => {
                            if !fields.insert(__FieldTag::__routing_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for routing_type"));
                            }
                            result.routing_type = map.next_value::<std::option::Option<crate::model::vpn_tunnel_info::RoutingType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InterconnectAttachmentInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __interconnect_uri,
            __region,
            __cloud_router_uri,
            __type,
            __l2_attachment_matched_ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InterconnectAttachmentInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "interconnectUri" => Ok(__FieldTag::__interconnect_uri),
                            "interconnect_uri" => Ok(__FieldTag::__interconnect_uri),
                            "region" => Ok(__FieldTag::__region),
                            "cloudRouterUri" => Ok(__FieldTag::__cloud_router_uri),
                            "cloud_router_uri" => Ok(__FieldTag::__cloud_router_uri),
                            "type" => Ok(__FieldTag::__type),
                            "l2AttachmentMatchedIpAddress" => Ok(__FieldTag::__l2_attachment_matched_ip_address),
                            "l2_attachment_matched_ip_address" => Ok(__FieldTag::__l2_attachment_matched_ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InterconnectAttachmentInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InterconnectAttachmentInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__interconnect_uri => {
                            if !fields.insert(__FieldTag::__interconnect_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for interconnect_uri"));
                            }
                            result.interconnect_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cloud_router_uri => {
                            if !fields.insert(__FieldTag::__cloud_router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cloud_router_uri"));
                            }
                            result.cloud_router_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::interconnect_attachment_info::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__l2_attachment_matched_ip_address => {
                            if !fields.insert(__FieldTag::__l2_attachment_matched_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for l2_attachment_matched_ip_address"));
                            }
                            result.l2_attachment_matched_ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EndpointInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_ip,
            __destination_ip,
            __protocol,
            __source_port,
            __destination_port,
            __source_network_uri,
            __destination_network_uri,
            __source_agent_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EndpointInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "sourcePort" => Ok(__FieldTag::__source_port),
                            "source_port" => Ok(__FieldTag::__source_port),
                            "destinationPort" => Ok(__FieldTag::__destination_port),
                            "destination_port" => Ok(__FieldTag::__destination_port),
                            "sourceNetworkUri" => Ok(__FieldTag::__source_network_uri),
                            "source_network_uri" => Ok(__FieldTag::__source_network_uri),
                            "destinationNetworkUri" => Ok(__FieldTag::__destination_network_uri),
                            "destination_network_uri" => Ok(__FieldTag::__destination_network_uri),
                            "sourceAgentUri" => Ok(__FieldTag::__source_agent_uri),
                            "source_agent_uri" => Ok(__FieldTag::__source_agent_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EndpointInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EndpointInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_ip"));
                            }
                            result.source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_ip"));
                            }
                            result.destination_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protocol"));
                            }
                            result.protocol = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_port => {
                            if !fields.insert(__FieldTag::__source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__destination_port => {
                            if !fields.insert(__FieldTag::__destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.destination_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__source_network_uri => {
                            if !fields.insert(__FieldTag::__source_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_network_uri"));
                            }
                            result.source_network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_network_uri => {
                            if !fields.insert(__FieldTag::__destination_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_network_uri"));
                            }
                            result.destination_network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_agent_uri => {
                            if !fields.insert(__FieldTag::__source_agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_agent_uri"));
                            }
                            result.source_agent_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeliverInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target,
            __resource_uri,
            __ip_address,
            __storage_bucket,
            __psc_google_api_target,
            __google_service_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeliverInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "target" => Ok(__FieldTag::__target),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "storageBucket" => Ok(__FieldTag::__storage_bucket),
                            "storage_bucket" => Ok(__FieldTag::__storage_bucket),
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            "googleServiceType" => Ok(__FieldTag::__google_service_type),
                            "google_service_type" => Ok(__FieldTag::__google_service_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeliverInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeliverInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target"));
                            }
                            result.target = map.next_value::<std::option::Option<crate::model::deliver_info::Target>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource_uri"));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ip_address"));
                            }
                            result.ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__storage_bucket => {
                            if !fields.insert(__FieldTag::__storage_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for storage_bucket"));
                            }
                            result.storage_bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for psc_google_api_target"));
                            }
                            result.psc_google_api_target = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__google_service_type => {
                            if !fields.insert(__FieldTag::__google_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for google_service_type"));
                            }
                            result.google_service_type = map.next_value::<std::option::Option<crate::model::deliver_info::GoogleServiceType>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForwardInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target,
            __resource_uri,
            __ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "target" => Ok(__FieldTag::__target),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForwardInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target"));
                            }
                            result.target = map.next_value::<std::option::Option<crate::model::forward_info::Target>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource_uri"));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ip_address"));
                            }
                            result.ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AbortInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cause,
            __resource_uri,
            __ip_address,
            __projects_missing_permission,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AbortInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cause" => Ok(__FieldTag::__cause),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "projectsMissingPermission" => Ok(__FieldTag::__projects_missing_permission),
                            "projects_missing_permission" => Ok(__FieldTag::__projects_missing_permission),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AbortInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AbortInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cause"));
                            }
                            result.cause = map.next_value::<std::option::Option<crate::model::abort_info::Cause>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource_uri"));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ip_address"));
                            }
                            result.ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__projects_missing_permission => {
                            if !fields.insert(__FieldTag::__projects_missing_permission) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for projects_missing_permission"));
                            }
                            result.projects_missing_permission = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DropInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cause,
            __resource_uri,
            __source_ip,
            __destination_ip,
            __region,
            __source_geolocation_code,
            __destination_geolocation_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DropInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cause" => Ok(__FieldTag::__cause),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "region" => Ok(__FieldTag::__region),
                            "sourceGeolocationCode" => Ok(__FieldTag::__source_geolocation_code),
                            "source_geolocation_code" => Ok(__FieldTag::__source_geolocation_code),
                            "destinationGeolocationCode" => Ok(__FieldTag::__destination_geolocation_code),
                            "destination_geolocation_code" => Ok(__FieldTag::__destination_geolocation_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DropInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DropInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cause"));
                            }
                            result.cause = map.next_value::<std::option::Option<crate::model::drop_info::Cause>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource_uri"));
                            }
                            result.resource_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_ip"));
                            }
                            result.source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_ip"));
                            }
                            result.destination_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_geolocation_code => {
                            if !fields.insert(__FieldTag::__source_geolocation_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_geolocation_code"));
                            }
                            result.source_geolocation_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_geolocation_code => {
                            if !fields.insert(__FieldTag::__destination_geolocation_code) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_geolocation_code"));
                            }
                            result.destination_geolocation_code = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GKEMasterInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_uri,
            __cluster_network_uri,
            __internal_ip,
            __external_ip,
            __dns_endpoint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GKEMasterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterUri" => Ok(__FieldTag::__cluster_uri),
                            "cluster_uri" => Ok(__FieldTag::__cluster_uri),
                            "clusterNetworkUri" => Ok(__FieldTag::__cluster_network_uri),
                            "cluster_network_uri" => Ok(__FieldTag::__cluster_network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "dnsEndpoint" => Ok(__FieldTag::__dns_endpoint),
                            "dns_endpoint" => Ok(__FieldTag::__dns_endpoint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GKEMasterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GKEMasterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_uri => {
                            if !fields.insert(__FieldTag::__cluster_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cluster_uri"));
                            }
                            result.cluster_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cluster_network_uri => {
                            if !fields.insert(__FieldTag::__cluster_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cluster_network_uri"));
                            }
                            result.cluster_network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for internal_ip"));
                            }
                            result.internal_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for external_ip"));
                            }
                            result.external_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__dns_endpoint => {
                            if !fields.insert(__FieldTag::__dns_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for dns_endpoint"));
                            }
                            result.dns_endpoint = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudSQLInstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __internal_ip,
            __external_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSQLInstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudSQLInstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSQLInstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for internal_ip"));
                            }
                            result.internal_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for external_ip"));
                            }
                            result.external_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RedisInstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __primary_endpoint_ip,
            __read_endpoint_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedisInstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "primaryEndpointIp" => Ok(__FieldTag::__primary_endpoint_ip),
                            "primary_endpoint_ip" => Ok(__FieldTag::__primary_endpoint_ip),
                            "readEndpointIp" => Ok(__FieldTag::__read_endpoint_ip),
                            "read_endpoint_ip" => Ok(__FieldTag::__read_endpoint_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RedisInstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedisInstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__primary_endpoint_ip => {
                            if !fields.insert(__FieldTag::__primary_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for primary_endpoint_ip"));
                            }
                            result.primary_endpoint_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__read_endpoint_ip => {
                            if !fields.insert(__FieldTag::__read_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_endpoint_ip"));
                            }
                            result.read_endpoint_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RedisClusterInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __discovery_endpoint_ip_address,
            __secondary_endpoint_ip_address,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedisClusterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "discoveryEndpointIpAddress" => Ok(__FieldTag::__discovery_endpoint_ip_address),
                            "discovery_endpoint_ip_address" => Ok(__FieldTag::__discovery_endpoint_ip_address),
                            "secondaryEndpointIpAddress" => Ok(__FieldTag::__secondary_endpoint_ip_address),
                            "secondary_endpoint_ip_address" => Ok(__FieldTag::__secondary_endpoint_ip_address),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RedisClusterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedisClusterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__discovery_endpoint_ip_address => {
                            if !fields.insert(__FieldTag::__discovery_endpoint_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for discovery_endpoint_ip_address"));
                            }
                            result.discovery_endpoint_ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__secondary_endpoint_ip_address => {
                            if !fields.insert(__FieldTag::__secondary_endpoint_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for secondary_endpoint_ip_address"));
                            }
                            result.secondary_endpoint_ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location"));
                            }
                            result.location = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudFunctionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            __version_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudFunctionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            "versionId" => Ok(__FieldTag::__version_id),
                            "version_id" => Ok(__FieldTag::__version_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudFunctionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudFunctionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location"));
                            }
                            result.location = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__version_id => {
                            if !fields.insert(__FieldTag::__version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for version_id"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudRunRevisionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            __service_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunRevisionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            "serviceUri" => Ok(__FieldTag::__service_uri),
                            "service_uri" => Ok(__FieldTag::__service_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudRunRevisionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunRevisionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location"));
                            }
                            result.location = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__service_uri => {
                            if !fields.insert(__FieldTag::__service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service_uri"));
                            }
                            result.service_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AppEngineVersionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __runtime,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineVersionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "runtime" => Ok(__FieldTag::__runtime),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AppEngineVersionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineVersionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__runtime => {
                            if !fields.insert(__FieldTag::__runtime) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for runtime"));
                            }
                            result.runtime = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for environment"));
                            }
                            result.environment = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpcConnectorInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcConnectorInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpcConnectorInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcConnectorInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uri"));
                            }
                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location"));
                            }
                            result.location = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DirectVpcEgressConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_uri,
            __subnetwork_uri,
            __selected_ip_range,
            __selected_ip_address,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DirectVpcEgressConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "subnetworkUri" => Ok(__FieldTag::__subnetwork_uri),
                            "subnetwork_uri" => Ok(__FieldTag::__subnetwork_uri),
                            "selectedIpRange" => Ok(__FieldTag::__selected_ip_range),
                            "selected_ip_range" => Ok(__FieldTag::__selected_ip_range),
                            "selectedIpAddress" => Ok(__FieldTag::__selected_ip_address),
                            "selected_ip_address" => Ok(__FieldTag::__selected_ip_address),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DirectVpcEgressConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DirectVpcEgressConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__subnetwork_uri => {
                            if !fields.insert(__FieldTag::__subnetwork_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subnetwork_uri"));
                            }
                            result.subnetwork_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__selected_ip_range => {
                            if !fields.insert(__FieldTag::__selected_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for selected_ip_range"));
                            }
                            result.selected_ip_range = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__selected_ip_address => {
                            if !fields.insert(__FieldTag::__selected_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for selected_ip_address"));
                            }
                            result.selected_ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for region"));
                            }
                            result.region = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ServerlessExternalConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __selected_ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerlessExternalConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "selectedIpAddress" => Ok(__FieldTag::__selected_ip_address),
                            "selected_ip_address" => Ok(__FieldTag::__selected_ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ServerlessExternalConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerlessExternalConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__selected_ip_address => {
                            if !fields.insert(__FieldTag::__selected_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for selected_ip_address"));
                            }
                            result.selected_ip_address = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NatInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __protocol,
            __network_uri,
            __old_source_ip,
            __new_source_ip,
            __old_destination_ip,
            __new_destination_ip,
            __old_source_port,
            __new_source_port,
            __old_destination_port,
            __new_destination_port,
            __router_uri,
            __nat_gateway_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NatInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "oldSourceIp" => Ok(__FieldTag::__old_source_ip),
                            "old_source_ip" => Ok(__FieldTag::__old_source_ip),
                            "newSourceIp" => Ok(__FieldTag::__new_source_ip),
                            "new_source_ip" => Ok(__FieldTag::__new_source_ip),
                            "oldDestinationIp" => Ok(__FieldTag::__old_destination_ip),
                            "old_destination_ip" => Ok(__FieldTag::__old_destination_ip),
                            "newDestinationIp" => Ok(__FieldTag::__new_destination_ip),
                            "new_destination_ip" => Ok(__FieldTag::__new_destination_ip),
                            "oldSourcePort" => Ok(__FieldTag::__old_source_port),
                            "old_source_port" => Ok(__FieldTag::__old_source_port),
                            "newSourcePort" => Ok(__FieldTag::__new_source_port),
                            "new_source_port" => Ok(__FieldTag::__new_source_port),
                            "oldDestinationPort" => Ok(__FieldTag::__old_destination_port),
                            "old_destination_port" => Ok(__FieldTag::__old_destination_port),
                            "newDestinationPort" => Ok(__FieldTag::__new_destination_port),
                            "new_destination_port" => Ok(__FieldTag::__new_destination_port),
                            "routerUri" => Ok(__FieldTag::__router_uri),
                            "router_uri" => Ok(__FieldTag::__router_uri),
                            "natGatewayName" => Ok(__FieldTag::__nat_gateway_name),
                            "nat_gateway_name" => Ok(__FieldTag::__nat_gateway_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NatInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NatInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::nat_info::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protocol"));
                            }
                            result.protocol = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__old_source_ip => {
                            if !fields.insert(__FieldTag::__old_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_source_ip"));
                            }
                            result.old_source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__new_source_ip => {
                            if !fields.insert(__FieldTag::__new_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_source_ip"));
                            }
                            result.new_source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__old_destination_ip => {
                            if !fields.insert(__FieldTag::__old_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_destination_ip"));
                            }
                            result.old_destination_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__new_destination_ip => {
                            if !fields.insert(__FieldTag::__new_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_destination_ip"));
                            }
                            result.new_destination_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__old_source_port => {
                            if !fields.insert(__FieldTag::__old_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_source_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_source_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__new_source_port => {
                            if !fields.insert(__FieldTag::__new_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_source_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_source_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__old_destination_port => {
                            if !fields.insert(__FieldTag::__old_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_destination_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_destination_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__new_destination_port => {
                            if !fields.insert(__FieldTag::__new_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_destination_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_destination_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__router_uri => {
                            if !fields.insert(__FieldTag::__router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for router_uri"));
                            }
                            result.router_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__nat_gateway_name => {
                            if !fields.insert(__FieldTag::__nat_gateway_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for nat_gateway_name"));
                            }
                            result.nat_gateway_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ProxyConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protocol,
            __old_source_ip,
            __new_source_ip,
            __old_destination_ip,
            __new_destination_ip,
            __old_source_port,
            __new_source_port,
            __old_destination_port,
            __new_destination_port,
            __subnet_uri,
            __network_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProxyConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protocol" => Ok(__FieldTag::__protocol),
                            "oldSourceIp" => Ok(__FieldTag::__old_source_ip),
                            "old_source_ip" => Ok(__FieldTag::__old_source_ip),
                            "newSourceIp" => Ok(__FieldTag::__new_source_ip),
                            "new_source_ip" => Ok(__FieldTag::__new_source_ip),
                            "oldDestinationIp" => Ok(__FieldTag::__old_destination_ip),
                            "old_destination_ip" => Ok(__FieldTag::__old_destination_ip),
                            "newDestinationIp" => Ok(__FieldTag::__new_destination_ip),
                            "new_destination_ip" => Ok(__FieldTag::__new_destination_ip),
                            "oldSourcePort" => Ok(__FieldTag::__old_source_port),
                            "old_source_port" => Ok(__FieldTag::__old_source_port),
                            "newSourcePort" => Ok(__FieldTag::__new_source_port),
                            "new_source_port" => Ok(__FieldTag::__new_source_port),
                            "oldDestinationPort" => Ok(__FieldTag::__old_destination_port),
                            "old_destination_port" => Ok(__FieldTag::__old_destination_port),
                            "newDestinationPort" => Ok(__FieldTag::__new_destination_port),
                            "new_destination_port" => Ok(__FieldTag::__new_destination_port),
                            "subnetUri" => Ok(__FieldTag::__subnet_uri),
                            "subnet_uri" => Ok(__FieldTag::__subnet_uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ProxyConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProxyConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protocol"));
                            }
                            result.protocol = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__old_source_ip => {
                            if !fields.insert(__FieldTag::__old_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_source_ip"));
                            }
                            result.old_source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__new_source_ip => {
                            if !fields.insert(__FieldTag::__new_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_source_ip"));
                            }
                            result.new_source_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__old_destination_ip => {
                            if !fields.insert(__FieldTag::__old_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_destination_ip"));
                            }
                            result.old_destination_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__new_destination_ip => {
                            if !fields.insert(__FieldTag::__new_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_destination_ip"));
                            }
                            result.new_destination_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__old_source_port => {
                            if !fields.insert(__FieldTag::__old_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_source_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_source_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__new_source_port => {
                            if !fields.insert(__FieldTag::__new_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_source_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_source_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__old_destination_port => {
                            if !fields.insert(__FieldTag::__old_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for old_destination_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_destination_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__new_destination_port => {
                            if !fields.insert(__FieldTag::__new_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for new_destination_port"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_destination_port = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__subnet_uri => {
                            if !fields.insert(__FieldTag::__subnet_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subnet_uri"));
                            }
                            result.subnet_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_uri"));
                            }
                            result.network_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadBalancerBackendInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance_uri,
            __backend_service_uri,
            __instance_group_uri,
            __network_endpoint_group_uri,
            __backend_bucket_uri,
            __psc_service_attachment_uri,
            __psc_google_api_target,
            __health_check_uri,
            __health_check_firewalls_config_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerBackendInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instanceUri" => Ok(__FieldTag::__instance_uri),
                            "instance_uri" => Ok(__FieldTag::__instance_uri),
                            "backendServiceUri" => Ok(__FieldTag::__backend_service_uri),
                            "backend_service_uri" => Ok(__FieldTag::__backend_service_uri),
                            "instanceGroupUri" => Ok(__FieldTag::__instance_group_uri),
                            "instance_group_uri" => Ok(__FieldTag::__instance_group_uri),
                            "networkEndpointGroupUri" => Ok(__FieldTag::__network_endpoint_group_uri),
                            "network_endpoint_group_uri" => Ok(__FieldTag::__network_endpoint_group_uri),
                            "backendBucketUri" => Ok(__FieldTag::__backend_bucket_uri),
                            "backend_bucket_uri" => Ok(__FieldTag::__backend_bucket_uri),
                            "pscServiceAttachmentUri" => Ok(__FieldTag::__psc_service_attachment_uri),
                            "psc_service_attachment_uri" => Ok(__FieldTag::__psc_service_attachment_uri),
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            "healthCheckUri" => Ok(__FieldTag::__health_check_uri),
                            "health_check_uri" => Ok(__FieldTag::__health_check_uri),
                            "healthCheckFirewallsConfigState" => Ok(__FieldTag::__health_check_firewalls_config_state),
                            "health_check_firewalls_config_state" => Ok(__FieldTag::__health_check_firewalls_config_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadBalancerBackendInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerBackendInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__instance_uri => {
                            if !fields.insert(__FieldTag::__instance_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instance_uri"));
                            }
                            result.instance_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__backend_service_uri => {
                            if !fields.insert(__FieldTag::__backend_service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for backend_service_uri"));
                            }
                            result.backend_service_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__instance_group_uri => {
                            if !fields.insert(__FieldTag::__instance_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for instance_group_uri"));
                            }
                            result.instance_group_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__network_endpoint_group_uri => {
                            if !fields.insert(__FieldTag::__network_endpoint_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network_endpoint_group_uri"));
                            }
                            result.network_endpoint_group_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__backend_bucket_uri => {
                            if !fields.insert(__FieldTag::__backend_bucket_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for backend_bucket_uri"));
                            }
                            result.backend_bucket_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__psc_service_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for psc_service_attachment_uri"));
                            }
                            result.psc_service_attachment_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for psc_google_api_target"));
                            }
                            result.psc_google_api_target = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__health_check_uri => {
                            if !fields.insert(__FieldTag::__health_check_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for health_check_uri"));
                            }
                            result.health_check_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__health_check_firewalls_config_state => {
                            if !fields.insert(__FieldTag::__health_check_firewalls_config_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for health_check_firewalls_config_state"));
                            }
                            result.health_check_firewalls_config_state = map.next_value::<std::option::Option<crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StorageBucketInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageBucketInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StorageBucketInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageBucketInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ServerlessNegInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __neg_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerlessNegInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "negUri" => Ok(__FieldTag::__neg_uri),
                            "neg_uri" => Ok(__FieldTag::__neg_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ServerlessNegInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerlessNegInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__neg_uri => {
                            if !fields.insert(__FieldTag::__neg_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for neg_uri"));
                            }
                            result.neg_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVpcFlowLogsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpcFlowLogsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVpcFlowLogsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpcFlowLogsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for order_by"));
                            }
                            result.order_by = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVpcFlowLogsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc_flow_logs_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpcFlowLogsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpcFlowLogsConfigs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "vpc_flow_logs_configs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVpcFlowLogsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpcFlowLogsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc_flow_logs_configs => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_flow_logs_configs"));
                            }
                            result.vpc_flow_logs_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VpcFlowLogsConfig>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for unreachable"));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __vpc_flow_logs_config_id,
            __vpc_flow_logs_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "vpcFlowLogsConfigId" => Ok(__FieldTag::__vpc_flow_logs_config_id),
                            "vpc_flow_logs_config_id" => Ok(__FieldTag::__vpc_flow_logs_config_id),
                            "vpcFlowLogsConfig" => Ok(__FieldTag::__vpc_flow_logs_config),
                            "vpc_flow_logs_config" => Ok(__FieldTag::__vpc_flow_logs_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__vpc_flow_logs_config_id => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_flow_logs_config_id"));
                            }
                            result.vpc_flow_logs_config_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__vpc_flow_logs_config => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_flow_logs_config"));
                            }
                            result.vpc_flow_logs_config = map.next_value::<std::option::Option<crate::model::VpcFlowLogsConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __vpc_flow_logs_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "vpcFlowLogsConfig" => Ok(__FieldTag::__vpc_flow_logs_config),
                            "vpc_flow_logs_config" => Ok(__FieldTag::__vpc_flow_logs_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__vpc_flow_logs_config => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_flow_logs_config"));
                            }
                            result.vpc_flow_logs_config = map.next_value::<std::option::Option<crate::model::VpcFlowLogsConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryOrgVpcFlowLogsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryOrgVpcFlowLogsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryOrgVpcFlowLogsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryOrgVpcFlowLogsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryOrgVpcFlowLogsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc_flow_logs_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryOrgVpcFlowLogsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpcFlowLogsConfigs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "vpc_flow_logs_configs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryOrgVpcFlowLogsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryOrgVpcFlowLogsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc_flow_logs_configs => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_flow_logs_configs"));
                            }
                            result.vpc_flow_logs_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VpcFlowLogsConfig>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for unreachable"));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShowEffectiveFlowLogsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __resource,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShowEffectiveFlowLogsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "resource" => Ok(__FieldTag::__resource),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShowEffectiveFlowLogsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShowEffectiveFlowLogsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource"));
                            }
                            result.resource = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShowEffectiveFlowLogsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __effective_flow_logs_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShowEffectiveFlowLogsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "effectiveFlowLogsConfigs" => Ok(__FieldTag::__effective_flow_logs_configs),
                            "effective_flow_logs_configs" => Ok(__FieldTag::__effective_flow_logs_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShowEffectiveFlowLogsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShowEffectiveFlowLogsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__effective_flow_logs_configs => {
                            if !fields.insert(__FieldTag::__effective_flow_logs_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effective_flow_logs_configs"));
                            }
                            result.effective_flow_logs_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EffectiveVpcFlowLogsConfig>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for unreachable"));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpcFlowLogsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __state,
            __aggregation_interval,
            __flow_sampling,
            __metadata,
            __metadata_fields,
            __filter_expr,
            __cross_project_metadata,
            __target_resource_state,
            __network,
            __subnet,
            __interconnect_attachment,
            __vpn_tunnel,
            __labels,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcFlowLogsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "aggregationInterval" => Ok(__FieldTag::__aggregation_interval),
                            "aggregation_interval" => Ok(__FieldTag::__aggregation_interval),
                            "flowSampling" => Ok(__FieldTag::__flow_sampling),
                            "flow_sampling" => Ok(__FieldTag::__flow_sampling),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "metadataFields" => Ok(__FieldTag::__metadata_fields),
                            "metadata_fields" => Ok(__FieldTag::__metadata_fields),
                            "filterExpr" => Ok(__FieldTag::__filter_expr),
                            "filter_expr" => Ok(__FieldTag::__filter_expr),
                            "crossProjectMetadata" => Ok(__FieldTag::__cross_project_metadata),
                            "cross_project_metadata" => Ok(__FieldTag::__cross_project_metadata),
                            "targetResourceState" => Ok(__FieldTag::__target_resource_state),
                            "target_resource_state" => Ok(__FieldTag::__target_resource_state),
                            "network" => Ok(__FieldTag::__network),
                            "subnet" => Ok(__FieldTag::__subnet),
                            "interconnectAttachment" => Ok(__FieldTag::__interconnect_attachment),
                            "interconnect_attachment" => Ok(__FieldTag::__interconnect_attachment),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpcFlowLogsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcFlowLogsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for description"));
                            }
                            result.description = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::State>>()?
                                ;
                        },
                        __FieldTag::__aggregation_interval => {
                            if !fields.insert(__FieldTag::__aggregation_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for aggregation_interval"));
                            }
                            result.aggregation_interval = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::AggregationInterval>>()?
                                ;
                        },
                        __FieldTag::__flow_sampling => {
                            if !fields.insert(__FieldTag::__flow_sampling) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for flow_sampling"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.flow_sampling = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::Metadata>>()?
                                ;
                        },
                        __FieldTag::__metadata_fields => {
                            if !fields.insert(__FieldTag::__metadata_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata_fields"));
                            }
                            result.metadata_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter_expr => {
                            if !fields.insert(__FieldTag::__filter_expr) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_expr"));
                            }
                            result.filter_expr = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__cross_project_metadata => {
                            if !fields.insert(__FieldTag::__cross_project_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cross_project_metadata"));
                            }
                            result.cross_project_metadata = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::CrossProjectMetadata>>()?
                                ;
                        },
                        __FieldTag::__target_resource_state => {
                            if !fields.insert(__FieldTag::__target_resource_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for target_resource_state"));
                            }
                            result.target_resource_state = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::TargetResourceState>>()?
                                ;
                        },
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.network, latest field was network",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::Network(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__subnet => {
                            if !fields.insert(__FieldTag::__subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subnet"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.subnet, latest field was subnet",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::Subnet(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__interconnect_attachment => {
                            if !fields.insert(__FieldTag::__interconnect_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for interconnect_attachment"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.interconnect_attachment, latest field was interconnectAttachment",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpn_tunnel"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for labels"));
                            }
                            result.labels = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EffectiveVpcFlowLogsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __aggregation_interval,
            __flow_sampling,
            __metadata,
            __metadata_fields,
            __filter_expr,
            __cross_project_metadata,
            __network,
            __subnet,
            __interconnect_attachment,
            __vpn_tunnel,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EffectiveVpcFlowLogsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "aggregationInterval" => Ok(__FieldTag::__aggregation_interval),
                            "aggregation_interval" => Ok(__FieldTag::__aggregation_interval),
                            "flowSampling" => Ok(__FieldTag::__flow_sampling),
                            "flow_sampling" => Ok(__FieldTag::__flow_sampling),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "metadataFields" => Ok(__FieldTag::__metadata_fields),
                            "metadata_fields" => Ok(__FieldTag::__metadata_fields),
                            "filterExpr" => Ok(__FieldTag::__filter_expr),
                            "filter_expr" => Ok(__FieldTag::__filter_expr),
                            "crossProjectMetadata" => Ok(__FieldTag::__cross_project_metadata),
                            "cross_project_metadata" => Ok(__FieldTag::__cross_project_metadata),
                            "network" => Ok(__FieldTag::__network),
                            "subnet" => Ok(__FieldTag::__subnet),
                            "interconnectAttachment" => Ok(__FieldTag::__interconnect_attachment),
                            "interconnect_attachment" => Ok(__FieldTag::__interconnect_attachment),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EffectiveVpcFlowLogsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EffectiveVpcFlowLogsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::State>>()?
                                ;
                        },
                        __FieldTag::__aggregation_interval => {
                            if !fields.insert(__FieldTag::__aggregation_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for aggregation_interval"));
                            }
                            result.aggregation_interval = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::AggregationInterval>>()?
                                ;
                        },
                        __FieldTag::__flow_sampling => {
                            if !fields.insert(__FieldTag::__flow_sampling) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for flow_sampling"));
                            }
                            struct __With( std::option::Option<f32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.flow_sampling = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::Metadata>>()?
                                ;
                        },
                        __FieldTag::__metadata_fields => {
                            if !fields.insert(__FieldTag::__metadata_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata_fields"));
                            }
                            result.metadata_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter_expr => {
                            if !fields.insert(__FieldTag::__filter_expr) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter_expr"));
                            }
                            result.filter_expr = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__cross_project_metadata => {
                            if !fields.insert(__FieldTag::__cross_project_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cross_project_metadata"));
                            }
                            result.cross_project_metadata = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::CrossProjectMetadata>>()?
                                ;
                        },
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.EffectiveVpcFlowLogsConfig.network, latest field was network",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::effective_vpc_flow_logs_config::TargetResource::Network(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__subnet => {
                            if !fields.insert(__FieldTag::__subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for subnet"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.EffectiveVpcFlowLogsConfig.subnet, latest field was subnet",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::effective_vpc_flow_logs_config::TargetResource::Subnet(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__interconnect_attachment => {
                            if !fields.insert(__FieldTag::__interconnect_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for interconnect_attachment"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.EffectiveVpcFlowLogsConfig.interconnect_attachment, latest field was interconnectAttachment",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::effective_vpc_flow_logs_config::TargetResource::InterconnectAttachment(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpn_tunnel"));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.EffectiveVpcFlowLogsConfig.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::effective_vpc_flow_logs_config::TargetResource::VpnTunnel(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for scope"));
                            }
                            result.scope = map.next_value::<std::option::Option<crate::model::effective_vpc_flow_logs_config::Scope>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
