// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConnectivityTest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __source,
            __destination,
            __protocol,
            __related_projects,
            __display_name,
            __labels,
            __create_time,
            __update_time,
            __reachability_details,
            __probing_details,
            __round_trip,
            __return_reachability_details,
            __bypass_firewall_checks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectivityTest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "source" => Ok(__FieldTag::__source),
                            "destination" => Ok(__FieldTag::__destination),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "relatedProjects" => Ok(__FieldTag::__related_projects),
                            "related_projects" => Ok(__FieldTag::__related_projects),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "reachabilityDetails" => Ok(__FieldTag::__reachability_details),
                            "reachability_details" => Ok(__FieldTag::__reachability_details),
                            "probingDetails" => Ok(__FieldTag::__probing_details),
                            "probing_details" => Ok(__FieldTag::__probing_details),
                            "roundTrip" => Ok(__FieldTag::__round_trip),
                            "round_trip" => Ok(__FieldTag::__round_trip),
                            "returnReachabilityDetails" => {
                                Ok(__FieldTag::__return_reachability_details)
                            }
                            "return_reachability_details" => {
                                Ok(__FieldTag::__return_reachability_details)
                            }
                            "bypassFirewallChecks" => Ok(__FieldTag::__bypass_firewall_checks),
                            "bypass_firewall_checks" => Ok(__FieldTag::__bypass_firewall_checks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConnectivityTest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectivityTest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Endpoint>>()?;
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination =
                                map.next_value::<std::option::Option<crate::model::Endpoint>>()?;
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_projects => {
                            if !fields.insert(__FieldTag::__related_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_projects",
                                ));
                            }
                            result.related_projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__reachability_details => {
                            if !fields.insert(__FieldTag::__reachability_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reachability_details",
                                ));
                            }
                            result.reachability_details = map.next_value::<std::option::Option<crate::model::ReachabilityDetails>>()?
                                ;
                        }
                        __FieldTag::__probing_details => {
                            if !fields.insert(__FieldTag::__probing_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for probing_details",
                                ));
                            }
                            result.probing_details = map
                                .next_value::<std::option::Option<crate::model::ProbingDetails>>(
                                )?;
                        }
                        __FieldTag::__round_trip => {
                            if !fields.insert(__FieldTag::__round_trip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for round_trip",
                                ));
                            }
                            result.round_trip = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_reachability_details => {
                            if !fields.insert(__FieldTag::__return_reachability_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_reachability_details",
                                ));
                            }
                            result.return_reachability_details = map.next_value::<std::option::Option<crate::model::ReachabilityDetails>>()?
                                ;
                        }
                        __FieldTag::__bypass_firewall_checks => {
                            if !fields.insert(__FieldTag::__bypass_firewall_checks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bypass_firewall_checks",
                                ));
                            }
                            result.bypass_firewall_checks = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Endpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_address,
            __port,
            __instance,
            __forwarding_rule,
            __forwarding_rule_target,
            __load_balancer_id,
            __load_balancer_type,
            __gke_master_cluster,
            __fqdn,
            __cloud_sql_instance,
            __redis_instance,
            __redis_cluster,
            __cloud_function,
            __app_engine_version,
            __cloud_run_revision,
            __network,
            __network_type,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Endpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "port" => Ok(__FieldTag::__port),
                            "instance" => Ok(__FieldTag::__instance),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "forwardingRuleTarget" => Ok(__FieldTag::__forwarding_rule_target),
                            "forwarding_rule_target" => Ok(__FieldTag::__forwarding_rule_target),
                            "loadBalancerId" => Ok(__FieldTag::__load_balancer_id),
                            "load_balancer_id" => Ok(__FieldTag::__load_balancer_id),
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            "gkeMasterCluster" => Ok(__FieldTag::__gke_master_cluster),
                            "gke_master_cluster" => Ok(__FieldTag::__gke_master_cluster),
                            "fqdn" => Ok(__FieldTag::__fqdn),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "redisInstance" => Ok(__FieldTag::__redis_instance),
                            "redis_instance" => Ok(__FieldTag::__redis_instance),
                            "redisCluster" => Ok(__FieldTag::__redis_cluster),
                            "redis_cluster" => Ok(__FieldTag::__redis_cluster),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "appEngineVersion" => Ok(__FieldTag::__app_engine_version),
                            "app_engine_version" => Ok(__FieldTag::__app_engine_version),
                            "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                            "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                            "network" => Ok(__FieldTag::__network),
                            "networkType" => Ok(__FieldTag::__network_type),
                            "network_type" => Ok(__FieldTag::__network_type),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Endpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Endpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule",
                                ));
                            }
                            result.forwarding_rule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__forwarding_rule_target => {
                            if !fields.insert(__FieldTag::__forwarding_rule_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule_target",
                                ));
                            }
                            result.forwarding_rule_target =
                                map.next_value::<std::option::Option<
                                    crate::model::endpoint::ForwardingRuleTarget,
                                >>()?;
                        }
                        __FieldTag::__load_balancer_id => {
                            if !fields.insert(__FieldTag::__load_balancer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_id",
                                ));
                            }
                            result.load_balancer_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map
                                .next_value::<std::option::Option<crate::model::LoadBalancerType>>(
                                )?;
                        }
                        __FieldTag::__gke_master_cluster => {
                            if !fields.insert(__FieldTag::__gke_master_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_master_cluster",
                                ));
                            }
                            result.gke_master_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fqdn => {
                            if !fields.insert(__FieldTag::__fqdn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fqdn",
                                ));
                            }
                            result.fqdn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_instance",
                                ));
                            }
                            result.cloud_sql_instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redis_instance => {
                            if !fields.insert(__FieldTag::__redis_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_instance",
                                ));
                            }
                            result.redis_instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redis_cluster => {
                            if !fields.insert(__FieldTag::__redis_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_cluster",
                                ));
                            }
                            result.redis_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_function",
                                ));
                            }
                            result.cloud_function = map.next_value::<std::option::Option<
                                crate::model::endpoint::CloudFunctionEndpoint,
                            >>()?;
                        }
                        __FieldTag::__app_engine_version => {
                            if !fields.insert(__FieldTag::__app_engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_version",
                                ));
                            }
                            result.app_engine_version = map.next_value::<std::option::Option<
                                crate::model::endpoint::AppEngineVersionEndpoint,
                            >>()?;
                        }
                        __FieldTag::__cloud_run_revision => {
                            if !fields.insert(__FieldTag::__cloud_run_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run_revision",
                                ));
                            }
                            result.cloud_run_revision = map.next_value::<std::option::Option<
                                crate::model::endpoint::CloudRunRevisionEndpoint,
                            >>()?;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_type => {
                            if !fields.insert(__FieldTag::__network_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_type",
                                ));
                            }
                            result.network_type = map.next_value::<std::option::Option<crate::model::endpoint::NetworkType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::endpoint::CloudFunctionEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudFunctionEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::endpoint::CloudFunctionEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudFunctionEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::endpoint::AppEngineVersionEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineVersionEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::endpoint::AppEngineVersionEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineVersionEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::endpoint::CloudRunRevisionEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __service_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunRevisionEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "serviceUri" => Ok(__FieldTag::__service_uri),
                            "service_uri" => Ok(__FieldTag::__service_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::endpoint::CloudRunRevisionEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunRevisionEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_uri => {
                            if !fields.insert(__FieldTag::__service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_uri",
                                ));
                            }
                            result.service_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReachabilityDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __verify_time,
            __error,
            __traces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReachabilityDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "verifyTime" => Ok(__FieldTag::__verify_time),
                            "verify_time" => Ok(__FieldTag::__verify_time),
                            "error" => Ok(__FieldTag::__error),
                            "traces" => Ok(__FieldTag::__traces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReachabilityDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReachabilityDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::reachability_details::Result>>()?.unwrap_or_default();
                        }
                        __FieldTag::__verify_time => {
                            if !fields.insert(__FieldTag::__verify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_time",
                                ));
                            }
                            result.verify_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__traces => {
                            if !fields.insert(__FieldTag::__traces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traces",
                                ));
                            }
                            result.traces = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Trace>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LatencyPercentile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __percent,
            __latency_micros,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatencyPercentile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "percent" => Ok(__FieldTag::__percent),
                            "latencyMicros" => Ok(__FieldTag::__latency_micros),
                            "latency_micros" => Ok(__FieldTag::__latency_micros),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LatencyPercentile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatencyPercentile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__latency_micros => {
                            if !fields.insert(__FieldTag::__latency_micros) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latency_micros",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.latency_micros =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LatencyDistribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __latency_percentiles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatencyDistribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latencyPercentiles" => Ok(__FieldTag::__latency_percentiles),
                            "latency_percentiles" => Ok(__FieldTag::__latency_percentiles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LatencyDistribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatencyDistribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__latency_percentiles => {
                            if !fields.insert(__FieldTag::__latency_percentiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latency_percentiles",
                                ));
                            }
                            result.latency_percentiles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LatencyPercentile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ProbingDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __verify_time,
            __error,
            __abort_cause,
            __sent_probe_count,
            __successful_probe_count,
            __endpoint_info,
            __probing_latency,
            __destination_egress_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProbingDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "verifyTime" => Ok(__FieldTag::__verify_time),
                            "verify_time" => Ok(__FieldTag::__verify_time),
                            "error" => Ok(__FieldTag::__error),
                            "abortCause" => Ok(__FieldTag::__abort_cause),
                            "abort_cause" => Ok(__FieldTag::__abort_cause),
                            "sentProbeCount" => Ok(__FieldTag::__sent_probe_count),
                            "sent_probe_count" => Ok(__FieldTag::__sent_probe_count),
                            "successfulProbeCount" => Ok(__FieldTag::__successful_probe_count),
                            "successful_probe_count" => Ok(__FieldTag::__successful_probe_count),
                            "endpointInfo" => Ok(__FieldTag::__endpoint_info),
                            "endpoint_info" => Ok(__FieldTag::__endpoint_info),
                            "probingLatency" => Ok(__FieldTag::__probing_latency),
                            "probing_latency" => Ok(__FieldTag::__probing_latency),
                            "destinationEgressLocation" => {
                                Ok(__FieldTag::__destination_egress_location)
                            }
                            "destination_egress_location" => {
                                Ok(__FieldTag::__destination_egress_location)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ProbingDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProbingDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result =
                                map.next_value::<std::option::Option<
                                    crate::model::probing_details::ProbingResult,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verify_time => {
                            if !fields.insert(__FieldTag::__verify_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_time",
                                ));
                            }
                            result.verify_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__abort_cause => {
                            if !fields.insert(__FieldTag::__abort_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abort_cause",
                                ));
                            }
                            result.abort_cause = map
                                .next_value::<std::option::Option<
                                    crate::model::probing_details::ProbingAbortCause,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sent_probe_count => {
                            if !fields.insert(__FieldTag::__sent_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sent_probe_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sent_probe_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__successful_probe_count => {
                            if !fields.insert(__FieldTag::__successful_probe_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for successful_probe_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.successful_probe_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__endpoint_info => {
                            if !fields.insert(__FieldTag::__endpoint_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_info",
                                ));
                            }
                            result.endpoint_info = map
                                .next_value::<std::option::Option<crate::model::EndpointInfo>>()?;
                        }
                        __FieldTag::__probing_latency => {
                            if !fields.insert(__FieldTag::__probing_latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for probing_latency",
                                ));
                            }
                            result.probing_latency = map.next_value::<std::option::Option<crate::model::LatencyDistribution>>()?
                                ;
                        }
                        __FieldTag::__destination_egress_location => {
                            if !fields.insert(__FieldTag::__destination_egress_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_egress_location",
                                ));
                            }
                            result.destination_egress_location =
                                map.next_value::<std::option::Option<
                                    crate::model::probing_details::EdgeLocation,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::probing_details::EdgeLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metropolitan_area,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EdgeLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metropolitanArea" => Ok(__FieldTag::__metropolitan_area),
                            "metropolitan_area" => Ok(__FieldTag::__metropolitan_area),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::probing_details::EdgeLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EdgeLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metropolitan_area => {
                            if !fields.insert(__FieldTag::__metropolitan_area) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metropolitan_area",
                                ));
                            }
                            result.metropolitan_area = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConnectivityTestsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectivityTestsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConnectivityTestsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectivityTestsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListConnectivityTestsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectivityTestsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resources" => Ok(__FieldTag::__resources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListConnectivityTestsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectivityTestsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectivityTest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __test_id,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "testId" => Ok(__FieldTag::__test_id),
                            "test_id" => Ok(__FieldTag::__test_id),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_id => {
                            if !fields.insert(__FieldTag::__test_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_id",
                                ));
                            }
                            result.test_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<crate::model::ConnectivityTest>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<crate::model::ConnectivityTest>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RerunConnectivityTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RerunConnectivityTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RerunConnectivityTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RerunConnectivityTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_detail,
            __cancel_requested,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusDetail" => Ok(__FieldTag::__status_detail),
                            "status_detail" => Ok(__FieldTag::__status_detail),
                            "cancelRequested" => Ok(__FieldTag::__cancel_requested),
                            "cancel_requested" => Ok(__FieldTag::__cancel_requested),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_detail => {
                            if !fields.insert(__FieldTag::__status_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_detail",
                                ));
                            }
                            result.status_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cancel_requested => {
                            if !fields.insert(__FieldTag::__cancel_requested) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancel_requested",
                                ));
                            }
                            result.cancel_requested = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Trace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint_info,
            __steps,
            __forward_trace_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Trace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpointInfo" => Ok(__FieldTag::__endpoint_info),
                            "endpoint_info" => Ok(__FieldTag::__endpoint_info),
                            "steps" => Ok(__FieldTag::__steps),
                            "forwardTraceId" => Ok(__FieldTag::__forward_trace_id),
                            "forward_trace_id" => Ok(__FieldTag::__forward_trace_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Trace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Trace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint_info => {
                            if !fields.insert(__FieldTag::__endpoint_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_info",
                                ));
                            }
                            result.endpoint_info = map
                                .next_value::<std::option::Option<crate::model::EndpointInfo>>()?;
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Step>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__forward_trace_id => {
                            if !fields.insert(__FieldTag::__forward_trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forward_trace_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.forward_trace_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Step {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __state,
            __causes_drop,
            __project_id,
            __instance,
            __firewall,
            __route,
            __endpoint,
            __google_service,
            __forwarding_rule,
            __vpn_gateway,
            __vpn_tunnel,
            __vpc_connector,
            __direct_vpc_egress_connection,
            __serverless_external_connection,
            __deliver,
            __forward,
            __abort,
            __drop,
            __load_balancer,
            __network,
            __gke_master,
            __cloud_sql_instance,
            __redis_instance,
            __redis_cluster,
            __cloud_function,
            __app_engine_version,
            __cloud_run_revision,
            __nat,
            __proxy_connection,
            __load_balancer_backend_info,
            __storage_bucket,
            __serverless_neg,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Step")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "causesDrop" => Ok(__FieldTag::__causes_drop),
                            "causes_drop" => Ok(__FieldTag::__causes_drop),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "firewall" => Ok(__FieldTag::__firewall),
                            "route" => Ok(__FieldTag::__route),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "googleService" => Ok(__FieldTag::__google_service),
                            "google_service" => Ok(__FieldTag::__google_service),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "vpnGateway" => Ok(__FieldTag::__vpn_gateway),
                            "vpn_gateway" => Ok(__FieldTag::__vpn_gateway),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpcConnector" => Ok(__FieldTag::__vpc_connector),
                            "vpc_connector" => Ok(__FieldTag::__vpc_connector),
                            "directVpcEgressConnection" => {
                                Ok(__FieldTag::__direct_vpc_egress_connection)
                            }
                            "direct_vpc_egress_connection" => {
                                Ok(__FieldTag::__direct_vpc_egress_connection)
                            }
                            "serverlessExternalConnection" => {
                                Ok(__FieldTag::__serverless_external_connection)
                            }
                            "serverless_external_connection" => {
                                Ok(__FieldTag::__serverless_external_connection)
                            }
                            "deliver" => Ok(__FieldTag::__deliver),
                            "forward" => Ok(__FieldTag::__forward),
                            "abort" => Ok(__FieldTag::__abort),
                            "drop" => Ok(__FieldTag::__drop),
                            "loadBalancer" => Ok(__FieldTag::__load_balancer),
                            "load_balancer" => Ok(__FieldTag::__load_balancer),
                            "network" => Ok(__FieldTag::__network),
                            "gkeMaster" => Ok(__FieldTag::__gke_master),
                            "gke_master" => Ok(__FieldTag::__gke_master),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "redisInstance" => Ok(__FieldTag::__redis_instance),
                            "redis_instance" => Ok(__FieldTag::__redis_instance),
                            "redisCluster" => Ok(__FieldTag::__redis_cluster),
                            "redis_cluster" => Ok(__FieldTag::__redis_cluster),
                            "cloudFunction" => Ok(__FieldTag::__cloud_function),
                            "cloud_function" => Ok(__FieldTag::__cloud_function),
                            "appEngineVersion" => Ok(__FieldTag::__app_engine_version),
                            "app_engine_version" => Ok(__FieldTag::__app_engine_version),
                            "cloudRunRevision" => Ok(__FieldTag::__cloud_run_revision),
                            "cloud_run_revision" => Ok(__FieldTag::__cloud_run_revision),
                            "nat" => Ok(__FieldTag::__nat),
                            "proxyConnection" => Ok(__FieldTag::__proxy_connection),
                            "proxy_connection" => Ok(__FieldTag::__proxy_connection),
                            "loadBalancerBackendInfo" => {
                                Ok(__FieldTag::__load_balancer_backend_info)
                            }
                            "load_balancer_backend_info" => {
                                Ok(__FieldTag::__load_balancer_backend_info)
                            }
                            "storageBucket" => Ok(__FieldTag::__storage_bucket),
                            "storage_bucket" => Ok(__FieldTag::__storage_bucket),
                            "serverlessNeg" => Ok(__FieldTag::__serverless_neg),
                            "serverless_neg" => Ok(__FieldTag::__serverless_neg),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Step;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Step")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::step::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__causes_drop => {
                            if !fields.insert(__FieldTag::__causes_drop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for causes_drop",
                                ));
                            }
                            result.causes_drop = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.instance, latest field was instance",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Instance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstanceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__firewall => {
                            if !fields.insert(__FieldTag::__firewall) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.firewall, latest field was firewall",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Firewall(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FirewallInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__route => {
                            if !fields.insert(__FieldTag::__route) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.route, latest field was route",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Route(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RouteInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.endpoint, latest field was endpoint",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Endpoint(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EndpointInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__google_service => {
                            if !fields.insert(__FieldTag::__google_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_service",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.google_service, latest field was googleService",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::GoogleService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GoogleServiceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.forwarding_rule, latest field was forwardingRule",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ForwardingRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ForwardingRuleInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vpn_gateway => {
                            if !fields.insert(__FieldTag::__vpn_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_gateway",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpn_gateway, latest field was vpnGateway",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpnGateway(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpnGatewayInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_tunnel",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::VpnTunnel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpnTunnelInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__vpc_connector => {
                            if !fields.insert(__FieldTag::__vpc_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_connector",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.vpc_connector, latest field was vpcConnector",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::VpcConnector(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpcConnectorInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__direct_vpc_egress_connection => {
                            if !fields.insert(__FieldTag::__direct_vpc_egress_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direct_vpc_egress_connection",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.direct_vpc_egress_connection, latest field was directVpcEgressConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::DirectVpcEgressConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::DirectVpcEgressConnectionInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__serverless_external_connection => {
                            if !fields.insert(__FieldTag::__serverless_external_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serverless_external_connection",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.serverless_external_connection, latest field was serverlessExternalConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ServerlessExternalConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::ServerlessExternalConnectionInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__deliver => {
                            if !fields.insert(__FieldTag::__deliver) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deliver",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.deliver, latest field was deliver",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Deliver(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeliverInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__forward => {
                            if !fields.insert(__FieldTag::__forward) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forward",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.forward, latest field was forward",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Forward(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ForwardInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__abort => {
                            if !fields.insert(__FieldTag::__abort) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abort",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.abort, latest field was abort",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Abort(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AbortInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__drop => {
                            if !fields.insert(__FieldTag::__drop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for drop",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.drop, latest field was drop",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Drop(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DropInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__load_balancer => {
                            if !fields.insert(__FieldTag::__load_balancer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.load_balancer, latest field was loadBalancer",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::LoadBalancer(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LoadBalancerInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.network, latest field was network",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::Network(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::NetworkInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__gke_master => {
                            if !fields.insert(__FieldTag::__gke_master) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_master",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.gke_master, latest field was gkeMaster",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(crate::model::step::StepInfo::GkeMaster(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GKEMasterInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_instance",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_sql_instance, latest field was cloudSqlInstance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudSqlInstance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSQLInstanceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__redis_instance => {
                            if !fields.insert(__FieldTag::__redis_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_instance",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.redis_instance, latest field was redisInstance",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::RedisInstance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RedisInstanceInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__redis_cluster => {
                            if !fields.insert(__FieldTag::__redis_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_cluster",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.redis_cluster, latest field was redisCluster",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::RedisCluster(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RedisClusterInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_function => {
                            if !fields.insert(__FieldTag::__cloud_function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_function",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_function, latest field was cloudFunction",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudFunction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudFunctionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__app_engine_version => {
                            if !fields.insert(__FieldTag::__app_engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_version",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.app_engine_version, latest field was appEngineVersion",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::AppEngineVersion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AppEngineVersionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_run_revision => {
                            if !fields.insert(__FieldTag::__cloud_run_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run_revision",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.cloud_run_revision, latest field was cloudRunRevision",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::CloudRunRevision(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRunRevisionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__nat => {
                            if !fields.insert(__FieldTag::__nat) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nat",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.nat, latest field was nat",
                                ));
                            }
                            result.step_info =
                                std::option::Option::Some(
                                    crate::model::step::StepInfo::Nat(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::NatInfo>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__proxy_connection => {
                            if !fields.insert(__FieldTag::__proxy_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_connection",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.proxy_connection, latest field was proxyConnection",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ProxyConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProxyConnectionInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__load_balancer_backend_info => {
                            if !fields.insert(__FieldTag::__load_balancer_backend_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_backend_info",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.load_balancer_backend_info, latest field was loadBalancerBackendInfo",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::LoadBalancerBackendInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LoadBalancerBackendInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__storage_bucket => {
                            if !fields.insert(__FieldTag::__storage_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_bucket",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.storage_bucket, latest field was storageBucket",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::StorageBucket(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageBucketInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__serverless_neg => {
                            if !fields.insert(__FieldTag::__serverless_neg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serverless_neg",
                                ));
                            }
                            if result.step_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step_info`, a oneof with full ID .google.cloud.networkmanagement.v1.Step.serverless_neg, latest field was serverlessNeg",
                                ));
                            }
                            result.step_info = std::option::Option::Some(
                                crate::model::step::StepInfo::ServerlessNeg(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ServerlessNegInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __interface,
            __network_uri,
            __internal_ip,
            __external_ip,
            __network_tags,
            __service_account,
            __psc_network_attachment_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "interface" => Ok(__FieldTag::__interface),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "pscNetworkAttachmentUri" => {
                                Ok(__FieldTag::__psc_network_attachment_uri)
                            }
                            "psc_network_attachment_uri" => {
                                Ok(__FieldTag::__psc_network_attachment_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interface => {
                            if !fields.insert(__FieldTag::__interface) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interface",
                                ));
                            }
                            result.interface = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_network_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_network_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_network_attachment_uri",
                                ));
                            }
                            result.psc_network_attachment_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NetworkInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __matched_subnet_uri,
            __matched_ip_range,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "matchedSubnetUri" => Ok(__FieldTag::__matched_subnet_uri),
                            "matched_subnet_uri" => Ok(__FieldTag::__matched_subnet_uri),
                            "matchedIpRange" => Ok(__FieldTag::__matched_ip_range),
                            "matched_ip_range" => Ok(__FieldTag::__matched_ip_range),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NetworkInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_subnet_uri => {
                            if !fields.insert(__FieldTag::__matched_subnet_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_subnet_uri",
                                ));
                            }
                            result.matched_subnet_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_ip_range => {
                            if !fields.insert(__FieldTag::__matched_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_ip_range",
                                ));
                            }
                            result.matched_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FirewallInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __direction,
            __action,
            __priority,
            __network_uri,
            __target_tags,
            __target_service_accounts,
            __policy,
            __policy_uri,
            __firewall_rule_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "direction" => Ok(__FieldTag::__direction),
                            "action" => Ok(__FieldTag::__action),
                            "priority" => Ok(__FieldTag::__priority),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "targetTags" => Ok(__FieldTag::__target_tags),
                            "target_tags" => Ok(__FieldTag::__target_tags),
                            "targetServiceAccounts" => Ok(__FieldTag::__target_service_accounts),
                            "target_service_accounts" => Ok(__FieldTag::__target_service_accounts),
                            "policy" => Ok(__FieldTag::__policy),
                            "policyUri" => Ok(__FieldTag::__policy_uri),
                            "policy_uri" => Ok(__FieldTag::__policy_uri),
                            "firewallRuleType" => Ok(__FieldTag::__firewall_rule_type),
                            "firewall_rule_type" => Ok(__FieldTag::__firewall_rule_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FirewallInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_tags => {
                            if !fields.insert(__FieldTag::__target_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_tags",
                                ));
                            }
                            result.target_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__target_service_accounts => {
                            if !fields.insert(__FieldTag::__target_service_accounts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_service_accounts",
                                ));
                            }
                            result.target_service_accounts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_uri => {
                            if !fields.insert(__FieldTag::__policy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_uri",
                                ));
                            }
                            result.policy_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__firewall_rule_type => {
                            if !fields.insert(__FieldTag::__firewall_rule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_rule_type",
                                ));
                            }
                            result.firewall_rule_type =
                                map.next_value::<std::option::Option<
                                    crate::model::firewall_info::FirewallRuleType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RouteInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __route_type,
            __next_hop_type,
            __route_scope,
            __display_name,
            __uri,
            __region,
            __dest_ip_range,
            __next_hop,
            __network_uri,
            __priority,
            __instance_tags,
            __src_ip_range,
            __dest_port_ranges,
            __src_port_ranges,
            __protocols,
            __ncc_hub_uri,
            __ncc_spoke_uri,
            __advertised_route_source_router_uri,
            __advertised_route_next_hop_uri,
            __next_hop_uri,
            __next_hop_network_uri,
            __originating_route_uri,
            __originating_route_display_name,
            __ncc_hub_route_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RouteInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routeType" => Ok(__FieldTag::__route_type),
                            "route_type" => Ok(__FieldTag::__route_type),
                            "nextHopType" => Ok(__FieldTag::__next_hop_type),
                            "next_hop_type" => Ok(__FieldTag::__next_hop_type),
                            "routeScope" => Ok(__FieldTag::__route_scope),
                            "route_scope" => Ok(__FieldTag::__route_scope),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "region" => Ok(__FieldTag::__region),
                            "destIpRange" => Ok(__FieldTag::__dest_ip_range),
                            "dest_ip_range" => Ok(__FieldTag::__dest_ip_range),
                            "nextHop" => Ok(__FieldTag::__next_hop),
                            "next_hop" => Ok(__FieldTag::__next_hop),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "priority" => Ok(__FieldTag::__priority),
                            "instanceTags" => Ok(__FieldTag::__instance_tags),
                            "instance_tags" => Ok(__FieldTag::__instance_tags),
                            "srcIpRange" => Ok(__FieldTag::__src_ip_range),
                            "src_ip_range" => Ok(__FieldTag::__src_ip_range),
                            "destPortRanges" => Ok(__FieldTag::__dest_port_ranges),
                            "dest_port_ranges" => Ok(__FieldTag::__dest_port_ranges),
                            "srcPortRanges" => Ok(__FieldTag::__src_port_ranges),
                            "src_port_ranges" => Ok(__FieldTag::__src_port_ranges),
                            "protocols" => Ok(__FieldTag::__protocols),
                            "nccHubUri" => Ok(__FieldTag::__ncc_hub_uri),
                            "ncc_hub_uri" => Ok(__FieldTag::__ncc_hub_uri),
                            "nccSpokeUri" => Ok(__FieldTag::__ncc_spoke_uri),
                            "ncc_spoke_uri" => Ok(__FieldTag::__ncc_spoke_uri),
                            "advertisedRouteSourceRouterUri" => {
                                Ok(__FieldTag::__advertised_route_source_router_uri)
                            }
                            "advertised_route_source_router_uri" => {
                                Ok(__FieldTag::__advertised_route_source_router_uri)
                            }
                            "advertisedRouteNextHopUri" => {
                                Ok(__FieldTag::__advertised_route_next_hop_uri)
                            }
                            "advertised_route_next_hop_uri" => {
                                Ok(__FieldTag::__advertised_route_next_hop_uri)
                            }
                            "nextHopUri" => Ok(__FieldTag::__next_hop_uri),
                            "next_hop_uri" => Ok(__FieldTag::__next_hop_uri),
                            "nextHopNetworkUri" => Ok(__FieldTag::__next_hop_network_uri),
                            "next_hop_network_uri" => Ok(__FieldTag::__next_hop_network_uri),
                            "originatingRouteUri" => Ok(__FieldTag::__originating_route_uri),
                            "originating_route_uri" => Ok(__FieldTag::__originating_route_uri),
                            "originatingRouteDisplayName" => {
                                Ok(__FieldTag::__originating_route_display_name)
                            }
                            "originating_route_display_name" => {
                                Ok(__FieldTag::__originating_route_display_name)
                            }
                            "nccHubRouteUri" => Ok(__FieldTag::__ncc_hub_route_uri),
                            "ncc_hub_route_uri" => Ok(__FieldTag::__ncc_hub_route_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RouteInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RouteInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__route_type => {
                            if !fields.insert(__FieldTag::__route_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_type",
                                ));
                            }
                            result.route_type = map.next_value::<std::option::Option<crate::model::route_info::RouteType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_hop_type => {
                            if !fields.insert(__FieldTag::__next_hop_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop_type",
                                ));
                            }
                            result.next_hop_type = map.next_value::<std::option::Option<crate::model::route_info::NextHopType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__route_scope => {
                            if !fields.insert(__FieldTag::__route_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_scope",
                                ));
                            }
                            result.route_scope = map.next_value::<std::option::Option<crate::model::route_info::RouteScope>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dest_ip_range => {
                            if !fields.insert(__FieldTag::__dest_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dest_ip_range",
                                ));
                            }
                            result.dest_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_hop => {
                            if !fields.insert(__FieldTag::__next_hop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop",
                                ));
                            }
                            result.next_hop = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance_tags => {
                            if !fields.insert(__FieldTag::__instance_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_tags",
                                ));
                            }
                            result.instance_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__src_ip_range => {
                            if !fields.insert(__FieldTag::__src_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for src_ip_range",
                                ));
                            }
                            result.src_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dest_port_ranges => {
                            if !fields.insert(__FieldTag::__dest_port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dest_port_ranges",
                                ));
                            }
                            result.dest_port_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__src_port_ranges => {
                            if !fields.insert(__FieldTag::__src_port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for src_port_ranges",
                                ));
                            }
                            result.src_port_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__protocols => {
                            if !fields.insert(__FieldTag::__protocols) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocols",
                                ));
                            }
                            result.protocols = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ncc_hub_uri => {
                            if !fields.insert(__FieldTag::__ncc_hub_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ncc_hub_uri",
                                ));
                            }
                            result.ncc_hub_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__ncc_spoke_uri => {
                            if !fields.insert(__FieldTag::__ncc_spoke_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ncc_spoke_uri",
                                ));
                            }
                            result.ncc_spoke_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__advertised_route_source_router_uri => {
                            if !fields.insert(__FieldTag::__advertised_route_source_router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advertised_route_source_router_uri",
                                ));
                            }
                            result.advertised_route_source_router_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__advertised_route_next_hop_uri => {
                            if !fields.insert(__FieldTag::__advertised_route_next_hop_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advertised_route_next_hop_uri",
                                ));
                            }
                            result.advertised_route_next_hop_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__next_hop_uri => {
                            if !fields.insert(__FieldTag::__next_hop_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop_uri",
                                ));
                            }
                            result.next_hop_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_hop_network_uri => {
                            if !fields.insert(__FieldTag::__next_hop_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_hop_network_uri",
                                ));
                            }
                            result.next_hop_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__originating_route_uri => {
                            if !fields.insert(__FieldTag::__originating_route_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for originating_route_uri",
                                ));
                            }
                            result.originating_route_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__originating_route_display_name => {
                            if !fields.insert(__FieldTag::__originating_route_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for originating_route_display_name",
                                ));
                            }
                            result.originating_route_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ncc_hub_route_uri => {
                            if !fields.insert(__FieldTag::__ncc_hub_route_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ncc_hub_route_uri",
                                ));
                            }
                            result.ncc_hub_route_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleServiceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_ip,
            __google_service_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleServiceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "googleServiceType" => Ok(__FieldTag::__google_service_type),
                            "google_service_type" => Ok(__FieldTag::__google_service_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleServiceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleServiceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_service_type => {
                            if !fields.insert(__FieldTag::__google_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_service_type",
                                ));
                            }
                            result.google_service_type = map
                                .next_value::<std::option::Option<
                                    crate::model::google_service_info::GoogleServiceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForwardingRuleInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __matched_protocol,
            __matched_port_range,
            __vip,
            __target,
            __network_uri,
            __region,
            __load_balancer_name,
            __psc_service_attachment_uri,
            __psc_google_api_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardingRuleInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "matchedProtocol" => Ok(__FieldTag::__matched_protocol),
                            "matched_protocol" => Ok(__FieldTag::__matched_protocol),
                            "matchedPortRange" => Ok(__FieldTag::__matched_port_range),
                            "matched_port_range" => Ok(__FieldTag::__matched_port_range),
                            "vip" => Ok(__FieldTag::__vip),
                            "target" => Ok(__FieldTag::__target),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "region" => Ok(__FieldTag::__region),
                            "loadBalancerName" => Ok(__FieldTag::__load_balancer_name),
                            "load_balancer_name" => Ok(__FieldTag::__load_balancer_name),
                            "pscServiceAttachmentUri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "psc_service_attachment_uri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForwardingRuleInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardingRuleInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_protocol => {
                            if !fields.insert(__FieldTag::__matched_protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_protocol",
                                ));
                            }
                            result.matched_protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_port_range => {
                            if !fields.insert(__FieldTag::__matched_port_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_port_range",
                                ));
                            }
                            result.matched_port_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vip => {
                            if !fields.insert(__FieldTag::__vip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vip",
                                ));
                            }
                            result.vip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__load_balancer_name => {
                            if !fields.insert(__FieldTag::__load_balancer_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_name",
                                ));
                            }
                            result.load_balancer_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_service_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_service_attachment_uri",
                                ));
                            }
                            result.psc_service_attachment_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_google_api_target",
                                ));
                            }
                            result.psc_google_api_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadBalancerInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __load_balancer_type,
            __health_check_uri,
            __backends,
            __backend_type,
            __backend_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            "healthCheckUri" => Ok(__FieldTag::__health_check_uri),
                            "health_check_uri" => Ok(__FieldTag::__health_check_uri),
                            "backends" => Ok(__FieldTag::__backends),
                            "backendType" => Ok(__FieldTag::__backend_type),
                            "backend_type" => Ok(__FieldTag::__backend_type),
                            "backendUri" => Ok(__FieldTag::__backend_uri),
                            "backend_uri" => Ok(__FieldTag::__backend_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadBalancerInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map
                                .next_value::<std::option::Option<
                                    crate::model::load_balancer_info::LoadBalancerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_uri => {
                            if !fields.insert(__FieldTag::__health_check_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_uri",
                                ));
                            }
                            result.health_check_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backends => {
                            if !fields.insert(__FieldTag::__backends) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backends",
                                ));
                            }
                            result.backends = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LoadBalancerBackend>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_type => {
                            if !fields.insert(__FieldTag::__backend_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_type",
                                ));
                            }
                            result.backend_type =
                                map.next_value::<std::option::Option<
                                    crate::model::load_balancer_info::BackendType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_uri => {
                            if !fields.insert(__FieldTag::__backend_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_uri",
                                ));
                            }
                            result.backend_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadBalancerBackend {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __health_check_firewall_state,
            __health_check_allowing_firewall_rules,
            __health_check_blocking_firewall_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerBackend")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "healthCheckFirewallState" => {
                                Ok(__FieldTag::__health_check_firewall_state)
                            }
                            "health_check_firewall_state" => {
                                Ok(__FieldTag::__health_check_firewall_state)
                            }
                            "healthCheckAllowingFirewallRules" => {
                                Ok(__FieldTag::__health_check_allowing_firewall_rules)
                            }
                            "health_check_allowing_firewall_rules" => {
                                Ok(__FieldTag::__health_check_allowing_firewall_rules)
                            }
                            "healthCheckBlockingFirewallRules" => {
                                Ok(__FieldTag::__health_check_blocking_firewall_rules)
                            }
                            "health_check_blocking_firewall_rules" => {
                                Ok(__FieldTag::__health_check_blocking_firewall_rules)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadBalancerBackend;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerBackend")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_firewall_state => {
                            if !fields.insert(__FieldTag::__health_check_firewall_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_firewall_state",
                                ));
                            }
                            result.health_check_firewall_state = map
                                .next_value::<std::option::Option<
                                    crate::model::load_balancer_backend::HealthCheckFirewallState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_allowing_firewall_rules => {
                            if !fields.insert(__FieldTag::__health_check_allowing_firewall_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_allowing_firewall_rules",
                                ));
                            }
                            result.health_check_allowing_firewall_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__health_check_blocking_firewall_rules => {
                            if !fields.insert(__FieldTag::__health_check_blocking_firewall_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_blocking_firewall_rules",
                                ));
                            }
                            result.health_check_blocking_firewall_rules = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpnGatewayInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __ip_address,
            __vpn_tunnel_uri,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnGatewayInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "vpnTunnelUri" => Ok(__FieldTag::__vpn_tunnel_uri),
                            "vpn_tunnel_uri" => Ok(__FieldTag::__vpn_tunnel_uri),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpnGatewayInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnGatewayInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpn_tunnel_uri => {
                            if !fields.insert(__FieldTag::__vpn_tunnel_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_tunnel_uri",
                                ));
                            }
                            result.vpn_tunnel_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpnTunnelInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __source_gateway,
            __remote_gateway,
            __remote_gateway_ip,
            __source_gateway_ip,
            __network_uri,
            __region,
            __routing_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnTunnelInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "sourceGateway" => Ok(__FieldTag::__source_gateway),
                            "source_gateway" => Ok(__FieldTag::__source_gateway),
                            "remoteGateway" => Ok(__FieldTag::__remote_gateway),
                            "remote_gateway" => Ok(__FieldTag::__remote_gateway),
                            "remoteGatewayIp" => Ok(__FieldTag::__remote_gateway_ip),
                            "remote_gateway_ip" => Ok(__FieldTag::__remote_gateway_ip),
                            "sourceGatewayIp" => Ok(__FieldTag::__source_gateway_ip),
                            "source_gateway_ip" => Ok(__FieldTag::__source_gateway_ip),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "region" => Ok(__FieldTag::__region),
                            "routingType" => Ok(__FieldTag::__routing_type),
                            "routing_type" => Ok(__FieldTag::__routing_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpnTunnelInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnTunnelInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_gateway => {
                            if !fields.insert(__FieldTag::__source_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_gateway",
                                ));
                            }
                            result.source_gateway = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_gateway => {
                            if !fields.insert(__FieldTag::__remote_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_gateway",
                                ));
                            }
                            result.remote_gateway = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_gateway_ip => {
                            if !fields.insert(__FieldTag::__remote_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_gateway_ip",
                                ));
                            }
                            result.remote_gateway_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_gateway_ip => {
                            if !fields.insert(__FieldTag::__source_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_gateway_ip",
                                ));
                            }
                            result.source_gateway_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routing_type => {
                            if !fields.insert(__FieldTag::__routing_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routing_type",
                                ));
                            }
                            result.routing_type = map.next_value::<std::option::Option<crate::model::vpn_tunnel_info::RoutingType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EndpointInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_ip,
            __destination_ip,
            __protocol,
            __source_port,
            __destination_port,
            __source_network_uri,
            __destination_network_uri,
            __source_agent_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EndpointInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "sourcePort" => Ok(__FieldTag::__source_port),
                            "source_port" => Ok(__FieldTag::__source_port),
                            "destinationPort" => Ok(__FieldTag::__destination_port),
                            "destination_port" => Ok(__FieldTag::__destination_port),
                            "sourceNetworkUri" => Ok(__FieldTag::__source_network_uri),
                            "source_network_uri" => Ok(__FieldTag::__source_network_uri),
                            "destinationNetworkUri" => Ok(__FieldTag::__destination_network_uri),
                            "destination_network_uri" => Ok(__FieldTag::__destination_network_uri),
                            "sourceAgentUri" => Ok(__FieldTag::__source_agent_uri),
                            "source_agent_uri" => Ok(__FieldTag::__source_agent_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EndpointInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EndpointInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_ip",
                                ));
                            }
                            result.destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_port => {
                            if !fields.insert(__FieldTag::__source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__destination_port => {
                            if !fields.insert(__FieldTag::__destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_network_uri => {
                            if !fields.insert(__FieldTag::__source_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_network_uri",
                                ));
                            }
                            result.source_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_network_uri => {
                            if !fields.insert(__FieldTag::__destination_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_network_uri",
                                ));
                            }
                            result.destination_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_agent_uri => {
                            if !fields.insert(__FieldTag::__source_agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_agent_uri",
                                ));
                            }
                            result.source_agent_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeliverInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target,
            __resource_uri,
            __ip_address,
            __storage_bucket,
            __psc_google_api_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeliverInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "target" => Ok(__FieldTag::__target),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "storageBucket" => Ok(__FieldTag::__storage_bucket),
                            "storage_bucket" => Ok(__FieldTag::__storage_bucket),
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeliverInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeliverInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map.next_value::<std::option::Option<crate::model::deliver_info::Target>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_bucket => {
                            if !fields.insert(__FieldTag::__storage_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_bucket",
                                ));
                            }
                            result.storage_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_google_api_target",
                                ));
                            }
                            result.psc_google_api_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForwardInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target,
            __resource_uri,
            __ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "target" => Ok(__FieldTag::__target),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForwardInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map.next_value::<std::option::Option<crate::model::forward_info::Target>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AbortInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cause,
            __resource_uri,
            __ip_address,
            __projects_missing_permission,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AbortInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cause" => Ok(__FieldTag::__cause),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "projectsMissingPermission" => {
                                Ok(__FieldTag::__projects_missing_permission)
                            }
                            "projects_missing_permission" => {
                                Ok(__FieldTag::__projects_missing_permission)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AbortInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AbortInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cause",
                                ));
                            }
                            result.cause = map
                                .next_value::<std::option::Option<crate::model::abort_info::Cause>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__projects_missing_permission => {
                            if !fields.insert(__FieldTag::__projects_missing_permission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for projects_missing_permission",
                                ));
                            }
                            result.projects_missing_permission = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DropInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cause,
            __resource_uri,
            __source_ip,
            __destination_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DropInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cause" => Ok(__FieldTag::__cause),
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DropInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DropInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cause",
                                ));
                            }
                            result.cause = map
                                .next_value::<std::option::Option<crate::model::drop_info::Cause>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_ip",
                                ));
                            }
                            result.destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GKEMasterInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_uri,
            __cluster_network_uri,
            __internal_ip,
            __external_ip,
            __dns_endpoint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GKEMasterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterUri" => Ok(__FieldTag::__cluster_uri),
                            "cluster_uri" => Ok(__FieldTag::__cluster_uri),
                            "clusterNetworkUri" => Ok(__FieldTag::__cluster_network_uri),
                            "cluster_network_uri" => Ok(__FieldTag::__cluster_network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "dnsEndpoint" => Ok(__FieldTag::__dns_endpoint),
                            "dns_endpoint" => Ok(__FieldTag::__dns_endpoint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GKEMasterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GKEMasterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_uri => {
                            if !fields.insert(__FieldTag::__cluster_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uri",
                                ));
                            }
                            result.cluster_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_network_uri => {
                            if !fields.insert(__FieldTag::__cluster_network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_network_uri",
                                ));
                            }
                            result.cluster_network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns_endpoint => {
                            if !fields.insert(__FieldTag::__dns_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_endpoint",
                                ));
                            }
                            result.dns_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudSQLInstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __internal_ip,
            __external_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSQLInstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudSQLInstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSQLInstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RedisInstanceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __primary_endpoint_ip,
            __read_endpoint_ip,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedisInstanceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "primaryEndpointIp" => Ok(__FieldTag::__primary_endpoint_ip),
                            "primary_endpoint_ip" => Ok(__FieldTag::__primary_endpoint_ip),
                            "readEndpointIp" => Ok(__FieldTag::__read_endpoint_ip),
                            "read_endpoint_ip" => Ok(__FieldTag::__read_endpoint_ip),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RedisInstanceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedisInstanceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_endpoint_ip => {
                            if !fields.insert(__FieldTag::__primary_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_endpoint_ip",
                                ));
                            }
                            result.primary_endpoint_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_endpoint_ip => {
                            if !fields.insert(__FieldTag::__read_endpoint_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_endpoint_ip",
                                ));
                            }
                            result.read_endpoint_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RedisClusterInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __network_uri,
            __discovery_endpoint_ip_address,
            __secondary_endpoint_ip_address,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedisClusterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "discoveryEndpointIpAddress" => {
                                Ok(__FieldTag::__discovery_endpoint_ip_address)
                            }
                            "discovery_endpoint_ip_address" => {
                                Ok(__FieldTag::__discovery_endpoint_ip_address)
                            }
                            "secondaryEndpointIpAddress" => {
                                Ok(__FieldTag::__secondary_endpoint_ip_address)
                            }
                            "secondary_endpoint_ip_address" => {
                                Ok(__FieldTag::__secondary_endpoint_ip_address)
                            }
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RedisClusterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedisClusterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__discovery_endpoint_ip_address => {
                            if !fields.insert(__FieldTag::__discovery_endpoint_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_endpoint_ip_address",
                                ));
                            }
                            result.discovery_endpoint_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_endpoint_ip_address => {
                            if !fields.insert(__FieldTag::__secondary_endpoint_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_endpoint_ip_address",
                                ));
                            }
                            result.secondary_endpoint_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudFunctionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            __version_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudFunctionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            "versionId" => Ok(__FieldTag::__version_id),
                            "version_id" => Ok(__FieldTag::__version_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudFunctionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudFunctionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_id => {
                            if !fields.insert(__FieldTag::__version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudRunRevisionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            __service_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunRevisionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            "serviceUri" => Ok(__FieldTag::__service_uri),
                            "service_uri" => Ok(__FieldTag::__service_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudRunRevisionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunRevisionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_uri => {
                            if !fields.insert(__FieldTag::__service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_uri",
                                ));
                            }
                            result.service_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AppEngineVersionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __runtime,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineVersionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "runtime" => Ok(__FieldTag::__runtime),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AppEngineVersionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineVersionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime => {
                            if !fields.insert(__FieldTag::__runtime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime",
                                ));
                            }
                            result.runtime = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpcConnectorInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __uri,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcConnectorInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uri" => Ok(__FieldTag::__uri),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpcConnectorInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcConnectorInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DirectVpcEgressConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_uri,
            __subnetwork_uri,
            __selected_ip_range,
            __selected_ip_address,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DirectVpcEgressConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "subnetworkUri" => Ok(__FieldTag::__subnetwork_uri),
                            "subnetwork_uri" => Ok(__FieldTag::__subnetwork_uri),
                            "selectedIpRange" => Ok(__FieldTag::__selected_ip_range),
                            "selected_ip_range" => Ok(__FieldTag::__selected_ip_range),
                            "selectedIpAddress" => Ok(__FieldTag::__selected_ip_address),
                            "selected_ip_address" => Ok(__FieldTag::__selected_ip_address),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DirectVpcEgressConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DirectVpcEgressConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork_uri => {
                            if !fields.insert(__FieldTag::__subnetwork_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_uri",
                                ));
                            }
                            result.subnetwork_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_ip_range => {
                            if !fields.insert(__FieldTag::__selected_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_ip_range",
                                ));
                            }
                            result.selected_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_ip_address => {
                            if !fields.insert(__FieldTag::__selected_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_ip_address",
                                ));
                            }
                            result.selected_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ServerlessExternalConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __selected_ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerlessExternalConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "selectedIpAddress" => Ok(__FieldTag::__selected_ip_address),
                            "selected_ip_address" => Ok(__FieldTag::__selected_ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ServerlessExternalConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerlessExternalConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__selected_ip_address => {
                            if !fields.insert(__FieldTag::__selected_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_ip_address",
                                ));
                            }
                            result.selected_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NatInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __protocol,
            __network_uri,
            __old_source_ip,
            __new_source_ip,
            __old_destination_ip,
            __new_destination_ip,
            __old_source_port,
            __new_source_port,
            __old_destination_port,
            __new_destination_port,
            __router_uri,
            __nat_gateway_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NatInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "oldSourceIp" => Ok(__FieldTag::__old_source_ip),
                            "old_source_ip" => Ok(__FieldTag::__old_source_ip),
                            "newSourceIp" => Ok(__FieldTag::__new_source_ip),
                            "new_source_ip" => Ok(__FieldTag::__new_source_ip),
                            "oldDestinationIp" => Ok(__FieldTag::__old_destination_ip),
                            "old_destination_ip" => Ok(__FieldTag::__old_destination_ip),
                            "newDestinationIp" => Ok(__FieldTag::__new_destination_ip),
                            "new_destination_ip" => Ok(__FieldTag::__new_destination_ip),
                            "oldSourcePort" => Ok(__FieldTag::__old_source_port),
                            "old_source_port" => Ok(__FieldTag::__old_source_port),
                            "newSourcePort" => Ok(__FieldTag::__new_source_port),
                            "new_source_port" => Ok(__FieldTag::__new_source_port),
                            "oldDestinationPort" => Ok(__FieldTag::__old_destination_port),
                            "old_destination_port" => Ok(__FieldTag::__old_destination_port),
                            "newDestinationPort" => Ok(__FieldTag::__new_destination_port),
                            "new_destination_port" => Ok(__FieldTag::__new_destination_port),
                            "routerUri" => Ok(__FieldTag::__router_uri),
                            "router_uri" => Ok(__FieldTag::__router_uri),
                            "natGatewayName" => Ok(__FieldTag::__nat_gateway_name),
                            "nat_gateway_name" => Ok(__FieldTag::__nat_gateway_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NatInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NatInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::nat_info::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_ip => {
                            if !fields.insert(__FieldTag::__old_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_ip",
                                ));
                            }
                            result.old_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_source_ip => {
                            if !fields.insert(__FieldTag::__new_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_ip",
                                ));
                            }
                            result.new_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_destination_ip => {
                            if !fields.insert(__FieldTag::__old_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_ip",
                                ));
                            }
                            result.old_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_destination_ip => {
                            if !fields.insert(__FieldTag::__new_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_ip",
                                ));
                            }
                            result.new_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_port => {
                            if !fields.insert(__FieldTag::__old_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_source_port => {
                            if !fields.insert(__FieldTag::__new_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__old_destination_port => {
                            if !fields.insert(__FieldTag::__old_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_destination_port => {
                            if !fields.insert(__FieldTag::__new_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__router_uri => {
                            if !fields.insert(__FieldTag::__router_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for router_uri",
                                ));
                            }
                            result.router_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nat_gateway_name => {
                            if !fields.insert(__FieldTag::__nat_gateway_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nat_gateway_name",
                                ));
                            }
                            result.nat_gateway_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ProxyConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protocol,
            __old_source_ip,
            __new_source_ip,
            __old_destination_ip,
            __new_destination_ip,
            __old_source_port,
            __new_source_port,
            __old_destination_port,
            __new_destination_port,
            __subnet_uri,
            __network_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProxyConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protocol" => Ok(__FieldTag::__protocol),
                            "oldSourceIp" => Ok(__FieldTag::__old_source_ip),
                            "old_source_ip" => Ok(__FieldTag::__old_source_ip),
                            "newSourceIp" => Ok(__FieldTag::__new_source_ip),
                            "new_source_ip" => Ok(__FieldTag::__new_source_ip),
                            "oldDestinationIp" => Ok(__FieldTag::__old_destination_ip),
                            "old_destination_ip" => Ok(__FieldTag::__old_destination_ip),
                            "newDestinationIp" => Ok(__FieldTag::__new_destination_ip),
                            "new_destination_ip" => Ok(__FieldTag::__new_destination_ip),
                            "oldSourcePort" => Ok(__FieldTag::__old_source_port),
                            "old_source_port" => Ok(__FieldTag::__old_source_port),
                            "newSourcePort" => Ok(__FieldTag::__new_source_port),
                            "new_source_port" => Ok(__FieldTag::__new_source_port),
                            "oldDestinationPort" => Ok(__FieldTag::__old_destination_port),
                            "old_destination_port" => Ok(__FieldTag::__old_destination_port),
                            "newDestinationPort" => Ok(__FieldTag::__new_destination_port),
                            "new_destination_port" => Ok(__FieldTag::__new_destination_port),
                            "subnetUri" => Ok(__FieldTag::__subnet_uri),
                            "subnet_uri" => Ok(__FieldTag::__subnet_uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ProxyConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProxyConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_ip => {
                            if !fields.insert(__FieldTag::__old_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_ip",
                                ));
                            }
                            result.old_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_source_ip => {
                            if !fields.insert(__FieldTag::__new_source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_ip",
                                ));
                            }
                            result.new_source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_destination_ip => {
                            if !fields.insert(__FieldTag::__old_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_ip",
                                ));
                            }
                            result.old_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_destination_ip => {
                            if !fields.insert(__FieldTag::__new_destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_ip",
                                ));
                            }
                            result.new_destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__old_source_port => {
                            if !fields.insert(__FieldTag::__old_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_source_port => {
                            if !fields.insert(__FieldTag::__new_source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_source_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__old_destination_port => {
                            if !fields.insert(__FieldTag::__old_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.old_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__new_destination_port => {
                            if !fields.insert(__FieldTag::__new_destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.new_destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__subnet_uri => {
                            if !fields.insert(__FieldTag::__subnet_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_uri",
                                ));
                            }
                            result.subnet_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadBalancerBackendInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance_uri,
            __backend_service_uri,
            __instance_group_uri,
            __network_endpoint_group_uri,
            __backend_bucket_uri,
            __psc_service_attachment_uri,
            __psc_google_api_target,
            __health_check_uri,
            __health_check_firewalls_config_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancerBackendInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instanceUri" => Ok(__FieldTag::__instance_uri),
                            "instance_uri" => Ok(__FieldTag::__instance_uri),
                            "backendServiceUri" => Ok(__FieldTag::__backend_service_uri),
                            "backend_service_uri" => Ok(__FieldTag::__backend_service_uri),
                            "instanceGroupUri" => Ok(__FieldTag::__instance_group_uri),
                            "instance_group_uri" => Ok(__FieldTag::__instance_group_uri),
                            "networkEndpointGroupUri" => {
                                Ok(__FieldTag::__network_endpoint_group_uri)
                            }
                            "network_endpoint_group_uri" => {
                                Ok(__FieldTag::__network_endpoint_group_uri)
                            }
                            "backendBucketUri" => Ok(__FieldTag::__backend_bucket_uri),
                            "backend_bucket_uri" => Ok(__FieldTag::__backend_bucket_uri),
                            "pscServiceAttachmentUri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "psc_service_attachment_uri" => {
                                Ok(__FieldTag::__psc_service_attachment_uri)
                            }
                            "pscGoogleApiTarget" => Ok(__FieldTag::__psc_google_api_target),
                            "psc_google_api_target" => Ok(__FieldTag::__psc_google_api_target),
                            "healthCheckUri" => Ok(__FieldTag::__health_check_uri),
                            "health_check_uri" => Ok(__FieldTag::__health_check_uri),
                            "healthCheckFirewallsConfigState" => {
                                Ok(__FieldTag::__health_check_firewalls_config_state)
                            }
                            "health_check_firewalls_config_state" => {
                                Ok(__FieldTag::__health_check_firewalls_config_state)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadBalancerBackendInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancerBackendInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_uri => {
                            if !fields.insert(__FieldTag::__instance_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_uri",
                                ));
                            }
                            result.instance_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_service_uri => {
                            if !fields.insert(__FieldTag::__backend_service_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_service_uri",
                                ));
                            }
                            result.backend_service_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_uri => {
                            if !fields.insert(__FieldTag::__instance_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_uri",
                                ));
                            }
                            result.instance_group_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_endpoint_group_uri => {
                            if !fields.insert(__FieldTag::__network_endpoint_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_endpoint_group_uri",
                                ));
                            }
                            result.network_endpoint_group_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backend_bucket_uri => {
                            if !fields.insert(__FieldTag::__backend_bucket_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_bucket_uri",
                                ));
                            }
                            result.backend_bucket_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_service_attachment_uri => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_service_attachment_uri",
                                ));
                            }
                            result.psc_service_attachment_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_google_api_target => {
                            if !fields.insert(__FieldTag::__psc_google_api_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_google_api_target",
                                ));
                            }
                            result.psc_google_api_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_uri => {
                            if !fields.insert(__FieldTag::__health_check_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_uri",
                                ));
                            }
                            result.health_check_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_firewalls_config_state => {
                            if !fields.insert(__FieldTag::__health_check_firewalls_config_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_firewalls_config_state",
                                ));
                            }
                            result.health_check_firewalls_config_state = map.next_value::<std::option::Option<crate::model::load_balancer_backend_info::HealthCheckFirewallsConfigState>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StorageBucketInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageBucketInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StorageBucketInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageBucketInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ServerlessNegInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __neg_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerlessNegInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "negUri" => Ok(__FieldTag::__neg_uri),
                            "neg_uri" => Ok(__FieldTag::__neg_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ServerlessNegInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerlessNegInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__neg_uri => {
                            if !fields.insert(__FieldTag::__neg_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for neg_uri",
                                ));
                            }
                            result.neg_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVpcFlowLogsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpcFlowLogsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVpcFlowLogsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpcFlowLogsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVpcFlowLogsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc_flow_logs_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpcFlowLogsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpcFlowLogsConfigs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "vpc_flow_logs_configs" => Ok(__FieldTag::__vpc_flow_logs_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVpcFlowLogsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpcFlowLogsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc_flow_logs_configs => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_configs",
                                ));
                            }
                            result.vpc_flow_logs_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VpcFlowLogsConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __vpc_flow_logs_config_id,
            __vpc_flow_logs_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "vpcFlowLogsConfigId" => Ok(__FieldTag::__vpc_flow_logs_config_id),
                            "vpc_flow_logs_config_id" => Ok(__FieldTag::__vpc_flow_logs_config_id),
                            "vpcFlowLogsConfig" => Ok(__FieldTag::__vpc_flow_logs_config),
                            "vpc_flow_logs_config" => Ok(__FieldTag::__vpc_flow_logs_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_flow_logs_config_id => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_config_id",
                                ));
                            }
                            result.vpc_flow_logs_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_flow_logs_config => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_config",
                                ));
                            }
                            result.vpc_flow_logs_config = map
                                .next_value::<std::option::Option<crate::model::VpcFlowLogsConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __vpc_flow_logs_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "vpcFlowLogsConfig" => Ok(__FieldTag::__vpc_flow_logs_config),
                            "vpc_flow_logs_config" => Ok(__FieldTag::__vpc_flow_logs_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__vpc_flow_logs_config => {
                            if !fields.insert(__FieldTag::__vpc_flow_logs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_flow_logs_config",
                                ));
                            }
                            result.vpc_flow_logs_config = map
                                .next_value::<std::option::Option<crate::model::VpcFlowLogsConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteVpcFlowLogsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVpcFlowLogsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteVpcFlowLogsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVpcFlowLogsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VpcFlowLogsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __state,
            __aggregation_interval,
            __flow_sampling,
            __metadata,
            __metadata_fields,
            __filter_expr,
            __target_resource_state,
            __interconnect_attachment,
            __vpn_tunnel,
            __labels,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcFlowLogsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "aggregationInterval" => Ok(__FieldTag::__aggregation_interval),
                            "aggregation_interval" => Ok(__FieldTag::__aggregation_interval),
                            "flowSampling" => Ok(__FieldTag::__flow_sampling),
                            "flow_sampling" => Ok(__FieldTag::__flow_sampling),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "metadataFields" => Ok(__FieldTag::__metadata_fields),
                            "metadata_fields" => Ok(__FieldTag::__metadata_fields),
                            "filterExpr" => Ok(__FieldTag::__filter_expr),
                            "filter_expr" => Ok(__FieldTag::__filter_expr),
                            "targetResourceState" => Ok(__FieldTag::__target_resource_state),
                            "target_resource_state" => Ok(__FieldTag::__target_resource_state),
                            "interconnectAttachment" => Ok(__FieldTag::__interconnect_attachment),
                            "interconnect_attachment" => Ok(__FieldTag::__interconnect_attachment),
                            "vpnTunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "vpn_tunnel" => Ok(__FieldTag::__vpn_tunnel),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VpcFlowLogsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcFlowLogsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::vpc_flow_logs_config::State>>()?
                                ;
                        }
                        __FieldTag::__aggregation_interval => {
                            if !fields.insert(__FieldTag::__aggregation_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_interval",
                                ));
                            }
                            result.aggregation_interval = map.next_value::<std::option::Option<
                                crate::model::vpc_flow_logs_config::AggregationInterval,
                            >>()?;
                        }
                        __FieldTag::__flow_sampling => {
                            if !fields.insert(__FieldTag::__flow_sampling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_sampling",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.flow_sampling = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::vpc_flow_logs_config::Metadata,
                                >>()?;
                        }
                        __FieldTag::__metadata_fields => {
                            if !fields.insert(__FieldTag::__metadata_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_fields",
                                ));
                            }
                            result.metadata_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter_expr => {
                            if !fields.insert(__FieldTag::__filter_expr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_expr",
                                ));
                            }
                            result.filter_expr =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__target_resource_state => {
                            if !fields.insert(__FieldTag::__target_resource_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_state",
                                ));
                            }
                            result.target_resource_state = map.next_value::<std::option::Option<
                                crate::model::vpc_flow_logs_config::TargetResourceState,
                            >>()?;
                        }
                        __FieldTag::__interconnect_attachment => {
                            if !fields.insert(__FieldTag::__interconnect_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interconnect_attachment",
                                ));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.interconnect_attachment, latest field was interconnectAttachment",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::InterconnectAttachment(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vpn_tunnel => {
                            if !fields.insert(__FieldTag::__vpn_tunnel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_tunnel",
                                ));
                            }
                            if result.target_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_resource`, a oneof with full ID .google.cloud.networkmanagement.v1.VpcFlowLogsConfig.vpn_tunnel, latest field was vpnTunnel",
                                ));
                            }
                            result.target_resource = std::option::Option::Some(
                                crate::model::vpc_flow_logs_config::TargetResource::VpnTunnel(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
