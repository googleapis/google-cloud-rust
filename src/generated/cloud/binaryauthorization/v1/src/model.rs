// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate grafeas;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A [policy][google.cloud.binaryauthorization.v1.Policy] for container image binary authorization.
///
/// [google.cloud.binaryauthorization.v1.Policy]: crate::model::Policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Policy {
    /// Output only. The resource name, in the format `projects/*/policy`. There is
    /// at most one policy per project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A descriptive comment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Controls the evaluation of a Google-maintained global admission
    /// policy for common system-level images. Images not covered by the global
    /// policy will be subject to the project admission policy. This setting
    /// has no effect when specified inside a global admission policy.
    pub global_policy_evaluation_mode: crate::model::policy::GlobalPolicyEvaluationMode,

    /// Optional. Admission policy allowlisting. A matching admission request will
    /// always be permitted. This feature is typically used to exclude Google or
    /// third-party infrastructure images from Binary Authorization policies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub admission_whitelist_patterns: std::vec::Vec<crate::model::AdmissionWhitelistPattern>,

    /// Optional. Per-cluster admission rules. Cluster spec format:
    /// `location.clusterId`. There can be at most one admission rule per cluster
    /// spec.
    /// A `location` is either a compute zone (e.g. us-central1-a) or a region
    /// (e.g. us-central1).
    /// For `clusterId` syntax restrictions see
    /// <https://cloud.google.com/container-engine/reference/rest/v1/projects.zones.clusters>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub cluster_admission_rules:
        std::collections::HashMap<std::string::String, crate::model::AdmissionRule>,

    /// Optional. Per-kubernetes-namespace admission rules. K8s namespace spec format:
    /// [a-z.-]+, e.g. 'some-namespace'
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub kubernetes_namespace_admission_rules:
        std::collections::HashMap<std::string::String, crate::model::AdmissionRule>,

    /// Optional. Per-kubernetes-service-account admission rules. Service account
    /// spec format: `namespace:serviceaccount`. e.g. 'test-ns:default'
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub kubernetes_service_account_admission_rules:
        std::collections::HashMap<std::string::String, crate::model::AdmissionRule>,

    /// Optional. Per-istio-service-identity admission rules. Istio service
    /// identity spec format:
    /// spiffe://\<domain\>/ns/\<namespace\>/sa/\<serviceaccount\> or
    /// \<domain\>/ns/\<namespace\>/sa/\<serviceaccount\>
    /// e.g. spiffe://example.com/ns/test-ns/sa/default
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub istio_service_identity_admission_rules:
        std::collections::HashMap<std::string::String, crate::model::AdmissionRule>,

    /// Required. Default admission rule for a cluster without a per-cluster, per-
    /// kubernetes-service-account, or per-istio-service-identity admission rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_admission_rule: std::option::Option<crate::model::AdmissionRule>,

    /// Output only. Time when the policy was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Policy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Policy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [global_policy_evaluation_mode][crate::model::Policy::global_policy_evaluation_mode].
    pub fn set_global_policy_evaluation_mode<
        T: std::convert::Into<crate::model::policy::GlobalPolicyEvaluationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.global_policy_evaluation_mode = v.into();
        self
    }

    /// Sets the value of [default_admission_rule][crate::model::Policy::default_admission_rule].
    pub fn set_default_admission_rule<
        T: std::convert::Into<std::option::Option<crate::model::AdmissionRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_admission_rule = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Policy::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [admission_whitelist_patterns][crate::model::Policy::admission_whitelist_patterns].
    pub fn set_admission_whitelist_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdmissionWhitelistPattern>,
    {
        use std::iter::Iterator;
        self.admission_whitelist_patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_admission_rules][crate::model::Policy::cluster_admission_rules].
    pub fn set_cluster_admission_rules<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AdmissionRule>,
    {
        use std::iter::Iterator;
        self.cluster_admission_rules = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kubernetes_namespace_admission_rules][crate::model::Policy::kubernetes_namespace_admission_rules].
    pub fn set_kubernetes_namespace_admission_rules<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AdmissionRule>,
    {
        use std::iter::Iterator;
        self.kubernetes_namespace_admission_rules =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kubernetes_service_account_admission_rules][crate::model::Policy::kubernetes_service_account_admission_rules].
    pub fn set_kubernetes_service_account_admission_rules<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AdmissionRule>,
    {
        use std::iter::Iterator;
        self.kubernetes_service_account_admission_rules =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [istio_service_identity_admission_rules][crate::model::Policy::istio_service_identity_admission_rules].
    pub fn set_istio_service_identity_admission_rules<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AdmissionRule>,
    {
        use std::iter::Iterator;
        self.istio_service_identity_admission_rules =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.Policy"
    }
}

/// Defines additional types related to Policy
pub mod policy {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct GlobalPolicyEvaluationMode(i32);

    impl GlobalPolicyEvaluationMode {
        /// Not specified: DISABLE is assumed.
        pub const GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED: GlobalPolicyEvaluationMode =
            GlobalPolicyEvaluationMode::new(0);

        /// Enables system policy evaluation.
        pub const ENABLE: GlobalPolicyEvaluationMode = GlobalPolicyEvaluationMode::new(1);

        /// Disables system policy evaluation.
        pub const DISABLE: GlobalPolicyEvaluationMode = GlobalPolicyEvaluationMode::new(2);

        /// Creates a new GlobalPolicyEvaluationMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLE"),
                2 => std::borrow::Cow::Borrowed("DISABLE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED)
                }
                "ENABLE" => std::option::Option::Some(Self::ENABLE),
                "DISABLE" => std::option::Option::Some(Self::DISABLE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for GlobalPolicyEvaluationMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for GlobalPolicyEvaluationMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An [admission allowlist pattern][google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern] exempts images
/// from checks by [admission rules][google.cloud.binaryauthorization.v1.AdmissionRule].
///
/// [google.cloud.binaryauthorization.v1.AdmissionRule]: crate::model::AdmissionRule
/// [google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern]: crate::model::AdmissionWhitelistPattern
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdmissionWhitelistPattern {
    /// An image name pattern to allowlist, in the form `registry/path/to/image`.
    /// This supports a trailing `*` wildcard, but this is allowed only in
    /// text after the `registry/` part. This also supports a trailing `**`
    /// wildcard which matches subdirectories of a given entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name_pattern: std::string::String,
}

impl AdmissionWhitelistPattern {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name_pattern][crate::model::AdmissionWhitelistPattern::name_pattern].
    pub fn set_name_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name_pattern = v.into();
        self
    }
}

impl wkt::message::Message for AdmissionWhitelistPattern {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern"
    }
}

/// An [admission rule][google.cloud.binaryauthorization.v1.AdmissionRule] specifies either that all container images
/// used in a pod creation request must be attested to by one or more
/// [attestors][google.cloud.binaryauthorization.v1.Attestor], that all pod creations will be allowed, or that all
/// pod creations will be denied.
///
/// Images matching an [admission allowlist pattern][google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern]
/// are exempted from admission rules and will never block a pod creation.
///
/// [google.cloud.binaryauthorization.v1.AdmissionRule]: crate::model::AdmissionRule
/// [google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern]: crate::model::AdmissionWhitelistPattern
/// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdmissionRule {
    /// Required. How this admission rule will be evaluated.
    pub evaluation_mode: crate::model::admission_rule::EvaluationMode,

    /// Optional. The resource names of the attestors that must attest to
    /// a container image, in the format `projects/*/attestors/*`. Each
    /// attestor must exist before a policy can reference it.  To add an attestor
    /// to a policy the principal issuing the policy change request must be able
    /// to read the attestor resource.
    ///
    /// Note: this field must be non-empty when the evaluation_mode field specifies
    /// REQUIRE_ATTESTATION, otherwise it must be empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub require_attestations_by: std::vec::Vec<std::string::String>,

    /// Required. The action when a pod creation is denied by the admission rule.
    pub enforcement_mode: crate::model::admission_rule::EnforcementMode,
}

impl AdmissionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation_mode][crate::model::AdmissionRule::evaluation_mode].
    pub fn set_evaluation_mode<
        T: std::convert::Into<crate::model::admission_rule::EvaluationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_mode = v.into();
        self
    }

    /// Sets the value of [enforcement_mode][crate::model::AdmissionRule::enforcement_mode].
    pub fn set_enforcement_mode<
        T: std::convert::Into<crate::model::admission_rule::EnforcementMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enforcement_mode = v.into();
        self
    }

    /// Sets the value of [require_attestations_by][crate::model::AdmissionRule::require_attestations_by].
    pub fn set_require_attestations_by<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.require_attestations_by = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdmissionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.AdmissionRule"
    }
}

/// Defines additional types related to AdmissionRule
pub mod admission_rule {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EvaluationMode(i32);

    impl EvaluationMode {
        /// Do not use.
        pub const EVALUATION_MODE_UNSPECIFIED: EvaluationMode = EvaluationMode::new(0);

        /// This rule allows all all pod creations.
        pub const ALWAYS_ALLOW: EvaluationMode = EvaluationMode::new(1);

        /// This rule allows a pod creation if all the attestors listed in
        /// 'require_attestations_by' have valid attestations for all of the
        /// images in the pod spec.
        pub const REQUIRE_ATTESTATION: EvaluationMode = EvaluationMode::new(2);

        /// This rule denies all pod creations.
        pub const ALWAYS_DENY: EvaluationMode = EvaluationMode::new(3);

        /// Creates a new EvaluationMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EVALUATION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALWAYS_ALLOW"),
                2 => std::borrow::Cow::Borrowed("REQUIRE_ATTESTATION"),
                3 => std::borrow::Cow::Borrowed("ALWAYS_DENY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EVALUATION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EVALUATION_MODE_UNSPECIFIED)
                }
                "ALWAYS_ALLOW" => std::option::Option::Some(Self::ALWAYS_ALLOW),
                "REQUIRE_ATTESTATION" => std::option::Option::Some(Self::REQUIRE_ATTESTATION),
                "ALWAYS_DENY" => std::option::Option::Some(Self::ALWAYS_DENY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EvaluationMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EvaluationMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Defines the possible actions when a pod creation is denied by an admission
    /// rule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EnforcementMode(i32);

    impl EnforcementMode {
        /// Do not use.
        pub const ENFORCEMENT_MODE_UNSPECIFIED: EnforcementMode = EnforcementMode::new(0);

        /// Enforce the admission rule by blocking the pod creation.
        pub const ENFORCED_BLOCK_AND_AUDIT_LOG: EnforcementMode = EnforcementMode::new(1);

        /// Dryrun mode: Audit logging only.  This will allow the pod creation as if
        /// the admission request had specified break-glass.
        pub const DRYRUN_AUDIT_LOG_ONLY: EnforcementMode = EnforcementMode::new(2);

        /// Creates a new EnforcementMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ENFORCEMENT_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENFORCED_BLOCK_AND_AUDIT_LOG"),
                2 => std::borrow::Cow::Borrowed("DRYRUN_AUDIT_LOG_ONLY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ENFORCEMENT_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ENFORCEMENT_MODE_UNSPECIFIED)
                }
                "ENFORCED_BLOCK_AND_AUDIT_LOG" => {
                    std::option::Option::Some(Self::ENFORCED_BLOCK_AND_AUDIT_LOG)
                }
                "DRYRUN_AUDIT_LOG_ONLY" => std::option::Option::Some(Self::DRYRUN_AUDIT_LOG_ONLY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EnforcementMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EnforcementMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An [attestor][google.cloud.binaryauthorization.v1.Attestor] that attests to container image
/// artifacts. An existing attestor cannot be modified except where
/// indicated.
///
/// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Attestor {
    /// Required. The resource name, in the format:
    /// `projects/*/attestors/*`. This field may not be updated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A descriptive comment.  This field may be updated.
    /// The field may be displayed in chooser dialogs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Time when the attestor was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub attestor_type: std::option::Option<crate::model::attestor::AttestorType>,
}

impl Attestor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Attestor::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Attestor::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Attestor::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of `attestor_type`.
    pub fn set_attestor_type<
        T: std::convert::Into<std::option::Option<crate::model::attestor::AttestorType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attestor_type = v.into();
        self
    }

    /// The value of [attestor_type][crate::model::Attestor::attestor_type]
    /// if it holds a `UserOwnedGrafeasNote`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_user_owned_grafeas_note(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UserOwnedGrafeasNote>> {
        #[allow(unreachable_patterns)]
        self.attestor_type.as_ref().and_then(|v| match v {
            crate::model::attestor::AttestorType::UserOwnedGrafeasNote(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [attestor_type][crate::model::Attestor::attestor_type]
    /// to hold a `UserOwnedGrafeasNote`.
    ///
    /// Note that all the setters affecting `attestor_type` are
    /// mutually exclusive.
    pub fn set_user_owned_grafeas_note<
        T: std::convert::Into<std::boxed::Box<crate::model::UserOwnedGrafeasNote>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attestor_type = std::option::Option::Some(
            crate::model::attestor::AttestorType::UserOwnedGrafeasNote(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Attestor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.Attestor"
    }
}

/// Defines additional types related to Attestor
pub mod attestor {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AttestorType {
        /// This specifies how an attestation will be read, and how it will be used
        /// during policy enforcement.
        UserOwnedGrafeasNote(std::boxed::Box<crate::model::UserOwnedGrafeasNote>),
    }
}

/// An [user owned Grafeas note][google.cloud.binaryauthorization.v1.UserOwnedGrafeasNote] references a Grafeas
/// Attestation.Authority Note created by the user.
///
/// [google.cloud.binaryauthorization.v1.UserOwnedGrafeasNote]: crate::model::UserOwnedGrafeasNote
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserOwnedGrafeasNote {
    /// Required. The Grafeas resource name of a Attestation.Authority Note,
    /// created by the user, in the format: `projects/*/notes/*`. This field may
    /// not be updated.
    ///
    /// An attestation by this attestor is stored as a Grafeas
    /// Attestation.Authority Occurrence that names a container image and that
    /// links to this Note. Grafeas is an external dependency.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub note_reference: std::string::String,

    /// Optional. Public keys that verify attestations signed by this
    /// attestor.  This field may be updated.
    ///
    /// If this field is non-empty, one of the specified public keys must
    /// verify that an attestation was signed by this attestor for the
    /// image specified in the admission request.
    ///
    /// If this field is empty, this attestor always returns that no
    /// valid attestations exist.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub public_keys: std::vec::Vec<crate::model::AttestorPublicKey>,

    /// Output only. This field will contain the service account email address
    /// that this Attestor will use as the principal when querying Container
    /// Analysis. Attestor administrators must grant this service account the
    /// IAM role needed to read attestations from the [note_reference][Note] in
    /// Container Analysis (`containeranalysis.notes.occurrences.viewer`).
    ///
    /// This email address is fixed for the lifetime of the Attestor, but callers
    /// should not make any other assumptions about the service account email;
    /// future versions may use an email based on a different naming pattern.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub delegation_service_account_email: std::string::String,
}

impl UserOwnedGrafeasNote {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [note_reference][crate::model::UserOwnedGrafeasNote::note_reference].
    pub fn set_note_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note_reference = v.into();
        self
    }

    /// Sets the value of [delegation_service_account_email][crate::model::UserOwnedGrafeasNote::delegation_service_account_email].
    pub fn set_delegation_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delegation_service_account_email = v.into();
        self
    }

    /// Sets the value of [public_keys][crate::model::UserOwnedGrafeasNote::public_keys].
    pub fn set_public_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttestorPublicKey>,
    {
        use std::iter::Iterator;
        self.public_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserOwnedGrafeasNote {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.UserOwnedGrafeasNote"
    }
}

/// A public key in the PkixPublicKey format (see
/// <https://tools.ietf.org/html/rfc5280#section-4.1.2.7> for details).
/// Public keys of this type are typically textually encoded using the PEM
/// format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PkixPublicKey {
    /// A PEM-encoded public key, as described in
    /// <https://tools.ietf.org/html/rfc7468#section-13>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key_pem: std::string::String,

    /// The signature algorithm used to verify a message against a signature using
    /// this key.
    /// These signature algorithm must match the structure and any object
    /// identifiers encoded in `public_key_pem` (i.e. this algorithm must match
    /// that of the public key).
    pub signature_algorithm: crate::model::pkix_public_key::SignatureAlgorithm,
}

impl PkixPublicKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_key_pem][crate::model::PkixPublicKey::public_key_pem].
    pub fn set_public_key_pem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key_pem = v.into();
        self
    }

    /// Sets the value of [signature_algorithm][crate::model::PkixPublicKey::signature_algorithm].
    pub fn set_signature_algorithm<
        T: std::convert::Into<crate::model::pkix_public_key::SignatureAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.signature_algorithm = v.into();
        self
    }
}

impl wkt::message::Message for PkixPublicKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.PkixPublicKey"
    }
}

/// Defines additional types related to PkixPublicKey
pub mod pkix_public_key {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a signature algorithm and other information necessary to verify
    /// signatures with a given public key.
    /// This is based primarily on the public key types supported by Tink's
    /// PemKeyType, which is in turn based on KMS's supported signing algorithms.
    /// See <https://cloud.google.com/kms/docs/algorithms>. In the future, BinAuthz
    /// might support additional public key types independently of Tink and/or KMS.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SignatureAlgorithm(i32);

    impl SignatureAlgorithm {
        /// Not specified.
        pub const SIGNATURE_ALGORITHM_UNSPECIFIED: SignatureAlgorithm = SignatureAlgorithm::new(0);

        /// RSASSA-PSS 2048 bit key with a SHA256 digest.
        pub const RSA_PSS_2048_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(1);

        /// RSASSA-PSS 3072 bit key with a SHA256 digest.
        pub const RSA_PSS_3072_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(2);

        /// RSASSA-PSS 4096 bit key with a SHA256 digest.
        pub const RSA_PSS_4096_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(3);

        /// RSASSA-PSS 4096 bit key with a SHA512 digest.
        pub const RSA_PSS_4096_SHA512: SignatureAlgorithm = SignatureAlgorithm::new(4);

        /// RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.
        pub const RSA_SIGN_PKCS1_2048_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(5);

        /// RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.
        pub const RSA_SIGN_PKCS1_3072_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(6);

        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.
        pub const RSA_SIGN_PKCS1_4096_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(7);

        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.
        pub const RSA_SIGN_PKCS1_4096_SHA512: SignatureAlgorithm = SignatureAlgorithm::new(8);

        /// ECDSA on the NIST P-256 curve with a SHA256 digest.
        pub const ECDSA_P256_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(9);

        /// ECDSA on the NIST P-256 curve with a SHA256 digest.
        pub const EC_SIGN_P256_SHA256: SignatureAlgorithm = SignatureAlgorithm::new(9);

        /// ECDSA on the NIST P-384 curve with a SHA384 digest.
        pub const ECDSA_P384_SHA384: SignatureAlgorithm = SignatureAlgorithm::new(10);

        /// ECDSA on the NIST P-384 curve with a SHA384 digest.
        pub const EC_SIGN_P384_SHA384: SignatureAlgorithm = SignatureAlgorithm::new(10);

        /// ECDSA on the NIST P-521 curve with a SHA512 digest.
        pub const ECDSA_P521_SHA512: SignatureAlgorithm = SignatureAlgorithm::new(11);

        /// ECDSA on the NIST P-521 curve with a SHA512 digest.
        pub const EC_SIGN_P521_SHA512: SignatureAlgorithm = SignatureAlgorithm::new(11);

        /// Creates a new SignatureAlgorithm instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SIGNATURE_ALGORITHM_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RSA_PSS_2048_SHA256"),
                2 => std::borrow::Cow::Borrowed("RSA_PSS_3072_SHA256"),
                3 => std::borrow::Cow::Borrowed("RSA_PSS_4096_SHA256"),
                4 => std::borrow::Cow::Borrowed("RSA_PSS_4096_SHA512"),
                5 => std::borrow::Cow::Borrowed("RSA_SIGN_PKCS1_2048_SHA256"),
                6 => std::borrow::Cow::Borrowed("RSA_SIGN_PKCS1_3072_SHA256"),
                7 => std::borrow::Cow::Borrowed("RSA_SIGN_PKCS1_4096_SHA256"),
                8 => std::borrow::Cow::Borrowed("RSA_SIGN_PKCS1_4096_SHA512"),
                9 => std::borrow::Cow::Borrowed("ECDSA_P256_SHA256"),
                10 => std::borrow::Cow::Borrowed("ECDSA_P384_SHA384"),
                11 => std::borrow::Cow::Borrowed("ECDSA_P521_SHA512"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SIGNATURE_ALGORITHM_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SIGNATURE_ALGORITHM_UNSPECIFIED)
                }
                "RSA_PSS_2048_SHA256" => std::option::Option::Some(Self::RSA_PSS_2048_SHA256),
                "RSA_PSS_3072_SHA256" => std::option::Option::Some(Self::RSA_PSS_3072_SHA256),
                "RSA_PSS_4096_SHA256" => std::option::Option::Some(Self::RSA_PSS_4096_SHA256),
                "RSA_PSS_4096_SHA512" => std::option::Option::Some(Self::RSA_PSS_4096_SHA512),
                "RSA_SIGN_PKCS1_2048_SHA256" => {
                    std::option::Option::Some(Self::RSA_SIGN_PKCS1_2048_SHA256)
                }
                "RSA_SIGN_PKCS1_3072_SHA256" => {
                    std::option::Option::Some(Self::RSA_SIGN_PKCS1_3072_SHA256)
                }
                "RSA_SIGN_PKCS1_4096_SHA256" => {
                    std::option::Option::Some(Self::RSA_SIGN_PKCS1_4096_SHA256)
                }
                "RSA_SIGN_PKCS1_4096_SHA512" => {
                    std::option::Option::Some(Self::RSA_SIGN_PKCS1_4096_SHA512)
                }
                "ECDSA_P256_SHA256" => std::option::Option::Some(Self::ECDSA_P256_SHA256),
                "EC_SIGN_P256_SHA256" => std::option::Option::Some(Self::EC_SIGN_P256_SHA256),
                "ECDSA_P384_SHA384" => std::option::Option::Some(Self::ECDSA_P384_SHA384),
                "EC_SIGN_P384_SHA384" => std::option::Option::Some(Self::EC_SIGN_P384_SHA384),
                "ECDSA_P521_SHA512" => std::option::Option::Some(Self::ECDSA_P521_SHA512),
                "EC_SIGN_P521_SHA512" => std::option::Option::Some(Self::EC_SIGN_P521_SHA512),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SignatureAlgorithm {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SignatureAlgorithm {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An [attestor public key][google.cloud.binaryauthorization.v1.AttestorPublicKey] that will be used to verify
/// attestations signed by this attestor.
///
/// [google.cloud.binaryauthorization.v1.AttestorPublicKey]: crate::model::AttestorPublicKey
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttestorPublicKey {
    /// Optional. A descriptive comment. This field may be updated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,

    /// The ID of this public key.
    /// Signatures verified by BinAuthz must include the ID of the public key that
    /// can be used to verify them, and that ID must match the contents of this
    /// field exactly.
    /// Additional restrictions on this field can be imposed based on which public
    /// key type is encapsulated. See the documentation on `public_key` cases below
    /// for details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub public_key: std::option::Option<crate::model::attestor_public_key::PublicKey>,
}

impl AttestorPublicKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [comment][crate::model::AttestorPublicKey::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [id][crate::model::AttestorPublicKey::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of `public_key`.
    pub fn set_public_key<
        T: std::convert::Into<std::option::Option<crate::model::attestor_public_key::PublicKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.public_key = v.into();
        self
    }

    /// The value of [public_key][crate::model::AttestorPublicKey::public_key]
    /// if it holds a `AsciiArmoredPgpPublicKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ascii_armored_pgp_public_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.public_key.as_ref().and_then(|v| match v {
            crate::model::attestor_public_key::PublicKey::AsciiArmoredPgpPublicKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [public_key][crate::model::AttestorPublicKey::public_key]
    /// if it holds a `PkixPublicKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_pkix_public_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PkixPublicKey>> {
        #[allow(unreachable_patterns)]
        self.public_key.as_ref().and_then(|v| match v {
            crate::model::attestor_public_key::PublicKey::PkixPublicKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [public_key][crate::model::AttestorPublicKey::public_key]
    /// to hold a `AsciiArmoredPgpPublicKey`.
    ///
    /// Note that all the setters affecting `public_key` are
    /// mutually exclusive.
    pub fn set_ascii_armored_pgp_public_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_key = std::option::Option::Some(
            crate::model::attestor_public_key::PublicKey::AsciiArmoredPgpPublicKey(v.into()),
        );
        self
    }

    /// Sets the value of [public_key][crate::model::AttestorPublicKey::public_key]
    /// to hold a `PkixPublicKey`.
    ///
    /// Note that all the setters affecting `public_key` are
    /// mutually exclusive.
    pub fn set_pkix_public_key<
        T: std::convert::Into<std::boxed::Box<crate::model::PkixPublicKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.public_key = std::option::Option::Some(
            crate::model::attestor_public_key::PublicKey::PkixPublicKey(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AttestorPublicKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.AttestorPublicKey"
    }
}

/// Defines additional types related to AttestorPublicKey
pub mod attestor_public_key {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PublicKey {
        /// ASCII-armored representation of a PGP public key, as the entire output by
        /// the command `gpg --export --armor foo@example.com` (either LF or CRLF
        /// line endings).
        /// When using this field, `id` should be left blank.  The BinAuthz API
        /// handlers will calculate the ID and fill it in automatically.  BinAuthz
        /// computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as
        /// upper-case hex.  If `id` is provided by the caller, it will be
        /// overwritten by the API-calculated ID.
        AsciiArmoredPgpPublicKey(std::string::String),
        /// A raw PKIX SubjectPublicKeyInfo format public key.
        ///
        /// NOTE: `id` may be explicitly provided by the caller when using this
        /// type of public key, but it MUST be a valid RFC3986 URI. If `id` is left
        /// blank, a default one will be computed based on the digest of the DER
        /// encoding of the public key.
        PkixPublicKey(std::boxed::Box<crate::model::PkixPublicKey>),
    }
}

/// Request message for [BinauthzManagementService.GetPolicy][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPolicyRequest {
    /// Required. The resource name of the [policy][google.cloud.binaryauthorization.v1.Policy] to retrieve,
    /// in the format `projects/*/policy`.
    ///
    /// [google.cloud.binaryauthorization.v1.Policy]: crate::model::Policy
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.GetPolicyRequest"
    }
}

/// Request message for [BinauthzManagementService.UpdatePolicy][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePolicyRequest {
    /// Required. A new or updated [policy][google.cloud.binaryauthorization.v1.Policy] value. The service will
    /// overwrite the [policy name][google.cloud.binaryauthorization.v1.Policy.name] field with the resource name in
    /// the request URL, in the format `projects/*/policy`.
    ///
    /// [google.cloud.binaryauthorization.v1.Policy]: crate::model::Policy
    /// [google.cloud.binaryauthorization.v1.Policy.name]: crate::model::Policy::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::Policy>,
}

impl UpdatePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::UpdatePolicyRequest::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<crate::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.UpdatePolicyRequest"
    }
}

/// Request message for [BinauthzManagementService.CreateAttestor][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAttestorRequest {
    /// Required. The parent of this [attestor][google.cloud.binaryauthorization.v1.Attestor].
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [attestors][google.cloud.binaryauthorization.v1.Attestor] ID.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attestor_id: std::string::String,

    /// Required. The initial [attestor][google.cloud.binaryauthorization.v1.Attestor] value. The service will
    /// overwrite the [attestor name][google.cloud.binaryauthorization.v1.Attestor.name] field with the resource name,
    /// in the format `projects/*/attestors/*`.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    /// [google.cloud.binaryauthorization.v1.Attestor.name]: crate::model::Attestor::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attestor: std::option::Option<crate::model::Attestor>,
}

impl CreateAttestorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAttestorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [attestor_id][crate::model::CreateAttestorRequest::attestor_id].
    pub fn set_attestor_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attestor_id = v.into();
        self
    }

    /// Sets the value of [attestor][crate::model::CreateAttestorRequest::attestor].
    pub fn set_attestor<T: std::convert::Into<std::option::Option<crate::model::Attestor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.attestor = v.into();
        self
    }
}

impl wkt::message::Message for CreateAttestorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.CreateAttestorRequest"
    }
}

/// Request message for [BinauthzManagementService.GetAttestor][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAttestorRequest {
    /// Required. The name of the [attestor][google.cloud.binaryauthorization.v1.Attestor] to retrieve, in the format
    /// `projects/*/attestors/*`.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAttestorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttestorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttestorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.GetAttestorRequest"
    }
}

/// Request message for [BinauthzManagementService.UpdateAttestor][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAttestorRequest {
    /// Required. The updated [attestor][google.cloud.binaryauthorization.v1.Attestor] value. The service will
    /// overwrite the [attestor name][google.cloud.binaryauthorization.v1.Attestor.name] field with the resource name
    /// in the request URL, in the format `projects/*/attestors/*`.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    /// [google.cloud.binaryauthorization.v1.Attestor.name]: crate::model::Attestor::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attestor: std::option::Option<crate::model::Attestor>,
}

impl UpdateAttestorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attestor][crate::model::UpdateAttestorRequest::attestor].
    pub fn set_attestor<T: std::convert::Into<std::option::Option<crate::model::Attestor>>>(
        mut self,
        v: T,
    ) -> Self {
        self.attestor = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAttestorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.UpdateAttestorRequest"
    }
}

/// Request message for [BinauthzManagementService.ListAttestors][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttestorsRequest {
    /// Required. The resource name of the project associated with the
    /// [attestors][google.cloud.binaryauthorization.v1.Attestor], in the format `projects/*`.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server may return fewer results than requested. If
    /// unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return. Typically,
    /// this is the value of [ListAttestorsResponse.next_page_token][google.cloud.binaryauthorization.v1.ListAttestorsResponse.next_page_token] returned
    /// from the previous call to the `ListAttestors` method.
    ///
    /// [google.cloud.binaryauthorization.v1.ListAttestorsResponse.next_page_token]: crate::model::ListAttestorsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAttestorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttestorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttestorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttestorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttestorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.ListAttestorsRequest"
    }
}

/// Response message for [BinauthzManagementService.ListAttestors][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttestorsResponse {
    /// The list of [attestors][google.cloud.binaryauthorization.v1.Attestor].
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attestors: std::vec::Vec<crate::model::Attestor>,

    /// A token to retrieve the next page of results. Pass this value in the
    /// [ListAttestorsRequest.page_token][google.cloud.binaryauthorization.v1.ListAttestorsRequest.page_token] field in the subsequent call to the
    /// `ListAttestors` method to retrieve the next page of results.
    ///
    /// [google.cloud.binaryauthorization.v1.ListAttestorsRequest.page_token]: crate::model::ListAttestorsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAttestorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAttestorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [attestors][crate::model::ListAttestorsResponse::attestors].
    pub fn set_attestors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attestor>,
    {
        use std::iter::Iterator;
        self.attestors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAttestorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.ListAttestorsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAttestorsResponse {
    type PageItem = crate::model::Attestor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attestors
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for [BinauthzManagementService.DeleteAttestor][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAttestorRequest {
    /// Required. The name of the [attestors][google.cloud.binaryauthorization.v1.Attestor] to delete, in the format
    /// `projects/*/attestors/*`.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteAttestorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAttestorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAttestorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.DeleteAttestorRequest"
    }
}

/// Request to read the current system policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSystemPolicyRequest {
    /// Required. The resource name, in the format `locations/*/policy`.
    /// Note that the system policy is not associated with a project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSystemPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSystemPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSystemPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.GetSystemPolicyRequest"
    }
}

/// Request message for
/// [ValidationHelperV1.ValidateAttestationOccurrence][google.cloud.binaryauthorization.v1.ValidationHelperV1.ValidateAttestationOccurrence].
///
/// [google.cloud.binaryauthorization.v1.ValidationHelperV1.ValidateAttestationOccurrence]: crate::client::ValidationHelperV1::validate_attestation_occurrence
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidateAttestationOccurrenceRequest {
    /// Required. The resource name of the [Attestor][google.cloud.binaryauthorization.v1.Attestor] of the
    /// [occurrence][grafeas.v1.Occurrence], in the format
    /// `projects/*/attestors/*`.
    ///
    /// [google.cloud.binaryauthorization.v1.Attestor]: crate::model::Attestor
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attestor: std::string::String,

    /// Required. An [AttestationOccurrence][grafeas.v1.AttestationOccurrence] to
    /// be checked that it can be verified by the Attestor. It does not have to be
    /// an existing entity in Container Analysis. It must otherwise be a valid
    /// AttestationOccurrence.
    ///
    /// [grafeas.v1.AttestationOccurrence]: grafeas::model::AttestationOccurrence
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attestation: std::option::Option<grafeas::model::AttestationOccurrence>,

    /// Required. The resource name of the [Note][grafeas.v1.Note] to which the
    /// containing [Occurrence][grafeas.v1.Occurrence] is associated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub occurrence_note: std::string::String,

    /// Required. The URI of the artifact (e.g. container image) that is the
    /// subject of the containing [Occurrence][grafeas.v1.Occurrence].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub occurrence_resource_uri: std::string::String,
}

impl ValidateAttestationOccurrenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attestor][crate::model::ValidateAttestationOccurrenceRequest::attestor].
    pub fn set_attestor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attestor = v.into();
        self
    }

    /// Sets the value of [attestation][crate::model::ValidateAttestationOccurrenceRequest::attestation].
    pub fn set_attestation<
        T: std::convert::Into<std::option::Option<grafeas::model::AttestationOccurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attestation = v.into();
        self
    }

    /// Sets the value of [occurrence_note][crate::model::ValidateAttestationOccurrenceRequest::occurrence_note].
    pub fn set_occurrence_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.occurrence_note = v.into();
        self
    }

    /// Sets the value of [occurrence_resource_uri][crate::model::ValidateAttestationOccurrenceRequest::occurrence_resource_uri].
    pub fn set_occurrence_resource_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.occurrence_resource_uri = v.into();
        self
    }
}

impl wkt::message::Message for ValidateAttestationOccurrenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.ValidateAttestationOccurrenceRequest"
    }
}

/// Response message for
/// [ValidationHelperV1.ValidateAttestationOccurrence][google.cloud.binaryauthorization.v1.ValidationHelperV1.ValidateAttestationOccurrence].
///
/// [google.cloud.binaryauthorization.v1.ValidationHelperV1.ValidateAttestationOccurrence]: crate::client::ValidationHelperV1::validate_attestation_occurrence
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidateAttestationOccurrenceResponse {
    /// The result of the Attestation validation.
    pub result: crate::model::validate_attestation_occurrence_response::Result,

    /// The reason for denial if the Attestation couldn't be validated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub denial_reason: std::string::String,
}

impl ValidateAttestationOccurrenceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ValidateAttestationOccurrenceResponse::result].
    pub fn set_result<
        T: std::convert::Into<crate::model::validate_attestation_occurrence_response::Result>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [denial_reason][crate::model::ValidateAttestationOccurrenceResponse::denial_reason].
    pub fn set_denial_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.denial_reason = v.into();
        self
    }
}

impl wkt::message::Message for ValidateAttestationOccurrenceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.binaryauthorization.v1.ValidateAttestationOccurrenceResponse"
    }
}

/// Defines additional types related to ValidateAttestationOccurrenceResponse
pub mod validate_attestation_occurrence_response {
    #[allow(unused_imports)]
    use super::*;

    /// The enum returned in the "result" field.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Result(i32);

    impl Result {
        /// Unspecified.
        pub const RESULT_UNSPECIFIED: Result = Result::new(0);

        /// The Attestation was able to verified by the Attestor.
        pub const VERIFIED: Result = Result::new(1);

        /// The Attestation was not able to verified by the Attestor.
        pub const ATTESTATION_NOT_VERIFIABLE: Result = Result::new(2);

        /// Creates a new Result instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESULT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("VERIFIED"),
                2 => std::borrow::Cow::Borrowed("ATTESTATION_NOT_VERIFIABLE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESULT_UNSPECIFIED" => std::option::Option::Some(Self::RESULT_UNSPECIFIED),
                "VERIFIED" => std::option::Option::Some(Self::VERIFIED),
                "ATTESTATION_NOT_VERIFIABLE" => {
                    std::option::Option::Some(Self::ATTESTATION_NOT_VERIFIABLE)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            Self::new(0)
        }
    }
}
