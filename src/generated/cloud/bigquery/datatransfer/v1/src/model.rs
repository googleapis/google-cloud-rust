// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A parameter used to define custom fields in a data source definition.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSourceParameter {
    /// Parameter identifier.
    pub param_id: std::string::String,

    /// Parameter display name in the user interface.
    pub display_name: std::string::String,

    /// Parameter description.
    pub description: std::string::String,

    /// Parameter type.
    pub r#type: crate::model::data_source_parameter::Type,

    /// Is parameter required.
    pub required: bool,

    /// Deprecated. This field has no effect.
    pub repeated: bool,

    /// Regular expression which can be used for parameter validation.
    pub validation_regex: std::string::String,

    /// All possible values for the parameter.
    pub allowed_values: std::vec::Vec<std::string::String>,

    /// For integer and double values specifies minimum allowed value.
    pub min_value: std::option::Option<wkt::DoubleValue>,

    /// For integer and double values specifies maximum allowed value.
    pub max_value: std::option::Option<wkt::DoubleValue>,

    /// Deprecated. This field has no effect.
    pub fields: std::vec::Vec<crate::model::DataSourceParameter>,

    /// Description of the requirements for this field, in case the user input does
    /// not fulfill the regex pattern or min/max values.
    pub validation_description: std::string::String,

    /// URL to a help document to further explain the naming requirements.
    pub validation_help_url: std::string::String,

    /// Cannot be changed after initial creation.
    pub immutable: bool,

    /// Deprecated. This field has no effect.
    pub recurse: bool,

    /// If true, it should not be used in new transfers, and it should not be
    /// visible to users.
    pub deprecated: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSourceParameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [param_id][crate::model::DataSourceParameter::param_id].
    pub fn set_param_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.param_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataSourceParameter::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataSourceParameter::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataSourceParameter::type].
    pub fn set_type<T: std::convert::Into<crate::model::data_source_parameter::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [required][crate::model::DataSourceParameter::required].
    pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.required = v.into();
        self
    }

    /// Sets the value of [repeated][crate::model::DataSourceParameter::repeated].
    pub fn set_repeated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.repeated = v.into();
        self
    }

    /// Sets the value of [validation_regex][crate::model::DataSourceParameter::validation_regex].
    pub fn set_validation_regex<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_regex = v.into();
        self
    }

    /// Sets the value of [allowed_values][crate::model::DataSourceParameter::allowed_values].
    pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_value][crate::model::DataSourceParameter::min_value].
    pub fn set_min_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::DoubleValue>,
    {
        self.min_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_value][crate::model::DataSourceParameter::min_value].
    pub fn set_or_clear_min_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::DoubleValue>,
    {
        self.min_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_value][crate::model::DataSourceParameter::max_value].
    pub fn set_max_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::DoubleValue>,
    {
        self.max_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_value][crate::model::DataSourceParameter::max_value].
    pub fn set_or_clear_max_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::DoubleValue>,
    {
        self.max_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fields][crate::model::DataSourceParameter::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSourceParameter>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [validation_description][crate::model::DataSourceParameter::validation_description].
    pub fn set_validation_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_description = v.into();
        self
    }

    /// Sets the value of [validation_help_url][crate::model::DataSourceParameter::validation_help_url].
    pub fn set_validation_help_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_help_url = v.into();
        self
    }

    /// Sets the value of [immutable][crate::model::DataSourceParameter::immutable].
    pub fn set_immutable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.immutable = v.into();
        self
    }

    /// Sets the value of [recurse][crate::model::DataSourceParameter::recurse].
    pub fn set_recurse<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.recurse = v.into();
        self
    }

    /// Sets the value of [deprecated][crate::model::DataSourceParameter::deprecated].
    pub fn set_deprecated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deprecated = v.into();
        self
    }
}

impl wkt::message::Message for DataSourceParameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.DataSourceParameter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSourceParameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __param_id,
            __display_name,
            __description,
            __type,
            __required,
            __repeated,
            __validation_regex,
            __allowed_values,
            __min_value,
            __max_value,
            __fields,
            __validation_description,
            __validation_help_url,
            __immutable,
            __recurse,
            __deprecated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSourceParameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "paramId" => Ok(__FieldTag::__param_id),
                            "param_id" => Ok(__FieldTag::__param_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "type" => Ok(__FieldTag::__type),
                            "required" => Ok(__FieldTag::__required),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "validationRegex" => Ok(__FieldTag::__validation_regex),
                            "validation_regex" => Ok(__FieldTag::__validation_regex),
                            "allowedValues" => Ok(__FieldTag::__allowed_values),
                            "allowed_values" => Ok(__FieldTag::__allowed_values),
                            "minValue" => Ok(__FieldTag::__min_value),
                            "min_value" => Ok(__FieldTag::__min_value),
                            "maxValue" => Ok(__FieldTag::__max_value),
                            "max_value" => Ok(__FieldTag::__max_value),
                            "fields" => Ok(__FieldTag::__fields),
                            "validationDescription" => Ok(__FieldTag::__validation_description),
                            "validation_description" => Ok(__FieldTag::__validation_description),
                            "validationHelpUrl" => Ok(__FieldTag::__validation_help_url),
                            "validation_help_url" => Ok(__FieldTag::__validation_help_url),
                            "immutable" => Ok(__FieldTag::__immutable),
                            "recurse" => Ok(__FieldTag::__recurse),
                            "deprecated" => Ok(__FieldTag::__deprecated),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSourceParameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSourceParameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__param_id => {
                            if !fields.insert(__FieldTag::__param_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for param_id",
                                ));
                            }
                            result.param_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::data_source_parameter::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__required => {
                            if !fields.insert(__FieldTag::__required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required",
                                ));
                            }
                            result.required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_regex => {
                            if !fields.insert(__FieldTag::__validation_regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_regex",
                                ));
                            }
                            result.validation_regex = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed_values => {
                            if !fields.insert(__FieldTag::__allowed_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_values",
                                ));
                            }
                            result.allowed_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__min_value => {
                            if !fields.insert(__FieldTag::__min_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_value",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_value => {
                            if !fields.insert(__FieldTag::__max_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_value",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataSourceParameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_description => {
                            if !fields.insert(__FieldTag::__validation_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_description",
                                ));
                            }
                            result.validation_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_help_url => {
                            if !fields.insert(__FieldTag::__validation_help_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_help_url",
                                ));
                            }
                            result.validation_help_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__immutable => {
                            if !fields.insert(__FieldTag::__immutable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for immutable",
                                ));
                            }
                            result.immutable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recurse => {
                            if !fields.insert(__FieldTag::__recurse) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurse",
                                ));
                            }
                            result.recurse = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deprecated => {
                            if !fields.insert(__FieldTag::__deprecated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deprecated",
                                ));
                            }
                            result.deprecated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSourceParameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.param_id.is_empty() {
            state.serialize_entry("paramId", &self.param_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.required) {
            state.serialize_entry("required", &self.required)?;
        }
        if !wkt::internal::is_default(&self.repeated) {
            state.serialize_entry("repeated", &self.repeated)?;
        }
        if !self.validation_regex.is_empty() {
            state.serialize_entry("validationRegex", &self.validation_regex)?;
        }
        if !self.allowed_values.is_empty() {
            state.serialize_entry("allowedValues", &self.allowed_values)?;
        }
        if self.min_value.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minValue", &__With(&self.min_value))?;
        }
        if self.max_value.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxValue", &__With(&self.max_value))?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self.validation_description.is_empty() {
            state.serialize_entry("validationDescription", &self.validation_description)?;
        }
        if !self.validation_help_url.is_empty() {
            state.serialize_entry("validationHelpUrl", &self.validation_help_url)?;
        }
        if !wkt::internal::is_default(&self.immutable) {
            state.serialize_entry("immutable", &self.immutable)?;
        }
        if !wkt::internal::is_default(&self.recurse) {
            state.serialize_entry("recurse", &self.recurse)?;
        }
        if !wkt::internal::is_default(&self.deprecated) {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataSourceParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSourceParameter");
        debug_struct.field("param_id", &self.param_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("required", &self.required);
        debug_struct.field("repeated", &self.repeated);
        debug_struct.field("validation_regex", &self.validation_regex);
        debug_struct.field("allowed_values", &self.allowed_values);
        debug_struct.field("min_value", &self.min_value);
        debug_struct.field("max_value", &self.max_value);
        debug_struct.field("fields", &self.fields);
        debug_struct.field("validation_description", &self.validation_description);
        debug_struct.field("validation_help_url", &self.validation_help_url);
        debug_struct.field("immutable", &self.immutable);
        debug_struct.field("recurse", &self.recurse);
        debug_struct.field("deprecated", &self.deprecated);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DataSourceParameter].
pub mod data_source_parameter {
    #[allow(unused_imports)]
    use super::*;

    /// Parameter type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Type unspecified.
        Unspecified,
        /// String parameter.
        String,
        /// Integer parameter (64-bits).
        /// Will be serialized to json as string.
        Integer,
        /// Double precision floating point parameter.
        Double,
        /// Boolean parameter.
        Boolean,
        /// Deprecated. This field has no effect.
        Record,
        /// Page ID for a Google+ Page.
        PlusPage,
        /// List of strings parameter.
        List,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Integer => std::option::Option::Some(2),
                Self::Double => std::option::Option::Some(3),
                Self::Boolean => std::option::Option::Some(4),
                Self::Record => std::option::Option::Some(5),
                Self::PlusPage => std::option::Option::Some(6),
                Self::List => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Integer => std::option::Option::Some("INTEGER"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::Boolean => std::option::Option::Some("BOOLEAN"),
                Self::Record => std::option::Option::Some("RECORD"),
                Self::PlusPage => std::option::Option::Some("PLUS_PAGE"),
                Self::List => std::option::Option::Some("LIST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Integer,
                3 => Self::Double,
                4 => Self::Boolean,
                5 => Self::Record,
                6 => Self::PlusPage,
                7 => Self::List,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "INTEGER" => Self::Integer,
                "DOUBLE" => Self::Double,
                "BOOLEAN" => Self::Boolean,
                "RECORD" => Self::Record,
                "PLUS_PAGE" => Self::PlusPage,
                "LIST" => Self::List,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Integer => serializer.serialize_i32(2),
                Self::Double => serializer.serialize_i32(3),
                Self::Boolean => serializer.serialize_i32(4),
                Self::Record => serializer.serialize_i32(5),
                Self::PlusPage => serializer.serialize_i32(6),
                Self::List => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.bigquery.datatransfer.v1.DataSourceParameter.Type",
            ))
        }
    }
}

/// Defines the properties and custom parameters for a data source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataSource {
    /// Output only. Data source resource name.
    pub name: std::string::String,

    /// Data source id.
    pub data_source_id: std::string::String,

    /// User friendly data source name.
    pub display_name: std::string::String,

    /// User friendly data source description string.
    pub description: std::string::String,

    /// Data source client id which should be used to receive refresh token.
    pub client_id: std::string::String,

    /// Api auth scopes for which refresh token needs to be obtained. These are
    /// scopes needed by a data source to prepare data and ingest them into
    /// BigQuery, e.g., <https://www.googleapis.com/auth/bigquery>
    pub scopes: std::vec::Vec<std::string::String>,

    /// Deprecated. This field has no effect.
    #[deprecated]
    pub transfer_type: crate::model::TransferType,

    /// Deprecated. This field has no effect.
    #[deprecated]
    pub supports_multiple_transfers: bool,

    /// The number of seconds to wait for an update from the data source
    /// before the Data Transfer Service marks the transfer as FAILED.
    pub update_deadline_seconds: i32,

    /// Default data transfer schedule.
    /// Examples of valid schedules include:
    /// `1st,3rd monday of month 15:30`,
    /// `every wed,fri of jan,jun 13:15`, and
    /// `first sunday of quarter 00:00`.
    pub default_schedule: std::string::String,

    /// Specifies whether the data source supports a user defined schedule, or
    /// operates on the default schedule.
    /// When set to `true`, user can override default schedule.
    pub supports_custom_schedule: bool,

    /// Data source parameters.
    pub parameters: std::vec::Vec<crate::model::DataSourceParameter>,

    /// Url for the help document for this data source.
    pub help_url: std::string::String,

    /// Indicates the type of authorization.
    pub authorization_type: crate::model::data_source::AuthorizationType,

    /// Specifies whether the data source supports automatic data refresh for the
    /// past few days, and how it's supported.
    /// For some data sources, data might not be complete until a few days later,
    /// so it's useful to refresh data automatically.
    pub data_refresh_type: crate::model::data_source::DataRefreshType,

    /// Default data refresh window on days.
    /// Only meaningful when `data_refresh_type` = `SLIDING_WINDOW`.
    pub default_data_refresh_window_days: i32,

    /// Disables backfilling and manual run scheduling
    /// for the data source.
    pub manual_runs_disabled: bool,

    /// The minimum interval for scheduler to schedule runs.
    pub minimum_schedule_interval: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataSource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_id][crate::model::DataSource::data_source_id].
    pub fn set_data_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataSource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataSource::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::DataSource::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::DataSource::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transfer_type][crate::model::DataSource::transfer_type].
    #[deprecated]
    pub fn set_transfer_type<T: std::convert::Into<crate::model::TransferType>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_type = v.into();
        self
    }

    /// Sets the value of [supports_multiple_transfers][crate::model::DataSource::supports_multiple_transfers].
    #[deprecated]
    pub fn set_supports_multiple_transfers<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_multiple_transfers = v.into();
        self
    }

    /// Sets the value of [update_deadline_seconds][crate::model::DataSource::update_deadline_seconds].
    pub fn set_update_deadline_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.update_deadline_seconds = v.into();
        self
    }

    /// Sets the value of [default_schedule][crate::model::DataSource::default_schedule].
    pub fn set_default_schedule<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_schedule = v.into();
        self
    }

    /// Sets the value of [supports_custom_schedule][crate::model::DataSource::supports_custom_schedule].
    pub fn set_supports_custom_schedule<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.supports_custom_schedule = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::DataSource::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSourceParameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [help_url][crate::model::DataSource::help_url].
    pub fn set_help_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.help_url = v.into();
        self
    }

    /// Sets the value of [authorization_type][crate::model::DataSource::authorization_type].
    pub fn set_authorization_type<
        T: std::convert::Into<crate::model::data_source::AuthorizationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_type = v.into();
        self
    }

    /// Sets the value of [data_refresh_type][crate::model::DataSource::data_refresh_type].
    pub fn set_data_refresh_type<
        T: std::convert::Into<crate::model::data_source::DataRefreshType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_refresh_type = v.into();
        self
    }

    /// Sets the value of [default_data_refresh_window_days][crate::model::DataSource::default_data_refresh_window_days].
    pub fn set_default_data_refresh_window_days<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_data_refresh_window_days = v.into();
        self
    }

    /// Sets the value of [manual_runs_disabled][crate::model::DataSource::manual_runs_disabled].
    pub fn set_manual_runs_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.manual_runs_disabled = v.into();
        self
    }

    /// Sets the value of [minimum_schedule_interval][crate::model::DataSource::minimum_schedule_interval].
    pub fn set_minimum_schedule_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_schedule_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimum_schedule_interval][crate::model::DataSource::minimum_schedule_interval].
    pub fn set_or_clear_minimum_schedule_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_schedule_interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.DataSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_source_id,
            __display_name,
            __description,
            __client_id,
            __scopes,
            __transfer_type,
            __supports_multiple_transfers,
            __update_deadline_seconds,
            __default_schedule,
            __supports_custom_schedule,
            __parameters,
            __help_url,
            __authorization_type,
            __data_refresh_type,
            __default_data_refresh_window_days,
            __manual_runs_disabled,
            __minimum_schedule_interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataSourceId" => Ok(__FieldTag::__data_source_id),
                            "data_source_id" => Ok(__FieldTag::__data_source_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "clientId" => Ok(__FieldTag::__client_id),
                            "client_id" => Ok(__FieldTag::__client_id),
                            "scopes" => Ok(__FieldTag::__scopes),
                            "transferType" => Ok(__FieldTag::__transfer_type),
                            "transfer_type" => Ok(__FieldTag::__transfer_type),
                            "supportsMultipleTransfers" => {
                                Ok(__FieldTag::__supports_multiple_transfers)
                            }
                            "supports_multiple_transfers" => {
                                Ok(__FieldTag::__supports_multiple_transfers)
                            }
                            "updateDeadlineSeconds" => Ok(__FieldTag::__update_deadline_seconds),
                            "update_deadline_seconds" => Ok(__FieldTag::__update_deadline_seconds),
                            "defaultSchedule" => Ok(__FieldTag::__default_schedule),
                            "default_schedule" => Ok(__FieldTag::__default_schedule),
                            "supportsCustomSchedule" => Ok(__FieldTag::__supports_custom_schedule),
                            "supports_custom_schedule" => {
                                Ok(__FieldTag::__supports_custom_schedule)
                            }
                            "parameters" => Ok(__FieldTag::__parameters),
                            "helpUrl" => Ok(__FieldTag::__help_url),
                            "help_url" => Ok(__FieldTag::__help_url),
                            "authorizationType" => Ok(__FieldTag::__authorization_type),
                            "authorization_type" => Ok(__FieldTag::__authorization_type),
                            "dataRefreshType" => Ok(__FieldTag::__data_refresh_type),
                            "data_refresh_type" => Ok(__FieldTag::__data_refresh_type),
                            "defaultDataRefreshWindowDays" => {
                                Ok(__FieldTag::__default_data_refresh_window_days)
                            }
                            "default_data_refresh_window_days" => {
                                Ok(__FieldTag::__default_data_refresh_window_days)
                            }
                            "manualRunsDisabled" => Ok(__FieldTag::__manual_runs_disabled),
                            "manual_runs_disabled" => Ok(__FieldTag::__manual_runs_disabled),
                            "minimumScheduleInterval" => {
                                Ok(__FieldTag::__minimum_schedule_interval)
                            }
                            "minimum_schedule_interval" => {
                                Ok(__FieldTag::__minimum_schedule_interval)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_id => {
                            if !fields.insert(__FieldTag::__data_source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_id",
                                ));
                            }
                            result.data_source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_id => {
                            if !fields.insert(__FieldTag::__client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_id",
                                ));
                            }
                            result.client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transfer_type => {
                            if !fields.insert(__FieldTag::__transfer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_type",
                                ));
                            }
                            result.transfer_type = map
                                .next_value::<std::option::Option<crate::model::TransferType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supports_multiple_transfers => {
                            if !fields.insert(__FieldTag::__supports_multiple_transfers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supports_multiple_transfers",
                                ));
                            }
                            result.supports_multiple_transfers = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_deadline_seconds => {
                            if !fields.insert(__FieldTag::__update_deadline_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_deadline_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.update_deadline_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__default_schedule => {
                            if !fields.insert(__FieldTag::__default_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_schedule",
                                ));
                            }
                            result.default_schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supports_custom_schedule => {
                            if !fields.insert(__FieldTag::__supports_custom_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supports_custom_schedule",
                                ));
                            }
                            result.supports_custom_schedule = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataSourceParameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__help_url => {
                            if !fields.insert(__FieldTag::__help_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for help_url",
                                ));
                            }
                            result.help_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorization_type => {
                            if !fields.insert(__FieldTag::__authorization_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization_type",
                                ));
                            }
                            result.authorization_type =
                                map.next_value::<std::option::Option<
                                    crate::model::data_source::AuthorizationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_refresh_type => {
                            if !fields.insert(__FieldTag::__data_refresh_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_refresh_type",
                                ));
                            }
                            result.data_refresh_type = map.next_value::<std::option::Option<crate::model::data_source::DataRefreshType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_data_refresh_window_days => {
                            if !fields.insert(__FieldTag::__default_data_refresh_window_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_data_refresh_window_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_data_refresh_window_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__manual_runs_disabled => {
                            if !fields.insert(__FieldTag::__manual_runs_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_runs_disabled",
                                ));
                            }
                            result.manual_runs_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimum_schedule_interval => {
                            if !fields.insert(__FieldTag::__minimum_schedule_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum_schedule_interval",
                                ));
                            }
                            result.minimum_schedule_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data_source_id.is_empty() {
            state.serialize_entry("dataSourceId", &self.data_source_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.client_id.is_empty() {
            state.serialize_entry("clientId", &self.client_id)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !wkt::internal::is_default(&self.transfer_type) {
            state.serialize_entry("transferType", &self.transfer_type)?;
        }
        if !wkt::internal::is_default(&self.supports_multiple_transfers) {
            state.serialize_entry(
                "supportsMultipleTransfers",
                &self.supports_multiple_transfers,
            )?;
        }
        if !wkt::internal::is_default(&self.update_deadline_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "updateDeadlineSeconds",
                &__With(&self.update_deadline_seconds),
            )?;
        }
        if !self.default_schedule.is_empty() {
            state.serialize_entry("defaultSchedule", &self.default_schedule)?;
        }
        if !wkt::internal::is_default(&self.supports_custom_schedule) {
            state.serialize_entry("supportsCustomSchedule", &self.supports_custom_schedule)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.help_url.is_empty() {
            state.serialize_entry("helpUrl", &self.help_url)?;
        }
        if !wkt::internal::is_default(&self.authorization_type) {
            state.serialize_entry("authorizationType", &self.authorization_type)?;
        }
        if !wkt::internal::is_default(&self.data_refresh_type) {
            state.serialize_entry("dataRefreshType", &self.data_refresh_type)?;
        }
        if !wkt::internal::is_default(&self.default_data_refresh_window_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "defaultDataRefreshWindowDays",
                &__With(&self.default_data_refresh_window_days),
            )?;
        }
        if !wkt::internal::is_default(&self.manual_runs_disabled) {
            state.serialize_entry("manualRunsDisabled", &self.manual_runs_disabled)?;
        }
        if self.minimum_schedule_interval.is_some() {
            state.serialize_entry("minimumScheduleInterval", &self.minimum_schedule_interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSource");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_source_id", &self.data_source_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("scopes", &self.scopes);
        debug_struct.field("transfer_type", &self.transfer_type);
        debug_struct.field(
            "supports_multiple_transfers",
            &self.supports_multiple_transfers,
        );
        debug_struct.field("update_deadline_seconds", &self.update_deadline_seconds);
        debug_struct.field("default_schedule", &self.default_schedule);
        debug_struct.field("supports_custom_schedule", &self.supports_custom_schedule);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("help_url", &self.help_url);
        debug_struct.field("authorization_type", &self.authorization_type);
        debug_struct.field("data_refresh_type", &self.data_refresh_type);
        debug_struct.field(
            "default_data_refresh_window_days",
            &self.default_data_refresh_window_days,
        );
        debug_struct.field("manual_runs_disabled", &self.manual_runs_disabled);
        debug_struct.field("minimum_schedule_interval", &self.minimum_schedule_interval);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// The type of authorization needed for this data source.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthorizationType {
        /// Type unspecified.
        Unspecified,
        /// Use OAuth 2 authorization codes that can be exchanged
        /// for a refresh token on the backend.
        AuthorizationCode,
        /// Return an authorization code for a given Google+ page that can then be
        /// exchanged for a refresh token on the backend.
        GooglePlusAuthorizationCode,
        /// Use First Party OAuth.
        FirstPartyOauth,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AuthorizationType::value] or
        /// [AuthorizationType::name].
        UnknownValue(authorization_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authorization_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AuthorizationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AuthorizationCode => std::option::Option::Some(1),
                Self::GooglePlusAuthorizationCode => std::option::Option::Some(2),
                Self::FirstPartyOauth => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHORIZATION_TYPE_UNSPECIFIED"),
                Self::AuthorizationCode => std::option::Option::Some("AUTHORIZATION_CODE"),
                Self::GooglePlusAuthorizationCode => {
                    std::option::Option::Some("GOOGLE_PLUS_AUTHORIZATION_CODE")
                }
                Self::FirstPartyOauth => std::option::Option::Some("FIRST_PARTY_OAUTH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AuthorizationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AuthorizationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AuthorizationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AuthorizationCode,
                2 => Self::GooglePlusAuthorizationCode,
                3 => Self::FirstPartyOauth,
                _ => Self::UnknownValue(authorization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AuthorizationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHORIZATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTHORIZATION_CODE" => Self::AuthorizationCode,
                "GOOGLE_PLUS_AUTHORIZATION_CODE" => Self::GooglePlusAuthorizationCode,
                "FIRST_PARTY_OAUTH" => Self::FirstPartyOauth,
                _ => Self::UnknownValue(authorization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AuthorizationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AuthorizationCode => serializer.serialize_i32(1),
                Self::GooglePlusAuthorizationCode => serializer.serialize_i32(2),
                Self::FirstPartyOauth => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AuthorizationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthorizationType>::new(
                ".google.cloud.bigquery.datatransfer.v1.DataSource.AuthorizationType",
            ))
        }
    }

    /// Represents how the data source supports data auto refresh.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataRefreshType {
        /// The data source won't support data auto refresh, which is default value.
        Unspecified,
        /// The data source supports data auto refresh, and runs will be scheduled
        /// for the past few days. Does not allow custom values to be set for each
        /// transfer config.
        SlidingWindow,
        /// The data source supports data auto refresh, and runs will be scheduled
        /// for the past few days. Allows custom values to be set for each transfer
        /// config.
        CustomSlidingWindow,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataRefreshType::value] or
        /// [DataRefreshType::name].
        UnknownValue(data_refresh_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_refresh_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataRefreshType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SlidingWindow => std::option::Option::Some(1),
                Self::CustomSlidingWindow => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_REFRESH_TYPE_UNSPECIFIED"),
                Self::SlidingWindow => std::option::Option::Some("SLIDING_WINDOW"),
                Self::CustomSlidingWindow => std::option::Option::Some("CUSTOM_SLIDING_WINDOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataRefreshType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataRefreshType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataRefreshType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SlidingWindow,
                2 => Self::CustomSlidingWindow,
                _ => Self::UnknownValue(data_refresh_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataRefreshType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_REFRESH_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SLIDING_WINDOW" => Self::SlidingWindow,
                "CUSTOM_SLIDING_WINDOW" => Self::CustomSlidingWindow,
                _ => Self::UnknownValue(data_refresh_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataRefreshType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SlidingWindow => serializer.serialize_i32(1),
                Self::CustomSlidingWindow => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataRefreshType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataRefreshType>::new(
                ".google.cloud.bigquery.datatransfer.v1.DataSource.DataRefreshType",
            ))
        }
    }
}

/// A request to get data source info.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDataSourceRequest {
    /// Required. The field will contain name of the resource requested, for
    /// example: `projects/{project_id}/dataSources/{data_source_id}` or
    /// `projects/{project_id}/locations/{location_id}/dataSources/{data_source_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.GetDataSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDataSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDataSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDataSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDataSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDataSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDataSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDataSourceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list supported data sources and their data transfer settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSourcesRequest {
    /// Required. The BigQuery project id for which data sources should be
    /// returned. Must be in the form: `projects/{project_id}` or
    /// `projects/{project_id}/locations/{location_id}`
    pub parent: std::string::String,

    /// Pagination token, which can be used to request a specific page
    /// of `ListDataSourcesRequest` list results. For multiple-page
    /// results, `ListDataSourcesResponse` outputs
    /// a `next_page` token, which can be used as the
    /// `page_token` value to request the next page of list results.
    pub page_token: std::string::String,

    /// Page size. The default page size is the maximum value of 1000 results.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListDataSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDataSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDataSourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Returns list of supported data sources and their metadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDataSourcesResponse {
    /// List of supported data sources and their transfer settings.
    pub data_sources: std::vec::Vec<crate::model::DataSource>,

    /// Output only. The next-pagination token. For multiple-page list results,
    /// this token can be used as the
    /// `ListDataSourcesRequest.page_token`
    /// to request the next page of list results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_sources][crate::model::ListDataSourcesResponse::data_sources].
    pub fn set_data_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataSource>,
    {
        use std::iter::Iterator;
        self.data_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListDataSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataSourcesResponse {
    type PageItem = crate::model::DataSource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDataSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_sources,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDataSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataSources" => Ok(__FieldTag::__data_sources),
                            "data_sources" => Ok(__FieldTag::__data_sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDataSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDataSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_sources => {
                            if !fields.insert(__FieldTag::__data_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_sources",
                                ));
                            }
                            result.data_sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataSource>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDataSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_sources.is_empty() {
            state.serialize_entry("dataSources", &self.data_sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDataSourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDataSourcesResponse");
        debug_struct.field("data_sources", &self.data_sources);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to create a data transfer configuration. If new credentials are
/// needed for this transfer configuration, authorization info must be provided.
/// If authorization info is provided, the transfer configuration will be
/// associated with the user id corresponding to the authorization info.
/// Otherwise, the transfer configuration will be associated with the calling
/// user.
///
/// When using a cross project service account for creating a transfer config,
/// you must enable cross project service account usage. For more information,
/// see [Disable attachment of service accounts to resources in other
/// projects](https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_cross_project_service_accounts).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTransferConfigRequest {
    /// Required. The BigQuery project id where the transfer configuration should
    /// be created. Must be in the format
    /// projects/{project_id}/locations/{location_id} or projects/{project_id}. If
    /// specified location and location of the destination bigquery dataset do not
    /// match - the request will fail.
    pub parent: std::string::String,

    /// Required. Data transfer configuration to create.
    pub transfer_config: std::option::Option<crate::model::TransferConfig>,

    /// Deprecated: Authorization code was required when
    /// `transferConfig.dataSourceId` is 'youtube_channel' but it is no longer used
    /// in any data sources. Use `version_info` instead.
    ///
    /// Optional OAuth2 authorization code to use with this transfer configuration.
    /// This is required only if `transferConfig.dataSourceId` is 'youtube_channel'
    /// and new credentials are needed, as indicated by `CheckValidCreds`. In order
    /// to obtain authorization_code, make a request to the following URL:
    ///
    /// * The \<var\>client_id\</var\> is the OAuth client_id of the data source as
    ///   returned by ListDataSources method.
    /// * \<var\>data_source_scopes\</var\> are the scopes returned by ListDataSources
    ///   method.
    ///
    /// Note that this should not be set when `service_account_name` is used to
    /// create the transfer config.
    #[deprecated]
    pub authorization_code: std::string::String,

    /// Optional version info. This parameter replaces `authorization_code` which
    /// is no longer used in any data sources. This is required only if
    /// `transferConfig.dataSourceId` is 'youtube_channel' *or* new credentials
    /// are needed, as indicated by `CheckValidCreds`. In order to obtain version
    /// info, make a request to the following URL:
    ///
    /// * The \<var\>client_id\</var\> is the OAuth client_id of the data source as
    ///   returned by ListDataSources method.
    /// * \<var\>data_source_scopes\</var\> are the scopes returned by ListDataSources
    ///   method.
    ///
    /// Note that this should not be set when `service_account_name` is used to
    /// create the transfer config.
    pub version_info: std::string::String,

    /// Optional service account email. If this field is set, the transfer config
    /// will be created with this service account's credentials. It requires that
    /// the requesting user calling this API has permissions to act as this service
    /// account.
    ///
    /// Note that not all data sources support service account credentials when
    /// creating a transfer config. For the latest list of data sources, read about
    /// [using service
    /// accounts](https://cloud.google.com/bigquery-transfer/docs/use-service-accounts).
    pub service_account_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTransferConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTransferConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [transfer_config][crate::model::CreateTransferConfigRequest::transfer_config].
    pub fn set_transfer_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferConfig>,
    {
        self.transfer_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_config][crate::model::CreateTransferConfigRequest::transfer_config].
    pub fn set_or_clear_transfer_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferConfig>,
    {
        self.transfer_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization_code][crate::model::CreateTransferConfigRequest::authorization_code].
    #[deprecated]
    pub fn set_authorization_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_code = v.into();
        self
    }

    /// Sets the value of [version_info][crate::model::CreateTransferConfigRequest::version_info].
    pub fn set_version_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_info = v.into();
        self
    }

    /// Sets the value of [service_account_name][crate::model::CreateTransferConfigRequest::service_account_name].
    pub fn set_service_account_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_name = v.into();
        self
    }
}

impl wkt::message::Message for CreateTransferConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.CreateTransferConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTransferConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __transfer_config,
            __authorization_code,
            __version_info,
            __service_account_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTransferConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "transferConfig" => Ok(__FieldTag::__transfer_config),
                            "transfer_config" => Ok(__FieldTag::__transfer_config),
                            "authorizationCode" => Ok(__FieldTag::__authorization_code),
                            "authorization_code" => Ok(__FieldTag::__authorization_code),
                            "versionInfo" => Ok(__FieldTag::__version_info),
                            "version_info" => Ok(__FieldTag::__version_info),
                            "serviceAccountName" => Ok(__FieldTag::__service_account_name),
                            "service_account_name" => Ok(__FieldTag::__service_account_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTransferConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTransferConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_config => {
                            if !fields.insert(__FieldTag::__transfer_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_config",
                                ));
                            }
                            result.transfer_config = map
                                .next_value::<std::option::Option<crate::model::TransferConfig>>(
                                )?;
                        }
                        __FieldTag::__authorization_code => {
                            if !fields.insert(__FieldTag::__authorization_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization_code",
                                ));
                            }
                            result.authorization_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_info => {
                            if !fields.insert(__FieldTag::__version_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_info",
                                ));
                            }
                            result.version_info = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_name => {
                            if !fields.insert(__FieldTag::__service_account_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_name",
                                ));
                            }
                            result.service_account_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTransferConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.transfer_config.is_some() {
            state.serialize_entry("transferConfig", &self.transfer_config)?;
        }
        if !self.authorization_code.is_empty() {
            state.serialize_entry("authorizationCode", &self.authorization_code)?;
        }
        if !self.version_info.is_empty() {
            state.serialize_entry("versionInfo", &self.version_info)?;
        }
        if !self.service_account_name.is_empty() {
            state.serialize_entry("serviceAccountName", &self.service_account_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTransferConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTransferConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("transfer_config", &self.transfer_config);
        debug_struct.field("authorization_code", &self.authorization_code);
        debug_struct.field("version_info", &self.version_info);
        debug_struct.field("service_account_name", &self.service_account_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update a transfer configuration. To update the user id of the
/// transfer configuration, authorization info needs to be provided.
///
/// When using a cross project service account for updating a transfer config,
/// you must enable cross project service account usage. For more information,
/// see [Disable attachment of service accounts to resources in other
/// projects](https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_cross_project_service_accounts).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTransferConfigRequest {
    /// Required. Data transfer configuration to create.
    pub transfer_config: std::option::Option<crate::model::TransferConfig>,

    /// Deprecated: Authorization code was required when
    /// `transferConfig.dataSourceId` is 'youtube_channel' but it is no longer used
    /// in any data sources. Use `version_info` instead.
    ///
    /// Optional OAuth2 authorization code to use with this transfer configuration.
    /// This is required only if `transferConfig.dataSourceId` is 'youtube_channel'
    /// and new credentials are needed, as indicated by `CheckValidCreds`. In order
    /// to obtain authorization_code, make a request to the following URL:
    ///
    /// * The \<var\>client_id\</var\> is the OAuth client_id of the data source as
    ///   returned by ListDataSources method.
    /// * \<var\>data_source_scopes\</var\> are the scopes returned by ListDataSources
    ///   method.
    ///
    /// Note that this should not be set when `service_account_name` is used to
    /// update the transfer config.
    #[deprecated]
    pub authorization_code: std::string::String,

    /// Required. Required list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional version info. This parameter replaces `authorization_code` which
    /// is no longer used in any data sources. This is required only if
    /// `transferConfig.dataSourceId` is 'youtube_channel' *or* new credentials
    /// are needed, as indicated by `CheckValidCreds`. In order to obtain version
    /// info, make a request to the following URL:
    ///
    /// * The \<var\>client_id\</var\> is the OAuth client_id of the data source as
    ///   returned by ListDataSources method.
    /// * \<var\>data_source_scopes\</var\> are the scopes returned by ListDataSources
    ///   method.
    ///
    /// Note that this should not be set when `service_account_name` is used to
    /// update the transfer config.
    pub version_info: std::string::String,

    /// Optional service account email. If this field is set, the transfer config
    /// will be created with this service account's credentials. It requires that
    /// the requesting user calling this API has permissions to act as this service
    /// account.
    ///
    /// Note that not all data sources support service account credentials when
    /// creating a transfer config. For the latest list of data sources, read about
    /// [using service
    /// accounts](https://cloud.google.com/bigquery-transfer/docs/use-service-accounts).
    pub service_account_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTransferConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_config][crate::model::UpdateTransferConfigRequest::transfer_config].
    pub fn set_transfer_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferConfig>,
    {
        self.transfer_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_config][crate::model::UpdateTransferConfigRequest::transfer_config].
    pub fn set_or_clear_transfer_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferConfig>,
    {
        self.transfer_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization_code][crate::model::UpdateTransferConfigRequest::authorization_code].
    #[deprecated]
    pub fn set_authorization_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTransferConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTransferConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version_info][crate::model::UpdateTransferConfigRequest::version_info].
    pub fn set_version_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_info = v.into();
        self
    }

    /// Sets the value of [service_account_name][crate::model::UpdateTransferConfigRequest::service_account_name].
    pub fn set_service_account_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_name = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTransferConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.UpdateTransferConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTransferConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_config,
            __authorization_code,
            __update_mask,
            __version_info,
            __service_account_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTransferConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferConfig" => Ok(__FieldTag::__transfer_config),
                            "transfer_config" => Ok(__FieldTag::__transfer_config),
                            "authorizationCode" => Ok(__FieldTag::__authorization_code),
                            "authorization_code" => Ok(__FieldTag::__authorization_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "versionInfo" => Ok(__FieldTag::__version_info),
                            "version_info" => Ok(__FieldTag::__version_info),
                            "serviceAccountName" => Ok(__FieldTag::__service_account_name),
                            "service_account_name" => Ok(__FieldTag::__service_account_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTransferConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTransferConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_config => {
                            if !fields.insert(__FieldTag::__transfer_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_config",
                                ));
                            }
                            result.transfer_config = map
                                .next_value::<std::option::Option<crate::model::TransferConfig>>(
                                )?;
                        }
                        __FieldTag::__authorization_code => {
                            if !fields.insert(__FieldTag::__authorization_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization_code",
                                ));
                            }
                            result.authorization_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__version_info => {
                            if !fields.insert(__FieldTag::__version_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_info",
                                ));
                            }
                            result.version_info = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_name => {
                            if !fields.insert(__FieldTag::__service_account_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_name",
                                ));
                            }
                            result.service_account_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTransferConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transfer_config.is_some() {
            state.serialize_entry("transferConfig", &self.transfer_config)?;
        }
        if !self.authorization_code.is_empty() {
            state.serialize_entry("authorizationCode", &self.authorization_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.version_info.is_empty() {
            state.serialize_entry("versionInfo", &self.version_info)?;
        }
        if !self.service_account_name.is_empty() {
            state.serialize_entry("serviceAccountName", &self.service_account_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTransferConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTransferConfigRequest");
        debug_struct.field("transfer_config", &self.transfer_config);
        debug_struct.field("authorization_code", &self.authorization_code);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("version_info", &self.version_info);
        debug_struct.field("service_account_name", &self.service_account_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get data transfer information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTransferConfigRequest {
    /// Required. The field will contain name of the resource requested, for
    /// example: `projects/{project_id}/transferConfigs/{config_id}` or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTransferConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTransferConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTransferConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.GetTransferConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTransferConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTransferConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTransferConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTransferConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTransferConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTransferConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTransferConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete data transfer information. All associated transfer runs
/// and log messages will be deleted as well.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTransferConfigRequest {
    /// Required. The field will contain name of the resource requested, for
    /// example: `projects/{project_id}/transferConfigs/{config_id}` or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTransferConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTransferConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTransferConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.DeleteTransferConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTransferConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTransferConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTransferConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTransferConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTransferConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTransferConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTransferConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get data transfer run information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTransferRunRequest {
    /// Required. The field will contain name of the resource requested, for
    /// example: `projects/{project_id}/transferConfigs/{config_id}/runs/{run_id}`
    /// or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}/runs/{run_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTransferRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTransferRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTransferRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.GetTransferRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTransferRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTransferRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTransferRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTransferRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTransferRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTransferRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTransferRunRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to delete data transfer run information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTransferRunRequest {
    /// Required. The field will contain name of the resource requested, for
    /// example: `projects/{project_id}/transferConfigs/{config_id}/runs/{run_id}`
    /// or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}/runs/{run_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTransferRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTransferRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTransferRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.DeleteTransferRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTransferRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTransferRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTransferRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTransferRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTransferRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTransferRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTransferRunRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to list data transfers configured for a BigQuery project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferConfigsRequest {
    /// Required. The BigQuery project id for which transfer configs
    /// should be returned: `projects/{project_id}` or
    /// `projects/{project_id}/locations/{location_id}`
    pub parent: std::string::String,

    /// When specified, only configurations of requested data sources are returned.
    pub data_source_ids: std::vec::Vec<std::string::String>,

    /// Pagination token, which can be used to request a specific page
    /// of `ListTransfersRequest` list results. For multiple-page
    /// results, `ListTransfersResponse` outputs
    /// a `next_page` token, which can be used as the
    /// `page_token` value to request the next page of list results.
    pub page_token: std::string::String,

    /// Page size. The default page size is the maximum value of 1000 results.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTransferConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_source_ids][crate::model::ListTransferConfigsRequest::data_source_ids].
    pub fn set_data_source_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_source_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTransferConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTransferConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListTransferConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __data_source_ids,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataSourceIds" => Ok(__FieldTag::__data_source_ids),
                            "data_source_ids" => Ok(__FieldTag::__data_source_ids),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_ids => {
                            if !fields.insert(__FieldTag::__data_source_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_ids",
                                ));
                            }
                            result.data_source_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.data_source_ids.is_empty() {
            state.serialize_entry("dataSourceIds", &self.data_source_ids)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("data_source_ids", &self.data_source_ids);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The returned list of pipelines in the project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferConfigsResponse {
    /// Output only. The stored pipeline transfer configurations.
    pub transfer_configs: std::vec::Vec<crate::model::TransferConfig>,

    /// Output only. The next-pagination token. For multiple-page list results,
    /// this token can be used as the
    /// `ListTransferConfigsRequest.page_token`
    /// to request the next page of list results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_configs][crate::model::ListTransferConfigsResponse::transfer_configs].
    pub fn set_transfer_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferConfig>,
    {
        use std::iter::Iterator;
        self.transfer_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTransferConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListTransferConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTransferConfigsResponse {
    type PageItem = crate::model::TransferConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.transfer_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferConfigs" => Ok(__FieldTag::__transfer_configs),
                            "transfer_configs" => Ok(__FieldTag::__transfer_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_configs => {
                            if !fields.insert(__FieldTag::__transfer_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_configs",
                                ));
                            }
                            result.transfer_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransferConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transfer_configs.is_empty() {
            state.serialize_entry("transferConfigs", &self.transfer_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferConfigsResponse");
        debug_struct.field("transfer_configs", &self.transfer_configs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to list data transfer runs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferRunsRequest {
    /// Required. Name of transfer configuration for which transfer runs should be
    /// retrieved. Format of transfer configuration resource name is:
    /// `projects/{project_id}/transferConfigs/{config_id}` or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}`.
    pub parent: std::string::String,

    /// When specified, only transfer runs with requested states are returned.
    pub states: std::vec::Vec<crate::model::TransferState>,

    /// Pagination token, which can be used to request a specific page
    /// of `ListTransferRunsRequest` list results. For multiple-page
    /// results, `ListTransferRunsResponse` outputs
    /// a `next_page` token, which can be used as the
    /// `page_token` value to request the next page of list results.
    pub page_token: std::string::String,

    /// Page size. The default page size is the maximum value of 1000 results.
    pub page_size: i32,

    /// Indicates how run attempts are to be pulled.
    pub run_attempt: crate::model::list_transfer_runs_request::RunAttempt,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTransferRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [states][crate::model::ListTransferRunsRequest::states].
    pub fn set_states<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferState>,
    {
        use std::iter::Iterator;
        self.states = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTransferRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTransferRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [run_attempt][crate::model::ListTransferRunsRequest::run_attempt].
    pub fn set_run_attempt<
        T: std::convert::Into<crate::model::list_transfer_runs_request::RunAttempt>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.run_attempt = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListTransferRunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferRunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __states,
            __page_token,
            __page_size,
            __run_attempt,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferRunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "states" => Ok(__FieldTag::__states),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "runAttempt" => Ok(__FieldTag::__run_attempt),
                            "run_attempt" => Ok(__FieldTag::__run_attempt),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferRunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferRunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__states => {
                            if !fields.insert(__FieldTag::__states) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for states",
                                ));
                            }
                            result.states = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TransferState>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__run_attempt => {
                            if !fields.insert(__FieldTag::__run_attempt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_attempt",
                                ));
                            }
                            result.run_attempt = map
                                .next_value::<std::option::Option<
                                    crate::model::list_transfer_runs_request::RunAttempt,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferRunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.states.is_empty() {
            state.serialize_entry("states", &self.states)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !wkt::internal::is_default(&self.run_attempt) {
            state.serialize_entry("runAttempt", &self.run_attempt)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferRunsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferRunsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("states", &self.states);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("run_attempt", &self.run_attempt);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ListTransferRunsRequest].
pub mod list_transfer_runs_request {
    #[allow(unused_imports)]
    use super::*;

    /// Represents which runs should be pulled.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RunAttempt {
        /// All runs should be returned.
        Unspecified,
        /// Only latest run per day should be returned.
        Latest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RunAttempt::value] or
        /// [RunAttempt::name].
        UnknownValue(run_attempt::UnknownValue),
    }

    #[doc(hidden)]
    pub mod run_attempt {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RunAttempt {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Latest => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RUN_ATTEMPT_UNSPECIFIED"),
                Self::Latest => std::option::Option::Some("LATEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RunAttempt {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RunAttempt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RunAttempt {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Latest,
                _ => Self::UnknownValue(run_attempt::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RunAttempt {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RUN_ATTEMPT_UNSPECIFIED" => Self::Unspecified,
                "LATEST" => Self::Latest,
                _ => Self::UnknownValue(run_attempt::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RunAttempt {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Latest => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RunAttempt {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RunAttempt>::new(
                ".google.cloud.bigquery.datatransfer.v1.ListTransferRunsRequest.RunAttempt",
            ))
        }
    }
}

/// The returned list of pipelines in the project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferRunsResponse {
    /// Output only. The stored pipeline transfer runs.
    pub transfer_runs: std::vec::Vec<crate::model::TransferRun>,

    /// Output only. The next-pagination token. For multiple-page list results,
    /// this token can be used as the
    /// `ListTransferRunsRequest.page_token`
    /// to request the next page of list results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_runs][crate::model::ListTransferRunsResponse::transfer_runs].
    pub fn set_transfer_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferRun>,
    {
        use std::iter::Iterator;
        self.transfer_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTransferRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListTransferRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTransferRunsResponse {
    type PageItem = crate::model::TransferRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.transfer_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferRunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_runs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferRunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferRuns" => Ok(__FieldTag::__transfer_runs),
                            "transfer_runs" => Ok(__FieldTag::__transfer_runs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferRunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferRunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_runs => {
                            if !fields.insert(__FieldTag::__transfer_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_runs",
                                ));
                            }
                            result.transfer_runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TransferRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferRunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transfer_runs.is_empty() {
            state.serialize_entry("transferRuns", &self.transfer_runs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferRunsResponse");
        debug_struct.field("transfer_runs", &self.transfer_runs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get user facing log messages associated with data transfer run.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferLogsRequest {
    /// Required. Transfer run name in the form:
    /// `projects/{project_id}/transferConfigs/{config_id}/runs/{run_id}` or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}/runs/{run_id}`
    pub parent: std::string::String,

    /// Pagination token, which can be used to request a specific page
    /// of `ListTransferLogsRequest` list results. For multiple-page
    /// results, `ListTransferLogsResponse` outputs
    /// a `next_page` token, which can be used as the
    /// `page_token` value to request the next page of list results.
    pub page_token: std::string::String,

    /// Page size. The default page size is the maximum value of 1000 results.
    pub page_size: i32,

    /// Message types to return. If not populated - INFO, WARNING and ERROR
    /// messages are returned.
    pub message_types: std::vec::Vec<crate::model::transfer_message::MessageSeverity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferLogsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTransferLogsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTransferLogsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTransferLogsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [message_types][crate::model::ListTransferLogsRequest::message_types].
    pub fn set_message_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transfer_message::MessageSeverity>,
    {
        use std::iter::Iterator;
        self.message_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTransferLogsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListTransferLogsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferLogsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __message_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferLogsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "messageTypes" => Ok(__FieldTag::__message_types),
                            "message_types" => Ok(__FieldTag::__message_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferLogsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferLogsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__message_types => {
                            if !fields.insert(__FieldTag::__message_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_types",
                                ));
                            }
                            result.message_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::transfer_message::MessageSeverity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferLogsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.message_types.is_empty() {
            state.serialize_entry("messageTypes", &self.message_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferLogsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferLogsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("message_types", &self.message_types);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The returned list transfer run messages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransferLogsResponse {
    /// Output only. The stored pipeline transfer messages.
    pub transfer_messages: std::vec::Vec<crate::model::TransferMessage>,

    /// Output only. The next-pagination token. For multiple-page list results,
    /// this token can be used as the
    /// `GetTransferRunLogRequest.page_token`
    /// to request the next page of list results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTransferLogsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_messages][crate::model::ListTransferLogsResponse::transfer_messages].
    pub fn set_transfer_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferMessage>,
    {
        use std::iter::Iterator;
        self.transfer_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTransferLogsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTransferLogsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ListTransferLogsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTransferLogsResponse {
    type PageItem = crate::model::TransferMessage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.transfer_messages
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransferLogsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_messages,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransferLogsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferMessages" => Ok(__FieldTag::__transfer_messages),
                            "transfer_messages" => Ok(__FieldTag::__transfer_messages),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransferLogsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransferLogsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_messages => {
                            if !fields.insert(__FieldTag::__transfer_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_messages",
                                ));
                            }
                            result.transfer_messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransferMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTransferLogsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transfer_messages.is_empty() {
            state.serialize_entry("transferMessages", &self.transfer_messages)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTransferLogsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTransferLogsResponse");
        debug_struct.field("transfer_messages", &self.transfer_messages);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to determine whether the user has valid credentials. This method
/// is used to limit the number of OAuth popups in the user interface. The
/// user id is inferred from the API call context.
/// If the data source has the Google+ authorization type, this method
/// returns false, as it cannot be determined whether the credentials are
/// already valid merely based on the user id.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckValidCredsRequest {
    /// Required. The data source in the form:
    /// `projects/{project_id}/dataSources/{data_source_id}` or
    /// `projects/{project_id}/locations/{location_id}/dataSources/{data_source_id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckValidCredsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CheckValidCredsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CheckValidCredsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.CheckValidCredsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckValidCredsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckValidCredsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckValidCredsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckValidCredsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckValidCredsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckValidCredsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckValidCredsRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response indicating whether the credentials exist and are valid.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckValidCredsResponse {
    /// If set to `true`, the credentials exist and are valid.
    pub has_valid_creds: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckValidCredsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [has_valid_creds][crate::model::CheckValidCredsResponse::has_valid_creds].
    pub fn set_has_valid_creds<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_valid_creds = v.into();
        self
    }
}

impl wkt::message::Message for CheckValidCredsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.CheckValidCredsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckValidCredsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __has_valid_creds,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckValidCredsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hasValidCreds" => Ok(__FieldTag::__has_valid_creds),
                            "has_valid_creds" => Ok(__FieldTag::__has_valid_creds),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckValidCredsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckValidCredsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__has_valid_creds => {
                            if !fields.insert(__FieldTag::__has_valid_creds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_valid_creds",
                                ));
                            }
                            result.has_valid_creds = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckValidCredsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.has_valid_creds) {
            state.serialize_entry("hasValidCreds", &self.has_valid_creds)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckValidCredsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckValidCredsResponse");
        debug_struct.field("has_valid_creds", &self.has_valid_creds);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to schedule transfer runs for a time range.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduleTransferRunsRequest {
    /// Required. Transfer configuration name in the form:
    /// `projects/{project_id}/transferConfigs/{config_id}` or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}`.
    pub parent: std::string::String,

    /// Required. Start time of the range of transfer runs. For example,
    /// `"2017-05-25T00:00:00+00:00"`.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. End time of the range of transfer runs. For example,
    /// `"2017-05-30T00:00:00+00:00"`.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduleTransferRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ScheduleTransferRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScheduleTransferRunsRequest::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ScheduleTransferRunsRequest::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ScheduleTransferRunsRequest::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ScheduleTransferRunsRequest::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ScheduleTransferRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ScheduleTransferRunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScheduleTransferRunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduleTransferRunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScheduleTransferRunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduleTransferRunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScheduleTransferRunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScheduleTransferRunsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduleTransferRunsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response to schedule transfer runs for a time range.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduleTransferRunsResponse {
    /// The transfer runs that were scheduled.
    pub runs: std::vec::Vec<crate::model::TransferRun>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduleTransferRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runs][crate::model::ScheduleTransferRunsResponse::runs].
    pub fn set_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferRun>,
    {
        use std::iter::Iterator;
        self.runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScheduleTransferRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ScheduleTransferRunsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScheduleTransferRunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduleTransferRunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runs" => Ok(__FieldTag::__runs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScheduleTransferRunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduleTransferRunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runs => {
                            if !fields.insert(__FieldTag::__runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runs",
                                ));
                            }
                            result.runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TransferRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScheduleTransferRunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.runs.is_empty() {
            state.serialize_entry("runs", &self.runs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScheduleTransferRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduleTransferRunsResponse");
        debug_struct.field("runs", &self.runs);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to start manual transfer runs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartManualTransferRunsRequest {
    /// Required. Transfer configuration name in the form:
    /// `projects/{project_id}/transferConfigs/{config_id}` or
    /// `projects/{project_id}/locations/{location_id}/transferConfigs/{config_id}`.
    pub parent: std::string::String,

    /// The requested time specification - this can be a time range or a specific
    /// run_time.
    pub time: std::option::Option<crate::model::start_manual_transfer_runs_request::Time>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartManualTransferRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::StartManualTransferRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [time][crate::model::StartManualTransferRunsRequest::time].
    ///
    /// Note that all the setters affecting `time` are mutually
    /// exclusive.
    pub fn set_time<
        T: std::convert::Into<
                std::option::Option<crate::model::start_manual_transfer_runs_request::Time>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time = v.into();
        self
    }

    /// The value of [time][crate::model::StartManualTransferRunsRequest::time]
    /// if it holds a `RequestedTimeRange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn requested_time_range(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::start_manual_transfer_runs_request::TimeRange>,
    > {
        #[allow(unreachable_patterns)]
        self.time.as_ref().and_then(|v| match v {
            crate::model::start_manual_transfer_runs_request::Time::RequestedTimeRange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time][crate::model::StartManualTransferRunsRequest::time]
    /// to hold a `RequestedTimeRange`.
    ///
    /// Note that all the setters affecting `time` are
    /// mutually exclusive.
    pub fn set_requested_time_range<
        T: std::convert::Into<
                std::boxed::Box<crate::model::start_manual_transfer_runs_request::TimeRange>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time = std::option::Option::Some(
            crate::model::start_manual_transfer_runs_request::Time::RequestedTimeRange(v.into()),
        );
        self
    }

    /// The value of [time][crate::model::StartManualTransferRunsRequest::time]
    /// if it holds a `RequestedRunTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn requested_run_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.time.as_ref().and_then(|v| match v {
            crate::model::start_manual_transfer_runs_request::Time::RequestedRunTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time][crate::model::StartManualTransferRunsRequest::time]
    /// to hold a `RequestedRunTime`.
    ///
    /// Note that all the setters affecting `time` are
    /// mutually exclusive.
    pub fn set_requested_run_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time = std::option::Option::Some(
            crate::model::start_manual_transfer_runs_request::Time::RequestedRunTime(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StartManualTransferRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartManualTransferRunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __requested_time_range,
            __requested_run_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartManualTransferRunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requestedTimeRange" => Ok(__FieldTag::__requested_time_range),
                            "requested_time_range" => Ok(__FieldTag::__requested_time_range),
                            "requestedRunTime" => Ok(__FieldTag::__requested_run_time),
                            "requested_run_time" => Ok(__FieldTag::__requested_run_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartManualTransferRunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartManualTransferRunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_time_range => {
                            if !fields.insert(__FieldTag::__requested_time_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_time_range",
                                ));
                            }
                            if result.time.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsRequest.requested_time_range, latest field was requestedTimeRange",
                                ));
                            }
                            result.time = std::option::Option::Some(
                                crate::model::start_manual_transfer_runs_request::Time::RequestedTimeRange(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::start_manual_transfer_runs_request::TimeRange>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__requested_run_time => {
                            if !fields.insert(__FieldTag::__requested_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_run_time",
                                ));
                            }
                            if result.time.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsRequest.requested_run_time, latest field was requestedRunTime",
                                ));
                            }
                            result.time = std::option::Option::Some(
                                crate::model::start_manual_transfer_runs_request::Time::RequestedRunTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartManualTransferRunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.requested_time_range() {
            state.serialize_entry("requestedTimeRange", value)?;
        }
        if let Some(value) = self.requested_run_time() {
            state.serialize_entry("requestedRunTime", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartManualTransferRunsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartManualTransferRunsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("time", &self.time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [StartManualTransferRunsRequest].
pub mod start_manual_transfer_runs_request {
    #[allow(unused_imports)]
    use super::*;

    /// A specification for a time range, this will request transfer runs with
    /// run_time between start_time (inclusive) and end_time (exclusive).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeRange {
        /// Start time of the range of transfer runs. For example,
        /// `"2017-05-25T00:00:00+00:00"`. The start_time must be strictly less than
        /// the end_time. Creates transfer runs where run_time is in the range
        /// between start_time (inclusive) and end_time (exclusive).
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// End time of the range of transfer runs. For example,
        /// `"2017-05-30T00:00:00+00:00"`. The end_time must not be in the future.
        /// Creates transfer runs where run_time is in the range between start_time
        /// (inclusive) and end_time (exclusive).
        pub end_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::start_manual_transfer_runs_request::TimeRange::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::start_manual_transfer_runs_request::TimeRange::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::start_manual_transfer_runs_request::TimeRange::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::start_manual_transfer_runs_request::TimeRange::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TimeRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsRequest.TimeRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                __end_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "endTime" => Ok(__FieldTag::__end_time),
                                "end_time" => Ok(__FieldTag::__end_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__end_time => {
                                if !fields.insert(__FieldTag::__end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time",
                                    ));
                                }
                                result.end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.end_time.is_some() {
                state.serialize_entry("endTime", &self.end_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TimeRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TimeRange");
            debug_struct.field("start_time", &self.start_time);
            debug_struct.field("end_time", &self.end_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The requested time specification - this can be a time range or a specific
    /// run_time.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Time {
        /// A time_range start and end timestamp for historical data files or reports
        /// that are scheduled to be transferred by the scheduled transfer run.
        /// requested_time_range must be a past time and cannot include future time
        /// values.
        RequestedTimeRange(
            std::boxed::Box<crate::model::start_manual_transfer_runs_request::TimeRange>,
        ),
        /// A run_time timestamp for historical data files or reports
        /// that are scheduled to be transferred by the scheduled transfer run.
        /// requested_run_time must be a past time and cannot include future time
        /// values.
        RequestedRunTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// A response to start manual transfer runs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartManualTransferRunsResponse {
    /// The transfer runs that were created.
    pub runs: std::vec::Vec<crate::model::TransferRun>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartManualTransferRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runs][crate::model::StartManualTransferRunsResponse::runs].
    pub fn set_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransferRun>,
    {
        use std::iter::Iterator;
        self.runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StartManualTransferRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartManualTransferRunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartManualTransferRunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runs" => Ok(__FieldTag::__runs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartManualTransferRunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartManualTransferRunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runs => {
                            if !fields.insert(__FieldTag::__runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runs",
                                ));
                            }
                            result.runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TransferRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartManualTransferRunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.runs.is_empty() {
            state.serialize_entry("runs", &self.runs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartManualTransferRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartManualTransferRunsResponse");
        debug_struct.field("runs", &self.runs);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to enroll a set of data sources so they are visible in the
/// BigQuery UI's `Transfer` tab.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnrollDataSourcesRequest {
    /// Required. The name of the project resource in the form:
    /// `projects/{project_id}`
    pub name: std::string::String,

    /// Data sources that are enrolled. It is required to provide at least one
    /// data source id.
    pub data_source_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnrollDataSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnrollDataSourcesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_ids][crate::model::EnrollDataSourcesRequest::data_source_ids].
    pub fn set_data_source_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_source_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EnrollDataSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.EnrollDataSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnrollDataSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_source_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnrollDataSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataSourceIds" => Ok(__FieldTag::__data_source_ids),
                            "data_source_ids" => Ok(__FieldTag::__data_source_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnrollDataSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnrollDataSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_ids => {
                            if !fields.insert(__FieldTag::__data_source_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_ids",
                                ));
                            }
                            result.data_source_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnrollDataSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data_source_ids.is_empty() {
            state.serialize_entry("dataSourceIds", &self.data_source_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnrollDataSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnrollDataSourcesRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_source_ids", &self.data_source_ids);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to unenroll a set of data sources so they are no longer visible in
/// the BigQuery UI's `Transfer` tab.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UnenrollDataSourcesRequest {
    /// Required. The name of the project resource in the form:
    /// `projects/{project_id}`
    pub name: std::string::String,

    /// Data sources that are unenrolled. It is required to provide at least one
    /// data source id.
    pub data_source_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnenrollDataSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UnenrollDataSourcesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source_ids][crate::model::UnenrollDataSourcesRequest::data_source_ids].
    pub fn set_data_source_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_source_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UnenrollDataSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.UnenrollDataSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnenrollDataSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_source_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnenrollDataSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataSourceIds" => Ok(__FieldTag::__data_source_ids),
                            "data_source_ids" => Ok(__FieldTag::__data_source_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnenrollDataSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnenrollDataSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_ids => {
                            if !fields.insert(__FieldTag::__data_source_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_ids",
                                ));
                            }
                            result.data_source_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnenrollDataSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data_source_ids.is_empty() {
            state.serialize_entry("dataSourceIds", &self.data_source_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UnenrollDataSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UnenrollDataSourcesRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_source_ids", &self.data_source_ids);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents preferences for sending email notifications for transfer run
/// events.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EmailPreferences {
    /// If true, email notifications will be sent on transfer run failures.
    pub enable_failure_email: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EmailPreferences {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_failure_email][crate::model::EmailPreferences::enable_failure_email].
    pub fn set_enable_failure_email<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_failure_email = v.into();
        self
    }
}

impl wkt::message::Message for EmailPreferences {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.EmailPreferences"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EmailPreferences {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_failure_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EmailPreferences")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableFailureEmail" => Ok(__FieldTag::__enable_failure_email),
                            "enable_failure_email" => Ok(__FieldTag::__enable_failure_email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EmailPreferences;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EmailPreferences")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_failure_email => {
                            if !fields.insert(__FieldTag::__enable_failure_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_failure_email",
                                ));
                            }
                            result.enable_failure_email = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EmailPreferences {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_failure_email) {
            state.serialize_entry("enableFailureEmail", &self.enable_failure_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EmailPreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EmailPreferences");
        debug_struct.field("enable_failure_email", &self.enable_failure_email);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options customizing the data transfer schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduleOptions {
    /// If true, automatic scheduling of data transfer runs for this configuration
    /// will be disabled. The runs can be started on ad-hoc basis using
    /// StartManualTransferRuns API. When automatic scheduling is disabled, the
    /// TransferConfig.schedule field will be ignored.
    pub disable_auto_scheduling: bool,

    /// Specifies time to start scheduling transfer runs. The first run will be
    /// scheduled at or after the start time according to a recurrence pattern
    /// defined in the schedule string. The start time can be changed at any
    /// moment. The time when a data transfer can be triggered manually is not
    /// limited by this option.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Defines time to stop scheduling transfer runs. A transfer run cannot be
    /// scheduled at or after the end time. The end time can be changed at any
    /// moment. The time when a data transfer can be triggered manually is not
    /// limited by this option.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduleOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_auto_scheduling][crate::model::ScheduleOptions::disable_auto_scheduling].
    pub fn set_disable_auto_scheduling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_auto_scheduling = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ScheduleOptions::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ScheduleOptions::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ScheduleOptions::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ScheduleOptions::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ScheduleOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ScheduleOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScheduleOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disable_auto_scheduling,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduleOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disableAutoScheduling" => Ok(__FieldTag::__disable_auto_scheduling),
                            "disable_auto_scheduling" => Ok(__FieldTag::__disable_auto_scheduling),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScheduleOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduleOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disable_auto_scheduling => {
                            if !fields.insert(__FieldTag::__disable_auto_scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_auto_scheduling",
                                ));
                            }
                            result.disable_auto_scheduling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScheduleOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disable_auto_scheduling) {
            state.serialize_entry("disableAutoScheduling", &self.disable_auto_scheduling)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScheduleOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduleOptions");
        debug_struct.field("disable_auto_scheduling", &self.disable_auto_scheduling);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// V2 options customizing different types of data transfer schedule.
/// This field supports existing time-based and manual transfer schedule. Also
/// supports Event-Driven transfer schedule. ScheduleOptionsV2 cannot be used
/// together with ScheduleOptions/Schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScheduleOptionsV2 {
    /// Data transfer schedules.
    pub schedule: std::option::Option<crate::model::schedule_options_v_2::Schedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScheduleOptionsV2 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule][crate::model::ScheduleOptionsV2::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::schedule_options_v_2::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::ScheduleOptionsV2::schedule]
    /// if it holds a `TimeBasedSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_based_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimeBasedSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::schedule_options_v_2::Schedule::TimeBasedSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::ScheduleOptionsV2::schedule]
    /// to hold a `TimeBasedSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_time_based_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::TimeBasedSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::schedule_options_v_2::Schedule::TimeBasedSchedule(v.into()),
        );
        self
    }

    /// The value of [schedule][crate::model::ScheduleOptionsV2::schedule]
    /// if it holds a `ManualSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn manual_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManualSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::schedule_options_v_2::Schedule::ManualSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::ScheduleOptionsV2::schedule]
    /// to hold a `ManualSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_manual_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::ManualSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::schedule_options_v_2::Schedule::ManualSchedule(v.into()),
        );
        self
    }

    /// The value of [schedule][crate::model::ScheduleOptionsV2::schedule]
    /// if it holds a `EventDrivenSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn event_driven_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EventDrivenSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::schedule_options_v_2::Schedule::EventDrivenSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::ScheduleOptionsV2::schedule]
    /// to hold a `EventDrivenSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_event_driven_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::EventDrivenSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::schedule_options_v_2::Schedule::EventDrivenSchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ScheduleOptionsV2 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ScheduleOptionsV2"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScheduleOptionsV2 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_based_schedule,
            __manual_schedule,
            __event_driven_schedule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScheduleOptionsV2")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeBasedSchedule" => Ok(__FieldTag::__time_based_schedule),
                            "time_based_schedule" => Ok(__FieldTag::__time_based_schedule),
                            "manualSchedule" => Ok(__FieldTag::__manual_schedule),
                            "manual_schedule" => Ok(__FieldTag::__manual_schedule),
                            "eventDrivenSchedule" => Ok(__FieldTag::__event_driven_schedule),
                            "event_driven_schedule" => Ok(__FieldTag::__event_driven_schedule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScheduleOptionsV2;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScheduleOptionsV2")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_based_schedule => {
                            if !fields.insert(__FieldTag::__time_based_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_based_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.ScheduleOptionsV2.time_based_schedule, latest field was timeBasedSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::schedule_options_v_2::Schedule::TimeBasedSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimeBasedSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__manual_schedule => {
                            if !fields.insert(__FieldTag::__manual_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.ScheduleOptionsV2.manual_schedule, latest field was manualSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::schedule_options_v_2::Schedule::ManualSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ManualSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__event_driven_schedule => {
                            if !fields.insert(__FieldTag::__event_driven_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_driven_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.ScheduleOptionsV2.event_driven_schedule, latest field was eventDrivenSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::schedule_options_v_2::Schedule::EventDrivenSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EventDrivenSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScheduleOptionsV2 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.time_based_schedule() {
            state.serialize_entry("timeBasedSchedule", value)?;
        }
        if let Some(value) = self.manual_schedule() {
            state.serialize_entry("manualSchedule", value)?;
        }
        if let Some(value) = self.event_driven_schedule() {
            state.serialize_entry("eventDrivenSchedule", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ScheduleOptionsV2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScheduleOptionsV2");
        debug_struct.field("schedule", &self.schedule);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ScheduleOptionsV2].
pub mod schedule_options_v_2 {
    #[allow(unused_imports)]
    use super::*;

    /// Data transfer schedules.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Time based transfer schedule options. This is the default schedule
        /// option.
        TimeBasedSchedule(std::boxed::Box<crate::model::TimeBasedSchedule>),
        /// Manual transfer schedule. If set, the transfer run will not be
        /// auto-scheduled by the system, unless the client invokes
        /// StartManualTransferRuns.  This is equivalent to
        /// disable_auto_scheduling = true.
        ManualSchedule(std::boxed::Box<crate::model::ManualSchedule>),
        /// Event driven transfer schedule options. If set, the transfer will be
        /// scheduled upon events arrial.
        EventDrivenSchedule(std::boxed::Box<crate::model::EventDrivenSchedule>),
    }
}

/// Options customizing the time based transfer schedule.
/// Options are migrated from the original ScheduleOptions message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeBasedSchedule {
    /// Data transfer schedule.
    /// If the data source does not support a custom schedule, this should be
    /// empty. If it is empty, the default value for the data source will be used.
    /// The specified times are in UTC.
    /// Examples of valid format:
    /// `1st,3rd monday of month 15:30`,
    /// `every wed,fri of jan,jun 13:15`, and
    /// `first sunday of quarter 00:00`.
    /// See more explanation about the format here:
    /// <https://cloud.google.com/appengine/docs/flexible/python/scheduling-jobs-with-cron-yaml#the_schedule_format>
    ///
    /// NOTE: The minimum interval time between recurring transfers depends on the
    /// data source; refer to the documentation for your data source.
    pub schedule: std::string::String,

    /// Specifies time to start scheduling transfer runs. The first run will be
    /// scheduled at or after the start time according to a recurrence pattern
    /// defined in the schedule string. The start time can be changed at any
    /// moment.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Defines time to stop scheduling transfer runs. A transfer run cannot be
    /// scheduled at or after the end time. The end time can be changed at any
    /// moment.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeBasedSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule][crate::model::TimeBasedSchedule::schedule].
    pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::TimeBasedSchedule::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeBasedSchedule::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeBasedSchedule::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeBasedSchedule::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeBasedSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.TimeBasedSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeBasedSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schedule,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeBasedSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schedule" => Ok(__FieldTag::__schedule),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeBasedSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeBasedSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeBasedSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schedule.is_empty() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeBasedSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeBasedSchedule");
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options customizing manual transfers schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManualSchedule {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManualSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ManualSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.ManualSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManualSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManualSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManualSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManualSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManualSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ManualSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManualSchedule");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options customizing EventDriven transfers schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EventDrivenSchedule {
    /// Pub/Sub subscription name used to receive events.
    /// Only Google Cloud Storage data source support this option.
    /// Format: projects/{project}/subscriptions/{subscription}
    pub pubsub_subscription: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventDrivenSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pubsub_subscription][crate::model::EventDrivenSchedule::pubsub_subscription].
    pub fn set_pubsub_subscription<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pubsub_subscription = v.into();
        self
    }
}

impl wkt::message::Message for EventDrivenSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.EventDrivenSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventDrivenSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub_subscription,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventDrivenSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsubSubscription" => Ok(__FieldTag::__pubsub_subscription),
                            "pubsub_subscription" => Ok(__FieldTag::__pubsub_subscription),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventDrivenSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventDrivenSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub_subscription => {
                            if !fields.insert(__FieldTag::__pubsub_subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_subscription",
                                ));
                            }
                            result.pubsub_subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EventDrivenSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pubsub_subscription.is_empty() {
            state.serialize_entry("pubsubSubscription", &self.pubsub_subscription)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EventDrivenSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EventDrivenSchedule");
        debug_struct.field("pubsub_subscription", &self.pubsub_subscription);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about a user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserInfo {
    /// E-mail address of the user.
    pub email: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::UserInfo::email].
    pub fn set_email<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email][crate::model::UserInfo::email].
    pub fn set_or_clear_email<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UserInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.UserInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.email.is_some() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserInfo");
        debug_struct.field("email", &self.email);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a data transfer configuration. A transfer configuration
/// contains all metadata needed to perform a data transfer. For example,
/// `destination_dataset_id` specifies where data should be stored.
/// When a new transfer configuration is created, the specified
/// `destination_dataset_id` is created when needed and shared with the
/// appropriate data source service account.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferConfig {
    /// Identifier. The resource name of the transfer config.
    /// Transfer config names have the form either
    /// `projects/{project_id}/locations/{region}/transferConfigs/{config_id}` or
    /// `projects/{project_id}/transferConfigs/{config_id}`,
    /// where `config_id` is usually a UUID, even though it is not
    /// guaranteed or required. The name is ignored when creating a transfer
    /// config.
    pub name: std::string::String,

    /// User specified display name for the data transfer.
    pub display_name: std::string::String,

    /// Data source ID. This cannot be changed once data transfer is created. The
    /// full list of available data source IDs can be returned through an API call:
    /// <https://cloud.google.com/bigquery-transfer/docs/reference/datatransfer/rest/v1/projects.locations.dataSources/list>
    pub data_source_id: std::string::String,

    /// Parameters specific to each data source. For more information see the
    /// bq tab in the 'Setting up a data transfer' section for each data source.
    /// For example the parameters for Cloud Storage transfers are listed here:
    /// <https://cloud.google.com/bigquery-transfer/docs/cloud-storage-transfer#bq>
    pub params: std::option::Option<wkt::Struct>,

    /// Data transfer schedule.
    /// If the data source does not support a custom schedule, this should be
    /// empty. If it is empty, the default value for the data source will be used.
    /// The specified times are in UTC.
    /// Examples of valid format:
    /// `1st,3rd monday of month 15:30`,
    /// `every wed,fri of jan,jun 13:15`, and
    /// `first sunday of quarter 00:00`.
    /// See more explanation about the format here:
    /// <https://cloud.google.com/appengine/docs/flexible/python/scheduling-jobs-with-cron-yaml#the_schedule_format>
    ///
    /// NOTE: The minimum interval time between recurring transfers depends on the
    /// data source; refer to the documentation for your data source.
    pub schedule: std::string::String,

    /// Options customizing the data transfer schedule.
    pub schedule_options: std::option::Option<crate::model::ScheduleOptions>,

    /// Options customizing different types of data transfer schedule.
    /// This field replaces "schedule" and "schedule_options" fields.
    /// ScheduleOptionsV2 cannot be used together with ScheduleOptions/Schedule.
    pub schedule_options_v2: std::option::Option<crate::model::ScheduleOptionsV2>,

    /// The number of days to look back to automatically refresh the data.
    /// For example, if `data_refresh_window_days = 10`, then every day
    /// BigQuery reingests data for [today-10, today-1], rather than ingesting data
    /// for just [today-1].
    /// Only valid if the data source supports the feature. Set the value to 0
    /// to use the default value.
    pub data_refresh_window_days: i32,

    /// Is this config disabled. When set to true, no runs will be scheduled for
    /// this transfer config.
    pub disabled: bool,

    /// Output only. Data transfer modification time. Ignored by server on input.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Next time when data transfer will run.
    pub next_run_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the most recently updated transfer run.
    pub state: crate::model::TransferState,

    /// Deprecated. Unique ID of the user on whose behalf transfer is done.
    pub user_id: i64,

    /// Output only. Region in which BigQuery dataset is located.
    pub dataset_region: std::string::String,

    /// Pub/Sub topic where notifications will be sent after transfer runs
    /// associated with this transfer config finish.
    ///
    /// The format for specifying a pubsub topic is:
    /// `projects/{project_id}/topics/{topic_id}`
    pub notification_pubsub_topic: std::string::String,

    /// Email notifications will be sent according to these preferences
    /// to the email address of the user who owns this transfer config.
    pub email_preferences: std::option::Option<crate::model::EmailPreferences>,

    /// Output only. Information about the user whose credentials are used to
    /// transfer data. Populated only for `transferConfigs.get` requests. In case
    /// the user information is not available, this field will not be populated.
    pub owner_info: std::option::Option<crate::model::UserInfo>,

    /// The encryption configuration part. Currently, it is only used for the
    /// optional KMS key name. The BigQuery service account of your project must be
    /// granted permissions to use the key. Read methods will return the key name
    /// applied in effect. Write methods will apply the key if it is present, or
    /// otherwise try to apply project default keys if it is absent.
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Error code with detailed information about reason of the
    /// latest config failure.
    pub error: std::option::Option<rpc::model::Status>,

    /// The desination of the transfer config.
    pub destination: std::option::Option<crate::model::transfer_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransferConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TransferConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [data_source_id][crate::model::TransferConfig::data_source_id].
    pub fn set_data_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source_id = v.into();
        self
    }

    /// Sets the value of [params][crate::model::TransferConfig::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::TransferConfig::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::TransferConfig::schedule].
    pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [schedule_options][crate::model::TransferConfig::schedule_options].
    pub fn set_schedule_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScheduleOptions>,
    {
        self.schedule_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_options][crate::model::TransferConfig::schedule_options].
    pub fn set_or_clear_schedule_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScheduleOptions>,
    {
        self.schedule_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule_options_v2][crate::model::TransferConfig::schedule_options_v2].
    pub fn set_schedule_options_v2<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScheduleOptionsV2>,
    {
        self.schedule_options_v2 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_options_v2][crate::model::TransferConfig::schedule_options_v2].
    pub fn set_or_clear_schedule_options_v2<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScheduleOptionsV2>,
    {
        self.schedule_options_v2 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_refresh_window_days][crate::model::TransferConfig::data_refresh_window_days].
    pub fn set_data_refresh_window_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_refresh_window_days = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::TransferConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TransferConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TransferConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_run_time][crate::model::TransferConfig::next_run_time].
    pub fn set_next_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_run_time][crate::model::TransferConfig::next_run_time].
    pub fn set_or_clear_next_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::TransferConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::TransferState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::TransferConfig::user_id].
    pub fn set_user_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [dataset_region][crate::model::TransferConfig::dataset_region].
    pub fn set_dataset_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_region = v.into();
        self
    }

    /// Sets the value of [notification_pubsub_topic][crate::model::TransferConfig::notification_pubsub_topic].
    pub fn set_notification_pubsub_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notification_pubsub_topic = v.into();
        self
    }

    /// Sets the value of [email_preferences][crate::model::TransferConfig::email_preferences].
    pub fn set_email_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EmailPreferences>,
    {
        self.email_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email_preferences][crate::model::TransferConfig::email_preferences].
    pub fn set_or_clear_email_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EmailPreferences>,
    {
        self.email_preferences = v.map(|x| x.into());
        self
    }

    /// Sets the value of [owner_info][crate::model::TransferConfig::owner_info].
    pub fn set_owner_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.owner_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [owner_info][crate::model::TransferConfig::owner_info].
    pub fn set_or_clear_owner_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.owner_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_configuration][crate::model::TransferConfig::encryption_configuration].
    pub fn set_encryption_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.encryption_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_configuration][crate::model::TransferConfig::encryption_configuration].
    pub fn set_or_clear_encryption_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.encryption_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::TransferConfig::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::TransferConfig::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination][crate::model::TransferConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::transfer_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::TransferConfig::destination]
    /// if it holds a `DestinationDatasetId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn destination_dataset_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::transfer_config::Destination::DestinationDatasetId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::TransferConfig::destination]
    /// to hold a `DestinationDatasetId`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_destination_dataset_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::transfer_config::Destination::DestinationDatasetId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransferConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.TransferConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __destination_dataset_id,
            __display_name,
            __data_source_id,
            __params,
            __schedule,
            __schedule_options,
            __schedule_options_v2,
            __data_refresh_window_days,
            __disabled,
            __update_time,
            __next_run_time,
            __state,
            __user_id,
            __dataset_region,
            __notification_pubsub_topic,
            __email_preferences,
            __owner_info,
            __encryption_configuration,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "destinationDatasetId" => Ok(__FieldTag::__destination_dataset_id),
                            "destination_dataset_id" => Ok(__FieldTag::__destination_dataset_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "dataSourceId" => Ok(__FieldTag::__data_source_id),
                            "data_source_id" => Ok(__FieldTag::__data_source_id),
                            "params" => Ok(__FieldTag::__params),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "scheduleOptions" => Ok(__FieldTag::__schedule_options),
                            "schedule_options" => Ok(__FieldTag::__schedule_options),
                            "scheduleOptionsV2" => Ok(__FieldTag::__schedule_options_v2),
                            "schedule_options_v2" => Ok(__FieldTag::__schedule_options_v2),
                            "dataRefreshWindowDays" => Ok(__FieldTag::__data_refresh_window_days),
                            "data_refresh_window_days" => {
                                Ok(__FieldTag::__data_refresh_window_days)
                            }
                            "disabled" => Ok(__FieldTag::__disabled),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "nextRunTime" => Ok(__FieldTag::__next_run_time),
                            "next_run_time" => Ok(__FieldTag::__next_run_time),
                            "state" => Ok(__FieldTag::__state),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "datasetRegion" => Ok(__FieldTag::__dataset_region),
                            "dataset_region" => Ok(__FieldTag::__dataset_region),
                            "notificationPubsubTopic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "notification_pubsub_topic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "emailPreferences" => Ok(__FieldTag::__email_preferences),
                            "email_preferences" => Ok(__FieldTag::__email_preferences),
                            "ownerInfo" => Ok(__FieldTag::__owner_info),
                            "owner_info" => Ok(__FieldTag::__owner_info),
                            "encryptionConfiguration" => Ok(__FieldTag::__encryption_configuration),
                            "encryption_configuration" => {
                                Ok(__FieldTag::__encryption_configuration)
                            }
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_dataset_id => {
                            if !fields.insert(__FieldTag::__destination_dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_dataset_id",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.TransferConfig.destination_dataset_id, latest field was destinationDatasetId",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::transfer_config::Destination::DestinationDatasetId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source_id => {
                            if !fields.insert(__FieldTag::__data_source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_id",
                                ));
                            }
                            result.data_source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__params => {
                            if !fields.insert(__FieldTag::__params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for params",
                                ));
                            }
                            result.params = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schedule_options => {
                            if !fields.insert(__FieldTag::__schedule_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_options",
                                ));
                            }
                            result.schedule_options = map
                                .next_value::<std::option::Option<crate::model::ScheduleOptions>>(
                                )?;
                        }
                        __FieldTag::__schedule_options_v2 => {
                            if !fields.insert(__FieldTag::__schedule_options_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_options_v2",
                                ));
                            }
                            result.schedule_options_v2 = map
                                .next_value::<std::option::Option<crate::model::ScheduleOptionsV2>>(
                                )?;
                        }
                        __FieldTag::__data_refresh_window_days => {
                            if !fields.insert(__FieldTag::__data_refresh_window_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_refresh_window_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_refresh_window_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_run_time => {
                            if !fields.insert(__FieldTag::__next_run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_run_time",
                                ));
                            }
                            result.next_run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::TransferState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.user_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__dataset_region => {
                            if !fields.insert(__FieldTag::__dataset_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_region",
                                ));
                            }
                            result.dataset_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_pubsub_topic => {
                            if !fields.insert(__FieldTag::__notification_pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_pubsub_topic",
                                ));
                            }
                            result.notification_pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email_preferences => {
                            if !fields.insert(__FieldTag::__email_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_preferences",
                                ));
                            }
                            result.email_preferences = map
                                .next_value::<std::option::Option<crate::model::EmailPreferences>>(
                                )?;
                        }
                        __FieldTag::__owner_info => {
                            if !fields.insert(__FieldTag::__owner_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner_info",
                                ));
                            }
                            result.owner_info =
                                map.next_value::<std::option::Option<crate::model::UserInfo>>()?;
                        }
                        __FieldTag::__encryption_configuration => {
                            if !fields.insert(__FieldTag::__encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_configuration",
                                ));
                            }
                            result.encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.destination_dataset_id() {
            state.serialize_entry("destinationDatasetId", value)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.data_source_id.is_empty() {
            state.serialize_entry("dataSourceId", &self.data_source_id)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if !self.schedule.is_empty() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if self.schedule_options.is_some() {
            state.serialize_entry("scheduleOptions", &self.schedule_options)?;
        }
        if self.schedule_options_v2.is_some() {
            state.serialize_entry("scheduleOptionsV2", &self.schedule_options_v2)?;
        }
        if !wkt::internal::is_default(&self.data_refresh_window_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "dataRefreshWindowDays",
                &__With(&self.data_refresh_window_days),
            )?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.next_run_time.is_some() {
            state.serialize_entry("nextRunTime", &self.next_run_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.user_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("userId", &__With(&self.user_id))?;
        }
        if !self.dataset_region.is_empty() {
            state.serialize_entry("datasetRegion", &self.dataset_region)?;
        }
        if !self.notification_pubsub_topic.is_empty() {
            state.serialize_entry("notificationPubsubTopic", &self.notification_pubsub_topic)?;
        }
        if self.email_preferences.is_some() {
            state.serialize_entry("emailPreferences", &self.email_preferences)?;
        }
        if self.owner_info.is_some() {
            state.serialize_entry("ownerInfo", &self.owner_info)?;
        }
        if self.encryption_configuration.is_some() {
            state.serialize_entry("encryptionConfiguration", &self.encryption_configuration)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("data_source_id", &self.data_source_id);
        debug_struct.field("params", &self.params);
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("schedule_options", &self.schedule_options);
        debug_struct.field("schedule_options_v2", &self.schedule_options_v2);
        debug_struct.field("data_refresh_window_days", &self.data_refresh_window_days);
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("next_run_time", &self.next_run_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("user_id", &self.user_id);
        debug_struct.field("dataset_region", &self.dataset_region);
        debug_struct.field("notification_pubsub_topic", &self.notification_pubsub_topic);
        debug_struct.field("email_preferences", &self.email_preferences);
        debug_struct.field("owner_info", &self.owner_info);
        debug_struct.field("encryption_configuration", &self.encryption_configuration);
        debug_struct.field("error", &self.error);
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferConfig].
pub mod transfer_config {
    #[allow(unused_imports)]
    use super::*;

    /// The desination of the transfer config.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// The BigQuery target dataset id.
        DestinationDatasetId(std::string::String),
    }
}

/// Represents the encryption configuration for a transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfiguration {
    /// The name of the KMS key used for encrypting BigQuery data.
    pub kms_key_name: std::option::Option<wkt::StringValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfiguration::kms_key_name].
    pub fn set_kms_key_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.kms_key_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_name][crate::model::EncryptionConfiguration::kms_key_name].
    pub fn set_or_clear_kms_key_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.kms_key_name = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EncryptionConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.EncryptionConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kms_key_name.is_some() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfiguration");
        debug_struct.field("kms_key_name", &self.kms_key_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a data transfer run.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferRun {
    /// Identifier. The resource name of the transfer run.
    /// Transfer run names have the form
    /// `projects/{project_id}/locations/{location}/transferConfigs/{config_id}/runs/{run_id}`.
    /// The name is ignored when creating a transfer run.
    pub name: std::string::String,

    /// Minimum time after which a transfer run can be started.
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    /// For batch transfer runs, specifies the date and time of the data should be
    /// ingested.
    pub run_time: std::option::Option<wkt::Timestamp>,

    /// Status of the transfer run.
    pub error_status: std::option::Option<rpc::model::Status>,

    /// Output only. Time when transfer run was started.
    /// Parameter ignored by server for input requests.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when transfer run ended.
    /// Parameter ignored by server for input requests.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last time the data transfer run state was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Parameters specific to each data source. For more information
    /// see the bq tab in the 'Setting up a data transfer' section for each data
    /// source. For example the parameters for Cloud Storage transfers are listed
    /// here:
    /// <https://cloud.google.com/bigquery-transfer/docs/cloud-storage-transfer#bq>
    pub params: std::option::Option<wkt::Struct>,

    /// Output only. Data source id.
    pub data_source_id: std::string::String,

    /// Data transfer run state. Ignored for input requests.
    pub state: crate::model::TransferState,

    /// Deprecated. Unique ID of the user on whose behalf transfer is done.
    pub user_id: i64,

    /// Output only. Describes the schedule of this transfer run if it was
    /// created as part of a regular schedule. For batch transfer runs that are
    /// scheduled manually, this is empty.
    /// NOTE: the system might choose to delay the schedule depending on the
    /// current load, so `schedule_time` doesn't always match this.
    pub schedule: std::string::String,

    /// Output only. Pub/Sub topic where a notification will be sent after this
    /// transfer run finishes.
    ///
    /// The format for specifying a pubsub topic is:
    /// `projects/{project_id}/topics/{topic_id}`
    pub notification_pubsub_topic: std::string::String,

    /// Output only. Email notifications will be sent according to these
    /// preferences to the email address of the user who owns the transfer config
    /// this run was derived from.
    pub email_preferences: std::option::Option<crate::model::EmailPreferences>,

    /// Data transfer destination.
    pub destination: std::option::Option<crate::model::transfer_run::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransferRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schedule_time][crate::model::TransferRun::schedule_time].
    pub fn set_schedule_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_time][crate::model::TransferRun::schedule_time].
    pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [run_time][crate::model::TransferRun::run_time].
    pub fn set_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [run_time][crate::model::TransferRun::run_time].
    pub fn set_or_clear_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.run_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_status][crate::model::TransferRun::error_status].
    pub fn set_error_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_status][crate::model::TransferRun::error_status].
    pub fn set_or_clear_error_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::TransferRun::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TransferRun::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TransferRun::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TransferRun::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::TransferRun::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TransferRun::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::TransferRun::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::TransferRun::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_source_id][crate::model::TransferRun::data_source_id].
    pub fn set_data_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::TransferRun::state].
    pub fn set_state<T: std::convert::Into<crate::model::TransferState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::TransferRun::user_id].
    pub fn set_user_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::TransferRun::schedule].
    pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [notification_pubsub_topic][crate::model::TransferRun::notification_pubsub_topic].
    pub fn set_notification_pubsub_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notification_pubsub_topic = v.into();
        self
    }

    /// Sets the value of [email_preferences][crate::model::TransferRun::email_preferences].
    pub fn set_email_preferences<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EmailPreferences>,
    {
        self.email_preferences = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email_preferences][crate::model::TransferRun::email_preferences].
    pub fn set_or_clear_email_preferences<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EmailPreferences>,
    {
        self.email_preferences = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination][crate::model::TransferRun::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::transfer_run::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::TransferRun::destination]
    /// if it holds a `DestinationDatasetId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn destination_dataset_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::transfer_run::Destination::DestinationDatasetId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::TransferRun::destination]
    /// to hold a `DestinationDatasetId`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_destination_dataset_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::transfer_run::Destination::DestinationDatasetId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TransferRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.TransferRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __schedule_time,
            __run_time,
            __error_status,
            __start_time,
            __end_time,
            __update_time,
            __params,
            __destination_dataset_id,
            __data_source_id,
            __state,
            __user_id,
            __schedule,
            __notification_pubsub_topic,
            __email_preferences,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "scheduleTime" => Ok(__FieldTag::__schedule_time),
                            "schedule_time" => Ok(__FieldTag::__schedule_time),
                            "runTime" => Ok(__FieldTag::__run_time),
                            "run_time" => Ok(__FieldTag::__run_time),
                            "errorStatus" => Ok(__FieldTag::__error_status),
                            "error_status" => Ok(__FieldTag::__error_status),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "params" => Ok(__FieldTag::__params),
                            "destinationDatasetId" => Ok(__FieldTag::__destination_dataset_id),
                            "destination_dataset_id" => Ok(__FieldTag::__destination_dataset_id),
                            "dataSourceId" => Ok(__FieldTag::__data_source_id),
                            "data_source_id" => Ok(__FieldTag::__data_source_id),
                            "state" => Ok(__FieldTag::__state),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "notificationPubsubTopic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "notification_pubsub_topic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "emailPreferences" => Ok(__FieldTag::__email_preferences),
                            "email_preferences" => Ok(__FieldTag::__email_preferences),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schedule_time => {
                            if !fields.insert(__FieldTag::__schedule_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_time",
                                ));
                            }
                            result.schedule_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__run_time => {
                            if !fields.insert(__FieldTag::__run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_time",
                                ));
                            }
                            result.run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error_status => {
                            if !fields.insert(__FieldTag::__error_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_status",
                                ));
                            }
                            result.error_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__params => {
                            if !fields.insert(__FieldTag::__params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for params",
                                ));
                            }
                            result.params = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__destination_dataset_id => {
                            if !fields.insert(__FieldTag::__destination_dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_dataset_id",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.bigquery.datatransfer.v1.TransferRun.destination_dataset_id, latest field was destinationDatasetId",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::transfer_run::Destination::DestinationDatasetId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_source_id => {
                            if !fields.insert(__FieldTag::__data_source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source_id",
                                ));
                            }
                            result.data_source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::TransferState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.user_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_pubsub_topic => {
                            if !fields.insert(__FieldTag::__notification_pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_pubsub_topic",
                                ));
                            }
                            result.notification_pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email_preferences => {
                            if !fields.insert(__FieldTag::__email_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_preferences",
                                ));
                            }
                            result.email_preferences = map
                                .next_value::<std::option::Option<crate::model::EmailPreferences>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.schedule_time.is_some() {
            state.serialize_entry("scheduleTime", &self.schedule_time)?;
        }
        if self.run_time.is_some() {
            state.serialize_entry("runTime", &self.run_time)?;
        }
        if self.error_status.is_some() {
            state.serialize_entry("errorStatus", &self.error_status)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if let Some(value) = self.destination_dataset_id() {
            state.serialize_entry("destinationDatasetId", value)?;
        }
        if !self.data_source_id.is_empty() {
            state.serialize_entry("dataSourceId", &self.data_source_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.user_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("userId", &__With(&self.user_id))?;
        }
        if !self.schedule.is_empty() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if !self.notification_pubsub_topic.is_empty() {
            state.serialize_entry("notificationPubsubTopic", &self.notification_pubsub_topic)?;
        }
        if self.email_preferences.is_some() {
            state.serialize_entry("emailPreferences", &self.email_preferences)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferRun");
        debug_struct.field("name", &self.name);
        debug_struct.field("schedule_time", &self.schedule_time);
        debug_struct.field("run_time", &self.run_time);
        debug_struct.field("error_status", &self.error_status);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("params", &self.params);
        debug_struct.field("data_source_id", &self.data_source_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("user_id", &self.user_id);
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("notification_pubsub_topic", &self.notification_pubsub_topic);
        debug_struct.field("email_preferences", &self.email_preferences);
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferRun].
pub mod transfer_run {
    #[allow(unused_imports)]
    use super::*;

    /// Data transfer destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Output only. The BigQuery target dataset id.
        DestinationDatasetId(std::string::String),
    }
}

/// Represents a user facing message for a particular data transfer run.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferMessage {
    /// Time when message was logged.
    pub message_time: std::option::Option<wkt::Timestamp>,

    /// Message severity.
    pub severity: crate::model::transfer_message::MessageSeverity,

    /// Message text.
    pub message_text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_time][crate::model::TransferMessage::message_time].
    pub fn set_message_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.message_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_time][crate::model::TransferMessage::message_time].
    pub fn set_or_clear_message_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.message_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::TransferMessage::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::transfer_message::MessageSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [message_text][crate::model::TransferMessage::message_text].
    pub fn set_message_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_text = v.into();
        self
    }
}

impl wkt::message::Message for TransferMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.datatransfer.v1.TransferMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_time,
            __severity,
            __message_text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageTime" => Ok(__FieldTag::__message_time),
                            "message_time" => Ok(__FieldTag::__message_time),
                            "severity" => Ok(__FieldTag::__severity),
                            "messageText" => Ok(__FieldTag::__message_text),
                            "message_text" => Ok(__FieldTag::__message_text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_time => {
                            if !fields.insert(__FieldTag::__message_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_time",
                                ));
                            }
                            result.message_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<
                                    crate::model::transfer_message::MessageSeverity,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_text => {
                            if !fields.insert(__FieldTag::__message_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_text",
                                ));
                            }
                            result.message_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.message_time.is_some() {
            state.serialize_entry("messageTime", &self.message_time)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.message_text.is_empty() {
            state.serialize_entry("messageText", &self.message_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferMessage");
        debug_struct.field("message_time", &self.message_time);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("message_text", &self.message_text);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TransferMessage].
pub mod transfer_message {
    #[allow(unused_imports)]
    use super::*;

    /// Represents data transfer user facing message severity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageSeverity {
        /// No severity specified.
        Unspecified,
        /// Informational message.
        Info,
        /// Warning message.
        Warning,
        /// Error message.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MessageSeverity::value] or
        /// [MessageSeverity::name].
        UnknownValue(message_severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod message_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MessageSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MESSAGE_SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MessageSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MessageSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MessageSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(message_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MessageSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MESSAGE_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(message_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MessageSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MessageSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MessageSeverity>::new(
                ".google.cloud.bigquery.datatransfer.v1.TransferMessage.MessageSeverity",
            ))
        }
    }
}

/// DEPRECATED. Represents data transfer type.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub enum TransferType {
    /// Invalid or Unknown transfer type placeholder.
    Unspecified,
    /// Batch data transfer.
    Batch,
    /// Streaming data transfer. Streaming data source currently doesn't
    /// support multiple transfer configs per project.
    Streaming,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransferType::value] or
    /// [TransferType::name].
    UnknownValue(transfer_type::UnknownValue),
}

#[doc(hidden)]
pub mod transfer_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransferType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Batch => std::option::Option::Some(1),
            Self::Streaming => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSFER_TYPE_UNSPECIFIED"),
            Self::Batch => std::option::Option::Some("BATCH"),
            Self::Streaming => std::option::Option::Some("STREAMING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransferType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransferType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Batch,
            2 => Self::Streaming,
            _ => Self::UnknownValue(transfer_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransferType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFER_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BATCH" => Self::Batch,
            "STREAMING" => Self::Streaming,
            _ => Self::UnknownValue(transfer_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransferType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Batch => serializer.serialize_i32(1),
            Self::Streaming => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransferType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransferType>::new(
            ".google.cloud.bigquery.datatransfer.v1.TransferType",
        ))
    }
}

/// Represents data transfer run state.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransferState {
    /// State placeholder (0).
    Unspecified,
    /// Data transfer is scheduled and is waiting to be picked up by
    /// data transfer backend (2).
    Pending,
    /// Data transfer is in progress (3).
    Running,
    /// Data transfer completed successfully (4).
    Succeeded,
    /// Data transfer failed (5).
    Failed,
    /// Data transfer is cancelled (6).
    Cancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransferState::value] or
    /// [TransferState::name].
    UnknownValue(transfer_state::UnknownValue),
}

#[doc(hidden)]
pub mod transfer_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransferState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pending => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Succeeded => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::Cancelled => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSFER_STATE_UNSPECIFIED"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::Running => std::option::Option::Some("RUNNING"),
            Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Cancelled => std::option::Option::Some("CANCELLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransferState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransferState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransferState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::Pending,
            3 => Self::Running,
            4 => Self::Succeeded,
            5 => Self::Failed,
            6 => Self::Cancelled,
            _ => Self::UnknownValue(transfer_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransferState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFER_STATE_UNSPECIFIED" => Self::Unspecified,
            "PENDING" => Self::Pending,
            "RUNNING" => Self::Running,
            "SUCCEEDED" => Self::Succeeded,
            "FAILED" => Self::Failed,
            "CANCELLED" => Self::Cancelled,
            _ => Self::UnknownValue(transfer_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransferState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pending => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Succeeded => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::Cancelled => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransferState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransferState>::new(
            ".google.cloud.bigquery.datatransfer.v1.TransferState",
        ))
    }
}
