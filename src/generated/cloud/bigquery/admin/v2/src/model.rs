// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Configuration for BigLake managed tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigLakeConfiguration {
    /// Optional. The connection specifying the credentials to be used to read and
    /// write to external storage, such as Cloud Storage. The connection_id can
    /// have the form `{project}.{location}.{connection_id}` or
    /// `projects/{project}/locations/{location}/connections/{connection_id}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_id: std::string::String,

    /// Optional. The fully qualified location prefix of the external folder where
    /// table data is stored. The '*' wildcard character is not allowed. The URI
    /// should be in the format `gs://bucket/path_to_table/`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_uri: std::string::String,

    /// Optional. The file format the table data is stored in.
    pub file_format: crate::model::big_lake_configuration::FileFormat,

    /// Optional. The table format the metadata only snapshots are stored in.
    pub table_format: crate::model::big_lake_configuration::TableFormat,
}

impl BigLakeConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_id][crate::model::BigLakeConfiguration::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [storage_uri][crate::model::BigLakeConfiguration::storage_uri].
    pub fn set_storage_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_uri = v.into();
        self
    }

    /// Sets the value of [file_format][crate::model::BigLakeConfiguration::file_format].
    pub fn set_file_format<
        T: std::convert::Into<crate::model::big_lake_configuration::FileFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = v.into();
        self
    }

    /// Sets the value of [table_format][crate::model::BigLakeConfiguration::table_format].
    pub fn set_table_format<
        T: std::convert::Into<crate::model::big_lake_configuration::TableFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_format = v.into();
        self
    }
}

impl wkt::message::Message for BigLakeConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigLakeConfiguration"
    }
}

/// Defines additional types related to BigLakeConfiguration
pub mod big_lake_configuration {
    #[allow(unused_imports)]
    use super::*;

    /// Supported file formats for BigLake tables.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FileFormat(i32);

    impl FileFormat {
        /// Default Value.
        pub const FILE_FORMAT_UNSPECIFIED: FileFormat = FileFormat::new(0);

        /// Apache Parquet format.
        pub const PARQUET: FileFormat = FileFormat::new(1);

        /// Creates a new FileFormat instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FILE_FORMAT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PARQUET"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FILE_FORMAT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FILE_FORMAT_UNSPECIFIED)
                }
                "PARQUET" => std::option::Option::Some(Self::PARQUET),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FileFormat {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FileFormat {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Supported table formats for BigLake tables.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TableFormat(i32);

    impl TableFormat {
        /// Default Value.
        pub const TABLE_FORMAT_UNSPECIFIED: TableFormat = TableFormat::new(0);

        /// Apache Iceberg format.
        pub const ICEBERG: TableFormat = TableFormat::new(1);

        /// Creates a new TableFormat instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TABLE_FORMAT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ICEBERG"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TABLE_FORMAT_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TABLE_FORMAT_UNSPECIFIED)
                }
                "ICEBERG" => std::option::Option::Some(Self::ICEBERG),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TableFormat {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TableFormat {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configures table clustering.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Clustering {
    /// One or more fields on which data should be clustered. Only top-level,
    /// non-repeated, simple-type fields are supported. The ordering of the
    /// clustering fields should be prioritized from most to least important
    /// for filtering purposes.
    ///
    /// For additional information, see
    /// [Introduction to clustered
    /// tables](https://cloud.google.com/bigquery/docs/clustered-tables#limitations).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<std::string::String>,
}

impl Clustering {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::Clustering::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Clustering {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Clustering"
    }
}

/// Options for data format adjustments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataFormatOptions {
    /// Optional. Output timestamp as usec int64. Default is false.
    pub use_int64_timestamp: bool,
}

impl DataFormatOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_int64_timestamp][crate::model::DataFormatOptions::use_int64_timestamp].
    pub fn set_use_int64_timestamp<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_int64_timestamp = v.into();
        self
    }
}

impl wkt::message::Message for DataFormatOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DataFormatOptions"
    }
}

/// Grants all resources of particular types in a particular dataset read access
/// to the current dataset.
///
/// Similar to how individually authorized views work, updates to any resource
/// granted through its dataset (including creation of new resources) requires
/// read permission to referenced resources, plus write permission to the
/// authorizing dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetAccessEntry {
    /// The dataset this entry applies to
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::DatasetReference>,

    /// Which resources in the dataset this entry applies to. Currently, only
    /// views are supported, but additional target types may be added in the
    /// future.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_types: std::vec::Vec<crate::model::dataset_access_entry::TargetType>,
}

impl DatasetAccessEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::DatasetAccessEntry::dataset].
    pub fn set_dataset<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [target_types][crate::model::DatasetAccessEntry::target_types].
    pub fn set_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dataset_access_entry::TargetType>,
    {
        use std::iter::Iterator;
        self.target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatasetAccessEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DatasetAccessEntry"
    }
}

/// Defines additional types related to DatasetAccessEntry
pub mod dataset_access_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of resources in a dataset that the entry applies to.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TargetType(i32);

    impl TargetType {
        /// Do not use. You must set a target type explicitly.
        pub const TARGET_TYPE_UNSPECIFIED: TargetType = TargetType::new(0);

        /// This entry applies to views in the dataset.
        pub const VIEWS: TargetType = TargetType::new(1);

        /// This entry applies to routines in the dataset.
        pub const ROUTINES: TargetType = TargetType::new(2);

        /// Creates a new TargetType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TARGET_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("VIEWS"),
                2 => std::borrow::Cow::Borrowed("ROUTINES"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TARGET_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TARGET_TYPE_UNSPECIFIED)
                }
                "VIEWS" => std::option::Option::Some(Self::VIEWS),
                "ROUTINES" => std::option::Option::Some(Self::ROUTINES),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TargetType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TargetType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An object that defines dataset access for an entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Access {
    /// An IAM role ID that should be granted to the user, group,
    /// or domain specified in this access entry.
    /// The following legacy mappings will be applied:
    ///
    /// * `OWNER`: `roles/bigquery.dataOwner`
    /// * `WRITER`: `roles/bigquery.dataEditor`
    /// * `READER`: `roles/bigquery.dataViewer`
    ///
    /// This field will accept any of the above formats, but will return only
    /// the legacy format. For example, if you set this field to
    /// "roles/bigquery.dataOwner", it will be returned back as "OWNER".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// [Pick one] An email address of a user to grant access to. For example:
    /// fred@example.com. Maps to IAM policy member "user:EMAIL" or
    /// "serviceAccount:EMAIL".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_by_email: std::string::String,

    /// [Pick one] An email address of a Google Group to grant access to.
    /// Maps to IAM policy member "group:GROUP".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group_by_email: std::string::String,

    /// [Pick one] A domain to grant access to. Any users signed in with the domain
    /// specified will be granted the specified access. Example: "example.com".
    /// Maps to IAM policy member "domain:DOMAIN".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// [Pick one] A special group to grant access to. Possible values include:
    ///
    /// * projectOwners: Owners of the enclosing project.
    /// * projectReaders: Readers of the enclosing project.
    /// * projectWriters: Writers of the enclosing project.
    /// * allAuthenticatedUsers: All authenticated BigQuery users.
    ///
    /// Maps to similarly-named IAM members.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub special_group: std::string::String,

    /// [Pick one] Some other type of member that appears in the IAM Policy but
    /// isn't a user, group, domain, or special group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub iam_member: std::string::String,

    /// [Pick one] A view from a different dataset to grant access to. Queries
    /// executed against that view will have read access to views/tables/routines
    /// in this dataset.
    /// The role field is not required when this field is set. If that view is
    /// updated by any user, access to the view needs to be granted again via an
    /// update operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::TableReference>,

    /// [Pick one] A routine from a different dataset to grant access to. Queries
    /// executed against that routine will have read access to
    /// views/tables/routines in this dataset. Only UDF is supported for now.
    /// The role field is not required when this field is set. If that routine is
    /// updated by any user, access to the routine needs to be granted again via
    /// an update operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routine: std::option::Option<crate::model::RoutineReference>,

    /// [Pick one] A grant authorizing all resources of a particular type in a
    /// particular dataset access to this dataset. Only views are supported for
    /// now. The role field is not required when this field is set. If that dataset
    /// is deleted and re-created, its access needs to be granted again via an
    /// update operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::DatasetAccessEntry>,

    /// Optional. condition for the binding. If CEL expression in this field is
    /// true, this access binding will be considered
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<gtype::model::Expr>,
}

impl Access {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::Access::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [user_by_email][crate::model::Access::user_by_email].
    pub fn set_user_by_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_by_email = v.into();
        self
    }

    /// Sets the value of [group_by_email][crate::model::Access::group_by_email].
    pub fn set_group_by_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_by_email = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::Access::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [special_group][crate::model::Access::special_group].
    pub fn set_special_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.special_group = v.into();
        self
    }

    /// Sets the value of [iam_member][crate::model::Access::iam_member].
    pub fn set_iam_member<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_member = v.into();
        self
    }

    /// Sets the value of [view][crate::model::Access::view].
    pub fn set_view<T: std::convert::Into<std::option::Option<crate::model::TableReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::Access::routine].
    pub fn set_routine<
        T: std::convert::Into<std::option::Option<crate::model::RoutineReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routine = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::Access::dataset].
    pub fn set_dataset<
        T: std::convert::Into<std::option::Option<crate::model::DatasetAccessEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::Access::condition].
    pub fn set_condition<T: std::convert::Into<std::option::Option<gtype::model::Expr>>>(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }
}

impl wkt::message::Message for Access {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Access"
    }
}

/// Represents a BigQuery dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dataset {
    /// Output only. The resource type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Output only. A hash of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The fully-qualified unique name of the dataset in the format
    /// projectId:datasetId. The dataset name without the project name is given in
    /// the datasetId field. When creating a new dataset, leave this field blank,
    /// and instead specify the datasetId field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. A URL that can be used to access the resource again. You can
    /// use this URL in Get or Update requests to the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Required. A reference that identifies the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_reference: std::option::Option<crate::model::DatasetReference>,

    /// Optional. A descriptive name for the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// Optional. A user-friendly description of the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<wkt::StringValue>,

    /// Optional. The default lifetime of all tables in the dataset, in
    /// milliseconds. The minimum lifetime value is 3600000 milliseconds (one
    /// hour). To clear an existing default expiration with a PATCH request, set to
    /// 0. Once this property is set, all newly-created tables in the dataset will
    /// have an expirationTime property set to the creation time plus the value in
    /// this property, and changing the value will only affect new tables, not
    /// existing ones. When the expirationTime for a given table is reached, that
    /// table will be deleted automatically.
    /// If a table's expirationTime is modified or removed before the table
    /// expires, or if you provide an explicit expirationTime when creating a
    /// table, that value takes precedence over the default expiration time
    /// indicated by this property.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub default_table_expiration_ms: std::option::Option<wkt::Int64Value>,

    /// This default partition expiration, expressed in milliseconds.
    ///
    /// When new time-partitioned tables are created in a dataset where this
    /// property is set, the table will inherit this value, propagated as the
    /// `TimePartitioning.expirationMs` property on the new table.  If you set
    /// `TimePartitioning.expirationMs` explicitly when creating a table,
    /// the `defaultPartitionExpirationMs` of the containing dataset is ignored.
    ///
    /// When creating a partitioned table, if `defaultPartitionExpirationMs`
    /// is set, the `defaultTableExpirationMs` value is ignored and the table
    /// will not be inherit a table expiration deadline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub default_partition_expiration_ms: std::option::Option<wkt::Int64Value>,

    /// The labels associated with this dataset. You can use these
    /// to organize and group your datasets.
    /// You can set this property when inserting or updating a dataset.
    /// See [Creating and Updating Dataset
    /// Labels](https://cloud.google.com/bigquery/docs/creating-managing-labels#creating_and_updating_dataset_labels)
    /// for more information.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. An array of objects that define dataset access for one or more
    /// entities. You can set this property when inserting or updating a dataset in
    /// order to control who is allowed to access the data. If unspecified at
    /// dataset creation time, BigQuery adds default dataset access for the
    /// following entities: access.specialGroup: projectReaders; access.role:
    /// READER; access.specialGroup: projectWriters; access.role: WRITER;
    /// access.specialGroup: projectOwners; access.role: OWNER;
    /// access.userByEmail: [dataset creator email]; access.role: OWNER;
    /// If you patch a dataset, then this field is overwritten by the patched
    /// dataset's access field. To add entities, you must supply the entire
    /// existing access array in addition to any new entities that you want to add.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub access: std::vec::Vec<crate::model::Access>,

    /// Output only. The time when this dataset was created, in milliseconds since
    /// the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// Output only. The date when this dataset was last modified, in milliseconds
    /// since the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub last_modified_time: i64,

    /// The geographic location where the dataset should reside. See
    /// <https://cloud.google.com/bigquery/docs/locations> for supported
    /// locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The default encryption key for all tables in the dataset.
    /// After this property is set, the encryption key of all newly-created tables
    /// in the dataset is set to this value unless the table creation request or
    /// query explicitly overrides the key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_encryption_configuration:
        std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<wkt::BoolValue>,

    /// Output only. Same as `type` in `ListFormatDataset`.
    /// The type of the dataset, one of:
    ///
    /// * DEFAULT - only accessible by owner and authorized accounts,
    /// * PUBLIC - accessible by everyone,
    /// * LINKED - linked dataset,
    /// * EXTERNAL - dataset with definition in external metadata catalog.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. The source dataset reference when the dataset is of type LINKED.
    /// For all other dataset types it is not set. This field cannot be updated
    /// once it is set. Any attempt to update this field using Update and Patch API
    /// Operations will be ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub linked_dataset_source: std::option::Option<crate::model::LinkedDatasetSource>,

    /// Output only. Metadata about the LinkedDataset. Filled out when the dataset
    /// type is LINKED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub linked_dataset_metadata: std::option::Option<crate::model::LinkedDatasetMetadata>,

    /// Optional. Reference to a read-only external dataset defined in data
    /// catalogs outside of BigQuery. Filled out when the dataset type is EXTERNAL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_dataset_reference: std::option::Option<crate::model::ExternalDatasetReference>,

    /// Optional. Options defining open source compatible datasets living in the
    /// BigQuery catalog. Contains metadata of open source database, schema or
    /// namespace represented by the current dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_catalog_dataset_options:
        std::option::Option<crate::model::ExternalCatalogDatasetOptions>,

    /// Optional. TRUE if the dataset and its table names are case-insensitive,
    /// otherwise FALSE. By default, this is FALSE, which means the dataset and its
    /// table names are case-sensitive. This field does not affect routine
    /// references.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_case_insensitive: std::option::Option<wkt::BoolValue>,

    /// Optional. Defines the default collation specification of future tables
    /// created in the dataset. If a table is created in this dataset without
    /// table-level default collation, then the table inherits the dataset default
    /// collation, which is applied to the string fields that do not have explicit
    /// collation specified. A change to this field affects only tables created
    /// afterwards, and does not alter the existing tables.
    /// The following values are supported:
    ///
    /// * 'und:ci': undetermined locale, case insensitive.
    /// * '': empty string. Default to case-sensitive behavior.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_collation: std::option::Option<wkt::StringValue>,

    /// Optional. Defines the default rounding mode specification of new tables
    /// created within this dataset. During table creation, if this field is
    /// specified, the table within this dataset will inherit the default rounding
    /// mode of the dataset. Setting the default rounding mode on a table overrides
    /// this option. Existing tables in the dataset are unaffected.
    /// If columns are defined during that table creation,
    /// they will immediately inherit the table's default rounding mode,
    /// unless otherwise specified.
    pub default_rounding_mode: crate::model::table_field_schema::RoundingMode,

    /// Optional. Defines the time travel window in hours. The value can be from 48
    /// to 168 hours (2 to 7 days). The default value is 168 hours if this is not
    /// set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_time_travel_hours: std::option::Option<wkt::Int64Value>,

    /// Output only. Tags for the dataset. To provide tags as inputs, use the
    /// `resourceTags` field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<crate::model::GcpTag>,

    /// Optional. Updates storage_billing_model for the dataset.
    pub storage_billing_model: crate::model::dataset::StorageBillingModel,

    /// Optional. Output only. Restriction config for all tables and dataset. If
    /// set, restrict certain accesses on the dataset and all its tables based on
    /// the config. See [Data
    /// egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
    /// for more details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restrictions: std::option::Option<crate::model::RestrictionConfig>,

    /// Optional. The [tags](https://cloud.google.com/bigquery/docs/tags) attached
    /// to this dataset. Tag keys are globally unique. Tag key is expected to be in
    /// the namespaced format, for example "123456789012/environment" where
    /// 123456789012 is the ID of the parent organization or project resource for
    /// this tag key. Tag value is expected to be the short name, for example
    /// "Production". See [Tag
    /// definitions](https://cloud.google.com/iam/docs/tags-access-control#definitions)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_tags: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Dataset::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dataset::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Dataset::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Dataset::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [dataset_reference][crate::model::Dataset::dataset_reference].
    pub fn set_dataset_reference<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_reference = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::Dataset::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Dataset::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [default_table_expiration_ms][crate::model::Dataset::default_table_expiration_ms].
    pub fn set_default_table_expiration_ms<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_table_expiration_ms = v.into();
        self
    }

    /// Sets the value of [default_partition_expiration_ms][crate::model::Dataset::default_partition_expiration_ms].
    pub fn set_default_partition_expiration_ms<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_partition_expiration_ms = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Dataset::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Dataset::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Dataset::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [default_encryption_configuration][crate::model::Dataset::default_encryption_configuration].
    pub fn set_default_encryption_configuration<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Dataset::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Dataset::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Dataset::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [linked_dataset_source][crate::model::Dataset::linked_dataset_source].
    pub fn set_linked_dataset_source<
        T: std::convert::Into<std::option::Option<crate::model::LinkedDatasetSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.linked_dataset_source = v.into();
        self
    }

    /// Sets the value of [linked_dataset_metadata][crate::model::Dataset::linked_dataset_metadata].
    pub fn set_linked_dataset_metadata<
        T: std::convert::Into<std::option::Option<crate::model::LinkedDatasetMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.linked_dataset_metadata = v.into();
        self
    }

    /// Sets the value of [external_dataset_reference][crate::model::Dataset::external_dataset_reference].
    pub fn set_external_dataset_reference<
        T: std::convert::Into<std::option::Option<crate::model::ExternalDatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.external_dataset_reference = v.into();
        self
    }

    /// Sets the value of [external_catalog_dataset_options][crate::model::Dataset::external_catalog_dataset_options].
    pub fn set_external_catalog_dataset_options<
        T: std::convert::Into<std::option::Option<crate::model::ExternalCatalogDatasetOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.external_catalog_dataset_options = v.into();
        self
    }

    /// Sets the value of [is_case_insensitive][crate::model::Dataset::is_case_insensitive].
    pub fn set_is_case_insensitive<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_case_insensitive = v.into();
        self
    }

    /// Sets the value of [default_collation][crate::model::Dataset::default_collation].
    pub fn set_default_collation<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_collation = v.into();
        self
    }

    /// Sets the value of [default_rounding_mode][crate::model::Dataset::default_rounding_mode].
    pub fn set_default_rounding_mode<
        T: std::convert::Into<crate::model::table_field_schema::RoundingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_rounding_mode = v.into();
        self
    }

    /// Sets the value of [max_time_travel_hours][crate::model::Dataset::max_time_travel_hours].
    pub fn set_max_time_travel_hours<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.max_time_travel_hours = v.into();
        self
    }

    /// Sets the value of [storage_billing_model][crate::model::Dataset::storage_billing_model].
    pub fn set_storage_billing_model<
        T: std::convert::Into<crate::model::dataset::StorageBillingModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_billing_model = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::Dataset::restrictions].
    pub fn set_restrictions<
        T: std::convert::Into<std::option::Option<crate::model::RestrictionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = v.into();
        self
    }

    /// Sets the value of [access][crate::model::Dataset::access].
    pub fn set_access<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Access>,
    {
        use std::iter::Iterator;
        self.access = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Dataset::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcpTag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Dataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_tags][crate::model::Dataset::resource_tags].
    pub fn set_resource_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Dataset"
    }
}

/// Defines additional types related to Dataset
pub mod dataset {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the billing model that will be applied to the dataset.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StorageBillingModel(i32);

    impl StorageBillingModel {
        /// Value not set.
        pub const STORAGE_BILLING_MODEL_UNSPECIFIED: StorageBillingModel =
            StorageBillingModel::new(0);

        /// Billing for logical bytes.
        pub const LOGICAL: StorageBillingModel = StorageBillingModel::new(1);

        /// Billing for physical bytes.
        pub const PHYSICAL: StorageBillingModel = StorageBillingModel::new(2);

        /// Creates a new StorageBillingModel instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STORAGE_BILLING_MODEL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LOGICAL"),
                2 => std::borrow::Cow::Borrowed("PHYSICAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STORAGE_BILLING_MODEL_UNSPECIFIED" => {
                    std::option::Option::Some(Self::STORAGE_BILLING_MODEL_UNSPECIFIED)
                }
                "LOGICAL" => std::option::Option::Some(Self::LOGICAL),
                "PHYSICAL" => std::option::Option::Some(Self::PHYSICAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StorageBillingModel {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StorageBillingModel {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A global tag managed by Resource Manager.
/// <https://cloud.google.com/iam/docs/tags-access-control#definitions>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcpTag {
    /// Required. The namespaced friendly name of the tag key, e.g.
    /// "12345/environment" where 12345 is org id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag_key: std::string::String,

    /// Required. The friendly short name of the tag value, e.g. "production".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag_value: std::string::String,
}

impl GcpTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_key][crate::model::GcpTag::tag_key].
    pub fn set_tag_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_key = v.into();
        self
    }

    /// Sets the value of [tag_value][crate::model::GcpTag::tag_value].
    pub fn set_tag_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_value = v.into();
        self
    }
}

impl wkt::message::Message for GcpTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GcpTag"
    }
}

/// A dataset source type which refers to another BigQuery dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LinkedDatasetSource {
    /// The source dataset reference contains project numbers and not project ids.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_dataset: std::option::Option<crate::model::DatasetReference>,
}

impl LinkedDatasetSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_dataset][crate::model::LinkedDatasetSource::source_dataset].
    pub fn set_source_dataset<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_dataset = v.into();
        self
    }
}

impl wkt::message::Message for LinkedDatasetSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LinkedDatasetSource"
    }
}

/// Metadata about the Linked Dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LinkedDatasetMetadata {
    /// Output only. Specifies whether Linked Dataset is currently in a linked
    /// state or not.
    pub link_state: crate::model::linked_dataset_metadata::LinkState,
}

impl LinkedDatasetMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [link_state][crate::model::LinkedDatasetMetadata::link_state].
    pub fn set_link_state<
        T: std::convert::Into<crate::model::linked_dataset_metadata::LinkState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.link_state = v.into();
        self
    }
}

impl wkt::message::Message for LinkedDatasetMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LinkedDatasetMetadata"
    }
}

/// Defines additional types related to LinkedDatasetMetadata
pub mod linked_dataset_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether Linked Dataset is currently in a linked state or not.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LinkState(i32);

    impl LinkState {
        /// The default value.
        /// Default to the LINKED state.
        pub const LINK_STATE_UNSPECIFIED: LinkState = LinkState::new(0);

        /// Normal Linked Dataset state. Data is queryable via the Linked Dataset.
        pub const LINKED: LinkState = LinkState::new(1);

        /// Data publisher or owner has unlinked this Linked Dataset. It means you
        /// can no longer query or see the data in the Linked Dataset.
        pub const UNLINKED: LinkState = LinkState::new(2);

        /// Creates a new LinkState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LINK_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LINKED"),
                2 => std::borrow::Cow::Borrowed("UNLINKED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LINK_STATE_UNSPECIFIED" => std::option::Option::Some(Self::LINK_STATE_UNSPECIFIED),
                "LINKED" => std::option::Option::Some(Self::LINKED),
                "UNLINKED" => std::option::Option::Some(Self::UNLINKED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LinkState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LinkState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request format for getting information about a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. Project ID of the requested dataset
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested dataset
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Optional. Specifies the view that determines which dataset information is
    /// returned. By default, metadata and ACL information are returned.
    pub dataset_view: crate::model::get_dataset_request::DatasetView,

    /// Optional. The version of the access policy schema to fetch.
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// Requests for conditional access policy binding in datasets must specify
    /// version 3. Dataset with no conditional role bindings in access policy may
    /// specify any valid value or leave the field unset.
    ///
    /// This field will be mapped to [IAM Policy version]
    /// (<https://cloud.google.com/iam/docs/policies#versions>) and will be used to
    /// fetch policy from IAM.
    ///
    /// If unset or if 0 or 1 value is used for dataset with conditional bindings,
    /// access entry with condition will have role string appended by
    /// 'withcond' string followed by a hash value. For example :
    /// {
    /// "access": [
    /// {
    /// "role":
    /// "roles/bigquery.dataViewer_with_conditionalbinding_7a34awqsda",
    /// "userByEmail": "user@example.com",
    /// }
    /// ]
    /// }
    /// Please refer <https://cloud.google.com/iam/docs/troubleshooting-withcond> for
    /// more details.
    pub access_policy_version: i32,
}

impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [dataset_view][crate::model::GetDatasetRequest::dataset_view].
    pub fn set_dataset_view<
        T: std::convert::Into<crate::model::get_dataset_request::DatasetView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_view = v.into();
        self
    }

    /// Sets the value of [access_policy_version][crate::model::GetDatasetRequest::access_policy_version].
    pub fn set_access_policy_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.access_policy_version = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetDatasetRequest"
    }
}

/// Defines additional types related to GetDatasetRequest
pub mod get_dataset_request {
    #[allow(unused_imports)]
    use super::*;

    /// DatasetView specifies which dataset information is returned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DatasetView(i32);

    impl DatasetView {
        /// The default value.
        /// Default to the FULL view.
        pub const DATASET_VIEW_UNSPECIFIED: DatasetView = DatasetView::new(0);

        /// Includes metadata information for the dataset, such as location,
        /// etag, lastModifiedTime, etc.
        pub const METADATA: DatasetView = DatasetView::new(1);

        /// Includes ACL information for the dataset, which defines dataset access
        /// for one or more entities.
        pub const ACL: DatasetView = DatasetView::new(2);

        /// Includes both dataset metadata and ACL information.
        pub const FULL: DatasetView = DatasetView::new(3);

        /// Creates a new DatasetView instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATASET_VIEW_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("METADATA"),
                2 => std::borrow::Cow::Borrowed("ACL"),
                3 => std::borrow::Cow::Borrowed("FULL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATASET_VIEW_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATASET_VIEW_UNSPECIFIED)
                }
                "METADATA" => std::option::Option::Some(Self::METADATA),
                "ACL" => std::option::Option::Some(Self::ACL),
                "FULL" => std::option::Option::Some(Self::FULL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DatasetView {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DatasetView {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request format for inserting a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsertDatasetRequest {
    /// Required. Project ID of the new dataset
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Datasets resource to use for the new dataset
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Optional. The version of the provided access policy schema.
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// This version refers to the schema version of the access policy and not the
    /// version of access policy. This field's value can be equal or more
    /// than the access policy schema provided in the request.
    /// For example,
    ///
    /// * Requests with conditional access policy binding in datasets must
    ///   specify
    ///   version 3.
    /// * But dataset with no conditional role bindings in access policy
    ///   may specify any valid value or leave the field unset.
    ///   If unset or if 0 or 1 value is used for dataset with conditional
    ///   bindings, request will be rejected.
    ///
    /// This field will be mapped to IAM Policy version
    /// (<https://cloud.google.com/iam/docs/policies#versions>) and will be used to
    /// set policy in IAM.
    pub access_policy_version: i32,
}

impl InsertDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::InsertDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [access_policy_version][crate::model::InsertDatasetRequest::access_policy_version].
    pub fn set_access_policy_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.access_policy_version = v.into();
        self
    }
}

impl wkt::message::Message for InsertDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertDatasetRequest"
    }
}

/// Message for updating or patching a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateOrPatchDatasetRequest {
    /// Required. Project ID of the dataset being updated
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the dataset being updated
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Datasets resource which will replace or patch the specified
    /// dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Optional. The version of the provided access policy schema.
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// This version refers to the schema version of the access policy and not the
    /// version of access policy. This field's value can be equal or more
    /// than the access policy schema provided in the request.
    /// For example,
    ///
    /// * Operations updating conditional access policy binding in datasets must
    ///   specify
    ///   version 3. Some of the operations are :
    ///   - Adding a new access policy entry with condition.
    ///   - Removing an access policy entry with condition.
    ///   - Updating an access policy entry with condition.
    /// * But dataset with no conditional role bindings in access policy
    ///   may specify any valid value or leave the field unset.
    ///   If unset or if 0 or 1 value is used for dataset with conditional
    ///   bindings, request will be rejected.
    ///
    /// This field will be mapped to IAM Policy version
    /// (<https://cloud.google.com/iam/docs/policies#versions>) and will be used to
    /// set policy in IAM.
    pub access_policy_version: i32,
}

impl UpdateOrPatchDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateOrPatchDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateOrPatchDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::UpdateOrPatchDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [access_policy_version][crate::model::UpdateOrPatchDatasetRequest::access_policy_version].
    pub fn set_access_policy_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.access_policy_version = v.into();
        self
    }
}

impl wkt::message::Message for UpdateOrPatchDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateOrPatchDatasetRequest"
    }
}

/// Request format for deleting a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. Project ID of the dataset being deleted
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of dataset being deleted
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// If True, delete all the tables in the dataset.
    /// If False and the dataset contains tables, the request will fail.
    /// Default is False
    pub delete_contents: bool,
}

impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [delete_contents][crate::model::DeleteDatasetRequest::delete_contents].
    pub fn set_delete_contents<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.delete_contents = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteDatasetRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. Project ID of the datasets to be listed
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Whether to list all datasets, including hidden ones
    pub all: bool,

    /// An expression for filtering the results of the request by label.
    /// The syntax is `labels.<name>[:<value>]`.
    /// Multiple filters can be AND-ed together by connecting with a space.
    /// Example: `labels.department:receiving labels.active`.
    /// See [Filtering datasets using
    /// labels](https://cloud.google.com/bigquery/docs/filtering-labels#filtering_datasets_using_labels)
    /// for details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListDatasetsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListDatasetsRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<std::option::Option<wkt::UInt32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [all][crate::model::ListDatasetsRequest::all].
    pub fn set_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListDatasetsRequest"
    }
}

/// A dataset resource with only a subset of fields, to be returned in a list of
/// datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFormatDataset {
    /// The resource type.
    /// This property always returns the value "bigquery#dataset"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The fully-qualified, unique, opaque ID of the dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The dataset reference.
    /// Use this property to access specific parts of the dataset's ID, such as
    /// project ID or dataset ID.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset_reference: std::option::Option<crate::model::DatasetReference>,

    /// The labels associated with this dataset.
    /// You can use these to organize and group your datasets.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// An alternate name for the dataset.  The friendly name is purely
    /// decorative in nature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// The geographic location where the dataset resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl ListFormatDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ListFormatDataset::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ListFormatDataset::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [dataset_reference][crate::model::ListFormatDataset::dataset_reference].
    pub fn set_dataset_reference<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_reference = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::ListFormatDataset::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ListFormatDataset::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ListFormatDataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ListFormatDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatDataset"
    }
}

/// Response format for a page of results when listing datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetList {
    /// Output only. The resource type.
    /// This property always returns the value "bigquery#datasetList"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Output only. A hash value of the results page. You can use this property to
    /// determine if the page has changed since the last request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// A token that can be used to request the next results page. This property is
    /// omitted on the final results page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// An array of the dataset resources in the project.
    /// Each resource contains basic information.
    /// For full information about a particular dataset resource, use the Datasets:
    /// get method. This property is omitted when there are no datasets in the
    /// project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<crate::model::ListFormatDataset>,

    /// A list of skipped locations that were unreachable. For more information
    /// about BigQuery locations, see:
    /// <https://cloud.google.com/bigquery/docs/locations>. Example: "europe-west5"
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl DatasetList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatasetList::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DatasetList::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::DatasetList::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::DatasetList::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ListFormatDataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::DatasetList::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatasetList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DatasetList"
    }
}

/// Request format for undeleting a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteDatasetRequest {
    /// Required. Project ID of the dataset to be undeleted
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of dataset being deleted
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Optional. The exact time when the dataset was deleted. If not specified,
    /// the most recently deleted version is undeleted. Undeleting a dataset
    /// using deletion time is not supported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_time: std::option::Option<wkt::Timestamp>,
}

impl UndeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UndeleteDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UndeleteDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [deletion_time][crate::model::UndeleteDatasetRequest::deletion_time].
    pub fn set_deletion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deletion_time = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UndeleteDatasetRequest"
    }
}

/// Identifier for a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetReference {
    /// Required. A unique ID for this dataset, without the project name. The ID
    /// must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_).
    /// The maximum length is 1,024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Optional. The ID of the project containing this dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,
}

impl DatasetReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::DatasetReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DatasetReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DatasetReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DatasetReference"
    }
}

/// Configuration for Cloud KMS encryption settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionConfiguration {
    /// Optional. Describes the Cloud KMS encryption key that will be used to
    /// protect destination BigQuery table. The BigQuery Service Account associated
    /// with your project requires access to this encryption key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kms_key_name: std::option::Option<wkt::StringValue>,
}

impl EncryptionConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfiguration::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.EncryptionConfiguration"
    }
}

/// Error details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorProto {
    /// A short error code that summarizes the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,

    /// Specifies where the error occurred, if present.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Debugging information. This property is internal to Google and should not
    /// be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub debug_info: std::string::String,

    /// A human-readable description of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl ErrorProto {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reason][crate::model::ErrorProto::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ErrorProto::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [debug_info][crate::model::ErrorProto::debug_info].
    pub fn set_debug_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.debug_info = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ErrorProto::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for ErrorProto {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ErrorProto"
    }
}

/// Options defining open source compatible datasets living in the BigQuery
/// catalog. Contains metadata of open source database, schema,
/// or namespace represented by the current dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalCatalogDatasetOptions {
    /// Optional. A map of key value pairs defining the parameters and properties
    /// of the open source schema. Maximum size of 2MiB.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The storage location URI for all tables in the dataset.
    /// Equivalent to hive metastore's database locationUri. Maximum length of 1024
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_storage_location_uri: std::string::String,
}

impl ExternalCatalogDatasetOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_storage_location_uri][crate::model::ExternalCatalogDatasetOptions::default_storage_location_uri].
    pub fn set_default_storage_location_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_storage_location_uri = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::ExternalCatalogDatasetOptions::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExternalCatalogDatasetOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalCatalogDatasetOptions"
    }
}

/// Metadata about open source compatible table. The fields contained in
/// these options correspond to Hive metastore's table-level properties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalCatalogTableOptions {
    /// Optional. A map of the key-value pairs defining the parameters and
    /// properties of the open source table. Corresponds with Hive metastore table
    /// parameters. Maximum size of 4MiB.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A storage descriptor containing information about the physical
    /// storage of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,

    /// Optional. A connection ID that specifies the credentials to be used to read
    /// external storage, such as Azure Blob, Cloud Storage, or Amazon S3. This
    /// connection is needed to read the open source table from BigQuery. The
    /// connection_id format must be either
    /// `<project_id>.<location_id>.<connection_id>` or
    /// `projects/<project_id>/locations/<location_id>/connections/<connection_id>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_id: std::string::String,
}

impl ExternalCatalogTableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_descriptor][crate::model::ExternalCatalogTableOptions::storage_descriptor].
    pub fn set_storage_descriptor<
        T: std::convert::Into<std::option::Option<crate::model::StorageDescriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_descriptor = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::ExternalCatalogTableOptions::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::ExternalCatalogTableOptions::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExternalCatalogTableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalCatalogTableOptions"
    }
}

/// Contains information about how a table's data is stored and accessed by open
/// source query engines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageDescriptor {
    /// Optional. The physical location of the table
    /// (e.g. `gs://spark-dataproc-data/pangea-data/case_sensitive/` or
    /// `gs://spark-dataproc-data/pangea-data/*`).
    /// The maximum length is 2056 bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_uri: std::string::String,

    /// Optional. Specifies the fully qualified class name of the InputFormat
    /// (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat").
    /// The maximum length is 128 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_format: std::string::String,

    /// Optional. Specifies the fully qualified class name of the OutputFormat
    /// (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat").
    /// The maximum length is 128 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_format: std::string::String,

    /// Optional. Serializer and deserializer information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub serde_info: std::option::Option<crate::model::SerDeInfo>,
}

impl StorageDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location_uri][crate::model::StorageDescriptor::location_uri].
    pub fn set_location_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_uri = v.into();
        self
    }

    /// Sets the value of [input_format][crate::model::StorageDescriptor::input_format].
    pub fn set_input_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_format = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::StorageDescriptor::output_format].
    pub fn set_output_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_format = v.into();
        self
    }

    /// Sets the value of [serde_info][crate::model::StorageDescriptor::serde_info].
    pub fn set_serde_info<T: std::convert::Into<std::option::Option<crate::model::SerDeInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.serde_info = v.into();
        self
    }
}

impl wkt::message::Message for StorageDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StorageDescriptor"
    }
}

/// Serializer and deserializer information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SerDeInfo {
    /// Optional. Name of the SerDe.
    /// The maximum length is 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Specifies a fully-qualified class name of the serialization
    /// library that is responsible for the translation of data between table
    /// representation and the underlying low-level input and output format
    /// structures. The maximum length is 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serialization_library: std::string::String,

    /// Optional. Key-value pairs that define the initialization parameters for the
    /// serialization library.
    /// Maximum size 10 Kib.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,
}

impl SerDeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SerDeInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [serialization_library][crate::model::SerDeInfo::serialization_library].
    pub fn set_serialization_library<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.serialization_library = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::SerDeInfo::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SerDeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SerDeInfo"
    }
}

/// Options for external data sources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvroOptions {
    /// Optional. If sourceFormat is set to "AVRO", indicates whether to interpret
    /// logical types as the corresponding BigQuery data type (for example,
    /// TIMESTAMP), instead of using the raw type (for example, INTEGER).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_avro_logical_types: std::option::Option<wkt::BoolValue>,
}

impl AvroOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_avro_logical_types][crate::model::AvroOptions::use_avro_logical_types].
    pub fn set_use_avro_logical_types<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.use_avro_logical_types = v.into();
        self
    }
}

impl wkt::message::Message for AvroOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.AvroOptions"
    }
}

/// Parquet Options for load and make external tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ParquetOptions {
    /// Optional. Indicates whether to infer Parquet ENUM logical type as STRING
    /// instead of BYTES by default.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enum_as_string: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates whether to use schema inference specifically for
    /// Parquet LIST logical type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_list_inference: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates how to represent a Parquet map if present.
    pub map_target_type: crate::model::MapTargetType,
}

impl ParquetOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enum_as_string][crate::model::ParquetOptions::enum_as_string].
    pub fn set_enum_as_string<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enum_as_string = v.into();
        self
    }

    /// Sets the value of [enable_list_inference][crate::model::ParquetOptions::enable_list_inference].
    pub fn set_enable_list_inference<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_list_inference = v.into();
        self
    }

    /// Sets the value of [map_target_type][crate::model::ParquetOptions::map_target_type].
    pub fn set_map_target_type<T: std::convert::Into<crate::model::MapTargetType>>(
        mut self,
        v: T,
    ) -> Self {
        self.map_target_type = v.into();
        self
    }
}

impl wkt::message::Message for ParquetOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ParquetOptions"
    }
}

/// Information related to a CSV data source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CsvOptions {
    /// Optional. The separator character for fields in a CSV file. The separator
    /// is interpreted as a single byte. For files encoded in ISO-8859-1, any
    /// single character can be used as a separator. For files encoded in UTF-8,
    /// characters represented in decimal range 1-127 (U+0001-U+007F) can be used
    /// without any modification. UTF-8 characters encoded with multiple bytes
    /// (i.e. U+0080 and above) will have only the first byte used for separating
    /// fields. The remaining bytes will be treated as a part of the field.
    /// BigQuery also supports the escape sequence "\t" (U+0009) to specify a tab
    /// separator. The default value is comma (",", U+002C).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_delimiter: std::string::String,

    /// Optional. The number of rows at the top of a CSV file that BigQuery will
    /// skip when reading the data. The default value is 0. This property is
    /// useful if you have header rows in the file that should be skipped.
    /// When autodetect is on, the behavior is the following:
    ///
    /// * skipLeadingRows unspecified - Autodetect tries to detect headers in the
    ///   first row. If they are not detected, the row is read as data. Otherwise
    ///   data is read starting from the second row.
    /// * skipLeadingRows is 0 - Instructs autodetect that there are no headers and
    ///   data should be read starting from the first row.
    /// * skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect
    ///   headers in row N. If headers are not detected, row N is just skipped.
    ///   Otherwise row N is used to extract column names for the detected schema.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub skip_leading_rows: std::option::Option<wkt::Int64Value>,

    /// Optional. The value that is used to quote data sections in a CSV file.
    /// BigQuery converts the string to ISO-8859-1 encoding, and then uses the
    /// first byte of the encoded string to split the data in its raw, binary
    /// state.
    /// The default value is a double-quote (").
    /// If your data does not contain quoted sections,
    /// set the property value to an empty string.
    /// If your data contains quoted newline characters, you must also set the
    /// allowQuotedNewlines property to true.
    /// To include the specific quote character within a quoted value, precede it
    /// with an additional matching quote character. For example, if you want to
    /// escape the default character  ' " ', use ' "" '.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quote: std::option::Option<wkt::StringValue>,

    /// Optional. Indicates if BigQuery should allow quoted data sections that
    /// contain newline characters in a CSV file. The default value is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_quoted_newlines: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates if BigQuery should accept rows that are missing
    /// trailing optional columns. If true, BigQuery treats missing trailing
    /// columns as null values.
    /// If false, records with missing trailing columns are treated as bad records,
    /// and if there are too many bad records, an invalid error is returned in the
    /// job result. The default value is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_jagged_rows: std::option::Option<wkt::BoolValue>,

    /// Optional. The character encoding of the data.
    /// The supported values are UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE,
    /// and UTF-32LE.  The default value is UTF-8.
    /// BigQuery decodes the data after the raw, binary data has been split using
    /// the values of the quote and fieldDelimiter properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,

    /// Optional. Indicates if the embedded ASCII control characters (the first 32
    /// characters in the ASCII-table, from '\x00' to '\x1F') are preserved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preserve_ascii_control_characters: std::option::Option<wkt::BoolValue>,

    /// Optional. Specifies a string that represents a null value in a CSV file.
    /// For example, if you specify "\N", BigQuery interprets "\N" as a null value
    /// when querying a CSV file.
    /// The default value is the empty string. If you set this property to a custom
    /// value, BigQuery throws an error if an empty string is present for all data
    /// types except for STRING and BYTE. For STRING and BYTE columns, BigQuery
    /// interprets the empty string as an empty value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub null_marker: std::option::Option<wkt::StringValue>,
}

impl CsvOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_delimiter][crate::model::CsvOptions::field_delimiter].
    pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_delimiter = v.into();
        self
    }

    /// Sets the value of [skip_leading_rows][crate::model::CsvOptions::skip_leading_rows].
    pub fn set_skip_leading_rows<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_leading_rows = v.into();
        self
    }

    /// Sets the value of [quote][crate::model::CsvOptions::quote].
    pub fn set_quote<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [allow_quoted_newlines][crate::model::CsvOptions::allow_quoted_newlines].
    pub fn set_allow_quoted_newlines<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_quoted_newlines = v.into();
        self
    }

    /// Sets the value of [allow_jagged_rows][crate::model::CsvOptions::allow_jagged_rows].
    pub fn set_allow_jagged_rows<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_jagged_rows = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::CsvOptions::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [preserve_ascii_control_characters][crate::model::CsvOptions::preserve_ascii_control_characters].
    pub fn set_preserve_ascii_control_characters<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preserve_ascii_control_characters = v.into();
        self
    }

    /// Sets the value of [null_marker][crate::model::CsvOptions::null_marker].
    pub fn set_null_marker<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.null_marker = v.into();
        self
    }
}

impl wkt::message::Message for CsvOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CsvOptions"
    }
}

/// Json Options for load and make external tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JsonOptions {
    /// Optional. The character encoding of the data.
    /// The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE,
    /// and UTF-32LE.  The default value is UTF-8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,
}

impl JsonOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encoding][crate::model::JsonOptions::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }
}

impl wkt::message::Message for JsonOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JsonOptions"
    }
}

/// Information related to a Bigtable column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigtableColumn {
    /// [Required] Qualifier of the column.
    /// Columns in the parent column family that has this exact qualifier are
    /// exposed as `<family field name>.<column field name>` field.
    /// If the qualifier is valid UTF-8 string, it can be specified in the
    /// qualifier_string field.  Otherwise, a base-64 encoded value must be set to
    /// qualifier_encoded.
    /// The column field name is the same as the column qualifier. However, if the
    /// qualifier is not a valid BigQuery field identifier i.e. does not match
    /// [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as field_name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::base64::Base64>")]
    pub qualifier_encoded: std::option::Option<wkt::BytesValue>,

    /// Qualifier string.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qualifier_string: std::option::Option<wkt::StringValue>,

    /// Optional. If the qualifier is not a valid BigQuery field identifier i.e.
    /// does not match [a-zA-Z][a-zA-Z0-9_]*,  a valid identifier must be provided
    /// as the column field name and is used as field name in queries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_name: std::string::String,

    /// Optional. The type to convert the value in cells of this column.
    /// The values are expected to be encoded using HBase Bytes.toBytes function
    /// when using the BINARY encoding value.
    /// Following BigQuery types are allowed (case-sensitive):
    ///
    /// * BYTES
    /// * STRING
    /// * INTEGER
    /// * FLOAT
    /// * BOOLEAN
    /// * JSON
    ///
    /// Default type is BYTES.
    /// 'type' can also be set at the column family level. However, the setting at
    /// this level takes precedence if 'type' is set at both levels.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. The encoding of the values when the type is not STRING.
    /// Acceptable encoding values are:
    /// TEXT - indicates values are alphanumeric text strings.
    /// BINARY - indicates values are encoded using HBase Bytes.toBytes family of
    /// functions.
    /// 'encoding' can also be set at the column family level. However, the setting
    /// at this level takes precedence if 'encoding' is set at both levels.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,

    /// Optional. If this is set, only the latest version of value in this column
    /// are exposed.
    /// 'onlyReadLatest' can also be set at the column family level. However, the
    /// setting at this level takes precedence if 'onlyReadLatest' is set at both
    /// levels.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub only_read_latest: std::option::Option<wkt::BoolValue>,
}

impl BigtableColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qualifier_encoded][crate::model::BigtableColumn::qualifier_encoded].
    pub fn set_qualifier_encoded<T: std::convert::Into<std::option::Option<wkt::BytesValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.qualifier_encoded = v.into();
        self
    }

    /// Sets the value of [qualifier_string][crate::model::BigtableColumn::qualifier_string].
    pub fn set_qualifier_string<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.qualifier_string = v.into();
        self
    }

    /// Sets the value of [field_name][crate::model::BigtableColumn::field_name].
    pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BigtableColumn::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::BigtableColumn::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [only_read_latest][crate::model::BigtableColumn::only_read_latest].
    pub fn set_only_read_latest<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.only_read_latest = v.into();
        self
    }
}

impl wkt::message::Message for BigtableColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigtableColumn"
    }
}

/// Information related to a Bigtable column family.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigtableColumnFamily {
    /// Identifier of the column family.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub family_id: std::string::String,

    /// Optional. The type to convert the value in cells of this column family.
    /// The values are expected to be encoded using HBase Bytes.toBytes function
    /// when using the BINARY encoding value.
    /// Following BigQuery types are allowed (case-sensitive):
    ///
    /// * BYTES
    /// * STRING
    /// * INTEGER
    /// * FLOAT
    /// * BOOLEAN
    /// * JSON
    ///
    /// Default type is BYTES.
    /// This can be overridden for a specific column by listing that column in
    /// 'columns' and specifying a type for it.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. The encoding of the values when the type is not STRING.
    /// Acceptable encoding values are:
    /// TEXT - indicates values are alphanumeric text strings.
    /// BINARY - indicates values are encoded using HBase Bytes.toBytes family of
    /// functions.
    /// This can be overridden for a specific column by listing that column in
    /// 'columns' and specifying an encoding for it.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,

    /// Optional. Lists of columns that should be exposed as individual fields as
    /// opposed to a list of (column name, value) pairs.
    /// All columns whose qualifier matches a qualifier in this list can be
    /// accessed as `<family field name>.<column field name>`.
    /// Other columns can be accessed as a list through
    /// the `<family field name>.Column` field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::BigtableColumn>,

    /// Optional. If this is set only the latest version of value are exposed for
    /// all columns in this column family.
    /// This can be overridden for a specific column by listing that column in
    /// 'columns' and specifying a different setting
    /// for that column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub only_read_latest: std::option::Option<wkt::BoolValue>,
}

impl BigtableColumnFamily {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [family_id][crate::model::BigtableColumnFamily::family_id].
    pub fn set_family_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.family_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BigtableColumnFamily::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::BigtableColumnFamily::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [only_read_latest][crate::model::BigtableColumnFamily::only_read_latest].
    pub fn set_only_read_latest<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.only_read_latest = v.into();
        self
    }

    /// Sets the value of [columns][crate::model::BigtableColumnFamily::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigtableColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigtableColumnFamily {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigtableColumnFamily"
    }
}

/// Options specific to Google Cloud Bigtable data sources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigtableOptions {
    /// Optional. List of column families to expose in the table schema along with
    /// their types.
    /// This list restricts the column families that can be referenced in queries
    /// and specifies their value types.
    /// You can use this list to do type conversions - see the 'type' field for
    /// more details.
    /// If you leave this list empty, all column families are present in the table
    /// schema and their values are read as BYTES.
    /// During a query only the column families referenced in that query are read
    /// from Bigtable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub column_families: std::vec::Vec<crate::model::BigtableColumnFamily>,

    /// Optional. If field is true, then the column families that are not
    /// specified in columnFamilies list are not exposed in the table schema.
    /// Otherwise, they are read with BYTES type values.
    /// The default value is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ignore_unspecified_column_families: std::option::Option<wkt::BoolValue>,

    /// Optional. If field is true, then the rowkey column families will be read
    /// and converted to string. Otherwise they are read with BYTES type values and
    /// users need to manually cast them with CAST if necessary.
    /// The default value is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_rowkey_as_string: std::option::Option<wkt::BoolValue>,

    /// Optional. If field is true, then each column family will be read as a
    /// single JSON column. Otherwise they are read as a repeated cell structure
    /// containing timestamp/value tuples. The default value is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_column_families_as_json: std::option::Option<wkt::BoolValue>,
}

impl BigtableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ignore_unspecified_column_families][crate::model::BigtableOptions::ignore_unspecified_column_families].
    pub fn set_ignore_unspecified_column_families<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ignore_unspecified_column_families = v.into();
        self
    }

    /// Sets the value of [read_rowkey_as_string][crate::model::BigtableOptions::read_rowkey_as_string].
    pub fn set_read_rowkey_as_string<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_rowkey_as_string = v.into();
        self
    }

    /// Sets the value of [output_column_families_as_json][crate::model::BigtableOptions::output_column_families_as_json].
    pub fn set_output_column_families_as_json<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_column_families_as_json = v.into();
        self
    }

    /// Sets the value of [column_families][crate::model::BigtableOptions::column_families].
    pub fn set_column_families<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigtableColumnFamily>,
    {
        use std::iter::Iterator;
        self.column_families = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BigtableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigtableOptions"
    }
}

/// Options specific to Google Sheets data sources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleSheetsOptions {
    /// Optional. The number of rows at the top of a sheet that BigQuery will skip
    /// when reading the data. The default value is 0. This property is useful if
    /// you have header rows that should be skipped. When autodetect is on,
    /// the behavior is the following:
    ///
    /// * skipLeadingRows unspecified - Autodetect tries to detect headers in the
    ///   first row. If they are not detected, the row is read as data. Otherwise
    ///   data is read starting from the second row.
    /// * skipLeadingRows is 0 - Instructs autodetect that there are no headers and
    ///   data should be read starting from the first row.
    /// * skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect
    ///   headers in row N. If headers are not detected, row N is just skipped.
    ///   Otherwise row N is used to extract column names for the detected schema.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub skip_leading_rows: std::option::Option<wkt::Int64Value>,

    /// Optional. Range of a sheet to query from. Only used when non-empty.
    /// Typical format: sheet_name!top_left_cell_id:bottom_right_cell_id
    /// For example: sheet1!A1:B20
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub range: std::string::String,
}

impl GoogleSheetsOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skip_leading_rows][crate::model::GoogleSheetsOptions::skip_leading_rows].
    pub fn set_skip_leading_rows<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_leading_rows = v.into();
        self
    }

    /// Sets the value of [range][crate::model::GoogleSheetsOptions::range].
    pub fn set_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.range = v.into();
        self
    }
}

impl wkt::message::Message for GoogleSheetsOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GoogleSheetsOptions"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalDataConfiguration {
    /// [Required] The fully-qualified URIs that point to your data in Google
    /// Cloud. For Google Cloud Storage URIs:
    /// Each URI can contain one '*' wildcard character and it must come after
    /// the 'bucket' name.
    /// Size limits related to load jobs apply to external data sources.
    /// For Google Cloud Bigtable URIs:
    /// Exactly one URI can be specified and it has be a fully specified and
    /// valid HTTPS URL for a Google Cloud Bigtable table.
    /// For Google Cloud Datastore backups, exactly one URI can be specified. Also,
    /// the '*' wildcard character is not allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_uris: std::vec::Vec<std::string::String>,

    /// Optional. Specifies how source URIs are interpreted for constructing the
    /// file set to load.  By default source URIs are expanded against the
    /// underlying storage.  Other options include specifying manifest files. Only
    /// applicable to object storage systems.
    pub file_set_spec_type: crate::model::FileSetSpecType,

    /// Optional. The schema for the data.
    /// Schema is required for CSV and JSON formats if autodetect is not on.
    /// Schema is disallowed for Google Cloud Bigtable, Cloud Datastore backups,
    /// Avro, ORC and Parquet formats.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// [Required] The data format.
    /// For CSV files, specify "CSV".
    /// For Google sheets, specify "GOOGLE_SHEETS".
    /// For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON".
    /// For Avro files, specify "AVRO".
    /// For Google Cloud Datastore backups, specify "DATASTORE_BACKUP".
    /// For Apache Iceberg tables, specify "ICEBERG".
    /// For ORC files, specify "ORC".
    /// For Parquet files, specify "PARQUET".
    /// [Beta] For Google Cloud Bigtable, specify "BIGTABLE".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_format: std::string::String,

    /// Optional. The maximum number of bad records that BigQuery can ignore when
    /// reading data. If the number of bad records exceeds this value, an invalid
    /// error is returned in the job result. The default value is 0, which requires
    /// that all records are valid. This setting is ignored for Google Cloud
    /// Bigtable, Google Cloud Datastore backups, Avro, ORC and Parquet formats.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_bad_records: std::option::Option<wkt::Int32Value>,

    /// Try to detect schema and format options automatically.
    /// Any option specified explicitly will be honored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autodetect: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates if BigQuery should allow extra values that are not
    /// represented in the table schema.
    /// If true, the extra values are ignored.
    /// If false, records with extra columns are treated as bad records, and if
    /// there are too many bad records, an invalid error is returned in the job
    /// result.
    /// The default value is false.
    /// The sourceFormat property determines what BigQuery treats as an extra
    /// value:
    /// CSV: Trailing columns
    /// JSON: Named values that don't match any column names
    /// Google Cloud Bigtable: This setting is ignored.
    /// Google Cloud Datastore backups: This setting is ignored.
    /// Avro: This setting is ignored.
    /// ORC: This setting is ignored.
    /// Parquet: This setting is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ignore_unknown_values: std::option::Option<wkt::BoolValue>,

    /// Optional. The compression type of the data source.
    /// Possible values include GZIP and NONE. The default value is NONE.
    /// This setting is ignored for Google Cloud Bigtable, Google Cloud Datastore
    /// backups, Avro, ORC and Parquet
    /// formats. An empty string is an invalid value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub compression: std::string::String,

    /// Optional. Additional properties to set if sourceFormat is set to CSV.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub csv_options: std::option::Option<crate::model::CsvOptions>,

    /// Optional. Additional properties to set if sourceFormat is set to JSON.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub json_options: std::option::Option<crate::model::JsonOptions>,

    /// Optional. Additional options if sourceFormat is set to BIGTABLE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigtable_options: std::option::Option<crate::model::BigtableOptions>,

    /// Optional. Additional options if sourceFormat is set to GOOGLE_SHEETS.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_sheets_options: std::option::Option<crate::model::GoogleSheetsOptions>,

    /// Optional. When set, configures hive partitioning support. Not all storage
    /// formats support hive partitioning -- requesting hive partitioning on an
    /// unsupported format will lead to an error, as will providing an invalid
    /// specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hive_partitioning_options: std::option::Option<crate::model::HivePartitioningOptions>,

    /// Optional. The connection specifying the credentials to be used to read
    /// external storage, such as Azure Blob, Cloud Storage, or S3. The
    /// connection_id can have the form
    /// `{project_id}.{location_id};{connection_id}` or
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_id: std::string::String,

    /// Defines the list of possible SQL data types to which the source decimal
    /// values are converted. This list and the precision and the scale parameters
    /// of the decimal field determine the target type. In the order of NUMERIC,
    /// BIGNUMERIC, and STRING, a
    /// type is picked if it is in the specified list and if it supports the
    /// precision and the scale. STRING supports all precision and scale values.
    /// If none of the listed types supports the precision and the scale, the type
    /// supporting the widest range in the specified list is picked, and if a value
    /// exceeds the supported range when reading the data, an error will be thrown.
    ///
    /// Example: Suppose the value of this field is ["NUMERIC", "BIGNUMERIC"].
    /// If (precision,scale) is:
    ///
    /// * (38,9) -> NUMERIC;
    /// * (39,9) -> BIGNUMERIC (NUMERIC cannot hold 30 integer digits);
    /// * (38,10) -> BIGNUMERIC (NUMERIC cannot hold 10 fractional digits);
    /// * (76,38) -> BIGNUMERIC;
    /// * (77,38) -> BIGNUMERIC (error if value exceeds supported range).
    ///
    /// This field cannot contain duplicate types. The order of the types in this
    /// field is ignored. For example, ["BIGNUMERIC", "NUMERIC"] is the same as
    /// ["NUMERIC", "BIGNUMERIC"] and NUMERIC always takes precedence over
    /// BIGNUMERIC.
    ///
    /// Defaults to ["NUMERIC", "STRING"] for ORC and ["NUMERIC"] for the other
    /// file formats.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub decimal_target_types: std::vec::Vec<crate::model::DecimalTargetType>,

    /// Optional. Additional properties to set if sourceFormat is set to AVRO.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub avro_options: std::option::Option<crate::model::AvroOptions>,

    /// Optional. Load option to be used together with source_format
    /// newline-delimited JSON to indicate that a variant of JSON is being loaded.
    /// To load newline-delimited GeoJSON, specify GEOJSON (and source_format must
    /// be set to NEWLINE_DELIMITED_JSON).
    pub json_extension: crate::model::JsonExtension,

    /// Optional. Additional properties to set if sourceFormat is set to PARQUET.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parquet_options: std::option::Option<crate::model::ParquetOptions>,

    /// Optional. ObjectMetadata is used to create Object Tables. Object Tables
    /// contain a listing of objects (with their metadata) found at the
    /// source_uris. If ObjectMetadata is set, source_format should be omitted.
    ///
    /// Currently SIMPLE is the only supported Object Metadata type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_metadata:
        std::option::Option<crate::model::external_data_configuration::ObjectMetadata>,

    /// Optional. When creating an external table, the user can provide a reference
    /// file with the table schema. This is enabled for the following formats:
    /// AVRO, PARQUET, ORC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference_file_schema_uri: std::option::Option<wkt::StringValue>,

    /// Optional. Metadata Cache Mode for the table. Set this to enable caching of
    /// metadata from external data source.
    pub metadata_cache_mode: crate::model::external_data_configuration::MetadataCacheMode,
}

impl ExternalDataConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_set_spec_type][crate::model::ExternalDataConfiguration::file_set_spec_type].
    pub fn set_file_set_spec_type<T: std::convert::Into<crate::model::FileSetSpecType>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_set_spec_type = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::ExternalDataConfiguration::schema].
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::TableSchema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [source_format][crate::model::ExternalDataConfiguration::source_format].
    pub fn set_source_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_format = v.into();
        self
    }

    /// Sets the value of [max_bad_records][crate::model::ExternalDataConfiguration::max_bad_records].
    pub fn set_max_bad_records<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_bad_records = v.into();
        self
    }

    /// Sets the value of [autodetect][crate::model::ExternalDataConfiguration::autodetect].
    pub fn set_autodetect<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.autodetect = v.into();
        self
    }

    /// Sets the value of [ignore_unknown_values][crate::model::ExternalDataConfiguration::ignore_unknown_values].
    pub fn set_ignore_unknown_values<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ignore_unknown_values = v.into();
        self
    }

    /// Sets the value of [compression][crate::model::ExternalDataConfiguration::compression].
    pub fn set_compression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compression = v.into();
        self
    }

    /// Sets the value of [csv_options][crate::model::ExternalDataConfiguration::csv_options].
    pub fn set_csv_options<T: std::convert::Into<std::option::Option<crate::model::CsvOptions>>>(
        mut self,
        v: T,
    ) -> Self {
        self.csv_options = v.into();
        self
    }

    /// Sets the value of [json_options][crate::model::ExternalDataConfiguration::json_options].
    pub fn set_json_options<
        T: std::convert::Into<std::option::Option<crate::model::JsonOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.json_options = v.into();
        self
    }

    /// Sets the value of [bigtable_options][crate::model::ExternalDataConfiguration::bigtable_options].
    pub fn set_bigtable_options<
        T: std::convert::Into<std::option::Option<crate::model::BigtableOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigtable_options = v.into();
        self
    }

    /// Sets the value of [google_sheets_options][crate::model::ExternalDataConfiguration::google_sheets_options].
    pub fn set_google_sheets_options<
        T: std::convert::Into<std::option::Option<crate::model::GoogleSheetsOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.google_sheets_options = v.into();
        self
    }

    /// Sets the value of [hive_partitioning_options][crate::model::ExternalDataConfiguration::hive_partitioning_options].
    pub fn set_hive_partitioning_options<
        T: std::convert::Into<std::option::Option<crate::model::HivePartitioningOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hive_partitioning_options = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::ExternalDataConfiguration::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [avro_options][crate::model::ExternalDataConfiguration::avro_options].
    pub fn set_avro_options<
        T: std::convert::Into<std::option::Option<crate::model::AvroOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.avro_options = v.into();
        self
    }

    /// Sets the value of [json_extension][crate::model::ExternalDataConfiguration::json_extension].
    pub fn set_json_extension<T: std::convert::Into<crate::model::JsonExtension>>(
        mut self,
        v: T,
    ) -> Self {
        self.json_extension = v.into();
        self
    }

    /// Sets the value of [parquet_options][crate::model::ExternalDataConfiguration::parquet_options].
    pub fn set_parquet_options<
        T: std::convert::Into<std::option::Option<crate::model::ParquetOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parquet_options = v.into();
        self
    }

    /// Sets the value of [object_metadata][crate::model::ExternalDataConfiguration::object_metadata].
    pub fn set_object_metadata<
        T: std::convert::Into<
            std::option::Option<crate::model::external_data_configuration::ObjectMetadata>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_metadata = v.into();
        self
    }

    /// Sets the value of [reference_file_schema_uri][crate::model::ExternalDataConfiguration::reference_file_schema_uri].
    pub fn set_reference_file_schema_uri<
        T: std::convert::Into<std::option::Option<wkt::StringValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reference_file_schema_uri = v.into();
        self
    }

    /// Sets the value of [metadata_cache_mode][crate::model::ExternalDataConfiguration::metadata_cache_mode].
    pub fn set_metadata_cache_mode<
        T: std::convert::Into<crate::model::external_data_configuration::MetadataCacheMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_cache_mode = v.into();
        self
    }

    /// Sets the value of [source_uris][crate::model::ExternalDataConfiguration::source_uris].
    pub fn set_source_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [decimal_target_types][crate::model::ExternalDataConfiguration::decimal_target_types].
    pub fn set_decimal_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DecimalTargetType>,
    {
        use std::iter::Iterator;
        self.decimal_target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExternalDataConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalDataConfiguration"
    }
}

/// Defines additional types related to ExternalDataConfiguration
pub mod external_data_configuration {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Object Metadata Types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ObjectMetadata(i32);

    impl ObjectMetadata {
        /// Unspecified by default.
        pub const OBJECT_METADATA_UNSPECIFIED: ObjectMetadata = ObjectMetadata::new(0);

        /// A synonym for `SIMPLE`.
        pub const DIRECTORY: ObjectMetadata = ObjectMetadata::new(1);

        /// Directory listing of objects.
        pub const SIMPLE: ObjectMetadata = ObjectMetadata::new(2);

        /// Creates a new ObjectMetadata instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("OBJECT_METADATA_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DIRECTORY"),
                2 => std::borrow::Cow::Borrowed("SIMPLE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "OBJECT_METADATA_UNSPECIFIED" => {
                    std::option::Option::Some(Self::OBJECT_METADATA_UNSPECIFIED)
                }
                "DIRECTORY" => std::option::Option::Some(Self::DIRECTORY),
                "SIMPLE" => std::option::Option::Some(Self::SIMPLE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ObjectMetadata {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ObjectMetadata {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// MetadataCacheMode identifies if the table should use metadata caching for
    /// files from external source (eg Google Cloud Storage).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MetadataCacheMode(i32);

    impl MetadataCacheMode {
        /// Unspecified metadata cache mode.
        pub const METADATA_CACHE_MODE_UNSPECIFIED: MetadataCacheMode = MetadataCacheMode::new(0);

        /// Set this mode to trigger automatic background refresh of metadata cache
        /// from the external source. Queries will use the latest available cache
        /// version within the table's maxStaleness interval.
        pub const AUTOMATIC: MetadataCacheMode = MetadataCacheMode::new(1);

        /// Set this mode to enable triggering manual refresh of the metadata cache
        /// from external source. Queries will use the latest manually triggered
        /// cache version within the table's maxStaleness interval.
        pub const MANUAL: MetadataCacheMode = MetadataCacheMode::new(2);

        /// Creates a new MetadataCacheMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("METADATA_CACHE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AUTOMATIC"),
                2 => std::borrow::Cow::Borrowed("MANUAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "METADATA_CACHE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::METADATA_CACHE_MODE_UNSPECIFIED)
                }
                "AUTOMATIC" => std::option::Option::Some(Self::AUTOMATIC),
                "MANUAL" => std::option::Option::Some(Self::MANUAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MetadataCacheMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MetadataCacheMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configures the access a dataset defined in an external metadata storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalDatasetReference {
    /// Required. External source that backs this dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_source: std::string::String,

    /// Required. The connection id that is used to access the external_source.
    ///
    /// Format:
    /// projects/{project_id}/locations/{location_id}/connections/{connection_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection: std::string::String,
}

impl ExternalDatasetReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_source][crate::model::ExternalDatasetReference::external_source].
    pub fn set_external_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_source = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::ExternalDatasetReference::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for ExternalDatasetReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalDatasetReference"
    }
}

/// Options for configuring hive partitioning detect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HivePartitioningOptions {
    /// Optional. When set, what mode of hive partitioning to use when reading
    /// data.  The following modes are supported:
    ///
    /// * AUTO: automatically infer partition key name(s) and type(s).
    ///
    /// * STRINGS: automatically infer partition key name(s).  All types are
    ///   strings.
    ///
    /// * CUSTOM: partition key schema is encoded in the source URI prefix.
    ///
    ///
    /// Not all storage formats support hive partitioning. Requesting hive
    /// partitioning on an unsupported format will lead to an error.
    /// Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mode: std::string::String,

    /// Optional. When hive partition detection is requested, a common prefix for
    /// all source uris must be required.  The prefix must end immediately before
    /// the partition key encoding begins. For example, consider files following
    /// this data layout:
    ///
    /// gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
    ///
    /// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro
    ///
    /// When hive partitioning is requested with either AUTO or STRINGS detection,
    /// the common prefix can be either of gs://bucket/path_to_table or
    /// gs://bucket/path_to_table/.
    ///
    /// CUSTOM detection requires encoding the partitioning schema immediately
    /// after the common prefix.  For CUSTOM, any of
    ///
    /// * gs://bucket/path_to_table/{dt:DATE}/{country:STRING}/{id:INTEGER}
    ///
    /// * gs://bucket/path_to_table/{dt:STRING}/{country:STRING}/{id:INTEGER}
    ///
    /// * gs://bucket/path_to_table/{dt:DATE}/{country:STRING}/{id:STRING}
    ///
    ///
    /// would all be valid source URI prefixes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_uri_prefix: std::string::String,

    /// Optional. If set to true, queries over this table require a partition
    /// filter that can be used for partition elimination to be specified.
    ///
    /// Note that this field should only be true when creating a permanent
    /// external table or querying a temporary external table.
    ///
    /// Hive-partitioned loads with require_partition_filter explicitly set to
    /// true will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_partition_filter: std::option::Option<wkt::BoolValue>,

    /// Output only. For permanent external tables, this field is populated with
    /// the hive partition keys in the order they were inferred. The types of the
    /// partition keys can be deduced by checking the table schema (which will
    /// include the partition keys). Not every API will populate this field in the
    /// output. For example, Tables.Get will populate it, but Tables.List will not
    /// contain this field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<std::string::String>,
}

impl HivePartitioningOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::HivePartitioningOptions::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [source_uri_prefix][crate::model::HivePartitioningOptions::source_uri_prefix].
    pub fn set_source_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_uri_prefix = v.into();
        self
    }

    /// Sets the value of [require_partition_filter][crate::model::HivePartitioningOptions::require_partition_filter].
    pub fn set_require_partition_filter<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.require_partition_filter = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::HivePartitioningOptions::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HivePartitioningOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.HivePartitioningOptions"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Job {
    /// Output only. The type of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Output only. A hash of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Opaque ID field of the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. A URL that can be used to access the resource again.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Output only. Email address of the user who ran the job.
    #[serde(rename = "user_email")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_email: std::string::String,

    /// Required. Describes the job configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub configuration: std::option::Option<crate::model::JobConfiguration>,

    /// Optional. Reference describing the unique-per-user name of the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_reference: std::option::Option<crate::model::JobReference>,

    /// Output only. Information about the job, including starting time and ending
    /// time of the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub statistics: std::option::Option<crate::model::JobStatistics>,

    /// Output only. The status of this job. Examine this value when polling an
    /// asynchronous job to see if the job is complete.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::JobStatus>,

    /// Output only. [Full-projection-only] String representation of identity of
    /// requesting party. Populated for both first- and third-party identities.
    /// Only present for APIs that support third-party identities.
    #[serde(rename = "principal_subject")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub principal_subject: std::string::String,

    /// Output only. The reason why a Job was created.
    /// [Preview](https://cloud.google.com/products/#product-launch-stages)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_creation_reason: std::option::Option<crate::model::JobCreationReason>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Job::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Job::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Job::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Job::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [user_email][crate::model::Job::user_email].
    pub fn set_user_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_email = v.into();
        self
    }

    /// Sets the value of [configuration][crate::model::Job::configuration].
    pub fn set_configuration<
        T: std::convert::Into<std::option::Option<crate::model::JobConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = v.into();
        self
    }

    /// Sets the value of [job_reference][crate::model::Job::job_reference].
    pub fn set_job_reference<
        T: std::convert::Into<std::option::Option<crate::model::JobReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_reference = v.into();
        self
    }

    /// Sets the value of [statistics][crate::model::Job::statistics].
    pub fn set_statistics<
        T: std::convert::Into<std::option::Option<crate::model::JobStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.statistics = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Job::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::JobStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [principal_subject][crate::model::Job::principal_subject].
    pub fn set_principal_subject<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal_subject = v.into();
        self
    }

    /// Sets the value of [job_creation_reason][crate::model::Job::job_creation_reason].
    pub fn set_job_creation_reason<
        T: std::convert::Into<std::option::Option<crate::model::JobCreationReason>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_creation_reason = v.into();
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Job"
    }
}

/// Describes format of a jobs cancellation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelJobRequest {
    /// Required. Project ID of the job to cancel
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Job ID of the job to cancel
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// The geographic location of the job. You must
    /// [specify the
    /// location](https://cloud.google.com/bigquery/docs/locations#specify_locations)
    /// to run the job for the following scenarios:
    ///
    /// * If the location to run a job is not in the `us` or
    ///   the `eu` multi-regional location
    /// * If the job's location is in a single region (for example,
    ///   `us-central1`)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl CancelJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CancelJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CancelJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::CancelJobRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for CancelJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CancelJobRequest"
    }
}

/// Describes format of a jobs cancellation response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobCancelResponse {
    /// The resource type of the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The final state of the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,
}

impl JobCancelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::JobCancelResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [job][crate::model::JobCancelResponse::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }
}

impl wkt::message::Message for JobCancelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobCancelResponse"
    }
}

/// Describes format of a jobs get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. Project ID of the requested job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Job ID of the requested job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// The geographic location of the job. You must specify the location to run
    /// the job for the following scenarios:
    ///
    /// * If the location to run a job is not in the `us` or
    ///   the `eu` multi-regional location
    /// * If the job's location is in a single region (for example,
    ///   `us-central1`)
    ///
    /// For more information, see how to
    /// [specify
    /// locations](https://cloud.google.com/bigquery/docs/locations#specify_locations).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::GetJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GetJobRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetJobRequest"
    }
}

/// Describes format of a job insertion request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsertJobRequest {
    /// Project ID of project that will be billed for the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Jobs resource to insert.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,
}

impl InsertJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job][crate::model::InsertJobRequest::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }
}

impl wkt::message::Message for InsertJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertJobRequest"
    }
}

/// Describes the format of a jobs deletion request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. Project ID of the job for which metadata is to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Job ID of the job for which metadata is to be deleted. If this is
    /// a parent job which has child jobs, the metadata from all child jobs will be
    /// deleted as well. Direct deletion of the metadata of child jobs is not
    /// allowed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// The geographic location of the job. Required.
    ///
    /// For more information, see how to
    /// [specify
    /// locations](https://cloud.google.com/bigquery/docs/locations#specify_locations).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::DeleteJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DeleteJobRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteJobRequest"
    }
}

/// Describes the format of the list jobs request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Project ID of the jobs to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Whether to display jobs owned by all users in the project. Default False.
    pub all_users: bool,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_results: std::option::Option<wkt::Int32Value>,

    /// Min value for job creation time, in milliseconds since the POSIX epoch.
    /// If set, only jobs created after or at this timestamp are returned.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub min_creation_time: u64,

    /// Max value for job creation time, in milliseconds since the POSIX epoch.
    /// If set, only jobs created before or at this timestamp are returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_creation_time: std::option::Option<wkt::UInt64Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Restrict information returned to a set of selected fields
    pub projection: crate::model::list_jobs_request::Projection,

    /// Filter for job state
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub state_filter: std::vec::Vec<crate::model::list_jobs_request::StateFilter>,

    /// If set, show only child jobs of the specified parent.  Otherwise, show all
    /// top-level jobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_job_id: std::string::String,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListJobsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [all_users][crate::model::ListJobsRequest::all_users].
    pub fn set_all_users<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all_users = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListJobsRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [min_creation_time][crate::model::ListJobsRequest::min_creation_time].
    pub fn set_min_creation_time<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.min_creation_time = v.into();
        self
    }

    /// Sets the value of [max_creation_time][crate::model::ListJobsRequest::max_creation_time].
    pub fn set_max_creation_time<T: std::convert::Into<std::option::Option<wkt::UInt64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_creation_time = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [projection][crate::model::ListJobsRequest::projection].
    pub fn set_projection<T: std::convert::Into<crate::model::list_jobs_request::Projection>>(
        mut self,
        v: T,
    ) -> Self {
        self.projection = v.into();
        self
    }

    /// Sets the value of [parent_job_id][crate::model::ListJobsRequest::parent_job_id].
    pub fn set_parent_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_job_id = v.into();
        self
    }

    /// Sets the value of [state_filter][crate::model::ListJobsRequest::state_filter].
    pub fn set_state_filter<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::list_jobs_request::StateFilter>,
    {
        use std::iter::Iterator;
        self.state_filter = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListJobsRequest"
    }
}

/// Defines additional types related to ListJobsRequest
pub mod list_jobs_request {
    #[allow(unused_imports)]
    use super::*;

    /// Projection is used to control what job information is returned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Projection(i32);

    impl Projection {
        /// Does not include the job configuration
        pub const MINIMAL: Projection = Projection::new(0);

        /// Includes all job data
        pub const FULL: Projection = Projection::new(1);

        /// Creates a new Projection instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MINIMAL"),
                1 => std::borrow::Cow::Borrowed("FULL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "minimal" => std::option::Option::Some(Self::MINIMAL),
                "MINIMAL" => std::option::Option::Some(Self::MINIMAL),
                "full" => std::option::Option::Some(Self::FULL),
                "FULL" => std::option::Option::Some(Self::FULL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Projection {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Projection {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// StateFilter allows filtration by job execution state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StateFilter(i32);

    impl StateFilter {
        /// Finished jobs
        pub const DONE: StateFilter = StateFilter::new(0);

        /// Pending jobs
        pub const PENDING: StateFilter = StateFilter::new(1);

        /// Running jobs
        pub const RUNNING: StateFilter = StateFilter::new(2);

        /// Creates a new StateFilter instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DONE"),
                1 => std::borrow::Cow::Borrowed("PENDING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "done" => std::option::Option::Some(Self::DONE),
                "DONE" => std::option::Option::Some(Self::DONE),
                "pending" => std::option::Option::Some(Self::PENDING),
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "running" => std::option::Option::Some(Self::RUNNING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StateFilter {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StateFilter {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ListFormatJob is a partial projection of job information returned as part
/// of a jobs.list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFormatJob {
    /// Unique opaque ID of the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The resource type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Unique opaque ID of the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job_reference: std::option::Option<crate::model::JobReference>,

    /// Running state of the job. When the state is DONE, errorResult can be
    /// checked to determine whether the job succeeded or failed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state: std::string::String,

    /// A result object that will be present only if the job has failed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_result: std::option::Option<crate::model::ErrorProto>,

    /// Output only. Information about the job, including starting time and ending
    /// time of the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub statistics: std::option::Option<crate::model::JobStatistics>,

    /// Required. Describes the job configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub configuration: std::option::Option<crate::model::JobConfiguration>,

    /// [Full-projection-only] Describes the status of this job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::JobStatus>,

    /// [Full-projection-only] Email address of the user who ran the job.
    #[serde(rename = "user_email")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_email: std::string::String,

    /// [Full-projection-only] String representation of identity of requesting
    /// party. Populated for both first- and third-party identities. Only present
    /// for APIs that support third-party identities.
    #[serde(rename = "principal_subject")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub principal_subject: std::string::String,
}

impl ListFormatJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ListFormatJob::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ListFormatJob::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [job_reference][crate::model::ListFormatJob::job_reference].
    pub fn set_job_reference<
        T: std::convert::Into<std::option::Option<crate::model::JobReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_reference = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ListFormatJob::state].
    pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_result][crate::model::ListFormatJob::error_result].
    pub fn set_error_result<
        T: std::convert::Into<std::option::Option<crate::model::ErrorProto>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_result = v.into();
        self
    }

    /// Sets the value of [statistics][crate::model::ListFormatJob::statistics].
    pub fn set_statistics<
        T: std::convert::Into<std::option::Option<crate::model::JobStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.statistics = v.into();
        self
    }

    /// Sets the value of [configuration][crate::model::ListFormatJob::configuration].
    pub fn set_configuration<
        T: std::convert::Into<std::option::Option<crate::model::JobConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.configuration = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ListFormatJob::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::JobStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [user_email][crate::model::ListFormatJob::user_email].
    pub fn set_user_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_email = v.into();
        self
    }

    /// Sets the value of [principal_subject][crate::model::ListFormatJob::principal_subject].
    pub fn set_principal_subject<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal_subject = v.into();
        self
    }
}

impl wkt::message::Message for ListFormatJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatJob"
    }
}

/// JobList is the response format for a jobs.list call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobList {
    /// A hash of this page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The resource type of the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// A token to request the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// List of jobs that were requested.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::ListFormatJob>,

    /// A list of skipped locations that were unreachable. For more information
    /// about BigQuery locations, see:
    /// <https://cloud.google.com/bigquery/docs/locations>. Example: "europe-west5"
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl JobList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::JobList::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::JobList::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::JobList::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::JobList::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ListFormatJob>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::JobList::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobList"
    }
}

/// Properties for the destination table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestinationTableProperties {
    /// Optional. Friendly name for the destination table. If the table already
    /// exists, it should be same as the existing friendly name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// Optional. The description for the destination table.
    /// This will only be used if the destination table is newly created.
    /// If the table already exists and a value different than the current
    /// description is provided, the job will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<wkt::StringValue>,

    /// Optional. The labels associated with this table. You can use these to
    /// organize and group your tables. This will only be used if the destination
    /// table is newly created. If the table already exists and labels are
    /// different than the current labels are provided, the job will fail.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl DestinationTableProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [friendly_name][crate::model::DestinationTableProperties::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DestinationTableProperties::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DestinationTableProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DestinationTableProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DestinationTableProperties"
    }
}

/// A connection-level property to customize query behavior. Under JDBC, these
/// correspond directly to connection properties passed to the DriverManager.
/// Under ODBC, these correspond to properties in the connection string.
///
/// Currently supported connection properties:
///
/// * **dataset_project_id**: represents the default project for datasets that
///   are used in the query. Setting the
///   system variable `@@dataset_project_id` achieves the same behavior.  For
///   more information about system variables, see:
///   <https://cloud.google.com/bigquery/docs/reference/system-variables>
///
/// * **time_zone**: represents the default timezone used to run the query.
///
/// * **session_id**: associates the query with a given session.
///
/// * **query_label**: associates the query with a given job label. If set,
///   all subsequent queries in a script or session will have this label. For the
///   format in which a you can specify a query label, see labels
///   in the JobConfiguration resource type:
///   <https://cloud.google.com/bigquery/docs/reference/rest/v2/Job#jobconfiguration>
///
/// * **service_account**: indicates the service account to use to run a
///   continuous query. If set, the query job uses the service account to access
///   Google Cloud resources. Service account access is bounded by the IAM
///   permissions that you have granted to the service account.
///
///
/// Additional properties are allowed, but ignored. Specifying multiple
/// connection properties with the same key returns an error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionProperty {
    /// The key of the property to set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// The value of the property to set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,
}

impl ConnectionProperty {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ConnectionProperty::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::ConnectionProperty::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionProperty {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ConnectionProperty"
    }
}

/// JobConfigurationQuery configures a BigQuery query job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobConfigurationQuery {
    /// [Required] SQL query text to execute. The useLegacySql field can be used
    /// to indicate whether the query uses legacy SQL or GoogleSQL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. Describes the table where the query results should be stored.
    /// This property must be set for large results that exceed the maximum
    /// response size.  For queries that produce anonymous (cached) results, this
    /// field will be populated by BigQuery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_table: std::option::Option<crate::model::TableReference>,

    /// Optional. You can specify external table definitions, which operate as
    /// ephemeral tables that can be queried.  These definitions are configured
    /// using a JSON map, where the string key represents the table identifier, and
    /// the value is the corresponding external data configuration object.
    #[serde(rename = "tableDefinitions")]
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub external_table_definitions:
        std::collections::HashMap<std::string::String, crate::model::ExternalDataConfiguration>,

    /// Describes user-defined function resources used in the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_defined_function_resources: std::vec::Vec<crate::model::UserDefinedFunctionResource>,

    /// Optional. Specifies whether the job is allowed to create new tables.
    /// The following values are supported:
    ///
    /// * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the
    ///   table.
    /// * CREATE_NEVER: The table must already exist. If it does not,
    ///   a 'notFound' error is returned in the job result.
    ///
    /// The default value is CREATE_IF_NEEDED.
    /// Creation, truncation and append actions occur as one atomic update
    /// upon job completion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub create_disposition: std::string::String,

    /// Optional. Specifies the action that occurs if the destination table
    /// already exists. The following values are supported:
    ///
    /// * WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the
    ///   data, removes the constraints, and uses the schema from the query result.
    /// * WRITE_APPEND: If the table already exists, BigQuery appends the data to
    ///   the table.
    /// * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate'
    ///   error is returned in the job result.
    ///
    /// The default value is WRITE_EMPTY. Each action is atomic and only occurs if
    /// BigQuery is able to complete the job successfully. Creation, truncation and
    /// append actions occur as one atomic update upon job completion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub write_disposition: std::string::String,

    /// Optional. Specifies the default dataset to use for unqualified
    /// table names in the query. This setting does not alter behavior of
    /// unqualified dataset names. Setting the system variable
    /// `@@dataset_id` achieves the same behavior.  See
    /// <https://cloud.google.com/bigquery/docs/reference/system-variables> for more
    /// information on system variables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_dataset: std::option::Option<crate::model::DatasetReference>,

    /// Optional. Specifies a priority for the query. Possible values include
    /// INTERACTIVE and BATCH. The default value is INTERACTIVE.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub priority: std::string::String,

    /// Optional. If true and query uses legacy SQL dialect, allows the query
    /// to produce arbitrarily large result tables at a slight cost in performance.
    /// Requires destinationTable to be set.
    /// For GoogleSQL queries, this flag is ignored and large results are
    /// always allowed.  However, you must still set destinationTable when result
    /// size exceeds the allowed maximum response size.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_large_results: std::option::Option<wkt::BoolValue>,

    /// Optional. Whether to look for the result in the query cache. The query
    /// cache is a best-effort cache that will be flushed whenever tables in the
    /// query are modified. Moreover, the query cache is only available when a
    /// query does not have a destination table specified. The default value is
    /// true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_query_cache: std::option::Option<wkt::BoolValue>,

    /// Optional. If true and query uses legacy SQL dialect, flattens all nested
    /// and repeated fields in the query results.
    /// allowLargeResults must be true if this is set to false.
    /// For GoogleSQL queries, this flag is ignored and results are never
    /// flattened.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub flatten_results: std::option::Option<wkt::BoolValue>,

    /// Limits the bytes billed for this job. Queries that will have
    /// bytes billed beyond this limit will fail (without incurring a charge).
    /// If unspecified, this will be set to your project default.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub maximum_bytes_billed: std::option::Option<wkt::Int64Value>,

    /// Optional. Specifies whether to use BigQuery's legacy SQL dialect for this
    /// query. The default value is true. If set to false, the query will use
    /// BigQuery's GoogleSQL:
    /// <https://cloud.google.com/bigquery/sql-reference/>
    ///
    /// When useLegacySql is set to false, the value of flattenResults is ignored;
    /// query will be run as if flattenResults is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_legacy_sql: std::option::Option<wkt::BoolValue>,

    /// GoogleSQL only. Set to POSITIONAL to use positional (?) query parameters
    /// or to NAMED to use named (@myparam) query parameters in this query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parameter_mode: std::string::String,

    /// Query parameters for GoogleSQL queries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub query_parameters: std::vec::Vec<crate::model::QueryParameter>,

    /// Output only. System variables for GoogleSQL queries. A system variable is
    /// output if the variable is settable and its value differs from the system
    /// default.
    /// "@@" prefix is not included in the name of the System variables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_variables: std::option::Option<crate::model::SystemVariables>,

    /// Allows the schema of the destination table to be updated as a side effect
    /// of the query job. Schema update options are supported in two cases:
    /// when writeDisposition is WRITE_APPEND;
    /// when writeDisposition is WRITE_TRUNCATE and the destination table is a
    /// partition of a table, specified by partition decorators. For normal tables,
    /// WRITE_TRUNCATE will always overwrite the schema.
    /// One or more of the following values are specified:
    ///
    /// * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
    /// * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original
    ///   schema to nullable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schema_update_options: std::vec::Vec<std::string::String>,

    /// Time-based partitioning specification for the destination table. Only one
    /// of timePartitioning and rangePartitioning should be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_partitioning: std::option::Option<crate::model::TimePartitioning>,

    /// Range partitioning specification for the destination table.
    /// Only one of timePartitioning and rangePartitioning should be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_partitioning: std::option::Option<crate::model::RangePartitioning>,

    /// Clustering specification for the destination table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clustering: std::option::Option<crate::model::Clustering>,

    /// Custom encryption configuration (e.g., Cloud KMS keys)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_encryption_configuration:
        std::option::Option<crate::model::EncryptionConfiguration>,

    /// Options controlling the execution of scripts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub script_options: std::option::Option<crate::model::ScriptOptions>,

    /// Connection properties which can modify the query behavior.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connection_properties: std::vec::Vec<crate::model::ConnectionProperty>,

    /// If this property is true, the job creates a new session using a randomly
    /// generated session_id.  To continue using a created session with
    /// subsequent queries, pass the existing session identifier as a
    /// `ConnectionProperty` value.  The session identifier is returned as part of
    /// the `SessionInfo` message within the query statistics.
    ///
    /// The new session's location will be set to `Job.JobReference.location` if it
    /// is present, otherwise it's set to the default location based on existing
    /// routing logic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_session: std::option::Option<wkt::BoolValue>,

    /// Optional. Whether to run the query as continuous or a regular query.
    /// Continuous query is currently in experimental stage and not ready for
    /// general usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub continuous: std::option::Option<wkt::BoolValue>,

    /// Optional. This is only supported for a SELECT query using a temporary
    /// table. If set, the query is allowed to write results incrementally to the
    /// temporary result table. This may incur a performance penalty. This option
    /// cannot be used with Legacy SQL. This feature is not yet available.
    pub write_incremental_results: bool,
}

impl JobConfigurationQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::JobConfigurationQuery::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [destination_table][crate::model::JobConfigurationQuery::destination_table].
    pub fn set_destination_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_table = v.into();
        self
    }

    /// Sets the value of [create_disposition][crate::model::JobConfigurationQuery::create_disposition].
    pub fn set_create_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_disposition = v.into();
        self
    }

    /// Sets the value of [write_disposition][crate::model::JobConfigurationQuery::write_disposition].
    pub fn set_write_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_disposition = v.into();
        self
    }

    /// Sets the value of [default_dataset][crate::model::JobConfigurationQuery::default_dataset].
    pub fn set_default_dataset<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_dataset = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::JobConfigurationQuery::priority].
    pub fn set_priority<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [allow_large_results][crate::model::JobConfigurationQuery::allow_large_results].
    pub fn set_allow_large_results<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_large_results = v.into();
        self
    }

    /// Sets the value of [use_query_cache][crate::model::JobConfigurationQuery::use_query_cache].
    pub fn set_use_query_cache<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.use_query_cache = v.into();
        self
    }

    /// Sets the value of [flatten_results][crate::model::JobConfigurationQuery::flatten_results].
    pub fn set_flatten_results<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.flatten_results = v.into();
        self
    }

    /// Sets the value of [maximum_bytes_billed][crate::model::JobConfigurationQuery::maximum_bytes_billed].
    pub fn set_maximum_bytes_billed<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.maximum_bytes_billed = v.into();
        self
    }

    /// Sets the value of [use_legacy_sql][crate::model::JobConfigurationQuery::use_legacy_sql].
    pub fn set_use_legacy_sql<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.use_legacy_sql = v.into();
        self
    }

    /// Sets the value of [parameter_mode][crate::model::JobConfigurationQuery::parameter_mode].
    pub fn set_parameter_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parameter_mode = v.into();
        self
    }

    /// Sets the value of [system_variables][crate::model::JobConfigurationQuery::system_variables].
    pub fn set_system_variables<
        T: std::convert::Into<std::option::Option<crate::model::SystemVariables>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_variables = v.into();
        self
    }

    /// Sets the value of [time_partitioning][crate::model::JobConfigurationQuery::time_partitioning].
    pub fn set_time_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::TimePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_partitioning = v.into();
        self
    }

    /// Sets the value of [range_partitioning][crate::model::JobConfigurationQuery::range_partitioning].
    pub fn set_range_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::RangePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_partitioning = v.into();
        self
    }

    /// Sets the value of [clustering][crate::model::JobConfigurationQuery::clustering].
    pub fn set_clustering<T: std::convert::Into<std::option::Option<crate::model::Clustering>>>(
        mut self,
        v: T,
    ) -> Self {
        self.clustering = v.into();
        self
    }

    /// Sets the value of [destination_encryption_configuration][crate::model::JobConfigurationQuery::destination_encryption_configuration].
    pub fn set_destination_encryption_configuration<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [script_options][crate::model::JobConfigurationQuery::script_options].
    pub fn set_script_options<
        T: std::convert::Into<std::option::Option<crate::model::ScriptOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.script_options = v.into();
        self
    }

    /// Sets the value of [create_session][crate::model::JobConfigurationQuery::create_session].
    pub fn set_create_session<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_session = v.into();
        self
    }

    /// Sets the value of [continuous][crate::model::JobConfigurationQuery::continuous].
    pub fn set_continuous<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.continuous = v.into();
        self
    }

    /// Sets the value of [write_incremental_results][crate::model::JobConfigurationQuery::write_incremental_results].
    pub fn set_write_incremental_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.write_incremental_results = v.into();
        self
    }

    /// Sets the value of [user_defined_function_resources][crate::model::JobConfigurationQuery::user_defined_function_resources].
    pub fn set_user_defined_function_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserDefinedFunctionResource>,
    {
        use std::iter::Iterator;
        self.user_defined_function_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [query_parameters][crate::model::JobConfigurationQuery::query_parameters].
    pub fn set_query_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryParameter>,
    {
        use std::iter::Iterator;
        self.query_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [schema_update_options][crate::model::JobConfigurationQuery::schema_update_options].
    pub fn set_schema_update_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.schema_update_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_properties][crate::model::JobConfigurationQuery::connection_properties].
    pub fn set_connection_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProperty>,
    {
        use std::iter::Iterator;
        self.connection_properties = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [external_table_definitions][crate::model::JobConfigurationQuery::external_table_definitions].
    pub fn set_external_table_definitions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ExternalDataConfiguration>,
    {
        use std::iter::Iterator;
        self.external_table_definitions =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for JobConfigurationQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobConfigurationQuery"
    }
}

/// Options related to script execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScriptOptions {
    /// Timeout period for each statement in a script.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub statement_timeout_ms: std::option::Option<wkt::Int64Value>,

    /// Limit on the number of bytes billed per statement. Exceeding this budget
    /// results in an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub statement_byte_budget: std::option::Option<wkt::Int64Value>,

    /// Determines which statement in the script represents the "key result",
    /// used to populate the schema and query results of the script job.
    /// Default is LAST.
    pub key_result_statement: crate::model::script_options::KeyResultStatementKind,
}

impl ScriptOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [statement_timeout_ms][crate::model::ScriptOptions::statement_timeout_ms].
    pub fn set_statement_timeout_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.statement_timeout_ms = v.into();
        self
    }

    /// Sets the value of [statement_byte_budget][crate::model::ScriptOptions::statement_byte_budget].
    pub fn set_statement_byte_budget<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.statement_byte_budget = v.into();
        self
    }

    /// Sets the value of [key_result_statement][crate::model::ScriptOptions::key_result_statement].
    pub fn set_key_result_statement<
        T: std::convert::Into<crate::model::script_options::KeyResultStatementKind>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_result_statement = v.into();
        self
    }
}

impl wkt::message::Message for ScriptOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ScriptOptions"
    }
}

/// Defines additional types related to ScriptOptions
pub mod script_options {
    #[allow(unused_imports)]
    use super::*;

    /// KeyResultStatementKind controls how the key result is determined.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct KeyResultStatementKind(i32);

    impl KeyResultStatementKind {
        /// Default value.
        pub const KEY_RESULT_STATEMENT_KIND_UNSPECIFIED: KeyResultStatementKind =
            KeyResultStatementKind::new(0);

        /// The last result determines the key result.
        pub const LAST: KeyResultStatementKind = KeyResultStatementKind::new(1);

        /// The first SELECT statement determines the key result.
        pub const FIRST_SELECT: KeyResultStatementKind = KeyResultStatementKind::new(2);

        /// Creates a new KeyResultStatementKind instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("KEY_RESULT_STATEMENT_KIND_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LAST"),
                2 => std::borrow::Cow::Borrowed("FIRST_SELECT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "KEY_RESULT_STATEMENT_KIND_UNSPECIFIED" => {
                    std::option::Option::Some(Self::KEY_RESULT_STATEMENT_KIND_UNSPECIFIED)
                }
                "LAST" => std::option::Option::Some(Self::LAST),
                "FIRST_SELECT" => std::option::Option::Some(Self::FIRST_SELECT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for KeyResultStatementKind {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for KeyResultStatementKind {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// JobConfigurationLoad contains the configuration properties for loading data
/// into a destination table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobConfigurationLoad {
    /// [Required] The fully-qualified URIs that point to your data in Google
    /// Cloud.
    /// For Google Cloud Storage URIs:
    /// Each URI can contain one '*' wildcard character and it must come after
    /// the 'bucket' name. Size limits related to load jobs apply to external
    /// data sources.
    /// For Google Cloud Bigtable URIs:
    /// Exactly one URI can be specified and it has be a fully specified and
    /// valid HTTPS URL for a Google Cloud Bigtable table.
    /// For Google Cloud Datastore backups:
    /// Exactly one URI can be specified. Also, the '*' wildcard character is not
    /// allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_uris: std::vec::Vec<std::string::String>,

    /// Optional. Specifies how source URIs are interpreted for constructing the
    /// file set to load. By default, source URIs are expanded against the
    /// underlying storage. You can also specify manifest files to control how the
    /// file set is constructed. This option is only applicable to object storage
    /// systems.
    pub file_set_spec_type: crate::model::FileSetSpecType,

    /// Optional. The schema for the destination table. The schema can be
    /// omitted if the destination table already exists, or if you're loading data
    /// from Google Cloud Datastore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// [Required] The destination table to load the data into.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_table: std::option::Option<crate::model::TableReference>,

    /// Optional. [Experimental] Properties with which to create the destination
    /// table if it is new.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_table_properties: std::option::Option<crate::model::DestinationTableProperties>,

    /// Optional. Specifies whether the job is allowed to create new tables.
    /// The following values are supported:
    ///
    /// * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the
    ///   table.
    /// * CREATE_NEVER: The table must already exist. If it does not,
    ///   a 'notFound' error is returned in the job result.
    ///   The default value is CREATE_IF_NEEDED.
    ///   Creation, truncation and append actions occur as one atomic update
    ///   upon job completion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub create_disposition: std::string::String,

    /// Optional. Specifies the action that occurs if the destination table
    /// already exists. The following values are supported:
    ///
    /// * WRITE_TRUNCATE:  If the table already exists, BigQuery overwrites the
    ///   data, removes the constraints and uses the schema from the load job.
    /// * WRITE_APPEND: If the table already exists, BigQuery appends the data to
    ///   the table.
    /// * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate'
    ///   error is returned in the job result.
    ///
    /// The default value is WRITE_APPEND.
    /// Each action is atomic and only occurs if BigQuery is able to complete the
    /// job successfully.
    /// Creation, truncation and append actions occur as one atomic update
    /// upon job completion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub write_disposition: std::string::String,

    /// Optional. Specifies a string that represents a null value in a CSV file.
    /// For example, if you specify "\N", BigQuery interprets "\N" as a null value
    /// when loading a CSV file.
    /// The default value is the empty string. If you set this property to a custom
    /// value, BigQuery throws an error if an empty string is present for all data
    /// types except for STRING and BYTE. For STRING and BYTE columns, BigQuery
    /// interprets the empty string as an empty value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub null_marker: std::option::Option<wkt::StringValue>,

    /// Optional. The separator character for fields in a CSV file. The separator
    /// is interpreted as a single byte. For files encoded in ISO-8859-1, any
    /// single character can be used as a separator. For files encoded in UTF-8,
    /// characters represented in decimal range 1-127 (U+0001-U+007F) can be used
    /// without any modification. UTF-8 characters encoded with multiple bytes
    /// (i.e. U+0080 and above) will have only the first byte used for separating
    /// fields. The remaining bytes will be treated as a part of the field.
    /// BigQuery also supports the escape sequence "\t" (U+0009) to specify a tab
    /// separator. The default value is comma (",", U+002C).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_delimiter: std::string::String,

    /// Optional. The number of rows at the top of a CSV file that BigQuery will
    /// skip when loading the data. The default value is 0. This property is useful
    /// if you have header rows in the file that should be skipped. When autodetect
    /// is on, the behavior is the following:
    ///
    /// * skipLeadingRows unspecified - Autodetect tries to detect headers in the
    ///   first row. If they are not detected, the row is read as data. Otherwise
    ///   data is read starting from the second row.
    /// * skipLeadingRows is 0 - Instructs autodetect that there are no headers and
    ///   data should be read starting from the first row.
    /// * skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect
    ///   headers in row N. If headers are not detected, row N is just skipped.
    ///   Otherwise row N is used to extract column names for the detected schema.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub skip_leading_rows: std::option::Option<wkt::Int32Value>,

    /// Optional. The character encoding of the data.
    /// The supported values are UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE,
    /// and UTF-32LE. The default value is UTF-8. BigQuery decodes the data after
    /// the raw, binary data has been split using the values of the `quote` and
    /// `fieldDelimiter` properties.
    ///
    /// If you don't specify an encoding, or if you specify a UTF-8 encoding when
    /// the CSV file is not UTF-8 encoded, BigQuery attempts to convert the data to
    /// UTF-8. Generally, your data loads successfully, but it may not match
    /// byte-for-byte what you expect. To avoid this, specify the correct encoding
    /// by using the `--encoding` flag.
    ///
    /// If BigQuery can't convert a character other than the ASCII `0` character,
    /// BigQuery converts the character to the standard Unicode replacement
    /// character: &#65533;.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,

    /// Optional. The value that is used to quote data sections in a CSV file.
    /// BigQuery converts the string to ISO-8859-1 encoding, and then uses the
    /// first byte of the encoded string to split the data in its raw, binary
    /// state.
    /// The default value is a double-quote ('"').
    /// If your data does not contain quoted sections, set the property value to an
    /// empty string.
    /// If your data contains quoted newline characters, you must also set the
    /// allowQuotedNewlines property to true.
    /// To include the specific quote character within a quoted value, precede it
    /// with an additional matching quote character. For example, if you want to
    /// escape the default character  ' " ', use ' "" '.
    /// @default "
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quote: std::option::Option<wkt::StringValue>,

    /// Optional. The maximum number of bad records that BigQuery can ignore when
    /// running the job. If the number of bad records exceeds this value, an
    /// invalid error is returned in the job result.
    /// The default value is 0, which requires that all records are valid.
    /// This is only supported for CSV and NEWLINE_DELIMITED_JSON file formats.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_bad_records: std::option::Option<wkt::Int32Value>,

    /// Indicates if BigQuery should allow quoted data sections that contain
    /// newline characters in a CSV file. The default value is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_quoted_newlines: std::option::Option<wkt::BoolValue>,

    /// Optional. The format of the data files.
    /// For CSV files, specify "CSV". For datastore backups,
    /// specify "DATASTORE_BACKUP". For newline-delimited JSON,
    /// specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO".
    /// For parquet, specify "PARQUET". For orc, specify "ORC".
    /// The default value is CSV.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_format: std::string::String,

    /// Optional. Accept rows that are missing trailing optional columns.
    /// The missing values are treated as nulls.
    /// If false, records with missing trailing columns are treated as bad records,
    /// and if there are too many bad records, an invalid error is returned in the
    /// job result.
    /// The default value is false.
    /// Only applicable to CSV, ignored for other formats.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_jagged_rows: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates if BigQuery should allow extra values that are not
    /// represented in the table schema.
    /// If true, the extra values are ignored.
    /// If false, records with extra columns are treated as bad records, and if
    /// there are too many bad records, an invalid error is returned in the job
    /// result. The default value is false.
    /// The sourceFormat property determines what BigQuery treats as an extra
    /// value:
    /// CSV: Trailing columns
    /// JSON: Named values that don't match any column names in the table schema
    /// Avro, Parquet, ORC: Fields in the file schema that don't exist in the
    /// table schema.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ignore_unknown_values: std::option::Option<wkt::BoolValue>,

    /// If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity
    /// properties to load into BigQuery from a Cloud Datastore backup. Property
    /// names are case sensitive and must be top-level properties. If no properties
    /// are specified, BigQuery loads all properties. If any named property isn't
    /// found in the Cloud Datastore backup, an invalid error is returned in the
    /// job result.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub projection_fields: std::vec::Vec<std::string::String>,

    /// Optional. Indicates if we should automatically infer the options and
    /// schema for CSV and JSON sources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autodetect: std::option::Option<wkt::BoolValue>,

    /// Allows the schema of the destination table to be updated as a side effect
    /// of the load job if a schema is autodetected or supplied in the job
    /// configuration.
    /// Schema update options are supported in two cases:
    /// when writeDisposition is WRITE_APPEND;
    /// when writeDisposition is WRITE_TRUNCATE and the destination table is a
    /// partition of a table, specified by partition decorators. For normal tables,
    /// WRITE_TRUNCATE will always overwrite the schema.
    /// One or more of the following values are specified:
    ///
    /// * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
    /// * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original
    ///   schema to nullable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schema_update_options: std::vec::Vec<std::string::String>,

    /// Time-based partitioning specification for the destination table. Only one
    /// of timePartitioning and rangePartitioning should be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_partitioning: std::option::Option<crate::model::TimePartitioning>,

    /// Range partitioning specification for the destination table.
    /// Only one of timePartitioning and rangePartitioning should be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_partitioning: std::option::Option<crate::model::RangePartitioning>,

    /// Clustering specification for the destination table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clustering: std::option::Option<crate::model::Clustering>,

    /// Custom encryption configuration (e.g., Cloud KMS keys)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_encryption_configuration:
        std::option::Option<crate::model::EncryptionConfiguration>,

    /// Optional. If sourceFormat is set to "AVRO", indicates whether to interpret
    /// logical types as the corresponding BigQuery data type (for example,
    /// TIMESTAMP), instead of using the raw type (for example, INTEGER).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_avro_logical_types: std::option::Option<wkt::BoolValue>,

    /// Optional. The user can provide a reference file with the reader schema.
    /// This file is only loaded if it is part of source URIs, but is not loaded
    /// otherwise. It is enabled for the following formats: AVRO, PARQUET, ORC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference_file_schema_uri: std::option::Option<wkt::StringValue>,

    /// Optional. When set, configures hive partitioning support.
    /// Not all storage formats support hive partitioning -- requesting hive
    /// partitioning on an unsupported format will lead to an error, as will
    /// providing an invalid specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hive_partitioning_options: std::option::Option<crate::model::HivePartitioningOptions>,

    /// Defines the list of possible SQL data types to which the source decimal
    /// values are converted. This list and the precision and the scale parameters
    /// of the decimal field determine the target type. In the order of NUMERIC,
    /// BIGNUMERIC, and STRING, a
    /// type is picked if it is in the specified list and if it supports the
    /// precision and the scale. STRING supports all precision and scale values.
    /// If none of the listed types supports the precision and the scale, the type
    /// supporting the widest range in the specified list is picked, and if a value
    /// exceeds the supported range when reading the data, an error will be thrown.
    ///
    /// Example: Suppose the value of this field is ["NUMERIC", "BIGNUMERIC"].
    /// If (precision,scale) is:
    ///
    /// * (38,9) -> NUMERIC;
    /// * (39,9) -> BIGNUMERIC (NUMERIC cannot hold 30 integer digits);
    /// * (38,10) -> BIGNUMERIC (NUMERIC cannot hold 10 fractional digits);
    /// * (76,38) -> BIGNUMERIC;
    /// * (77,38) -> BIGNUMERIC (error if value exceeds supported range).
    ///
    /// This field cannot contain duplicate types. The order of the types in this
    /// field is ignored. For example, ["BIGNUMERIC", "NUMERIC"] is the same as
    /// ["NUMERIC", "BIGNUMERIC"] and NUMERIC always takes precedence over
    /// BIGNUMERIC.
    ///
    /// Defaults to ["NUMERIC", "STRING"] for ORC and ["NUMERIC"] for the other
    /// file formats.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub decimal_target_types: std::vec::Vec<crate::model::DecimalTargetType>,

    /// Optional. Load option to be used together with source_format
    /// newline-delimited JSON to indicate that a variant of JSON is being loaded.
    /// To load newline-delimited GeoJSON, specify GEOJSON (and source_format must
    /// be set to NEWLINE_DELIMITED_JSON).
    pub json_extension: crate::model::JsonExtension,

    /// Optional. Additional properties to set if sourceFormat is set to PARQUET.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parquet_options: std::option::Option<crate::model::ParquetOptions>,

    /// Optional. When sourceFormat is set to "CSV", this indicates whether the
    /// embedded ASCII control characters (the first 32 characters in the
    /// ASCII-table, from
    /// '\x00' to '\x1F') are preserved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preserve_ascii_control_characters: std::option::Option<wkt::BoolValue>,

    /// Optional. Connection properties which can modify the load job behavior.
    /// Currently, only the 'session_id' connection property is supported, and is
    /// used to resolve _SESSION appearing as the dataset id.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connection_properties: std::vec::Vec<crate::model::ConnectionProperty>,

    /// Optional. If this property is true, the job creates a new session using a
    /// randomly generated session_id.  To continue using a created session with
    /// subsequent queries, pass the existing session identifier as a
    /// `ConnectionProperty` value.  The session identifier is returned as part of
    /// the `SessionInfo` message within the query statistics.
    ///
    /// The new session's location will be set to `Job.JobReference.location` if it
    /// is present, otherwise it's set to the default location based on existing
    /// routing logic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_session: std::option::Option<wkt::BoolValue>,

    /// Optional. Character map supported for column names in CSV/Parquet loads.
    /// Defaults to STRICT and can be overridden by Project Config Service. Using
    /// this option with unsupporting load formats will result in an error.
    pub column_name_character_map: crate::model::job_configuration_load::ColumnNameCharacterMap,

    /// Optional. [Experimental] Configures the load job to copy files directly to
    /// the destination BigLake managed table, bypassing file content reading and
    /// rewriting.
    ///
    /// Copying files only is supported when all the following are true:
    ///
    /// * `source_uris` are located in the same Cloud Storage location as the
    ///   destination table's `storage_uri` location.
    /// * `source_format` is `PARQUET`.
    /// * `destination_table` is an existing BigLake managed table. The table's
    ///   schema does not have flexible column names. The table's columns do not
    ///   have type parameters other than precision and scale.
    /// * No options other than the above are specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub copy_files_only: std::option::Option<wkt::BoolValue>,
}

impl JobConfigurationLoad {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_set_spec_type][crate::model::JobConfigurationLoad::file_set_spec_type].
    pub fn set_file_set_spec_type<T: std::convert::Into<crate::model::FileSetSpecType>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_set_spec_type = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::JobConfigurationLoad::schema].
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::TableSchema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [destination_table][crate::model::JobConfigurationLoad::destination_table].
    pub fn set_destination_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_table = v.into();
        self
    }

    /// Sets the value of [destination_table_properties][crate::model::JobConfigurationLoad::destination_table_properties].
    pub fn set_destination_table_properties<
        T: std::convert::Into<std::option::Option<crate::model::DestinationTableProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_table_properties = v.into();
        self
    }

    /// Sets the value of [create_disposition][crate::model::JobConfigurationLoad::create_disposition].
    pub fn set_create_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_disposition = v.into();
        self
    }

    /// Sets the value of [write_disposition][crate::model::JobConfigurationLoad::write_disposition].
    pub fn set_write_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_disposition = v.into();
        self
    }

    /// Sets the value of [null_marker][crate::model::JobConfigurationLoad::null_marker].
    pub fn set_null_marker<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.null_marker = v.into();
        self
    }

    /// Sets the value of [field_delimiter][crate::model::JobConfigurationLoad::field_delimiter].
    pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_delimiter = v.into();
        self
    }

    /// Sets the value of [skip_leading_rows][crate::model::JobConfigurationLoad::skip_leading_rows].
    pub fn set_skip_leading_rows<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.skip_leading_rows = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::JobConfigurationLoad::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [quote][crate::model::JobConfigurationLoad::quote].
    pub fn set_quote<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quote = v.into();
        self
    }

    /// Sets the value of [max_bad_records][crate::model::JobConfigurationLoad::max_bad_records].
    pub fn set_max_bad_records<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_bad_records = v.into();
        self
    }

    /// Sets the value of [allow_quoted_newlines][crate::model::JobConfigurationLoad::allow_quoted_newlines].
    pub fn set_allow_quoted_newlines<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_quoted_newlines = v.into();
        self
    }

    /// Sets the value of [source_format][crate::model::JobConfigurationLoad::source_format].
    pub fn set_source_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_format = v.into();
        self
    }

    /// Sets the value of [allow_jagged_rows][crate::model::JobConfigurationLoad::allow_jagged_rows].
    pub fn set_allow_jagged_rows<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_jagged_rows = v.into();
        self
    }

    /// Sets the value of [ignore_unknown_values][crate::model::JobConfigurationLoad::ignore_unknown_values].
    pub fn set_ignore_unknown_values<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ignore_unknown_values = v.into();
        self
    }

    /// Sets the value of [autodetect][crate::model::JobConfigurationLoad::autodetect].
    pub fn set_autodetect<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.autodetect = v.into();
        self
    }

    /// Sets the value of [time_partitioning][crate::model::JobConfigurationLoad::time_partitioning].
    pub fn set_time_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::TimePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_partitioning = v.into();
        self
    }

    /// Sets the value of [range_partitioning][crate::model::JobConfigurationLoad::range_partitioning].
    pub fn set_range_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::RangePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_partitioning = v.into();
        self
    }

    /// Sets the value of [clustering][crate::model::JobConfigurationLoad::clustering].
    pub fn set_clustering<T: std::convert::Into<std::option::Option<crate::model::Clustering>>>(
        mut self,
        v: T,
    ) -> Self {
        self.clustering = v.into();
        self
    }

    /// Sets the value of [destination_encryption_configuration][crate::model::JobConfigurationLoad::destination_encryption_configuration].
    pub fn set_destination_encryption_configuration<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [use_avro_logical_types][crate::model::JobConfigurationLoad::use_avro_logical_types].
    pub fn set_use_avro_logical_types<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.use_avro_logical_types = v.into();
        self
    }

    /// Sets the value of [reference_file_schema_uri][crate::model::JobConfigurationLoad::reference_file_schema_uri].
    pub fn set_reference_file_schema_uri<
        T: std::convert::Into<std::option::Option<wkt::StringValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reference_file_schema_uri = v.into();
        self
    }

    /// Sets the value of [hive_partitioning_options][crate::model::JobConfigurationLoad::hive_partitioning_options].
    pub fn set_hive_partitioning_options<
        T: std::convert::Into<std::option::Option<crate::model::HivePartitioningOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hive_partitioning_options = v.into();
        self
    }

    /// Sets the value of [json_extension][crate::model::JobConfigurationLoad::json_extension].
    pub fn set_json_extension<T: std::convert::Into<crate::model::JsonExtension>>(
        mut self,
        v: T,
    ) -> Self {
        self.json_extension = v.into();
        self
    }

    /// Sets the value of [parquet_options][crate::model::JobConfigurationLoad::parquet_options].
    pub fn set_parquet_options<
        T: std::convert::Into<std::option::Option<crate::model::ParquetOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parquet_options = v.into();
        self
    }

    /// Sets the value of [preserve_ascii_control_characters][crate::model::JobConfigurationLoad::preserve_ascii_control_characters].
    pub fn set_preserve_ascii_control_characters<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preserve_ascii_control_characters = v.into();
        self
    }

    /// Sets the value of [create_session][crate::model::JobConfigurationLoad::create_session].
    pub fn set_create_session<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_session = v.into();
        self
    }

    /// Sets the value of [column_name_character_map][crate::model::JobConfigurationLoad::column_name_character_map].
    pub fn set_column_name_character_map<
        T: std::convert::Into<crate::model::job_configuration_load::ColumnNameCharacterMap>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.column_name_character_map = v.into();
        self
    }

    /// Sets the value of [copy_files_only][crate::model::JobConfigurationLoad::copy_files_only].
    pub fn set_copy_files_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_files_only = v.into();
        self
    }

    /// Sets the value of [source_uris][crate::model::JobConfigurationLoad::source_uris].
    pub fn set_source_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [projection_fields][crate::model::JobConfigurationLoad::projection_fields].
    pub fn set_projection_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.projection_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [schema_update_options][crate::model::JobConfigurationLoad::schema_update_options].
    pub fn set_schema_update_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.schema_update_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [decimal_target_types][crate::model::JobConfigurationLoad::decimal_target_types].
    pub fn set_decimal_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DecimalTargetType>,
    {
        use std::iter::Iterator;
        self.decimal_target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_properties][crate::model::JobConfigurationLoad::connection_properties].
    pub fn set_connection_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProperty>,
    {
        use std::iter::Iterator;
        self.connection_properties = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobConfigurationLoad {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobConfigurationLoad"
    }
}

/// Defines additional types related to JobConfigurationLoad
pub mod job_configuration_load {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the character map used for column names.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ColumnNameCharacterMap(i32);

    impl ColumnNameCharacterMap {
        /// Unspecified column name character map.
        pub const COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED: ColumnNameCharacterMap =
            ColumnNameCharacterMap::new(0);

        /// Support flexible column name and reject invalid column names.
        pub const STRICT: ColumnNameCharacterMap = ColumnNameCharacterMap::new(1);

        /// Support alphanumeric + underscore characters and names must start with a
        /// letter or underscore. Invalid column names will be normalized.
        pub const V1: ColumnNameCharacterMap = ColumnNameCharacterMap::new(2);

        /// Support flexible column name. Invalid column names will be normalized.
        pub const V2: ColumnNameCharacterMap = ColumnNameCharacterMap::new(3);

        /// Creates a new ColumnNameCharacterMap instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STRICT"),
                2 => std::borrow::Cow::Borrowed("V1"),
                3 => std::borrow::Cow::Borrowed("V2"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED)
                }
                "STRICT" => std::option::Option::Some(Self::STRICT),
                "V1" => std::option::Option::Some(Self::V1),
                "V2" => std::option::Option::Some(Self::V2),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ColumnNameCharacterMap {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ColumnNameCharacterMap {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// JobConfigurationTableCopy configures a job that copies data from one table
/// to another.
/// For more information on copying tables, see [Copy a
/// table](https://cloud.google.com/bigquery/docs/managing-tables#copy-table).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobConfigurationTableCopy {
    /// [Pick one] Source table to copy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_table: std::option::Option<crate::model::TableReference>,

    /// [Pick one] Source tables to copy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_tables: std::vec::Vec<crate::model::TableReference>,

    /// [Required] The destination table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_table: std::option::Option<crate::model::TableReference>,

    /// Optional. Specifies whether the job is allowed to create new tables.
    /// The following values are supported:
    ///
    /// * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the
    ///   table.
    /// * CREATE_NEVER: The table must already exist. If it does not,
    ///   a 'notFound' error is returned in the job result.
    ///
    /// The default value is CREATE_IF_NEEDED.
    /// Creation, truncation and append actions occur as one atomic update
    /// upon job completion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub create_disposition: std::string::String,

    /// Optional. Specifies the action that occurs if the destination table
    /// already exists. The following values are supported:
    ///
    /// * WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the
    ///   table data and uses the schema and table constraints from the source table.
    /// * WRITE_APPEND: If the table already exists, BigQuery appends the data to
    ///   the table.
    /// * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate'
    ///   error is returned in the job result.
    ///
    /// The default value is WRITE_EMPTY. Each action is atomic and only occurs if
    /// BigQuery is able to complete the job successfully. Creation, truncation and
    /// append actions occur as one atomic update upon job completion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub write_disposition: std::string::String,

    /// Custom encryption configuration (e.g., Cloud KMS keys).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_encryption_configuration:
        std::option::Option<crate::model::EncryptionConfiguration>,

    /// Optional. Supported operation types in table copy job.
    pub operation_type: crate::model::job_configuration_table_copy::OperationType,

    /// Optional. The time when the destination table expires. Expired tables will
    /// be deleted and their storage reclaimed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_expiration_time: std::option::Option<wkt::Timestamp>,
}

impl JobConfigurationTableCopy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_table][crate::model::JobConfigurationTableCopy::source_table].
    pub fn set_source_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [destination_table][crate::model::JobConfigurationTableCopy::destination_table].
    pub fn set_destination_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_table = v.into();
        self
    }

    /// Sets the value of [create_disposition][crate::model::JobConfigurationTableCopy::create_disposition].
    pub fn set_create_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_disposition = v.into();
        self
    }

    /// Sets the value of [write_disposition][crate::model::JobConfigurationTableCopy::write_disposition].
    pub fn set_write_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_disposition = v.into();
        self
    }

    /// Sets the value of [destination_encryption_configuration][crate::model::JobConfigurationTableCopy::destination_encryption_configuration].
    pub fn set_destination_encryption_configuration<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::JobConfigurationTableCopy::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::job_configuration_table_copy::OperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [destination_expiration_time][crate::model::JobConfigurationTableCopy::destination_expiration_time].
    pub fn set_destination_expiration_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_expiration_time = v.into();
        self
    }

    /// Sets the value of [source_tables][crate::model::JobConfigurationTableCopy::source_tables].
    pub fn set_source_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableReference>,
    {
        use std::iter::Iterator;
        self.source_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobConfigurationTableCopy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobConfigurationTableCopy"
    }
}

/// Defines additional types related to JobConfigurationTableCopy
pub mod job_configuration_table_copy {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates different operation types supported in table copy job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct OperationType(i32);

    impl OperationType {
        /// Unspecified operation type.
        pub const OPERATION_TYPE_UNSPECIFIED: OperationType = OperationType::new(0);

        /// The source and destination table have the same table type.
        pub const COPY: OperationType = OperationType::new(1);

        /// The source table type is TABLE and
        /// the destination table type is SNAPSHOT.
        pub const SNAPSHOT: OperationType = OperationType::new(2);

        /// The source table type is SNAPSHOT and
        /// the destination table type is TABLE.
        pub const RESTORE: OperationType = OperationType::new(3);

        /// The source and destination table have the same table type,
        /// but only bill for unique data.
        pub const CLONE: OperationType = OperationType::new(4);

        /// Creates a new OperationType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("OPERATION_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("COPY"),
                2 => std::borrow::Cow::Borrowed("SNAPSHOT"),
                3 => std::borrow::Cow::Borrowed("RESTORE"),
                4 => std::borrow::Cow::Borrowed("CLONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "OPERATION_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::OPERATION_TYPE_UNSPECIFIED)
                }
                "COPY" => std::option::Option::Some(Self::COPY),
                "SNAPSHOT" => std::option::Option::Some(Self::SNAPSHOT),
                "RESTORE" => std::option::Option::Some(Self::RESTORE),
                "CLONE" => std::option::Option::Some(Self::CLONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for OperationType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for OperationType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// JobConfigurationExtract configures a job that exports data from a BigQuery
/// table into Google Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobConfigurationExtract {
    /// [Pick one] A list of fully-qualified Google Cloud Storage URIs where the
    /// extracted table should be written.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub destination_uris: std::vec::Vec<std::string::String>,

    /// Optional. Whether to print out a header row in the results.
    /// Default is true. Not applicable when extracting models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub print_header: std::option::Option<wkt::BoolValue>,

    /// Optional. When extracting data in CSV format, this defines the
    /// delimiter to use between fields in the exported data.
    /// Default is ','. Not applicable when extracting models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_delimiter: std::string::String,

    /// Optional. The exported file format. Possible values include CSV,
    /// NEWLINE_DELIMITED_JSON, PARQUET, or AVRO for tables and ML_TF_SAVED_MODEL
    /// or ML_XGBOOST_BOOSTER for models. The default value for tables is CSV.
    /// Tables with nested or repeated fields cannot be exported as CSV. The
    /// default value for models is ML_TF_SAVED_MODEL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_format: std::string::String,

    /// Optional. The compression type to use for exported files. Possible values
    /// include DEFLATE, GZIP, NONE, SNAPPY, and ZSTD. The default value is NONE.
    /// Not all compression formats are support for all file formats. DEFLATE is
    /// only supported for Avro. ZSTD is only supported for Parquet. Not applicable
    /// when extracting models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub compression: std::string::String,

    /// Whether to use logical types when extracting to AVRO format. Not applicable
    /// when extracting models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_avro_logical_types: std::option::Option<wkt::BoolValue>,

    /// Optional. Model extract options only applicable when extracting models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_extract_options:
        std::option::Option<crate::model::job_configuration_extract::ModelExtractOptions>,

    /// Required. Source reference for the export.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::job_configuration_extract::Source>,
}

impl JobConfigurationExtract {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [print_header][crate::model::JobConfigurationExtract::print_header].
    pub fn set_print_header<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.print_header = v.into();
        self
    }

    /// Sets the value of [field_delimiter][crate::model::JobConfigurationExtract::field_delimiter].
    pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_delimiter = v.into();
        self
    }

    /// Sets the value of [destination_format][crate::model::JobConfigurationExtract::destination_format].
    pub fn set_destination_format<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_format = v.into();
        self
    }

    /// Sets the value of [compression][crate::model::JobConfigurationExtract::compression].
    pub fn set_compression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compression = v.into();
        self
    }

    /// Sets the value of [use_avro_logical_types][crate::model::JobConfigurationExtract::use_avro_logical_types].
    pub fn set_use_avro_logical_types<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.use_avro_logical_types = v.into();
        self
    }

    /// Sets the value of [model_extract_options][crate::model::JobConfigurationExtract::model_extract_options].
    pub fn set_model_extract_options<
        T: std::convert::Into<
            std::option::Option<crate::model::job_configuration_extract::ModelExtractOptions>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_extract_options = v.into();
        self
    }

    /// Sets the value of [destination_uris][crate::model::JobConfigurationExtract::destination_uris].
    pub fn set_destination_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.destination_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::job_configuration_extract::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::JobConfigurationExtract::source]
    /// if it holds a `SourceTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_table(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TableReference>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::job_configuration_extract::Source::SourceTable(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::JobConfigurationExtract::source]
    /// if it holds a `SourceModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_model(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ModelReference>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::job_configuration_extract::Source::SourceModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::JobConfigurationExtract::source]
    /// to hold a `SourceTable`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_table<
        T: std::convert::Into<std::boxed::Box<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::job_configuration_extract::Source::SourceTable(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::JobConfigurationExtract::source]
    /// to hold a `SourceModel`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_model<
        T: std::convert::Into<std::boxed::Box<crate::model::ModelReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::job_configuration_extract::Source::SourceModel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for JobConfigurationExtract {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobConfigurationExtract"
    }
}

/// Defines additional types related to JobConfigurationExtract
pub mod job_configuration_extract {
    #[allow(unused_imports)]
    use super::*;

    /// Options related to model extraction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ModelExtractOptions {
        /// The 1-based ID of the trial to be exported from a hyperparameter tuning
        /// model. If not specified, the trial with id =
        /// [Model](https://cloud.google.com/bigquery/docs/reference/rest/v2/models#resource:-model).defaultTrialId
        /// is exported. This field is ignored for models not trained with
        /// hyperparameter tuning.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub trial_id: std::option::Option<wkt::Int64Value>,
    }

    impl ModelExtractOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trial_id][crate::model::job_configuration_extract::ModelExtractOptions::trial_id].
        pub fn set_trial_id<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trial_id = v.into();
            self
        }
    }

    impl wkt::message::Message for ModelExtractOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.JobConfigurationExtract.ModelExtractOptions"
        }
    }

    /// Required. Source reference for the export.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// A reference to the table being exported.
        SourceTable(std::boxed::Box<crate::model::TableReference>),
        /// A reference to the model being exported.
        SourceModel(std::boxed::Box<crate::model::ModelReference>),
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobConfiguration {
    /// Output only. The type of the job. Can be QUERY, LOAD, EXTRACT, COPY or
    /// UNKNOWN.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_type: std::string::String,

    /// [Pick one] Configures a query job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::JobConfigurationQuery>,

    /// [Pick one] Configures a load job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub load: std::option::Option<crate::model::JobConfigurationLoad>,

    /// [Pick one] Copies a table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub copy: std::option::Option<crate::model::JobConfigurationTableCopy>,

    /// [Pick one] Configures an extract job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub extract: std::option::Option<crate::model::JobConfigurationExtract>,

    /// Optional. If set, don't actually run this job. A valid query will return
    /// a mostly empty response with some processing statistics, while an invalid
    /// query will return the same error it would if it wasn't a dry run. Behavior
    /// of non-query jobs is undefined.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dry_run: std::option::Option<wkt::BoolValue>,

    /// Optional. Job timeout in milliseconds. If this time limit is exceeded,
    /// BigQuery will attempt to stop a longer job, but may not always succeed in
    /// canceling it before the job completes. For example, a job that takes more
    /// than 60 seconds to complete has a better chance of being stopped than a job
    /// that takes 10 seconds to complete.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub job_timeout_ms: std::option::Option<wkt::Int64Value>,

    /// The labels associated with this job. You can use these to organize and
    /// group your jobs.
    /// Label keys and values can be no longer than 63 characters, can only contain
    /// lowercase letters, numeric characters, underscores and dashes.
    /// International characters are allowed. Label values are optional.  Label
    /// keys must start with a letter and each label in the list must have a
    /// different key.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl JobConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_type][crate::model::JobConfiguration::job_type].
    pub fn set_job_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_type = v.into();
        self
    }

    /// Sets the value of [query][crate::model::JobConfiguration::query].
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::JobConfigurationQuery>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [load][crate::model::JobConfiguration::load].
    pub fn set_load<
        T: std::convert::Into<std::option::Option<crate::model::JobConfigurationLoad>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::JobConfiguration::copy].
    pub fn set_copy<
        T: std::convert::Into<std::option::Option<crate::model::JobConfigurationTableCopy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.copy = v.into();
        self
    }

    /// Sets the value of [extract][crate::model::JobConfiguration::extract].
    pub fn set_extract<
        T: std::convert::Into<std::option::Option<crate::model::JobConfigurationExtract>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.extract = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::JobConfiguration::dry_run].
    pub fn set_dry_run<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [job_timeout_ms][crate::model::JobConfiguration::job_timeout_ms].
    pub fn set_job_timeout_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_timeout_ms = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::JobConfiguration::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for JobConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobConfiguration"
    }
}

/// Reason about why a Job was created from a
/// [`jobs.query`](https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query)
/// method when used with `JOB_CREATION_OPTIONAL` Job creation mode.
///
/// For
/// [`jobs.insert`](https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert)
/// method calls it will always be `REQUESTED`.
///
/// [Preview](https://cloud.google.com/products/#product-launch-stages)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobCreationReason {
    /// Output only. Specifies the high level reason why a Job was created.
    pub code: crate::model::job_creation_reason::Code,
}

impl JobCreationReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::JobCreationReason::code].
    pub fn set_code<T: std::convert::Into<crate::model::job_creation_reason::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for JobCreationReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobCreationReason"
    }
}

/// Defines additional types related to JobCreationReason
pub mod job_creation_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the high level reason why a job was created.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// Reason is not specified.
        pub const CODE_UNSPECIFIED: Code = Code::new(0);

        /// Job creation was requested.
        pub const REQUESTED: Code = Code::new(1);

        /// The query request ran beyond a system defined timeout specified by the
        /// [timeoutMs field in the
        /// QueryRequest](https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query#queryrequest).
        /// As a result it was considered a long running operation for which a job
        /// was created.
        pub const LONG_RUNNING: Code = Code::new(2);

        /// The results from the query cannot fit in the response.
        pub const LARGE_RESULTS: Code = Code::new(3);

        /// BigQuery has determined that the query needs to be executed as a Job.
        pub const OTHER: Code = Code::new(4);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REQUESTED"),
                2 => std::borrow::Cow::Borrowed("LONG_RUNNING"),
                3 => std::borrow::Cow::Borrowed("LARGE_RESULTS"),
                4 => std::borrow::Cow::Borrowed("OTHER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                "REQUESTED" => std::option::Option::Some(Self::REQUESTED),
                "LONG_RUNNING" => std::option::Option::Some(Self::LONG_RUNNING),
                "LARGE_RESULTS" => std::option::Option::Some(Self::LARGE_RESULTS),
                "OTHER" => std::option::Option::Some(Self::OTHER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A job reference is a fully qualified identifier for referring to a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobReference {
    /// Required. The ID of the project containing this job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The ID of the job. The ID must contain only letters (a-z, A-Z),
    /// numbers (0-9), underscores (_), or dashes (-). The maximum length is 1,024
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Optional. The geographic location of the job. The default value is US.
    ///
    /// For more information about BigQuery locations, see:
    /// <https://cloud.google.com/bigquery/docs/locations>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<wkt::StringValue>,
}

impl JobReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::JobReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobReference::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::JobReference::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for JobReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobReference"
    }
}

/// An operation within a stage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainQueryStep {
    /// Machine-readable operation type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Human-readable description of the step(s).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub substeps: std::vec::Vec<std::string::String>,
}

impl ExplainQueryStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ExplainQueryStep::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [substeps][crate::model::ExplainQueryStep::substeps].
    pub fn set_substeps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.substeps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainQueryStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExplainQueryStep"
    }
}

/// A single stage of query execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainQueryStage {
    /// Human-readable name for the stage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Unique ID for the stage within the plan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub id: std::option::Option<wkt::Int64Value>,

    /// Stage start time represented as milliseconds since the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub start_ms: i64,

    /// Stage end time represented as milliseconds since the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub end_ms: i64,

    /// IDs for stages that are inputs to this stage.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub input_stages: std::vec::Vec<i64>,

    /// Relative amount of time the average shard spent waiting to be
    /// scheduled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait_ratio_avg: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the average shard spent waiting to be scheduled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub wait_ms_avg: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the slowest shard spent waiting to be
    /// scheduled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait_ratio_max: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the slowest shard spent waiting to be scheduled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub wait_ms_max: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the average shard spent reading input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_ratio_avg: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the average shard spent reading input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub read_ms_avg: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the slowest shard spent reading input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_ratio_max: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the slowest shard spent reading input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub read_ms_max: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the average shard spent on CPU-bound tasks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compute_ratio_avg: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the average shard spent on CPU-bound tasks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub compute_ms_avg: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the slowest shard spent on CPU-bound tasks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compute_ratio_max: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the slowest shard spent on CPU-bound tasks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub compute_ms_max: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the average shard spent on writing output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_ratio_avg: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the average shard spent on writing output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub write_ms_avg: std::option::Option<wkt::Int64Value>,

    /// Relative amount of time the slowest shard spent on writing output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_ratio_max: std::option::Option<wkt::DoubleValue>,

    /// Milliseconds the slowest shard spent on writing output.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub write_ms_max: std::option::Option<wkt::Int64Value>,

    /// Total number of bytes written to shuffle.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub shuffle_output_bytes: std::option::Option<wkt::Int64Value>,

    /// Total number of bytes written to shuffle and spilled to disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub shuffle_output_bytes_spilled: std::option::Option<wkt::Int64Value>,

    /// Number of records read into the stage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub records_read: std::option::Option<wkt::Int64Value>,

    /// Number of records written by the stage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub records_written: std::option::Option<wkt::Int64Value>,

    /// Number of parallel input segments to be processed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub parallel_inputs: std::option::Option<wkt::Int64Value>,

    /// Number of parallel input segments completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub completed_parallel_inputs: std::option::Option<wkt::Int64Value>,

    /// Current status for this stage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status: std::string::String,

    /// List of operations within the stage in dependency order (approximately
    /// chronological).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::ExplainQueryStep>,

    /// Slot-milliseconds used by the stage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub slot_ms: std::option::Option<wkt::Int64Value>,

    /// Output only. Compute mode for this stage.
    pub compute_mode: crate::model::explain_query_stage::ComputeMode,
}

impl ExplainQueryStage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExplainQueryStage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ExplainQueryStage::id].
    pub fn set_id<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [start_ms][crate::model::ExplainQueryStage::start_ms].
    pub fn set_start_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.start_ms = v.into();
        self
    }

    /// Sets the value of [end_ms][crate::model::ExplainQueryStage::end_ms].
    pub fn set_end_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.end_ms = v.into();
        self
    }

    /// Sets the value of [wait_ratio_avg][crate::model::ExplainQueryStage::wait_ratio_avg].
    pub fn set_wait_ratio_avg<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.wait_ratio_avg = v.into();
        self
    }

    /// Sets the value of [wait_ms_avg][crate::model::ExplainQueryStage::wait_ms_avg].
    pub fn set_wait_ms_avg<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.wait_ms_avg = v.into();
        self
    }

    /// Sets the value of [wait_ratio_max][crate::model::ExplainQueryStage::wait_ratio_max].
    pub fn set_wait_ratio_max<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.wait_ratio_max = v.into();
        self
    }

    /// Sets the value of [wait_ms_max][crate::model::ExplainQueryStage::wait_ms_max].
    pub fn set_wait_ms_max<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.wait_ms_max = v.into();
        self
    }

    /// Sets the value of [read_ratio_avg][crate::model::ExplainQueryStage::read_ratio_avg].
    pub fn set_read_ratio_avg<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_ratio_avg = v.into();
        self
    }

    /// Sets the value of [read_ms_avg][crate::model::ExplainQueryStage::read_ms_avg].
    pub fn set_read_ms_avg<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_ms_avg = v.into();
        self
    }

    /// Sets the value of [read_ratio_max][crate::model::ExplainQueryStage::read_ratio_max].
    pub fn set_read_ratio_max<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_ratio_max = v.into();
        self
    }

    /// Sets the value of [read_ms_max][crate::model::ExplainQueryStage::read_ms_max].
    pub fn set_read_ms_max<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_ms_max = v.into();
        self
    }

    /// Sets the value of [compute_ratio_avg][crate::model::ExplainQueryStage::compute_ratio_avg].
    pub fn set_compute_ratio_avg<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.compute_ratio_avg = v.into();
        self
    }

    /// Sets the value of [compute_ms_avg][crate::model::ExplainQueryStage::compute_ms_avg].
    pub fn set_compute_ms_avg<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.compute_ms_avg = v.into();
        self
    }

    /// Sets the value of [compute_ratio_max][crate::model::ExplainQueryStage::compute_ratio_max].
    pub fn set_compute_ratio_max<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.compute_ratio_max = v.into();
        self
    }

    /// Sets the value of [compute_ms_max][crate::model::ExplainQueryStage::compute_ms_max].
    pub fn set_compute_ms_max<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.compute_ms_max = v.into();
        self
    }

    /// Sets the value of [write_ratio_avg][crate::model::ExplainQueryStage::write_ratio_avg].
    pub fn set_write_ratio_avg<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_ratio_avg = v.into();
        self
    }

    /// Sets the value of [write_ms_avg][crate::model::ExplainQueryStage::write_ms_avg].
    pub fn set_write_ms_avg<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_ms_avg = v.into();
        self
    }

    /// Sets the value of [write_ratio_max][crate::model::ExplainQueryStage::write_ratio_max].
    pub fn set_write_ratio_max<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_ratio_max = v.into();
        self
    }

    /// Sets the value of [write_ms_max][crate::model::ExplainQueryStage::write_ms_max].
    pub fn set_write_ms_max<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_ms_max = v.into();
        self
    }

    /// Sets the value of [shuffle_output_bytes][crate::model::ExplainQueryStage::shuffle_output_bytes].
    pub fn set_shuffle_output_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.shuffle_output_bytes = v.into();
        self
    }

    /// Sets the value of [shuffle_output_bytes_spilled][crate::model::ExplainQueryStage::shuffle_output_bytes_spilled].
    pub fn set_shuffle_output_bytes_spilled<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shuffle_output_bytes_spilled = v.into();
        self
    }

    /// Sets the value of [records_read][crate::model::ExplainQueryStage::records_read].
    pub fn set_records_read<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.records_read = v.into();
        self
    }

    /// Sets the value of [records_written][crate::model::ExplainQueryStage::records_written].
    pub fn set_records_written<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.records_written = v.into();
        self
    }

    /// Sets the value of [parallel_inputs][crate::model::ExplainQueryStage::parallel_inputs].
    pub fn set_parallel_inputs<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.parallel_inputs = v.into();
        self
    }

    /// Sets the value of [completed_parallel_inputs][crate::model::ExplainQueryStage::completed_parallel_inputs].
    pub fn set_completed_parallel_inputs<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completed_parallel_inputs = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ExplainQueryStage::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [slot_ms][crate::model::ExplainQueryStage::slot_ms].
    pub fn set_slot_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.slot_ms = v.into();
        self
    }

    /// Sets the value of [compute_mode][crate::model::ExplainQueryStage::compute_mode].
    pub fn set_compute_mode<
        T: std::convert::Into<crate::model::explain_query_stage::ComputeMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compute_mode = v.into();
        self
    }

    /// Sets the value of [input_stages][crate::model::ExplainQueryStage::input_stages].
    pub fn set_input_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.input_stages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [steps][crate::model::ExplainQueryStage::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExplainQueryStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainQueryStage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExplainQueryStage"
    }
}

/// Defines additional types related to ExplainQueryStage
pub mod explain_query_stage {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of compute mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ComputeMode(i32);

    impl ComputeMode {
        /// ComputeMode type not specified.
        pub const COMPUTE_MODE_UNSPECIFIED: ComputeMode = ComputeMode::new(0);

        /// This stage was processed using BigQuery slots.
        pub const BIGQUERY: ComputeMode = ComputeMode::new(1);

        /// This stage was processed using BI Engine compute.
        pub const BI_ENGINE: ComputeMode = ComputeMode::new(2);

        /// Creates a new ComputeMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COMPUTE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BIGQUERY"),
                2 => std::borrow::Cow::Borrowed("BI_ENGINE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COMPUTE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COMPUTE_MODE_UNSPECIFIED)
                }
                "BIGQUERY" => std::option::Option::Some(Self::BIGQUERY),
                "BI_ENGINE" => std::option::Option::Some(Self::BI_ENGINE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ComputeMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ComputeMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Summary of the state of query execution at a given time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryTimelineSample {
    /// Milliseconds elapsed since the start of query execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub elapsed_ms: std::option::Option<wkt::Int64Value>,

    /// Cumulative slot-ms consumed by the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_slot_ms: std::option::Option<wkt::Int64Value>,

    /// Total units of work remaining for the query. This number can be revised
    /// (increased or decreased) while the query is running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub pending_units: std::option::Option<wkt::Int64Value>,

    /// Total parallel units of work completed by this query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub completed_units: std::option::Option<wkt::Int64Value>,

    /// Total number of active workers. This does not correspond directly to
    /// slot usage. This is the largest value observed since the last sample.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub active_units: std::option::Option<wkt::Int64Value>,

    /// Units of work that can be scheduled immediately. Providing additional slots
    /// for these units of work will accelerate the query, if no other query in
    /// the reservation needs additional slots.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub estimated_runnable_units: std::option::Option<wkt::Int64Value>,
}

impl QueryTimelineSample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [elapsed_ms][crate::model::QueryTimelineSample::elapsed_ms].
    pub fn set_elapsed_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.elapsed_ms = v.into();
        self
    }

    /// Sets the value of [total_slot_ms][crate::model::QueryTimelineSample::total_slot_ms].
    pub fn set_total_slot_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_slot_ms = v.into();
        self
    }

    /// Sets the value of [pending_units][crate::model::QueryTimelineSample::pending_units].
    pub fn set_pending_units<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pending_units = v.into();
        self
    }

    /// Sets the value of [completed_units][crate::model::QueryTimelineSample::completed_units].
    pub fn set_completed_units<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completed_units = v.into();
        self
    }

    /// Sets the value of [active_units][crate::model::QueryTimelineSample::active_units].
    pub fn set_active_units<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_units = v.into();
        self
    }

    /// Sets the value of [estimated_runnable_units][crate::model::QueryTimelineSample::estimated_runnable_units].
    pub fn set_estimated_runnable_units<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_runnable_units = v.into();
        self
    }
}

impl wkt::message::Message for QueryTimelineSample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryTimelineSample"
    }
}

/// The external service cost is a portion of the total cost, these costs are not
/// additive with total_bytes_billed. Moreover, this field only track external
/// service costs that will show up as BigQuery costs (e.g. training BigQuery
/// ML job with google cloud CAIP or Automl Tables services), not other costs
/// which may be accrued by running the query (e.g. reading from Bigtable or
/// Cloud Storage). The external service costs with different billing sku (e.g.
/// CAIP job is charged based on VM usage) are converted to BigQuery
/// billed_bytes and slot_ms with equivalent amount of US dollars. Services may
/// not directly correlate to these metrics, but these are the equivalents for
/// billing purposes.
/// Output only.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalServiceCost {
    /// External service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_service: std::string::String,

    /// External service cost in terms of bigquery bytes processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub bytes_processed: std::option::Option<wkt::Int64Value>,

    /// External service cost in terms of bigquery bytes billed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub bytes_billed: std::option::Option<wkt::Int64Value>,

    /// External service cost in terms of bigquery slot milliseconds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub slot_ms: std::option::Option<wkt::Int64Value>,

    /// Non-preemptable reserved slots used for external job.
    /// For example, reserved slots for Cloua AI Platform job are the VM usages
    /// converted to BigQuery slot with equivalent mount of price.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub reserved_slot_count: i64,
}

impl ExternalServiceCost {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_service][crate::model::ExternalServiceCost::external_service].
    pub fn set_external_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_service = v.into();
        self
    }

    /// Sets the value of [bytes_processed][crate::model::ExternalServiceCost::bytes_processed].
    pub fn set_bytes_processed<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bytes_processed = v.into();
        self
    }

    /// Sets the value of [bytes_billed][crate::model::ExternalServiceCost::bytes_billed].
    pub fn set_bytes_billed<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bytes_billed = v.into();
        self
    }

    /// Sets the value of [slot_ms][crate::model::ExternalServiceCost::slot_ms].
    pub fn set_slot_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.slot_ms = v.into();
        self
    }

    /// Sets the value of [reserved_slot_count][crate::model::ExternalServiceCost::reserved_slot_count].
    pub fn set_reserved_slot_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.reserved_slot_count = v.into();
        self
    }
}

impl wkt::message::Message for ExternalServiceCost {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalServiceCost"
    }
}

/// Statistics for the EXPORT DATA statement as part of Query Job. EXTRACT
/// JOB statistics are populated in JobStatistics4.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataStatistics {
    /// Number of destination files generated in case of EXPORT DATA
    /// statement only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub file_count: std::option::Option<wkt::Int64Value>,

    /// [Alpha] Number of destination rows generated in case of EXPORT DATA
    /// statement only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub row_count: std::option::Option<wkt::Int64Value>,
}

impl ExportDataStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_count][crate::model::ExportDataStatistics::file_count].
    pub fn set_file_count<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_count = v.into();
        self
    }

    /// Sets the value of [row_count][crate::model::ExportDataStatistics::row_count].
    pub fn set_row_count<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.row_count = v.into();
        self
    }
}

impl wkt::message::Message for ExportDataStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExportDataStatistics"
    }
}

/// Reason why BI Engine didn't accelerate the query (or sub-query).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BiEngineReason {
    /// Output only. High-level BI Engine reason for partial or disabled
    /// acceleration
    pub code: crate::model::bi_engine_reason::Code,

    /// Output only. Free form human-readable reason for partial or disabled
    /// acceleration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl BiEngineReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::BiEngineReason::code].
    pub fn set_code<T: std::convert::Into<crate::model::bi_engine_reason::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::BiEngineReason::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for BiEngineReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BiEngineReason"
    }
}

/// Defines additional types related to BiEngineReason
pub mod bi_engine_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the high-level reason for no/partial acceleration
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// BiEngineReason not specified.
        pub const CODE_UNSPECIFIED: Code = Code::new(0);

        /// No reservation available for BI Engine acceleration.
        pub const NO_RESERVATION: Code = Code::new(1);

        /// Not enough memory available for BI Engine acceleration.
        pub const INSUFFICIENT_RESERVATION: Code = Code::new(2);

        /// This particular SQL text is not supported for acceleration by BI Engine.
        pub const UNSUPPORTED_SQL_TEXT: Code = Code::new(4);

        /// Input too large for acceleration by BI Engine.
        pub const INPUT_TOO_LARGE: Code = Code::new(5);

        /// Catch-all code for all other cases for partial or disabled acceleration.
        pub const OTHER_REASON: Code = Code::new(6);

        /// One or more tables were not eligible for BI Engine acceleration.
        pub const TABLE_EXCLUDED: Code = Code::new(7);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NO_RESERVATION"),
                2 => std::borrow::Cow::Borrowed("INSUFFICIENT_RESERVATION"),
                4 => std::borrow::Cow::Borrowed("UNSUPPORTED_SQL_TEXT"),
                5 => std::borrow::Cow::Borrowed("INPUT_TOO_LARGE"),
                6 => std::borrow::Cow::Borrowed("OTHER_REASON"),
                7 => std::borrow::Cow::Borrowed("TABLE_EXCLUDED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                "NO_RESERVATION" => std::option::Option::Some(Self::NO_RESERVATION),
                "INSUFFICIENT_RESERVATION" => {
                    std::option::Option::Some(Self::INSUFFICIENT_RESERVATION)
                }
                "UNSUPPORTED_SQL_TEXT" => std::option::Option::Some(Self::UNSUPPORTED_SQL_TEXT),
                "INPUT_TOO_LARGE" => std::option::Option::Some(Self::INPUT_TOO_LARGE),
                "OTHER_REASON" => std::option::Option::Some(Self::OTHER_REASON),
                "TABLE_EXCLUDED" => std::option::Option::Some(Self::TABLE_EXCLUDED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Statistics for a BI Engine specific query.
/// Populated as part of JobStatistics2
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BiEngineStatistics {
    /// Output only. Specifies which mode of BI Engine acceleration was performed
    /// (if any).
    pub bi_engine_mode: crate::model::bi_engine_statistics::BiEngineMode,

    /// Output only. Specifies which mode of BI Engine acceleration was performed
    /// (if any).
    pub acceleration_mode: crate::model::bi_engine_statistics::BiEngineAccelerationMode,

    /// In case of DISABLED or PARTIAL bi_engine_mode, these contain the
    /// explanatory reasons as to why BI Engine could not accelerate.
    /// In case the full query was accelerated, this field is not populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bi_engine_reasons: std::vec::Vec<crate::model::BiEngineReason>,
}

impl BiEngineStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bi_engine_mode][crate::model::BiEngineStatistics::bi_engine_mode].
    pub fn set_bi_engine_mode<
        T: std::convert::Into<crate::model::bi_engine_statistics::BiEngineMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bi_engine_mode = v.into();
        self
    }

    /// Sets the value of [acceleration_mode][crate::model::BiEngineStatistics::acceleration_mode].
    pub fn set_acceleration_mode<
        T: std::convert::Into<crate::model::bi_engine_statistics::BiEngineAccelerationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.acceleration_mode = v.into();
        self
    }

    /// Sets the value of [bi_engine_reasons][crate::model::BiEngineStatistics::bi_engine_reasons].
    pub fn set_bi_engine_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BiEngineReason>,
    {
        use std::iter::Iterator;
        self.bi_engine_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BiEngineStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BiEngineStatistics"
    }
}

/// Defines additional types related to BiEngineStatistics
pub mod bi_engine_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of BI Engine acceleration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BiEngineMode(i32);

    impl BiEngineMode {
        /// BiEngineMode type not specified.
        pub const ACCELERATION_MODE_UNSPECIFIED: BiEngineMode = BiEngineMode::new(0);

        /// BI Engine disabled the acceleration. bi_engine_reasons
        /// specifies a more detailed reason.
        pub const DISABLED: BiEngineMode = BiEngineMode::new(1);

        /// Part of the query was accelerated using BI Engine.
        /// See bi_engine_reasons for why parts of the query were not
        /// accelerated.
        pub const PARTIAL: BiEngineMode = BiEngineMode::new(2);

        /// All of the query was accelerated using BI Engine.
        pub const FULL: BiEngineMode = BiEngineMode::new(3);

        /// Creates a new BiEngineMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ACCELERATION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("PARTIAL"),
                3 => std::borrow::Cow::Borrowed("FULL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ACCELERATION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ACCELERATION_MODE_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "PARTIAL" => std::option::Option::Some(Self::PARTIAL),
                "FULL" => std::option::Option::Some(Self::FULL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BiEngineMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BiEngineMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the type of BI Engine acceleration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BiEngineAccelerationMode(i32);

    impl BiEngineAccelerationMode {
        /// BiEngineMode type not specified.
        pub const BI_ENGINE_ACCELERATION_MODE_UNSPECIFIED: BiEngineAccelerationMode =
            BiEngineAccelerationMode::new(0);

        /// BI Engine acceleration was attempted but disabled. bi_engine_reasons
        /// specifies a more detailed reason.
        pub const BI_ENGINE_DISABLED: BiEngineAccelerationMode = BiEngineAccelerationMode::new(1);

        /// Some inputs were accelerated using BI Engine.
        /// See bi_engine_reasons for why parts of the query were not
        /// accelerated.
        pub const PARTIAL_INPUT: BiEngineAccelerationMode = BiEngineAccelerationMode::new(2);

        /// All of the query inputs were accelerated using BI Engine.
        pub const FULL_INPUT: BiEngineAccelerationMode = BiEngineAccelerationMode::new(3);

        /// All of the query was accelerated using BI Engine.
        pub const FULL_QUERY: BiEngineAccelerationMode = BiEngineAccelerationMode::new(4);

        /// Creates a new BiEngineAccelerationMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BI_ENGINE_ACCELERATION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BI_ENGINE_DISABLED"),
                2 => std::borrow::Cow::Borrowed("PARTIAL_INPUT"),
                3 => std::borrow::Cow::Borrowed("FULL_INPUT"),
                4 => std::borrow::Cow::Borrowed("FULL_QUERY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BI_ENGINE_ACCELERATION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::BI_ENGINE_ACCELERATION_MODE_UNSPECIFIED)
                }
                "BI_ENGINE_DISABLED" => std::option::Option::Some(Self::BI_ENGINE_DISABLED),
                "PARTIAL_INPUT" => std::option::Option::Some(Self::PARTIAL_INPUT),
                "FULL_INPUT" => std::option::Option::Some(Self::FULL_INPUT),
                "FULL_QUERY" => std::option::Option::Some(Self::FULL_QUERY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BiEngineAccelerationMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BiEngineAccelerationMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Reason about why no search index was used in the search query (or
/// sub-query).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexUnusedReason {
    /// Specifies the high-level reason for the scenario when no search index was
    /// used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub code: std::option::Option<crate::model::index_unused_reason::Code>,

    /// Free form human-readable reason for the scenario when no search index was
    /// used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub message: std::option::Option<std::string::String>,

    /// Specifies the base table involved in the reason that no search index was
    /// used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_table: std::option::Option<crate::model::TableReference>,

    /// Specifies the name of the unused search index, if available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_name: std::option::Option<std::string::String>,
}

impl IndexUnusedReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::IndexUnusedReason::code].
    pub fn set_code<
        T: std::convert::Into<std::option::Option<crate::model::index_unused_reason::Code>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::IndexUnusedReason::message].
    pub fn set_message<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [base_table][crate::model::IndexUnusedReason::base_table].
    pub fn set_base_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_table = v.into();
        self
    }

    /// Sets the value of [index_name][crate::model::IndexUnusedReason::index_name].
    pub fn set_index_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_name = v.into();
        self
    }
}

impl wkt::message::Message for IndexUnusedReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.IndexUnusedReason"
    }
}

/// Defines additional types related to IndexUnusedReason
pub mod index_unused_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the high-level reason for the scenario when no search index was
    /// used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// Code not specified.
        pub const CODE_UNSPECIFIED: Code = Code::new(0);

        /// Indicates the search index configuration has not been created.
        pub const INDEX_CONFIG_NOT_AVAILABLE: Code = Code::new(1);

        /// Indicates the search index creation has not been completed.
        pub const PENDING_INDEX_CREATION: Code = Code::new(2);

        /// Indicates the base table has been truncated (rows have been removed
        /// from table with TRUNCATE TABLE statement) since the last time the search
        /// index was refreshed.
        pub const BASE_TABLE_TRUNCATED: Code = Code::new(3);

        /// Indicates the search index configuration has been changed since the last
        /// time the search index was refreshed.
        pub const INDEX_CONFIG_MODIFIED: Code = Code::new(4);

        /// Indicates the search query accesses data at a timestamp before the last
        /// time the search index was refreshed.
        pub const TIME_TRAVEL_QUERY: Code = Code::new(5);

        /// Indicates the usage of search index will not contribute to any pruning
        /// improvement for the search function, e.g. when the search predicate is in
        /// a disjunction with other non-search predicates.
        pub const NO_PRUNING_POWER: Code = Code::new(6);

        /// Indicates the search index does not cover all fields in the search
        /// function.
        pub const UNINDEXED_SEARCH_FIELDS: Code = Code::new(7);

        /// Indicates the search index does not support the given search query
        /// pattern.
        pub const UNSUPPORTED_SEARCH_PATTERN: Code = Code::new(8);

        /// Indicates the query has been optimized by using a materialized view.
        pub const OPTIMIZED_WITH_MATERIALIZED_VIEW: Code = Code::new(9);

        /// Indicates the query has been secured by data masking, and thus search
        /// indexes are not applicable.
        pub const SECURED_BY_DATA_MASKING: Code = Code::new(11);

        /// Indicates that the search index and the search function call do not
        /// have the same text analyzer.
        pub const MISMATCHED_TEXT_ANALYZER: Code = Code::new(12);

        /// Indicates the base table is too small (below a certain threshold).
        /// The index does not provide noticeable search performance gains
        /// when the base table is too small.
        pub const BASE_TABLE_TOO_SMALL: Code = Code::new(13);

        /// Indicates that the total size of indexed base tables in your organization
        /// exceeds your region's limit and the index is not used in the query. To
        /// index larger base tables, you can
        /// <a
        /// href="https://cloud.google.com/bigquery/docs/search-index#use_your_own_reservation">use
        /// your own reservation</a> for index-management jobs.
        pub const BASE_TABLE_TOO_LARGE: Code = Code::new(14);

        /// Indicates that the estimated performance gain from using the search index
        /// is too low for the given search query.
        pub const ESTIMATED_PERFORMANCE_GAIN_TOO_LOW: Code = Code::new(15);

        /// Indicates that search indexes can not be used for search query with
        /// STANDARD edition.
        pub const NOT_SUPPORTED_IN_STANDARD_EDITION: Code = Code::new(17);

        /// Indicates that an option in the search function that cannot make use of
        /// the index has been selected.
        pub const INDEX_SUPPRESSED_BY_FUNCTION_OPTION: Code = Code::new(18);

        /// Indicates that the query was cached, and thus the search index was not
        /// used.
        pub const QUERY_CACHE_HIT: Code = Code::new(19);

        /// The index cannot be used in the search query because it is stale.
        pub const STALE_INDEX: Code = Code::new(20);

        /// Indicates an internal error that causes the search index to be unused.
        pub const INTERNAL_ERROR: Code = Code::new(10);

        /// Indicates that the reason search indexes cannot be used in the query is
        /// not covered by any of the other IndexUnusedReason options.
        pub const OTHER_REASON: Code = Code::new(16);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INDEX_CONFIG_NOT_AVAILABLE"),
                2 => std::borrow::Cow::Borrowed("PENDING_INDEX_CREATION"),
                3 => std::borrow::Cow::Borrowed("BASE_TABLE_TRUNCATED"),
                4 => std::borrow::Cow::Borrowed("INDEX_CONFIG_MODIFIED"),
                5 => std::borrow::Cow::Borrowed("TIME_TRAVEL_QUERY"),
                6 => std::borrow::Cow::Borrowed("NO_PRUNING_POWER"),
                7 => std::borrow::Cow::Borrowed("UNINDEXED_SEARCH_FIELDS"),
                8 => std::borrow::Cow::Borrowed("UNSUPPORTED_SEARCH_PATTERN"),
                9 => std::borrow::Cow::Borrowed("OPTIMIZED_WITH_MATERIALIZED_VIEW"),
                10 => std::borrow::Cow::Borrowed("INTERNAL_ERROR"),
                11 => std::borrow::Cow::Borrowed("SECURED_BY_DATA_MASKING"),
                12 => std::borrow::Cow::Borrowed("MISMATCHED_TEXT_ANALYZER"),
                13 => std::borrow::Cow::Borrowed("BASE_TABLE_TOO_SMALL"),
                14 => std::borrow::Cow::Borrowed("BASE_TABLE_TOO_LARGE"),
                15 => std::borrow::Cow::Borrowed("ESTIMATED_PERFORMANCE_GAIN_TOO_LOW"),
                16 => std::borrow::Cow::Borrowed("OTHER_REASON"),
                17 => std::borrow::Cow::Borrowed("NOT_SUPPORTED_IN_STANDARD_EDITION"),
                18 => std::borrow::Cow::Borrowed("INDEX_SUPPRESSED_BY_FUNCTION_OPTION"),
                19 => std::borrow::Cow::Borrowed("QUERY_CACHE_HIT"),
                20 => std::borrow::Cow::Borrowed("STALE_INDEX"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                "INDEX_CONFIG_NOT_AVAILABLE" => {
                    std::option::Option::Some(Self::INDEX_CONFIG_NOT_AVAILABLE)
                }
                "PENDING_INDEX_CREATION" => std::option::Option::Some(Self::PENDING_INDEX_CREATION),
                "BASE_TABLE_TRUNCATED" => std::option::Option::Some(Self::BASE_TABLE_TRUNCATED),
                "INDEX_CONFIG_MODIFIED" => std::option::Option::Some(Self::INDEX_CONFIG_MODIFIED),
                "TIME_TRAVEL_QUERY" => std::option::Option::Some(Self::TIME_TRAVEL_QUERY),
                "NO_PRUNING_POWER" => std::option::Option::Some(Self::NO_PRUNING_POWER),
                "UNINDEXED_SEARCH_FIELDS" => {
                    std::option::Option::Some(Self::UNINDEXED_SEARCH_FIELDS)
                }
                "UNSUPPORTED_SEARCH_PATTERN" => {
                    std::option::Option::Some(Self::UNSUPPORTED_SEARCH_PATTERN)
                }
                "OPTIMIZED_WITH_MATERIALIZED_VIEW" => {
                    std::option::Option::Some(Self::OPTIMIZED_WITH_MATERIALIZED_VIEW)
                }
                "SECURED_BY_DATA_MASKING" => {
                    std::option::Option::Some(Self::SECURED_BY_DATA_MASKING)
                }
                "MISMATCHED_TEXT_ANALYZER" => {
                    std::option::Option::Some(Self::MISMATCHED_TEXT_ANALYZER)
                }
                "BASE_TABLE_TOO_SMALL" => std::option::Option::Some(Self::BASE_TABLE_TOO_SMALL),
                "BASE_TABLE_TOO_LARGE" => std::option::Option::Some(Self::BASE_TABLE_TOO_LARGE),
                "ESTIMATED_PERFORMANCE_GAIN_TOO_LOW" => {
                    std::option::Option::Some(Self::ESTIMATED_PERFORMANCE_GAIN_TOO_LOW)
                }
                "NOT_SUPPORTED_IN_STANDARD_EDITION" => {
                    std::option::Option::Some(Self::NOT_SUPPORTED_IN_STANDARD_EDITION)
                }
                "INDEX_SUPPRESSED_BY_FUNCTION_OPTION" => {
                    std::option::Option::Some(Self::INDEX_SUPPRESSED_BY_FUNCTION_OPTION)
                }
                "QUERY_CACHE_HIT" => std::option::Option::Some(Self::QUERY_CACHE_HIT),
                "STALE_INDEX" => std::option::Option::Some(Self::STALE_INDEX),
                "INTERNAL_ERROR" => std::option::Option::Some(Self::INTERNAL_ERROR),
                "OTHER_REASON" => std::option::Option::Some(Self::OTHER_REASON),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Indicates the stored columns usage in the query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredColumnsUsage {
    /// Specifies whether the query was accelerated with stored columns.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_query_accelerated: std::option::Option<bool>,

    /// Specifies the base table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_table: std::option::Option<crate::model::TableReference>,

    /// If stored columns were not used, explain why.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stored_columns_unused_reasons:
        std::vec::Vec<crate::model::stored_columns_usage::StoredColumnsUnusedReason>,
}

impl StoredColumnsUsage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_query_accelerated][crate::model::StoredColumnsUsage::is_query_accelerated].
    pub fn set_is_query_accelerated<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.is_query_accelerated = v.into();
        self
    }

    /// Sets the value of [base_table][crate::model::StoredColumnsUsage::base_table].
    pub fn set_base_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_table = v.into();
        self
    }

    /// Sets the value of [stored_columns_unused_reasons][crate::model::StoredColumnsUsage::stored_columns_unused_reasons].
    pub fn set_stored_columns_unused_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::stored_columns_usage::StoredColumnsUnusedReason>,
    {
        use std::iter::Iterator;
        self.stored_columns_unused_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StoredColumnsUsage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StoredColumnsUsage"
    }
}

/// Defines additional types related to StoredColumnsUsage
pub mod stored_columns_usage {
    #[allow(unused_imports)]
    use super::*;

    /// If the stored column was not used, explain why.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StoredColumnsUnusedReason {
        /// Specifies the high-level reason for the unused scenario, each reason must
        /// have a code associated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub code: std::option::Option<
            crate::model::stored_columns_usage::stored_columns_unused_reason::Code,
        >,

        /// Specifies the detailed description for the scenario.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub message: std::option::Option<std::string::String>,

        /// Specifies which columns were not covered by the stored columns for the
        /// specified code up to 20 columns. This is populated when the code is
        /// STORED_COLUMNS_COVER_INSUFFICIENT and BASE_TABLE_HAS_CLS.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub uncovered_columns: std::vec::Vec<std::string::String>,
    }

    impl StoredColumnsUnusedReason {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::stored_columns_usage::StoredColumnsUnusedReason::code].
        pub fn set_code<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::stored_columns_usage::stored_columns_unused_reason::Code,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [message][crate::model::stored_columns_usage::StoredColumnsUnusedReason::message].
        pub fn set_message<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [uncovered_columns][crate::model::stored_columns_usage::StoredColumnsUnusedReason::uncovered_columns].
        pub fn set_uncovered_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uncovered_columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StoredColumnsUnusedReason {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.StoredColumnsUsage.StoredColumnsUnusedReason"
        }
    }

    /// Defines additional types related to StoredColumnsUnusedReason
    pub mod stored_columns_unused_reason {
        #[allow(unused_imports)]
        use super::*;

        /// Indicates the high-level reason for the scenario when stored columns
        /// cannot be used in the query.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Code(i32);

        impl Code {
            /// Default value.
            pub const CODE_UNSPECIFIED: Code = Code::new(0);

            /// If stored columns do not fully cover the columns.
            pub const STORED_COLUMNS_COVER_INSUFFICIENT: Code = Code::new(1);

            /// If the base table has RLS (Row Level Security).
            pub const BASE_TABLE_HAS_RLS: Code = Code::new(2);

            /// If the base table has CLS (Column Level Security).
            pub const BASE_TABLE_HAS_CLS: Code = Code::new(3);

            /// If the provided prefilter is not supported.
            pub const UNSUPPORTED_PREFILTER: Code = Code::new(4);

            /// If an internal error is preventing stored columns from being used.
            pub const INTERNAL_ERROR: Code = Code::new(5);

            /// Indicates that the reason stored columns cannot be used in the query is
            /// not covered by any of the other StoredColumnsUnusedReason options.
            pub const OTHER_REASON: Code = Code::new(6);

            /// Creates a new Code instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("CODE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("STORED_COLUMNS_COVER_INSUFFICIENT"),
                    2 => std::borrow::Cow::Borrowed("BASE_TABLE_HAS_RLS"),
                    3 => std::borrow::Cow::Borrowed("BASE_TABLE_HAS_CLS"),
                    4 => std::borrow::Cow::Borrowed("UNSUPPORTED_PREFILTER"),
                    5 => std::borrow::Cow::Borrowed("INTERNAL_ERROR"),
                    6 => std::borrow::Cow::Borrowed("OTHER_REASON"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "CODE_UNSPECIFIED" => std::option::Option::Some(Self::CODE_UNSPECIFIED),
                    "STORED_COLUMNS_COVER_INSUFFICIENT" => {
                        std::option::Option::Some(Self::STORED_COLUMNS_COVER_INSUFFICIENT)
                    }
                    "BASE_TABLE_HAS_RLS" => std::option::Option::Some(Self::BASE_TABLE_HAS_RLS),
                    "BASE_TABLE_HAS_CLS" => std::option::Option::Some(Self::BASE_TABLE_HAS_CLS),
                    "UNSUPPORTED_PREFILTER" => {
                        std::option::Option::Some(Self::UNSUPPORTED_PREFILTER)
                    }
                    "INTERNAL_ERROR" => std::option::Option::Some(Self::INTERNAL_ERROR),
                    "OTHER_REASON" => std::option::Option::Some(Self::OTHER_REASON),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for Code {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }
}

/// Statistics for a search query.
/// Populated as part of JobStatistics2.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchStatistics {
    /// Specifies the index usage mode for the query.
    pub index_usage_mode: crate::model::search_statistics::IndexUsageMode,

    /// When `indexUsageMode` is `UNUSED` or `PARTIALLY_USED`, this field explains
    /// why indexes were not used in all or part of the search query. If
    /// `indexUsageMode` is `FULLY_USED`, this field is not populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_unused_reasons: std::vec::Vec<crate::model::IndexUnusedReason>,
}

impl SearchStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_usage_mode][crate::model::SearchStatistics::index_usage_mode].
    pub fn set_index_usage_mode<
        T: std::convert::Into<crate::model::search_statistics::IndexUsageMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_usage_mode = v.into();
        self
    }

    /// Sets the value of [index_unused_reasons][crate::model::SearchStatistics::index_unused_reasons].
    pub fn set_index_unused_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexUnusedReason>,
    {
        use std::iter::Iterator;
        self.index_unused_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SearchStatistics"
    }
}

/// Defines additional types related to SearchStatistics
pub mod search_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of search index usage in the entire search query.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IndexUsageMode(i32);

    impl IndexUsageMode {
        /// Index usage mode not specified.
        pub const INDEX_USAGE_MODE_UNSPECIFIED: IndexUsageMode = IndexUsageMode::new(0);

        /// No search indexes were used in the search query. See
        /// [`indexUnusedReasons`]
        /// (/bigquery/docs/reference/rest/v2/Job#IndexUnusedReason)
        /// for detailed reasons.
        pub const UNUSED: IndexUsageMode = IndexUsageMode::new(1);

        /// Part of the search query used search indexes. See [`indexUnusedReasons`]
        /// (/bigquery/docs/reference/rest/v2/Job#IndexUnusedReason)
        /// for why other parts of the query did not use search indexes.
        pub const PARTIALLY_USED: IndexUsageMode = IndexUsageMode::new(2);

        /// The entire search query used search indexes.
        pub const FULLY_USED: IndexUsageMode = IndexUsageMode::new(4);

        /// Creates a new IndexUsageMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INDEX_USAGE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("UNUSED"),
                2 => std::borrow::Cow::Borrowed("PARTIALLY_USED"),
                4 => std::borrow::Cow::Borrowed("FULLY_USED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INDEX_USAGE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INDEX_USAGE_MODE_UNSPECIFIED)
                }
                "UNUSED" => std::option::Option::Some(Self::UNUSED),
                "PARTIALLY_USED" => std::option::Option::Some(Self::PARTIALLY_USED),
                "FULLY_USED" => std::option::Option::Some(Self::FULLY_USED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for IndexUsageMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for IndexUsageMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Statistics for a vector search query.
/// Populated as part of JobStatistics2.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VectorSearchStatistics {
    /// Specifies the index usage mode for the query.
    pub index_usage_mode: crate::model::vector_search_statistics::IndexUsageMode,

    /// When `indexUsageMode` is `UNUSED` or `PARTIALLY_USED`, this field explains
    /// why indexes were not used in all or part of the vector search query. If
    /// `indexUsageMode` is `FULLY_USED`, this field is not populated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_unused_reasons: std::vec::Vec<crate::model::IndexUnusedReason>,

    /// Specifies the usage of stored columns in the query when stored columns are
    /// used in the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stored_columns_usages: std::vec::Vec<crate::model::StoredColumnsUsage>,
}

impl VectorSearchStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_usage_mode][crate::model::VectorSearchStatistics::index_usage_mode].
    pub fn set_index_usage_mode<
        T: std::convert::Into<crate::model::vector_search_statistics::IndexUsageMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.index_usage_mode = v.into();
        self
    }

    /// Sets the value of [index_unused_reasons][crate::model::VectorSearchStatistics::index_unused_reasons].
    pub fn set_index_unused_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexUnusedReason>,
    {
        use std::iter::Iterator;
        self.index_unused_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stored_columns_usages][crate::model::VectorSearchStatistics::stored_columns_usages].
    pub fn set_stored_columns_usages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoredColumnsUsage>,
    {
        use std::iter::Iterator;
        self.stored_columns_usages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VectorSearchStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.VectorSearchStatistics"
    }
}

/// Defines additional types related to VectorSearchStatistics
pub mod vector_search_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of vector index usage in the entire vector search query.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IndexUsageMode(i32);

    impl IndexUsageMode {
        /// Index usage mode not specified.
        pub const INDEX_USAGE_MODE_UNSPECIFIED: IndexUsageMode = IndexUsageMode::new(0);

        /// No vector indexes were used in the vector search query. See
        /// [`indexUnusedReasons`]
        /// (/bigquery/docs/reference/rest/v2/Job#IndexUnusedReason)
        /// for detailed reasons.
        pub const UNUSED: IndexUsageMode = IndexUsageMode::new(1);

        /// Part of the vector search query used vector indexes. See
        /// [`indexUnusedReasons`]
        /// (/bigquery/docs/reference/rest/v2/Job#IndexUnusedReason)
        /// for why other parts of the query did not use vector indexes.
        pub const PARTIALLY_USED: IndexUsageMode = IndexUsageMode::new(2);

        /// The entire vector search query used vector indexes.
        pub const FULLY_USED: IndexUsageMode = IndexUsageMode::new(4);

        /// Creates a new IndexUsageMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INDEX_USAGE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("UNUSED"),
                2 => std::borrow::Cow::Borrowed("PARTIALLY_USED"),
                4 => std::borrow::Cow::Borrowed("FULLY_USED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INDEX_USAGE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INDEX_USAGE_MODE_UNSPECIFIED)
                }
                "UNUSED" => std::option::Option::Some(Self::UNUSED),
                "PARTIALLY_USED" => std::option::Option::Some(Self::PARTIALLY_USED),
                "FULLY_USED" => std::option::Option::Some(Self::FULLY_USED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for IndexUsageMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for IndexUsageMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Query optimization information for a QUERY job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryInfo {
    /// Output only. Information about query optimizations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub optimization_details: std::option::Option<wkt::Struct>,
}

impl QueryInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [optimization_details][crate::model::QueryInfo::optimization_details].
    pub fn set_optimization_details<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.optimization_details = v.into();
        self
    }
}

impl wkt::message::Message for QueryInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryInfo"
    }
}

/// Statistics for a LOAD query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoadQueryStatistics {
    /// Output only. Number of source files in a LOAD query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub input_files: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of bytes of source data in a LOAD query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub input_file_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of rows imported in a LOAD query.
    /// Note that while a LOAD query is in the running state, this value may
    /// change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub output_rows: std::option::Option<wkt::Int64Value>,

    /// Output only. Size of the loaded data in bytes. Note that while a LOAD query
    /// is in the running state, this value may change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub output_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of bad records encountered while processing a LOAD
    /// query. Note that if the job has failed because of more bad records
    /// encountered than the maximum allowed in the load job configuration, then
    /// this number can be less than the total number of bad records present in the
    /// input data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub bad_records: std::option::Option<wkt::Int64Value>,
}

impl LoadQueryStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_files][crate::model::LoadQueryStatistics::input_files].
    pub fn set_input_files<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_files = v.into();
        self
    }

    /// Sets the value of [input_file_bytes][crate::model::LoadQueryStatistics::input_file_bytes].
    pub fn set_input_file_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_file_bytes = v.into();
        self
    }

    /// Sets the value of [output_rows][crate::model::LoadQueryStatistics::output_rows].
    pub fn set_output_rows<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_rows = v.into();
        self
    }

    /// Sets the value of [output_bytes][crate::model::LoadQueryStatistics::output_bytes].
    pub fn set_output_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_bytes = v.into();
        self
    }

    /// Sets the value of [bad_records][crate::model::LoadQueryStatistics::bad_records].
    pub fn set_bad_records<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bad_records = v.into();
        self
    }
}

impl wkt::message::Message for LoadQueryStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LoadQueryStatistics"
    }
}

/// Statistics for a query job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobStatistics2 {
    /// Output only. Describes execution plan for the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub query_plan: std::vec::Vec<crate::model::ExplainQueryStage>,

    /// Output only. The original estimate of bytes processed for the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub estimated_bytes_processed: std::option::Option<wkt::Int64Value>,

    /// Output only. Describes a timeline of job execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub timeline: std::vec::Vec<crate::model::QueryTimelineSample>,

    /// Output only. Total number of partitions processed from all partitioned
    /// tables referenced in the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_partitions_processed: std::option::Option<wkt::Int64Value>,

    /// Output only. Total bytes processed for the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_bytes_processed: std::option::Option<wkt::Int64Value>,

    /// Output only. For dry-run jobs, totalBytesProcessed is an estimate and this
    /// field specifies the accuracy of the estimate. Possible values can be:
    /// UNKNOWN: accuracy of the estimate is unknown.
    /// PRECISE: estimate is precise.
    /// LOWER_BOUND: estimate is lower bound of what the query would cost.
    /// UPPER_BOUND: estimate is upper bound of what the query would cost.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub total_bytes_processed_accuracy: std::string::String,

    /// Output only. If the project is configured to use on-demand pricing,
    /// then this field contains the total bytes billed for the job.
    /// If the project is configured to use flat-rate pricing, then you are
    /// not billed for bytes and this field is informational only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_bytes_billed: std::option::Option<wkt::Int64Value>,

    /// Output only. Billing tier for the job. This is a BigQuery-specific concept
    /// which is not related to the Google Cloud notion of "free tier". The value
    /// here is a measure of the query's resource consumption relative to the
    /// amount of data scanned. For on-demand queries, the limit is 100, and all
    /// queries within this limit are billed at the standard on-demand rates.
    /// On-demand queries that exceed this limit will fail with a
    /// billingTierLimitExceeded error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub billing_tier: std::option::Option<wkt::Int32Value>,

    /// Output only. Slot-milliseconds for the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_slot_ms: std::option::Option<wkt::Int64Value>,

    /// Output only. Whether the query result was fetched from the query cache.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cache_hit: std::option::Option<wkt::BoolValue>,

    /// Output only. Referenced tables for the job. Queries that reference more
    /// than 50 tables will not have a complete list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub referenced_tables: std::vec::Vec<crate::model::TableReference>,

    /// Output only. Referenced routines for the job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub referenced_routines: std::vec::Vec<crate::model::RoutineReference>,

    /// Output only. The schema of the results. Present only for successful dry
    /// run of non-legacy SQL queries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// Output only. The number of rows affected by a DML statement. Present
    /// only for DML statements INSERT, UPDATE or DELETE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_dml_affected_rows: std::option::Option<wkt::Int64Value>,

    /// Output only. Detailed statistics for DML statements INSERT, UPDATE, DELETE,
    /// MERGE or TRUNCATE.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dml_stats: std::option::Option<crate::model::DmlStats>,

    /// Output only. GoogleSQL only: list of undeclared query
    /// parameters detected during a dry run validation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub undeclared_query_parameters: std::vec::Vec<crate::model::QueryParameter>,

    /// Output only. The type of query statement, if valid.
    /// Possible values:
    ///
    /// * `SELECT`:
    ///   [`SELECT`](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#select_list)
    ///   statement.
    /// * `ASSERT`:
    ///   [`ASSERT`](https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging-statements#assert)
    ///   statement.
    /// * `INSERT`:
    ///   [`INSERT`](https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax#insert_statement)
    ///   statement.
    /// * `UPDATE`:
    ///   [`UPDATE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax#update_statement)
    ///   statement.
    /// * `DELETE`:
    ///   [`DELETE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)
    ///   statement.
    /// * `MERGE`:
    ///   [`MERGE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)
    ///   statement.
    /// * `CREATE_TABLE`: [`CREATE
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_table_statement)
    ///   statement, without `AS SELECT`.
    /// * `CREATE_TABLE_AS_SELECT`: [`CREATE TABLE AS
    ///   SELECT`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_table_statement)
    ///   statement.
    /// * `CREATE_VIEW`: [`CREATE
    ///   VIEW`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_view_statement)
    ///   statement.
    /// * `CREATE_MODEL`: [`CREATE
    ///   MODEL`](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create#create_model_statement)
    ///   statement.
    /// * `CREATE_MATERIALIZED_VIEW`: [`CREATE MATERIALIZED
    ///   VIEW`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_materialized_view_statement)
    ///   statement.
    /// * `CREATE_FUNCTION`: [`CREATE
    ///   FUNCTION`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_function_statement)
    ///   statement.
    /// * `CREATE_TABLE_FUNCTION`: [`CREATE TABLE
    ///   FUNCTION`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_table_function_statement)
    ///   statement.
    /// * `CREATE_PROCEDURE`: [`CREATE
    ///   PROCEDURE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_procedure)
    ///   statement.
    /// * `CREATE_ROW_ACCESS_POLICY`: [`CREATE ROW ACCESS
    ///   POLICY`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_row_access_policy_statement)
    ///   statement.
    /// * `CREATE_SCHEMA`: [`CREATE
    ///   SCHEMA`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_schema_statement)
    ///   statement.
    /// * `CREATE_SNAPSHOT_TABLE`: [`CREATE SNAPSHOT
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_snapshot_table_statement)
    ///   statement.
    /// * `CREATE_SEARCH_INDEX`: [`CREATE SEARCH
    ///   INDEX`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_search_index_statement)
    ///   statement.
    /// * `DROP_TABLE`: [`DROP
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_table_statement)
    ///   statement.
    /// * `DROP_EXTERNAL_TABLE`: [`DROP EXTERNAL
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_external_table_statement)
    ///   statement.
    /// * `DROP_VIEW`: [`DROP
    ///   VIEW`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_view_statement)
    ///   statement.
    /// * `DROP_MODEL`: [`DROP
    ///   MODEL`](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-drop-model)
    ///   statement.
    /// * `DROP_MATERIALIZED_VIEW`: [`DROP MATERIALIZED
    ///   VIEW`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_materialized_view_statement)
    ///   statement.
    /// * `DROP_FUNCTION` : [`DROP
    ///   FUNCTION`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_function_statement)
    ///   statement.
    /// * `DROP_TABLE_FUNCTION` : [`DROP TABLE
    ///   FUNCTION`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_table_function)
    ///   statement.
    /// * `DROP_PROCEDURE`: [`DROP
    ///   PROCEDURE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_procedure_statement)
    ///   statement.
    /// * `DROP_SEARCH_INDEX`: [`DROP SEARCH
    ///   INDEX`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_search_index)
    ///   statement.
    /// * `DROP_SCHEMA`: [`DROP
    ///   SCHEMA`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_schema_statement)
    ///   statement.
    /// * `DROP_SNAPSHOT_TABLE`: [`DROP SNAPSHOT
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_snapshot_table_statement)
    ///   statement.
    /// * `DROP_ROW_ACCESS_POLICY`: [`DROP [ALL] ROW ACCESS
    ///   POLICY|POLICIES`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#drop_row_access_policy_statement)
    ///   statement.
    /// * `ALTER_TABLE`: [`ALTER
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#alter_table_set_options_statement)
    ///   statement.
    /// * `ALTER_VIEW`: [`ALTER
    ///   VIEW`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#alter_view_set_options_statement)
    ///   statement.
    /// * `ALTER_MATERIALIZED_VIEW`: [`ALTER MATERIALIZED
    ///   VIEW`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#alter_materialized_view_set_options_statement)
    ///   statement.
    /// * `ALTER_SCHEMA`: [`ALTER
    ///   SCHEMA`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#alter_schema_set_options_statement)
    ///   statement.
    /// * `SCRIPT`:
    ///   [`SCRIPT`](https://cloud.google.com/bigquery/docs/reference/standard-sql/procedural-language).
    /// * `TRUNCATE_TABLE`: [`TRUNCATE
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax#truncate_table_statement)
    ///   statement.
    /// * `CREATE_EXTERNAL_TABLE`: [`CREATE EXTERNAL
    ///   TABLE`](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_external_table_statement)
    ///   statement.
    /// * `EXPORT_DATA`: [`EXPORT
    ///   DATA`](https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements#export_data_statement)
    ///   statement.
    /// * `EXPORT_MODEL`: [`EXPORT
    ///   MODEL`](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-export-model)
    ///   statement.
    /// * `LOAD_DATA`: [`LOAD
    ///   DATA`](https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements#load_data_statement)
    ///   statement.
    /// * `CALL`:
    ///   [`CALL`](https://cloud.google.com/bigquery/docs/reference/standard-sql/procedural-language#call)
    ///   statement.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub statement_type: std::string::String,

    /// Output only. The DDL operation performed, possibly
    /// dependent on the pre-existence of the DDL target.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ddl_operation_performed: std::string::String,

    /// Output only. The DDL target table. Present only for
    /// CREATE/DROP TABLE/VIEW and DROP ALL ROW ACCESS POLICIES queries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl_target_table: std::option::Option<crate::model::TableReference>,

    /// Output only. The table after rename. Present only for ALTER TABLE RENAME TO
    /// query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl_destination_table: std::option::Option<crate::model::TableReference>,

    /// Output only. The DDL target row access policy. Present only for
    /// CREATE/DROP ROW ACCESS POLICY queries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl_target_row_access_policy: std::option::Option<crate::model::RowAccessPolicyReference>,

    /// Output only. The number of row access policies affected by a DDL statement.
    /// Present only for DROP ALL ROW ACCESS POLICIES queries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub ddl_affected_row_access_policy_count: std::option::Option<wkt::Int64Value>,

    /// Output only. [Beta] The DDL target routine. Present only for
    /// CREATE/DROP FUNCTION/PROCEDURE queries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl_target_routine: std::option::Option<crate::model::RoutineReference>,

    /// Output only. The DDL target dataset. Present only for CREATE/ALTER/DROP
    /// SCHEMA(dataset) queries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl_target_dataset: std::option::Option<crate::model::DatasetReference>,

    /// Output only. Statistics of a BigQuery ML training job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ml_statistics: std::option::Option<crate::model::MlStatistics>,

    /// Output only. Stats for EXPORT DATA statement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_data_statistics: std::option::Option<crate::model::ExportDataStatistics>,

    /// Output only. Job cost breakdown as bigquery internal cost and external
    /// service costs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_service_costs: std::vec::Vec<crate::model::ExternalServiceCost>,

    /// Output only. BI Engine specific Statistics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bi_engine_statistics: std::option::Option<crate::model::BiEngineStatistics>,

    /// Output only. Statistics for a LOAD query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub load_query_statistics: std::option::Option<crate::model::LoadQueryStatistics>,

    /// Output only. Referenced table for DCL statement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dcl_target_table: std::option::Option<crate::model::TableReference>,

    /// Output only. Referenced view for DCL statement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dcl_target_view: std::option::Option<crate::model::TableReference>,

    /// Output only. Referenced dataset for DCL statement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dcl_target_dataset: std::option::Option<crate::model::DatasetReference>,

    /// Output only. Search query specific statistics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_statistics: std::option::Option<crate::model::SearchStatistics>,

    /// Output only. Vector Search query specific statistics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vector_search_statistics: std::option::Option<crate::model::VectorSearchStatistics>,

    /// Output only. Performance insights.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_insights: std::option::Option<crate::model::PerformanceInsights>,

    /// Output only. Query optimization information for a QUERY job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_info: std::option::Option<crate::model::QueryInfo>,

    /// Output only. Statistics of a Spark procedure job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_statistics: std::option::Option<crate::model::SparkStatistics>,

    /// Output only. Total bytes transferred for cross-cloud queries such as Cross
    /// Cloud Transfer and CREATE TABLE AS SELECT (CTAS).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub transferred_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Statistics of materialized views of a query job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub materialized_view_statistics: std::option::Option<crate::model::MaterializedViewStatistics>,

    /// Output only. Statistics of metadata cache usage in a query for BigLake
    /// tables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_cache_statistics: std::option::Option<crate::model::MetadataCacheStatistics>,
}

impl JobStatistics2 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_bytes_processed][crate::model::JobStatistics2::estimated_bytes_processed].
    pub fn set_estimated_bytes_processed<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_bytes_processed = v.into();
        self
    }

    /// Sets the value of [total_partitions_processed][crate::model::JobStatistics2::total_partitions_processed].
    pub fn set_total_partitions_processed<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.total_partitions_processed = v.into();
        self
    }

    /// Sets the value of [total_bytes_processed][crate::model::JobStatistics2::total_bytes_processed].
    pub fn set_total_bytes_processed<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.total_bytes_processed = v.into();
        self
    }

    /// Sets the value of [total_bytes_processed_accuracy][crate::model::JobStatistics2::total_bytes_processed_accuracy].
    pub fn set_total_bytes_processed_accuracy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_bytes_processed_accuracy = v.into();
        self
    }

    /// Sets the value of [total_bytes_billed][crate::model::JobStatistics2::total_bytes_billed].
    pub fn set_total_bytes_billed<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_bytes_billed = v.into();
        self
    }

    /// Sets the value of [billing_tier][crate::model::JobStatistics2::billing_tier].
    pub fn set_billing_tier<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.billing_tier = v.into();
        self
    }

    /// Sets the value of [total_slot_ms][crate::model::JobStatistics2::total_slot_ms].
    pub fn set_total_slot_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_slot_ms = v.into();
        self
    }

    /// Sets the value of [cache_hit][crate::model::JobStatistics2::cache_hit].
    pub fn set_cache_hit<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cache_hit = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::JobStatistics2::schema].
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::TableSchema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [num_dml_affected_rows][crate::model::JobStatistics2::num_dml_affected_rows].
    pub fn set_num_dml_affected_rows<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_dml_affected_rows = v.into();
        self
    }

    /// Sets the value of [dml_stats][crate::model::JobStatistics2::dml_stats].
    pub fn set_dml_stats<T: std::convert::Into<std::option::Option<crate::model::DmlStats>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dml_stats = v.into();
        self
    }

    /// Sets the value of [statement_type][crate::model::JobStatistics2::statement_type].
    pub fn set_statement_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.statement_type = v.into();
        self
    }

    /// Sets the value of [ddl_operation_performed][crate::model::JobStatistics2::ddl_operation_performed].
    pub fn set_ddl_operation_performed<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_operation_performed = v.into();
        self
    }

    /// Sets the value of [ddl_target_table][crate::model::JobStatistics2::ddl_target_table].
    pub fn set_ddl_target_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_target_table = v.into();
        self
    }

    /// Sets the value of [ddl_destination_table][crate::model::JobStatistics2::ddl_destination_table].
    pub fn set_ddl_destination_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_destination_table = v.into();
        self
    }

    /// Sets the value of [ddl_target_row_access_policy][crate::model::JobStatistics2::ddl_target_row_access_policy].
    pub fn set_ddl_target_row_access_policy<
        T: std::convert::Into<std::option::Option<crate::model::RowAccessPolicyReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_target_row_access_policy = v.into();
        self
    }

    /// Sets the value of [ddl_affected_row_access_policy_count][crate::model::JobStatistics2::ddl_affected_row_access_policy_count].
    pub fn set_ddl_affected_row_access_policy_count<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_affected_row_access_policy_count = v.into();
        self
    }

    /// Sets the value of [ddl_target_routine][crate::model::JobStatistics2::ddl_target_routine].
    pub fn set_ddl_target_routine<
        T: std::convert::Into<std::option::Option<crate::model::RoutineReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_target_routine = v.into();
        self
    }

    /// Sets the value of [ddl_target_dataset][crate::model::JobStatistics2::ddl_target_dataset].
    pub fn set_ddl_target_dataset<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ddl_target_dataset = v.into();
        self
    }

    /// Sets the value of [ml_statistics][crate::model::JobStatistics2::ml_statistics].
    pub fn set_ml_statistics<
        T: std::convert::Into<std::option::Option<crate::model::MlStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ml_statistics = v.into();
        self
    }

    /// Sets the value of [export_data_statistics][crate::model::JobStatistics2::export_data_statistics].
    pub fn set_export_data_statistics<
        T: std::convert::Into<std::option::Option<crate::model::ExportDataStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_data_statistics = v.into();
        self
    }

    /// Sets the value of [bi_engine_statistics][crate::model::JobStatistics2::bi_engine_statistics].
    pub fn set_bi_engine_statistics<
        T: std::convert::Into<std::option::Option<crate::model::BiEngineStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bi_engine_statistics = v.into();
        self
    }

    /// Sets the value of [load_query_statistics][crate::model::JobStatistics2::load_query_statistics].
    pub fn set_load_query_statistics<
        T: std::convert::Into<std::option::Option<crate::model::LoadQueryStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load_query_statistics = v.into();
        self
    }

    /// Sets the value of [dcl_target_table][crate::model::JobStatistics2::dcl_target_table].
    pub fn set_dcl_target_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dcl_target_table = v.into();
        self
    }

    /// Sets the value of [dcl_target_view][crate::model::JobStatistics2::dcl_target_view].
    pub fn set_dcl_target_view<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dcl_target_view = v.into();
        self
    }

    /// Sets the value of [dcl_target_dataset][crate::model::JobStatistics2::dcl_target_dataset].
    pub fn set_dcl_target_dataset<
        T: std::convert::Into<std::option::Option<crate::model::DatasetReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dcl_target_dataset = v.into();
        self
    }

    /// Sets the value of [search_statistics][crate::model::JobStatistics2::search_statistics].
    pub fn set_search_statistics<
        T: std::convert::Into<std::option::Option<crate::model::SearchStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.search_statistics = v.into();
        self
    }

    /// Sets the value of [vector_search_statistics][crate::model::JobStatistics2::vector_search_statistics].
    pub fn set_vector_search_statistics<
        T: std::convert::Into<std::option::Option<crate::model::VectorSearchStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vector_search_statistics = v.into();
        self
    }

    /// Sets the value of [performance_insights][crate::model::JobStatistics2::performance_insights].
    pub fn set_performance_insights<
        T: std::convert::Into<std::option::Option<crate::model::PerformanceInsights>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_insights = v.into();
        self
    }

    /// Sets the value of [query_info][crate::model::JobStatistics2::query_info].
    pub fn set_query_info<T: std::convert::Into<std::option::Option<crate::model::QueryInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query_info = v.into();
        self
    }

    /// Sets the value of [spark_statistics][crate::model::JobStatistics2::spark_statistics].
    pub fn set_spark_statistics<
        T: std::convert::Into<std::option::Option<crate::model::SparkStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spark_statistics = v.into();
        self
    }

    /// Sets the value of [transferred_bytes][crate::model::JobStatistics2::transferred_bytes].
    pub fn set_transferred_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transferred_bytes = v.into();
        self
    }

    /// Sets the value of [materialized_view_statistics][crate::model::JobStatistics2::materialized_view_statistics].
    pub fn set_materialized_view_statistics<
        T: std::convert::Into<std::option::Option<crate::model::MaterializedViewStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.materialized_view_statistics = v.into();
        self
    }

    /// Sets the value of [metadata_cache_statistics][crate::model::JobStatistics2::metadata_cache_statistics].
    pub fn set_metadata_cache_statistics<
        T: std::convert::Into<std::option::Option<crate::model::MetadataCacheStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_cache_statistics = v.into();
        self
    }

    /// Sets the value of [query_plan][crate::model::JobStatistics2::query_plan].
    pub fn set_query_plan<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExplainQueryStage>,
    {
        use std::iter::Iterator;
        self.query_plan = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timeline][crate::model::JobStatistics2::timeline].
    pub fn set_timeline<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryTimelineSample>,
    {
        use std::iter::Iterator;
        self.timeline = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [referenced_tables][crate::model::JobStatistics2::referenced_tables].
    pub fn set_referenced_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableReference>,
    {
        use std::iter::Iterator;
        self.referenced_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [referenced_routines][crate::model::JobStatistics2::referenced_routines].
    pub fn set_referenced_routines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RoutineReference>,
    {
        use std::iter::Iterator;
        self.referenced_routines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [undeclared_query_parameters][crate::model::JobStatistics2::undeclared_query_parameters].
    pub fn set_undeclared_query_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryParameter>,
    {
        use std::iter::Iterator;
        self.undeclared_query_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [external_service_costs][crate::model::JobStatistics2::external_service_costs].
    pub fn set_external_service_costs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExternalServiceCost>,
    {
        use std::iter::Iterator;
        self.external_service_costs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobStatistics2 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobStatistics2"
    }
}

/// Statistics for a load job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobStatistics3 {
    /// Output only. Number of source files in a load job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub input_files: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of bytes of source data in a load job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub input_file_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of rows imported in a load job.
    /// Note that while an import job is in the running state, this
    /// value may change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub output_rows: std::option::Option<wkt::Int64Value>,

    /// Output only. Size of the loaded data in bytes. Note
    /// that while a load job is in the running state, this value may change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub output_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of bad records encountered. Note that if the job
    /// has failed because of more bad records encountered than the maximum
    /// allowed in the load job configuration, then this number can be less than
    /// the total number of bad records present in the input data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub bad_records: std::option::Option<wkt::Int64Value>,

    /// Output only. Describes a timeline of job execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub timeline: std::vec::Vec<crate::model::QueryTimelineSample>,
}

impl JobStatistics3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_files][crate::model::JobStatistics3::input_files].
    pub fn set_input_files<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_files = v.into();
        self
    }

    /// Sets the value of [input_file_bytes][crate::model::JobStatistics3::input_file_bytes].
    pub fn set_input_file_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_file_bytes = v.into();
        self
    }

    /// Sets the value of [output_rows][crate::model::JobStatistics3::output_rows].
    pub fn set_output_rows<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_rows = v.into();
        self
    }

    /// Sets the value of [output_bytes][crate::model::JobStatistics3::output_bytes].
    pub fn set_output_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_bytes = v.into();
        self
    }

    /// Sets the value of [bad_records][crate::model::JobStatistics3::bad_records].
    pub fn set_bad_records<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bad_records = v.into();
        self
    }

    /// Sets the value of [timeline][crate::model::JobStatistics3::timeline].
    pub fn set_timeline<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryTimelineSample>,
    {
        use std::iter::Iterator;
        self.timeline = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobStatistics3 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobStatistics3"
    }
}

/// Statistics for an extract job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobStatistics4 {
    /// Output only. Number of files per destination URI or URI pattern
    /// specified in the extract configuration. These values will be in the same
    /// order as the URIs specified in the 'destinationUris' field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub destination_uri_file_counts: std::vec::Vec<i64>,

    /// Output only. Number of user bytes extracted into the result. This is the
    /// byte count as computed by BigQuery for billing purposes
    /// and doesn't have any relationship with the number of actual
    /// result bytes extracted in the desired format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub input_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Describes a timeline of job execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub timeline: std::vec::Vec<crate::model::QueryTimelineSample>,
}

impl JobStatistics4 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_bytes][crate::model::JobStatistics4::input_bytes].
    pub fn set_input_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_bytes = v.into();
        self
    }

    /// Sets the value of [destination_uri_file_counts][crate::model::JobStatistics4::destination_uri_file_counts].
    pub fn set_destination_uri_file_counts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.destination_uri_file_counts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timeline][crate::model::JobStatistics4::timeline].
    pub fn set_timeline<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryTimelineSample>,
    {
        use std::iter::Iterator;
        self.timeline = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobStatistics4 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobStatistics4"
    }
}

/// Statistics for a copy job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyJobStatistics {
    /// Output only. Number of rows copied to the destination table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub copied_rows: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of logical bytes copied to the destination table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub copied_logical_bytes: std::option::Option<wkt::Int64Value>,
}

impl CopyJobStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [copied_rows][crate::model::CopyJobStatistics::copied_rows].
    pub fn set_copied_rows<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.copied_rows = v.into();
        self
    }

    /// Sets the value of [copied_logical_bytes][crate::model::CopyJobStatistics::copied_logical_bytes].
    pub fn set_copied_logical_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.copied_logical_bytes = v.into();
        self
    }
}

impl wkt::message::Message for CopyJobStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CopyJobStatistics"
    }
}

/// Job statistics specific to a BigQuery ML training job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MlStatistics {
    /// Output only. Maximum number of iterations specified as max_iterations in
    /// the 'CREATE MODEL' query. The actual number of iterations may be less than
    /// this number due to early stop.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_iterations: i64,

    /// Results for all completed iterations.
    /// Empty for [hyperparameter tuning
    /// jobs](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub iteration_results: std::vec::Vec<crate::model::model::training_run::IterationResult>,

    /// Output only. The type of the model that is being trained.
    pub model_type: crate::model::model::ModelType,

    /// Output only. Training type of the job.
    pub training_type: crate::model::ml_statistics::TrainingType,

    /// Output only. Trials of a [hyperparameter tuning
    /// job](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// sorted by trial_id.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hparam_trials: std::vec::Vec<crate::model::model::HparamTuningTrial>,
}

impl MlStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_iterations][crate::model::MlStatistics::max_iterations].
    pub fn set_max_iterations<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_iterations = v.into();
        self
    }

    /// Sets the value of [model_type][crate::model::MlStatistics::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::model::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [training_type][crate::model::MlStatistics::training_type].
    pub fn set_training_type<T: std::convert::Into<crate::model::ml_statistics::TrainingType>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_type = v.into();
        self
    }

    /// Sets the value of [iteration_results][crate::model::MlStatistics::iteration_results].
    pub fn set_iteration_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::training_run::IterationResult>,
    {
        use std::iter::Iterator;
        self.iteration_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hparam_trials][crate::model::MlStatistics::hparam_trials].
    pub fn set_hparam_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::HparamTuningTrial>,
    {
        use std::iter::Iterator;
        self.hparam_trials = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MlStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MlStatistics"
    }
}

/// Defines additional types related to MlStatistics
pub mod ml_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// Training type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TrainingType(i32);

    impl TrainingType {
        /// Unspecified training type.
        pub const TRAINING_TYPE_UNSPECIFIED: TrainingType = TrainingType::new(0);

        /// Single training with fixed parameter space.
        pub const SINGLE_TRAINING: TrainingType = TrainingType::new(1);

        /// [Hyperparameter tuning
        /// training](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview).
        pub const HPARAM_TUNING: TrainingType = TrainingType::new(2);

        /// Creates a new TrainingType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TRAINING_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SINGLE_TRAINING"),
                2 => std::borrow::Cow::Borrowed("HPARAM_TUNING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TRAINING_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TRAINING_TYPE_UNSPECIFIED)
                }
                "SINGLE_TRAINING" => std::option::Option::Some(Self::SINGLE_TRAINING),
                "HPARAM_TUNING" => std::option::Option::Some(Self::HPARAM_TUNING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TrainingType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TrainingType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Job statistics specific to the child job of a script.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScriptStatistics {
    /// Whether this child job was a statement or expression.
    pub evaluation_kind: crate::model::script_statistics::EvaluationKind,

    /// Stack trace showing the line/column/procedure name of each frame on the
    /// stack at the point where the current evaluation happened. The leaf frame
    /// is first, the primary script is last. Never empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stack_frames: std::vec::Vec<crate::model::script_statistics::ScriptStackFrame>,
}

impl ScriptStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation_kind][crate::model::ScriptStatistics::evaluation_kind].
    pub fn set_evaluation_kind<
        T: std::convert::Into<crate::model::script_statistics::EvaluationKind>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_kind = v.into();
        self
    }

    /// Sets the value of [stack_frames][crate::model::ScriptStatistics::stack_frames].
    pub fn set_stack_frames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::script_statistics::ScriptStackFrame>,
    {
        use std::iter::Iterator;
        self.stack_frames = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ScriptStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ScriptStatistics"
    }
}

/// Defines additional types related to ScriptStatistics
pub mod script_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the location of the statement/expression being evaluated.
    /// Line and column numbers are defined as follows:
    ///
    /// - Line and column numbers start with one.  That is, line 1 column 1 denotes
    ///   the start of the script.
    /// - When inside a stored procedure, all line/column numbers are relative
    ///   to the procedure body, not the script in which the procedure was defined.
    /// - Start/end positions exclude leading/trailing comments and whitespace.
    ///   The end position always ends with a ";", when present.
    /// - Multi-byte Unicode characters are treated as just one column.
    /// - If the original script (or procedure definition) contains TAB characters,
    ///   a tab "snaps" the indentation forward to the nearest multiple of 8
    ///   characters, plus 1. For example, a TAB on column 1, 2, 3, 4, 5, 6 , or 8
    ///   will advance the next character to column 9.  A TAB on column 9, 10, 11,
    ///   12, 13, 14, 15, or 16 will advance the next character to column 17.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ScriptStackFrame {
        /// Output only. One-based start line.
        pub start_line: i32,

        /// Output only. One-based start column.
        pub start_column: i32,

        /// Output only. One-based end line.
        pub end_line: i32,

        /// Output only. One-based end column.
        pub end_column: i32,

        /// Output only. Name of the active procedure, empty if in a top-level
        /// script.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub procedure_id: std::string::String,

        /// Output only. Text of the current statement/expression.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub text: std::string::String,
    }

    impl ScriptStackFrame {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_line][crate::model::script_statistics::ScriptStackFrame::start_line].
        pub fn set_start_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.start_line = v.into();
            self
        }

        /// Sets the value of [start_column][crate::model::script_statistics::ScriptStackFrame::start_column].
        pub fn set_start_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.start_column = v.into();
            self
        }

        /// Sets the value of [end_line][crate::model::script_statistics::ScriptStackFrame::end_line].
        pub fn set_end_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.end_line = v.into();
            self
        }

        /// Sets the value of [end_column][crate::model::script_statistics::ScriptStackFrame::end_column].
        pub fn set_end_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.end_column = v.into();
            self
        }

        /// Sets the value of [procedure_id][crate::model::script_statistics::ScriptStackFrame::procedure_id].
        pub fn set_procedure_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.procedure_id = v.into();
            self
        }

        /// Sets the value of [text][crate::model::script_statistics::ScriptStackFrame::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for ScriptStackFrame {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.ScriptStatistics.ScriptStackFrame"
        }
    }

    /// Describes how the job is evaluated.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EvaluationKind(i32);

    impl EvaluationKind {
        /// Default value.
        pub const EVALUATION_KIND_UNSPECIFIED: EvaluationKind = EvaluationKind::new(0);

        /// The statement appears directly in the script.
        pub const STATEMENT: EvaluationKind = EvaluationKind::new(1);

        /// The statement evaluates an expression that appears in the script.
        pub const EXPRESSION: EvaluationKind = EvaluationKind::new(2);

        /// Creates a new EvaluationKind instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EVALUATION_KIND_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STATEMENT"),
                2 => std::borrow::Cow::Borrowed("EXPRESSION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EVALUATION_KIND_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EVALUATION_KIND_UNSPECIFIED)
                }
                "STATEMENT" => std::option::Option::Some(Self::STATEMENT),
                "EXPRESSION" => std::option::Option::Some(Self::EXPRESSION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EvaluationKind {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EvaluationKind {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Statistics for row-level security.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RowLevelSecurityStatistics {
    /// Whether any accessed data was protected by row access policies.
    pub row_level_security_applied: bool,
}

impl RowLevelSecurityStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_level_security_applied][crate::model::RowLevelSecurityStatistics::row_level_security_applied].
    pub fn set_row_level_security_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.row_level_security_applied = v.into();
        self
    }
}

impl wkt::message::Message for RowLevelSecurityStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RowLevelSecurityStatistics"
    }
}

/// Statistics for data-masking.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataMaskingStatistics {
    /// Whether any accessed data was protected by the data masking.
    pub data_masking_applied: bool,
}

impl DataMaskingStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_masking_applied][crate::model::DataMaskingStatistics::data_masking_applied].
    pub fn set_data_masking_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.data_masking_applied = v.into();
        self
    }
}

impl wkt::message::Message for DataMaskingStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DataMaskingStatistics"
    }
}

/// Statistics for a single job execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobStatistics {
    /// Output only. Creation time of this job, in milliseconds since the epoch.
    /// This field will be present on all jobs.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// Output only. Start time of this job, in milliseconds since the epoch.
    /// This field will be present when the job transitions from the PENDING state
    /// to either RUNNING or DONE.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub start_time: i64,

    /// Output only. End time of this job, in milliseconds since the epoch. This
    /// field will be present whenever a job is in the DONE state.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub end_time: i64,

    /// Output only. Total bytes processed for the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_bytes_processed: std::option::Option<wkt::Int64Value>,

    /// Output only. [TrustedTester] Job progress (0.0 -> 1.0) for LOAD and
    /// EXTRACT jobs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_ratio: std::option::Option<wkt::DoubleValue>,

    /// Output only. Quotas which delayed this job's start time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quota_deferments: std::vec::Vec<std::string::String>,

    /// Output only. Statistics for a query job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::JobStatistics2>,

    /// Output only. Statistics for a load job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub load: std::option::Option<crate::model::JobStatistics3>,

    /// Output only. Statistics for an extract job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub extract: std::option::Option<crate::model::JobStatistics4>,

    /// Output only. Statistics for a copy job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub copy: std::option::Option<crate::model::CopyJobStatistics>,

    /// Output only. Slot-milliseconds for the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub total_slot_ms: std::option::Option<wkt::Int64Value>,

    /// Output only. Name of the primary reservation assigned to this job. Note
    /// that this could be different than reservations reported in the reservation
    /// usage field if parent reservations were used to execute this job.
    #[serde(rename = "reservation_id")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reservation_id: std::string::String,

    /// Output only. Number of child jobs executed.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub num_child_jobs: i64,

    /// Output only. If this is a child job, specifies the job ID of the parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_job_id: std::string::String,

    /// Output only. If this a child job of a script, specifies information about
    /// the context of this job within the script.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub script_statistics: std::option::Option<crate::model::ScriptStatistics>,

    /// Output only. Statistics for row-level security. Present only for query and
    /// extract jobs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub row_level_security_statistics:
        std::option::Option<crate::model::RowLevelSecurityStatistics>,

    /// Output only. Statistics for data-masking. Present only for query and
    /// extract jobs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_masking_statistics: std::option::Option<crate::model::DataMaskingStatistics>,

    /// Output only. [Alpha] Information of the multi-statement transaction if this
    /// job is part of one.
    ///
    /// This property is only expected on a child job or a job that is in a
    /// session. A script parent job is not part of the transaction started in the
    /// script.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_info: std::option::Option<crate::model::job_statistics::TransactionInfo>,

    /// Output only. Information of the session if this job is part of one.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_info: std::option::Option<crate::model::SessionInfo>,

    /// Output only. The duration in milliseconds of the execution of the final
    /// attempt of this job, as BigQuery may internally re-attempt to execute the
    /// job.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub final_execution_duration_ms: i64,

    /// Output only. Name of edition corresponding to the reservation for this job
    /// at the time of this update.
    pub edition: crate::model::ReservationEdition,
}

impl JobStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [creation_time][crate::model::JobStatistics::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::JobStatistics::start_time].
    pub fn set_start_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::JobStatistics::end_time].
    pub fn set_end_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [total_bytes_processed][crate::model::JobStatistics::total_bytes_processed].
    pub fn set_total_bytes_processed<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.total_bytes_processed = v.into();
        self
    }

    /// Sets the value of [completion_ratio][crate::model::JobStatistics::completion_ratio].
    pub fn set_completion_ratio<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_ratio = v.into();
        self
    }

    /// Sets the value of [query][crate::model::JobStatistics::query].
    pub fn set_query<T: std::convert::Into<std::option::Option<crate::model::JobStatistics2>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [load][crate::model::JobStatistics::load].
    pub fn set_load<T: std::convert::Into<std::option::Option<crate::model::JobStatistics3>>>(
        mut self,
        v: T,
    ) -> Self {
        self.load = v.into();
        self
    }

    /// Sets the value of [extract][crate::model::JobStatistics::extract].
    pub fn set_extract<T: std::convert::Into<std::option::Option<crate::model::JobStatistics4>>>(
        mut self,
        v: T,
    ) -> Self {
        self.extract = v.into();
        self
    }

    /// Sets the value of [copy][crate::model::JobStatistics::copy].
    pub fn set_copy<T: std::convert::Into<std::option::Option<crate::model::CopyJobStatistics>>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy = v.into();
        self
    }

    /// Sets the value of [total_slot_ms][crate::model::JobStatistics::total_slot_ms].
    pub fn set_total_slot_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_slot_ms = v.into();
        self
    }

    /// Sets the value of [reservation_id][crate::model::JobStatistics::reservation_id].
    pub fn set_reservation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reservation_id = v.into();
        self
    }

    /// Sets the value of [num_child_jobs][crate::model::JobStatistics::num_child_jobs].
    pub fn set_num_child_jobs<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.num_child_jobs = v.into();
        self
    }

    /// Sets the value of [parent_job_id][crate::model::JobStatistics::parent_job_id].
    pub fn set_parent_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_job_id = v.into();
        self
    }

    /// Sets the value of [script_statistics][crate::model::JobStatistics::script_statistics].
    pub fn set_script_statistics<
        T: std::convert::Into<std::option::Option<crate::model::ScriptStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.script_statistics = v.into();
        self
    }

    /// Sets the value of [row_level_security_statistics][crate::model::JobStatistics::row_level_security_statistics].
    pub fn set_row_level_security_statistics<
        T: std::convert::Into<std::option::Option<crate::model::RowLevelSecurityStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.row_level_security_statistics = v.into();
        self
    }

    /// Sets the value of [data_masking_statistics][crate::model::JobStatistics::data_masking_statistics].
    pub fn set_data_masking_statistics<
        T: std::convert::Into<std::option::Option<crate::model::DataMaskingStatistics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_masking_statistics = v.into();
        self
    }

    /// Sets the value of [transaction_info][crate::model::JobStatistics::transaction_info].
    pub fn set_transaction_info<
        T: std::convert::Into<std::option::Option<crate::model::job_statistics::TransactionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transaction_info = v.into();
        self
    }

    /// Sets the value of [session_info][crate::model::JobStatistics::session_info].
    pub fn set_session_info<
        T: std::convert::Into<std::option::Option<crate::model::SessionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_info = v.into();
        self
    }

    /// Sets the value of [final_execution_duration_ms][crate::model::JobStatistics::final_execution_duration_ms].
    pub fn set_final_execution_duration_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.final_execution_duration_ms = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::JobStatistics::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::ReservationEdition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [quota_deferments][crate::model::JobStatistics::quota_deferments].
    pub fn set_quota_deferments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.quota_deferments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobStatistics"
    }
}

/// Defines additional types related to JobStatistics
pub mod job_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// [Alpha] Information of a multi-statement transaction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TransactionInfo {
        /// Output only. [Alpha] Id of the transaction.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub transaction_id: std::string::String,
    }

    impl TransactionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transaction_id][crate::model::job_statistics::TransactionInfo::transaction_id].
        pub fn set_transaction_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.transaction_id = v.into();
            self
        }
    }

    impl wkt::message::Message for TransactionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.JobStatistics.TransactionInfo"
        }
    }
}

/// Detailed statistics for DML statements
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DmlStats {
    /// Output only. Number of inserted Rows. Populated by DML INSERT and MERGE
    /// statements
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub inserted_row_count: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of deleted Rows. populated by DML DELETE, MERGE and
    /// TRUNCATE statements.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub deleted_row_count: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of updated Rows. Populated by DML UPDATE and MERGE
    /// statements.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub updated_row_count: std::option::Option<wkt::Int64Value>,
}

impl DmlStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inserted_row_count][crate::model::DmlStats::inserted_row_count].
    pub fn set_inserted_row_count<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.inserted_row_count = v.into();
        self
    }

    /// Sets the value of [deleted_row_count][crate::model::DmlStats::deleted_row_count].
    pub fn set_deleted_row_count<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deleted_row_count = v.into();
        self
    }

    /// Sets the value of [updated_row_count][crate::model::DmlStats::updated_row_count].
    pub fn set_updated_row_count<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.updated_row_count = v.into();
        self
    }
}

impl wkt::message::Message for DmlStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DmlStats"
    }
}

/// Performance insights for the job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PerformanceInsights {
    /// Output only. Average execution ms of previous runs. Indicates the job ran
    /// slow compared to previous executions. To find previous executions, use
    /// INFORMATION_SCHEMA tables and filter jobs with same query hash.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub avg_previous_execution_ms: i64,

    /// Output only. Standalone query stage performance insights, for exploring
    /// potential improvements.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stage_performance_standalone_insights:
        std::vec::Vec<crate::model::StagePerformanceStandaloneInsight>,

    /// Output only. Query stage performance insights compared to previous runs,
    /// for diagnosing performance regression.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stage_performance_change_insights:
        std::vec::Vec<crate::model::StagePerformanceChangeInsight>,
}

impl PerformanceInsights {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [avg_previous_execution_ms][crate::model::PerformanceInsights::avg_previous_execution_ms].
    pub fn set_avg_previous_execution_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.avg_previous_execution_ms = v.into();
        self
    }

    /// Sets the value of [stage_performance_standalone_insights][crate::model::PerformanceInsights::stage_performance_standalone_insights].
    pub fn set_stage_performance_standalone_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StagePerformanceStandaloneInsight>,
    {
        use std::iter::Iterator;
        self.stage_performance_standalone_insights = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stage_performance_change_insights][crate::model::PerformanceInsights::stage_performance_change_insights].
    pub fn set_stage_performance_change_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StagePerformanceChangeInsight>,
    {
        use std::iter::Iterator;
        self.stage_performance_change_insights = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PerformanceInsights {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PerformanceInsights"
    }
}

/// Performance insights compared to the previous executions for a specific
/// stage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StagePerformanceChangeInsight {
    /// Output only. The stage id that the insight mapped to.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub stage_id: i64,

    /// Output only. Input data change insight of the query stage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_data_change: std::option::Option<crate::model::InputDataChange>,
}

impl StagePerformanceChangeInsight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stage_id][crate::model::StagePerformanceChangeInsight::stage_id].
    pub fn set_stage_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.stage_id = v.into();
        self
    }

    /// Sets the value of [input_data_change][crate::model::StagePerformanceChangeInsight::input_data_change].
    pub fn set_input_data_change<
        T: std::convert::Into<std::option::Option<crate::model::InputDataChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_data_change = v.into();
        self
    }
}

impl wkt::message::Message for StagePerformanceChangeInsight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StagePerformanceChangeInsight"
    }
}

/// Details about the input data change insight.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InputDataChange {
    /// Output only. Records read difference percentage compared to a previous run.
    pub records_read_diff_percentage: f32,
}

impl InputDataChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [records_read_diff_percentage][crate::model::InputDataChange::records_read_diff_percentage].
    pub fn set_records_read_diff_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.records_read_diff_percentage = v.into();
        self
    }
}

impl wkt::message::Message for InputDataChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InputDataChange"
    }
}

/// Standalone performance insights for a specific stage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StagePerformanceStandaloneInsight {
    /// Output only. The stage id that the insight mapped to.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub stage_id: i64,

    /// Output only. True if the stage has a slot contention issue.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub slot_contention: std::option::Option<bool>,

    /// Output only. True if the stage has insufficient shuffle quota.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insufficient_shuffle_quota: std::option::Option<bool>,

    /// Output only. If present, the stage had the following reasons for being
    /// disqualified from BI Engine execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bi_engine_reasons: std::vec::Vec<crate::model::BiEngineReason>,

    /// Output only. High cardinality joins in the stage.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub high_cardinality_joins: std::vec::Vec<crate::model::HighCardinalityJoin>,

    /// Output only. Partition skew in the stage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition_skew: std::option::Option<crate::model::PartitionSkew>,
}

impl StagePerformanceStandaloneInsight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stage_id][crate::model::StagePerformanceStandaloneInsight::stage_id].
    pub fn set_stage_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.stage_id = v.into();
        self
    }

    /// Sets the value of [slot_contention][crate::model::StagePerformanceStandaloneInsight::slot_contention].
    pub fn set_slot_contention<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.slot_contention = v.into();
        self
    }

    /// Sets the value of [insufficient_shuffle_quota][crate::model::StagePerformanceStandaloneInsight::insufficient_shuffle_quota].
    pub fn set_insufficient_shuffle_quota<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.insufficient_shuffle_quota = v.into();
        self
    }

    /// Sets the value of [partition_skew][crate::model::StagePerformanceStandaloneInsight::partition_skew].
    pub fn set_partition_skew<
        T: std::convert::Into<std::option::Option<crate::model::PartitionSkew>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition_skew = v.into();
        self
    }

    /// Sets the value of [bi_engine_reasons][crate::model::StagePerformanceStandaloneInsight::bi_engine_reasons].
    pub fn set_bi_engine_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BiEngineReason>,
    {
        use std::iter::Iterator;
        self.bi_engine_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [high_cardinality_joins][crate::model::StagePerformanceStandaloneInsight::high_cardinality_joins].
    pub fn set_high_cardinality_joins<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HighCardinalityJoin>,
    {
        use std::iter::Iterator;
        self.high_cardinality_joins = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StagePerformanceStandaloneInsight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StagePerformanceStandaloneInsight"
    }
}

/// High cardinality join detailed information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HighCardinalityJoin {
    /// Output only. Count of left input rows.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub left_rows: i64,

    /// Output only. Count of right input rows.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub right_rows: i64,

    /// Output only. Count of the output rows.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub output_rows: i64,

    /// Output only. The index of the join operator in the ExplainQueryStep lists.
    pub step_index: i32,
}

impl HighCardinalityJoin {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [left_rows][crate::model::HighCardinalityJoin::left_rows].
    pub fn set_left_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.left_rows = v.into();
        self
    }

    /// Sets the value of [right_rows][crate::model::HighCardinalityJoin::right_rows].
    pub fn set_right_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.right_rows = v.into();
        self
    }

    /// Sets the value of [output_rows][crate::model::HighCardinalityJoin::output_rows].
    pub fn set_output_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.output_rows = v.into();
        self
    }

    /// Sets the value of [step_index][crate::model::HighCardinalityJoin::step_index].
    pub fn set_step_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.step_index = v.into();
        self
    }
}

impl wkt::message::Message for HighCardinalityJoin {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.HighCardinalityJoin"
    }
}

/// Partition skew detailed information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartitionSkew {
    /// Output only. Source stages which produce skewed data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub skew_sources: std::vec::Vec<crate::model::partition_skew::SkewSource>,
}

impl PartitionSkew {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skew_sources][crate::model::PartitionSkew::skew_sources].
    pub fn set_skew_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::partition_skew::SkewSource>,
    {
        use std::iter::Iterator;
        self.skew_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartitionSkew {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PartitionSkew"
    }
}

/// Defines additional types related to PartitionSkew
pub mod partition_skew {
    #[allow(unused_imports)]
    use super::*;

    /// Details about source stages which produce skewed data.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SkewSource {
        /// Output only. Stage id of the skew source stage.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub stage_id: i64,
    }

    impl SkewSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stage_id][crate::model::partition_skew::SkewSource::stage_id].
        pub fn set_stage_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.stage_id = v.into();
            self
        }
    }

    impl wkt::message::Message for SkewSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.PartitionSkew.SkewSource"
        }
    }
}

/// Statistics for a BigSpark query.
/// Populated as part of JobStatistics2
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkStatistics {
    /// Output only. Spark job ID if a Spark job is created successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_job_id: std::option::Option<std::string::String>,

    /// Output only. Location where the Spark job is executed.
    /// A location is selected by BigQueury for jobs configured to run in a
    /// multi-region.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_job_location: std::option::Option<std::string::String>,

    /// Output only. Endpoints returned from Dataproc.
    /// Key list:
    ///
    /// - history_server_endpoint: A link to Spark job UI.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub endpoints: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Logging info is used to generate a link to Cloud Logging.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_info: std::option::Option<crate::model::spark_statistics::LoggingInfo>,

    /// Output only. The Cloud KMS encryption key that is used to protect the
    /// resources created by the Spark job. If the Spark procedure uses the invoker
    /// security mode, the Cloud KMS encryption key is either inferred from the
    /// provided system variable,
    /// `@@spark_proc_properties.kms_key_name`, or the default key of the BigQuery
    /// job's project (if the CMEK organization policy is enforced). Otherwise, the
    /// Cloud KMS key is either inferred from the Spark connection associated with
    /// the procedure (if it is provided), or from the default key of the Spark
    /// connection's project if the CMEK organization policy is enforced.
    ///
    /// Example:
    ///
    /// * `projects/[kms_project_id]/locations/[region]/keyRings/[key_region]/cryptoKeys/[key]`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kms_key_name: std::option::Option<std::string::String>,

    /// Output only. The Google Cloud Storage bucket that is used as the default
    /// file system by the Spark application. This field is only filled when the
    /// Spark procedure uses the invoker security mode. The `gcsStagingBucket`
    /// bucket is inferred from the `@@spark_proc_properties.staging_bucket` system
    /// variable (if it is provided). Otherwise, BigQuery creates a default staging
    /// bucket for the job and returns the bucket name in this field.
    ///
    /// Example:
    ///
    /// * `gs://[bucket_name]`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_staging_bucket: std::option::Option<std::string::String>,
}

impl SparkStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [spark_job_id][crate::model::SparkStatistics::spark_job_id].
    pub fn set_spark_job_id<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spark_job_id = v.into();
        self
    }

    /// Sets the value of [spark_job_location][crate::model::SparkStatistics::spark_job_location].
    pub fn set_spark_job_location<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spark_job_location = v.into();
        self
    }

    /// Sets the value of [logging_info][crate::model::SparkStatistics::logging_info].
    pub fn set_logging_info<
        T: std::convert::Into<std::option::Option<crate::model::spark_statistics::LoggingInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_info = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::SparkStatistics::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [gcs_staging_bucket][crate::model::SparkStatistics::gcs_staging_bucket].
    pub fn set_gcs_staging_bucket<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_staging_bucket = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::SparkStatistics::endpoints].
    pub fn set_endpoints<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SparkStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SparkStatistics"
    }
}

/// Defines additional types related to SparkStatistics
pub mod spark_statistics {
    #[allow(unused_imports)]
    use super::*;

    /// Spark job logs can be filtered by these fields in Cloud Logging.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LoggingInfo {
        /// Output only. Resource type used for logging.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub resource_type: std::string::String,

        /// Output only. Project ID where the Spark logs were written.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,
    }

    impl LoggingInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_type][crate::model::spark_statistics::LoggingInfo::resource_type].
        pub fn set_resource_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// Sets the value of [project_id][crate::model::spark_statistics::LoggingInfo::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }
    }

    impl wkt::message::Message for LoggingInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.SparkStatistics.LoggingInfo"
        }
    }
}

/// Statistics of materialized views considered in a query job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaterializedViewStatistics {
    /// Materialized views considered for the query job. Only certain materialized
    /// views are used. For a detailed list, see the child message.
    ///
    /// If many materialized views are considered, then the list might be
    /// incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub materialized_view: std::vec::Vec<crate::model::MaterializedView>,
}

impl MaterializedViewStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [materialized_view][crate::model::MaterializedViewStatistics::materialized_view].
    pub fn set_materialized_view<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MaterializedView>,
    {
        use std::iter::Iterator;
        self.materialized_view = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaterializedViewStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MaterializedViewStatistics"
    }
}

/// A materialized view considered for a query job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaterializedView {
    /// The candidate materialized view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::TableReference>,

    /// Whether the materialized view is chosen for the query.
    ///
    /// A materialized view can be chosen to rewrite multiple parts of the same
    /// query. If a materialized view is chosen to rewrite any part of the query,
    /// then this field is true, even if the materialized view was not chosen to
    /// rewrite others parts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub chosen: std::option::Option<bool>,

    /// If present, specifies a best-effort estimation of the bytes saved by using
    /// the materialized view rather than its base tables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub estimated_bytes_saved: std::option::Option<i64>,

    /// If present, specifies the reason why the materialized view was not chosen
    /// for the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rejected_reason: std::option::Option<crate::model::materialized_view::RejectedReason>,
}

impl MaterializedView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::MaterializedView::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [chosen][crate::model::MaterializedView::chosen].
    pub fn set_chosen<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.chosen = v.into();
        self
    }

    /// Sets the value of [estimated_bytes_saved][crate::model::MaterializedView::estimated_bytes_saved].
    pub fn set_estimated_bytes_saved<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.estimated_bytes_saved = v.into();
        self
    }

    /// Sets the value of [rejected_reason][crate::model::MaterializedView::rejected_reason].
    pub fn set_rejected_reason<
        T: std::convert::Into<std::option::Option<crate::model::materialized_view::RejectedReason>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rejected_reason = v.into();
        self
    }
}

impl wkt::message::Message for MaterializedView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MaterializedView"
    }
}

/// Defines additional types related to MaterializedView
pub mod materialized_view {
    #[allow(unused_imports)]
    use super::*;

    /// Reason why a materialized view was not chosen for a query. For more
    /// information, see [Understand why materialized views were
    /// rejected](https://cloud.google.com/bigquery/docs/materialized-views-use#understand-rejected).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RejectedReason(i32);

    impl RejectedReason {
        /// Default unspecified value.
        pub const REJECTED_REASON_UNSPECIFIED: RejectedReason = RejectedReason::new(0);

        /// View has no cached data because it has not refreshed yet.
        pub const NO_DATA: RejectedReason = RejectedReason::new(1);

        /// The estimated cost of the view is more expensive than another view or the
        /// base table.
        ///
        /// Note: The estimate cost might not match the billed cost.
        pub const COST: RejectedReason = RejectedReason::new(2);

        /// View has no cached data because a base table is truncated.
        pub const BASE_TABLE_TRUNCATED: RejectedReason = RejectedReason::new(3);

        /// View is invalidated because of a data change in one or more base tables.
        /// It could be any recent change if the
        /// [`maxStaleness`](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#Table.FIELDS.max_staleness)
        /// option is not set for the view, or otherwise any change outside of the
        /// staleness window.
        pub const BASE_TABLE_DATA_CHANGE: RejectedReason = RejectedReason::new(4);

        /// View is invalidated because a base table's partition expiration has
        /// changed.
        pub const BASE_TABLE_PARTITION_EXPIRATION_CHANGE: RejectedReason = RejectedReason::new(5);

        /// View is invalidated because a base table's partition has expired.
        pub const BASE_TABLE_EXPIRED_PARTITION: RejectedReason = RejectedReason::new(6);

        /// View is invalidated because a base table has an incompatible metadata
        /// change.
        pub const BASE_TABLE_INCOMPATIBLE_METADATA_CHANGE: RejectedReason = RejectedReason::new(7);

        /// View is invalidated because it was refreshed with a time zone other than
        /// that of the current job.
        pub const TIME_ZONE: RejectedReason = RejectedReason::new(8);

        /// View is outside the time travel window.
        pub const OUT_OF_TIME_TRAVEL_WINDOW: RejectedReason = RejectedReason::new(9);

        /// View is inaccessible to the user because of a fine-grained security
        /// policy on one of its base tables.
        pub const BASE_TABLE_FINE_GRAINED_SECURITY_POLICY: RejectedReason = RejectedReason::new(10);

        /// One of the view's base tables is too stale. For example, the cached
        /// metadata of a BigLake external table needs to be updated.
        pub const BASE_TABLE_TOO_STALE: RejectedReason = RejectedReason::new(11);

        /// Creates a new RejectedReason instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("REJECTED_REASON_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NO_DATA"),
                2 => std::borrow::Cow::Borrowed("COST"),
                3 => std::borrow::Cow::Borrowed("BASE_TABLE_TRUNCATED"),
                4 => std::borrow::Cow::Borrowed("BASE_TABLE_DATA_CHANGE"),
                5 => std::borrow::Cow::Borrowed("BASE_TABLE_PARTITION_EXPIRATION_CHANGE"),
                6 => std::borrow::Cow::Borrowed("BASE_TABLE_EXPIRED_PARTITION"),
                7 => std::borrow::Cow::Borrowed("BASE_TABLE_INCOMPATIBLE_METADATA_CHANGE"),
                8 => std::borrow::Cow::Borrowed("TIME_ZONE"),
                9 => std::borrow::Cow::Borrowed("OUT_OF_TIME_TRAVEL_WINDOW"),
                10 => std::borrow::Cow::Borrowed("BASE_TABLE_FINE_GRAINED_SECURITY_POLICY"),
                11 => std::borrow::Cow::Borrowed("BASE_TABLE_TOO_STALE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "REJECTED_REASON_UNSPECIFIED" => {
                    std::option::Option::Some(Self::REJECTED_REASON_UNSPECIFIED)
                }
                "NO_DATA" => std::option::Option::Some(Self::NO_DATA),
                "COST" => std::option::Option::Some(Self::COST),
                "BASE_TABLE_TRUNCATED" => std::option::Option::Some(Self::BASE_TABLE_TRUNCATED),
                "BASE_TABLE_DATA_CHANGE" => std::option::Option::Some(Self::BASE_TABLE_DATA_CHANGE),
                "BASE_TABLE_PARTITION_EXPIRATION_CHANGE" => {
                    std::option::Option::Some(Self::BASE_TABLE_PARTITION_EXPIRATION_CHANGE)
                }
                "BASE_TABLE_EXPIRED_PARTITION" => {
                    std::option::Option::Some(Self::BASE_TABLE_EXPIRED_PARTITION)
                }
                "BASE_TABLE_INCOMPATIBLE_METADATA_CHANGE" => {
                    std::option::Option::Some(Self::BASE_TABLE_INCOMPATIBLE_METADATA_CHANGE)
                }
                "TIME_ZONE" => std::option::Option::Some(Self::TIME_ZONE),
                "OUT_OF_TIME_TRAVEL_WINDOW" => {
                    std::option::Option::Some(Self::OUT_OF_TIME_TRAVEL_WINDOW)
                }
                "BASE_TABLE_FINE_GRAINED_SECURITY_POLICY" => {
                    std::option::Option::Some(Self::BASE_TABLE_FINE_GRAINED_SECURITY_POLICY)
                }
                "BASE_TABLE_TOO_STALE" => std::option::Option::Some(Self::BASE_TABLE_TOO_STALE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RejectedReason {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RejectedReason {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Table level detail on the usage of metadata caching. Only set for Metadata
/// caching eligible tables referenced in the query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableMetadataCacheUsage {
    /// Metadata caching eligible table referenced in the query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::TableReference>,

    /// Reason for not using metadata caching for the table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub unused_reason: std::option::Option<crate::model::table_metadata_cache_usage::UnusedReason>,

    /// Free form human-readable reason metadata caching was unused for
    /// the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub explanation: std::option::Option<std::string::String>,

    /// Duration since last refresh as of this job for managed tables (indicates
    /// metadata cache staleness as seen by this job).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub staleness: std::option::Option<wkt::Duration>,

    /// [Table
    /// type](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#Table.FIELDS.type).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_type: std::string::String,
}

impl TableMetadataCacheUsage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_reference][crate::model::TableMetadataCacheUsage::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [unused_reason][crate::model::TableMetadataCacheUsage::unused_reason].
    pub fn set_unused_reason<
        T: std::convert::Into<
            std::option::Option<crate::model::table_metadata_cache_usage::UnusedReason>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.unused_reason = v.into();
        self
    }

    /// Sets the value of [explanation][crate::model::TableMetadataCacheUsage::explanation].
    pub fn set_explanation<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.explanation = v.into();
        self
    }

    /// Sets the value of [staleness][crate::model::TableMetadataCacheUsage::staleness].
    pub fn set_staleness<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.staleness = v.into();
        self
    }

    /// Sets the value of [table_type][crate::model::TableMetadataCacheUsage::table_type].
    pub fn set_table_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_type = v.into();
        self
    }
}

impl wkt::message::Message for TableMetadataCacheUsage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableMetadataCacheUsage"
    }
}

/// Defines additional types related to TableMetadataCacheUsage
pub mod table_metadata_cache_usage {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons for not using metadata caching.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct UnusedReason(i32);

    impl UnusedReason {
        /// Unused reasons not specified.
        pub const UNUSED_REASON_UNSPECIFIED: UnusedReason = UnusedReason::new(0);

        /// Metadata cache was outside the table's maxStaleness.
        pub const EXCEEDED_MAX_STALENESS: UnusedReason = UnusedReason::new(1);

        /// Metadata caching feature is not enabled. [Update BigLake tables]
        /// (/bigquery/docs/create-cloud-storage-table-biglake#update-biglake-tables)
        /// to enable the metadata caching.
        pub const METADATA_CACHING_NOT_ENABLED: UnusedReason = UnusedReason::new(3);

        /// Other unknown reason.
        pub const OTHER_REASON: UnusedReason = UnusedReason::new(2);

        /// Creates a new UnusedReason instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNUSED_REASON_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("EXCEEDED_MAX_STALENESS"),
                2 => std::borrow::Cow::Borrowed("OTHER_REASON"),
                3 => std::borrow::Cow::Borrowed("METADATA_CACHING_NOT_ENABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNUSED_REASON_UNSPECIFIED" => {
                    std::option::Option::Some(Self::UNUSED_REASON_UNSPECIFIED)
                }
                "EXCEEDED_MAX_STALENESS" => std::option::Option::Some(Self::EXCEEDED_MAX_STALENESS),
                "METADATA_CACHING_NOT_ENABLED" => {
                    std::option::Option::Some(Self::METADATA_CACHING_NOT_ENABLED)
                }
                "OTHER_REASON" => std::option::Option::Some(Self::OTHER_REASON),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for UnusedReason {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for UnusedReason {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Statistics for metadata caching in BigLake tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataCacheStatistics {
    /// Set for the Metadata caching eligible tables referenced in the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_metadata_cache_usage: std::vec::Vec<crate::model::TableMetadataCacheUsage>,
}

impl MetadataCacheStatistics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_metadata_cache_usage][crate::model::MetadataCacheStatistics::table_metadata_cache_usage].
    pub fn set_table_metadata_cache_usage<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableMetadataCacheUsage>,
    {
        use std::iter::Iterator;
        self.table_metadata_cache_usage = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MetadataCacheStatistics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MetadataCacheStatistics"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobStatus {
    /// Output only. Final error result of the job. If present, indicates that the
    /// job has completed and was unsuccessful.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_result: std::option::Option<crate::model::ErrorProto>,

    /// Output only. The first errors encountered during the running of the job.
    /// The final message includes the number of errors that caused the process to
    /// stop. Errors here do not necessarily mean that the job has not completed or
    /// was unsuccessful.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::ErrorProto>,

    /// Output only. Running state of the job.  Valid states include 'PENDING',
    /// 'RUNNING', and 'DONE'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state: std::string::String,
}

impl JobStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_result][crate::model::JobStatus::error_result].
    pub fn set_error_result<
        T: std::convert::Into<std::option::Option<crate::model::ErrorProto>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_result = v.into();
        self
    }

    /// Sets the value of [state][crate::model::JobStatus::state].
    pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::JobStatus::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorProto>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JobStatus"
    }
}

/// BigQuery-specific metadata about a location. This will be set on
/// google.cloud.location.Location.metadata in Cloud Location API
/// responses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// The legacy BigQuery location ID, e.g. EU for the europe location.
    /// This is for any API consumers that need the legacy US and EU locations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub legacy_location_id: std::string::String,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [legacy_location_id][crate::model::LocationMetadata::legacy_location_id].
    pub fn set_legacy_location_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_location_id = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LocationMetadata"
    }
}

/// Remote Model Info
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoteModelInfo {
    /// Output only. Fully qualified name of the user-provided connection object of
    /// the remote model. Format:
    /// ```"projects/{project_id}/locations/{location_id}/connections/{connection_id}"```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection: std::string::String,

    /// Output only. Max number of rows in each batch sent to the remote service.
    /// If unset, the number of rows in each batch is set dynamically.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_batching_rows: i64,

    /// Output only. The model version for LLM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remote_model_version: std::string::String,

    /// Output only. The name of the speech recognizer to use for speech
    /// recognition. The expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    /// Customers can specify this field at model creation. If not specified, a
    /// default recognizer `projects/{model
    /// project}/locations/global/recognizers/_` will be used. See more details at
    /// [recognizers](https://cloud.google.com/speech-to-text/v2/docs/reference/rest/v2/projects.locations.recognizers)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub speech_recognizer: std::string::String,

    /// Remote services are services outside of BigQuery used by remote models for
    /// predictions. A remote service is backed by either an arbitrary endpoint or
    /// a selected remote service type, but not both.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub remote_service: std::option::Option<crate::model::remote_model_info::RemoteService>,
}

impl RemoteModelInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::RemoteModelInfo::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [max_batching_rows][crate::model::RemoteModelInfo::max_batching_rows].
    pub fn set_max_batching_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_batching_rows = v.into();
        self
    }

    /// Sets the value of [remote_model_version][crate::model::RemoteModelInfo::remote_model_version].
    pub fn set_remote_model_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remote_model_version = v.into();
        self
    }

    /// Sets the value of [speech_recognizer][crate::model::RemoteModelInfo::speech_recognizer].
    pub fn set_speech_recognizer<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.speech_recognizer = v.into();
        self
    }

    /// Sets the value of `remote_service`.
    pub fn set_remote_service<
        T: std::convert::Into<std::option::Option<crate::model::remote_model_info::RemoteService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_service = v.into();
        self
    }

    /// The value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// if it holds a `Endpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_endpoint(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.remote_service.as_ref().and_then(|v| match v {
            crate::model::remote_model_info::RemoteService::Endpoint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// if it holds a `RemoteServiceType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_remote_service_type(
        &self,
    ) -> std::option::Option<&crate::model::remote_model_info::RemoteServiceType> {
        #[allow(unreachable_patterns)]
        self.remote_service.as_ref().and_then(|v| match v {
            crate::model::remote_model_info::RemoteService::RemoteServiceType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// to hold a `Endpoint`.
    ///
    /// Note that all the setters affecting `remote_service` are
    /// mutually exclusive.
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_service = std::option::Option::Some(
            crate::model::remote_model_info::RemoteService::Endpoint(v.into()),
        );
        self
    }

    /// Sets the value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// to hold a `RemoteServiceType`.
    ///
    /// Note that all the setters affecting `remote_service` are
    /// mutually exclusive.
    pub fn set_remote_service_type<
        T: std::convert::Into<crate::model::remote_model_info::RemoteServiceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_service = std::option::Option::Some(
            crate::model::remote_model_info::RemoteService::RemoteServiceType(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RemoteModelInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RemoteModelInfo"
    }
}

/// Defines additional types related to RemoteModelInfo
pub mod remote_model_info {
    #[allow(unused_imports)]
    use super::*;

    /// Supported service type for remote model.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RemoteServiceType(i32);

    impl RemoteServiceType {
        /// Unspecified remote service type.
        pub const REMOTE_SERVICE_TYPE_UNSPECIFIED: RemoteServiceType = RemoteServiceType::new(0);

        /// V3 Cloud AI Translation API. See more details at [Cloud Translation API]
        /// (<https://cloud.google.com/translate/docs/reference/rest>).
        pub const CLOUD_AI_TRANSLATE_V3: RemoteServiceType = RemoteServiceType::new(1);

        /// V1 Cloud AI Vision API See more details at [Cloud Vision API]
        /// (<https://cloud.google.com/vision/docs/reference/rest>).
        pub const CLOUD_AI_VISION_V1: RemoteServiceType = RemoteServiceType::new(2);

        /// V1 Cloud AI Natural Language API. See more details at [REST Resource:
        /// documents](https://cloud.google.com/natural-language/docs/reference/rest/v1/documents).
        pub const CLOUD_AI_NATURAL_LANGUAGE_V1: RemoteServiceType = RemoteServiceType::new(3);

        /// V2 Speech-to-Text API. See more details at [Google Cloud Speech-to-Text
        /// V2 API](https://cloud.google.com/speech-to-text/v2/docs)
        pub const CLOUD_AI_SPEECH_TO_TEXT_V2: RemoteServiceType = RemoteServiceType::new(7);

        /// Creates a new RemoteServiceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("REMOTE_SERVICE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLOUD_AI_TRANSLATE_V3"),
                2 => std::borrow::Cow::Borrowed("CLOUD_AI_VISION_V1"),
                3 => std::borrow::Cow::Borrowed("CLOUD_AI_NATURAL_LANGUAGE_V1"),
                7 => std::borrow::Cow::Borrowed("CLOUD_AI_SPEECH_TO_TEXT_V2"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "REMOTE_SERVICE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::REMOTE_SERVICE_TYPE_UNSPECIFIED)
                }
                "CLOUD_AI_TRANSLATE_V3" => std::option::Option::Some(Self::CLOUD_AI_TRANSLATE_V3),
                "CLOUD_AI_VISION_V1" => std::option::Option::Some(Self::CLOUD_AI_VISION_V1),
                "CLOUD_AI_NATURAL_LANGUAGE_V1" => {
                    std::option::Option::Some(Self::CLOUD_AI_NATURAL_LANGUAGE_V1)
                }
                "CLOUD_AI_SPEECH_TO_TEXT_V2" => {
                    std::option::Option::Some(Self::CLOUD_AI_SPEECH_TO_TEXT_V2)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RemoteServiceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RemoteServiceType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Remote services are services outside of BigQuery used by remote models for
    /// predictions. A remote service is backed by either an arbitrary endpoint or
    /// a selected remote service type, but not both.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RemoteService {
        /// Output only. The endpoint for remote model.
        Endpoint(std::string::String),
        /// Output only. The remote service type for remote model.
        RemoteServiceType(crate::model::remote_model_info::RemoteServiceType),
    }
}

/// Information about a single transform column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransformColumn {
    /// Output only. Name of the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Data type of the column after the transform.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<crate::model::StandardSqlDataType>,

    /// Output only. The SQL expression used in the column transform.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub transform_sql: std::string::String,
}

impl TransformColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransformColumn::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TransformColumn::type].
    pub fn set_type<
        T: std::convert::Into<std::option::Option<crate::model::StandardSqlDataType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [transform_sql][crate::model::TransformColumn::transform_sql].
    pub fn set_transform_sql<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transform_sql = v.into();
        self
    }
}

impl wkt::message::Message for TransformColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TransformColumn"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Model {
    /// Output only. A hash of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Required. Unique identifier for this model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model_reference: std::option::Option<crate::model::ModelReference>,

    /// Output only. The time when this model was created, in millisecs since the
    /// epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// Output only. The time when this model was last modified, in millisecs since
    /// the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub last_modified_time: i64,

    /// Optional. A user-friendly description of this model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. A descriptive name for this model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub friendly_name: std::string::String,

    /// The labels associated with this model. You can use these to organize
    /// and group your models. Label keys and values can be no longer
    /// than 63 characters, can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter and each
    /// label in the list must have a different key.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The time when this model expires, in milliseconds since the
    /// epoch. If not present, the model will persist indefinitely. Expired models
    /// will be deleted and their storage reclaimed.  The defaultTableExpirationMs
    /// property of the encapsulating dataset can be used to set a default
    /// expirationTime on newly created models.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub expiration_time: i64,

    /// Output only. The geographic location where the model resides. This value
    /// is inherited from the dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Custom encryption configuration (e.g., Cloud KMS keys). This shows the
    /// encryption configuration of the model data while stored in BigQuery
    /// storage. This field can be used with PatchModel to update encryption key
    /// for an already encrypted model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Type of the model resource.
    pub model_type: crate::model::model::ModelType,

    /// Information for all training runs in increasing order of start_time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub training_runs: std::vec::Vec<crate::model::model::TrainingRun>,

    /// Output only. Input feature columns for the model inference. If the model is
    /// trained with TRANSFORM clause, these are the input of the TRANSFORM clause.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feature_columns: std::vec::Vec<crate::model::StandardSqlField>,

    /// Output only. Label columns that were used to train this model.
    /// The output of the model will have a "predicted_" prefix to these columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub label_columns: std::vec::Vec<crate::model::StandardSqlField>,

    /// Output only. This field will be populated if a TRANSFORM clause was used to
    /// train a model. TRANSFORM clause (if used) takes feature_columns as input
    /// and outputs transform_columns. transform_columns then are used to train the
    /// model.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub transform_columns: std::vec::Vec<crate::model::TransformColumn>,

    /// Output only. All hyperparameter search spaces in this model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hparam_search_spaces: std::option::Option<crate::model::model::HparamSearchSpaces>,

    /// Output only. The default trial_id to use in TVFs when the trial_id is not
    /// passed in. For single-objective [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, this is the best trial ID. For multi-objective [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, this is the smallest trial ID among all Pareto optimal trials.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub default_trial_id: i64,

    /// Output only. Trials of a [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// model sorted by trial_id.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hparam_trials: std::vec::Vec<crate::model::model::HparamTuningTrial>,

    /// Output only. For single-objective [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, it only contains the best trial. For multi-objective
    /// [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, it contains all Pareto optimal trials sorted by trial_id.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub optimal_trial_ids: std::vec::Vec<i64>,

    /// Output only. Remote model info
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub remote_model_info: std::option::Option<crate::model::RemoteModelInfo>,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::Model::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [model_reference][crate::model::Model::model_reference].
    pub fn set_model_reference<
        T: std::convert::Into<std::option::Option<crate::model::ModelReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_reference = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Model::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Model::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Model::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::Model::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Model::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Model::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [encryption_configuration][crate::model::Model::encryption_configuration].
    pub fn set_encryption_configuration<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_configuration = v.into();
        self
    }

    /// Sets the value of [model_type][crate::model::Model::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::model::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [hparam_search_spaces][crate::model::Model::hparam_search_spaces].
    pub fn set_hparam_search_spaces<
        T: std::convert::Into<std::option::Option<crate::model::model::HparamSearchSpaces>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hparam_search_spaces = v.into();
        self
    }

    /// Sets the value of [default_trial_id][crate::model::Model::default_trial_id].
    pub fn set_default_trial_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.default_trial_id = v.into();
        self
    }

    /// Sets the value of [remote_model_info][crate::model::Model::remote_model_info].
    pub fn set_remote_model_info<
        T: std::convert::Into<std::option::Option<crate::model::RemoteModelInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_model_info = v.into();
        self
    }

    /// Sets the value of [training_runs][crate::model::Model::training_runs].
    pub fn set_training_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::TrainingRun>,
    {
        use std::iter::Iterator;
        self.training_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [feature_columns][crate::model::Model::feature_columns].
    pub fn set_feature_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.feature_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [label_columns][crate::model::Model::label_columns].
    pub fn set_label_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.label_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transform_columns][crate::model::Model::transform_columns].
    pub fn set_transform_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformColumn>,
    {
        use std::iter::Iterator;
        self.transform_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hparam_trials][crate::model::Model::hparam_trials].
    pub fn set_hparam_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::HparamTuningTrial>,
    {
        use std::iter::Iterator;
        self.hparam_trials = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optimal_trial_ids][crate::model::Model::optimal_trial_ids].
    pub fn set_optimal_trial_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.optimal_trial_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Model::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Model"
    }
}

/// Defines additional types related to Model
pub mod model {
    #[allow(unused_imports)]
    use super::*;

    /// Enums for seasonal period.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SeasonalPeriod {}

    impl SeasonalPeriod {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SeasonalPeriod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.SeasonalPeriod"
        }
    }

    /// Defines additional types related to SeasonalPeriod
    pub mod seasonal_period {
        #[allow(unused_imports)]
        use super::*;

        /// Seasonal period type.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct SeasonalPeriodType(i32);

        impl SeasonalPeriodType {
            /// Unspecified seasonal period.
            pub const SEASONAL_PERIOD_TYPE_UNSPECIFIED: SeasonalPeriodType =
                SeasonalPeriodType::new(0);

            /// No seasonality
            pub const NO_SEASONALITY: SeasonalPeriodType = SeasonalPeriodType::new(1);

            /// Daily period, 24 hours.
            pub const DAILY: SeasonalPeriodType = SeasonalPeriodType::new(2);

            /// Weekly period, 7 days.
            pub const WEEKLY: SeasonalPeriodType = SeasonalPeriodType::new(3);

            /// Monthly period, 30 days or irregular.
            pub const MONTHLY: SeasonalPeriodType = SeasonalPeriodType::new(4);

            /// Quarterly period, 90 days or irregular.
            pub const QUARTERLY: SeasonalPeriodType = SeasonalPeriodType::new(5);

            /// Yearly period, 365 days or irregular.
            pub const YEARLY: SeasonalPeriodType = SeasonalPeriodType::new(6);

            /// Creates a new SeasonalPeriodType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("SEASONAL_PERIOD_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("NO_SEASONALITY"),
                    2 => std::borrow::Cow::Borrowed("DAILY"),
                    3 => std::borrow::Cow::Borrowed("WEEKLY"),
                    4 => std::borrow::Cow::Borrowed("MONTHLY"),
                    5 => std::borrow::Cow::Borrowed("QUARTERLY"),
                    6 => std::borrow::Cow::Borrowed("YEARLY"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "SEASONAL_PERIOD_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::SEASONAL_PERIOD_TYPE_UNSPECIFIED)
                    }
                    "NO_SEASONALITY" => std::option::Option::Some(Self::NO_SEASONALITY),
                    "DAILY" => std::option::Option::Some(Self::DAILY),
                    "WEEKLY" => std::option::Option::Some(Self::WEEKLY),
                    "MONTHLY" => std::option::Option::Some(Self::MONTHLY),
                    "QUARTERLY" => std::option::Option::Some(Self::QUARTERLY),
                    "YEARLY" => std::option::Option::Some(Self::YEARLY),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for SeasonalPeriodType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for SeasonalPeriodType {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Enums for kmeans model type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KmeansEnums {}

    impl KmeansEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for KmeansEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.KmeansEnums"
        }
    }

    /// Defines additional types related to KmeansEnums
    pub mod kmeans_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Indicates the method used to initialize the centroids for KMeans
        /// clustering algorithm.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct KmeansInitializationMethod(i32);

        impl KmeansInitializationMethod {
            /// Unspecified initialization method.
            pub const KMEANS_INITIALIZATION_METHOD_UNSPECIFIED: KmeansInitializationMethod =
                KmeansInitializationMethod::new(0);

            /// Initializes the centroids randomly.
            pub const RANDOM: KmeansInitializationMethod = KmeansInitializationMethod::new(1);

            /// Initializes the centroids using data specified in
            /// kmeans_initialization_column.
            pub const CUSTOM: KmeansInitializationMethod = KmeansInitializationMethod::new(2);

            /// Initializes with kmeans++.
            pub const KMEANS_PLUS_PLUS: KmeansInitializationMethod =
                KmeansInitializationMethod::new(3);

            /// Creates a new KmeansInitializationMethod instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("KMEANS_INITIALIZATION_METHOD_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("RANDOM"),
                    2 => std::borrow::Cow::Borrowed("CUSTOM"),
                    3 => std::borrow::Cow::Borrowed("KMEANS_PLUS_PLUS"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED" => {
                        std::option::Option::Some(Self::KMEANS_INITIALIZATION_METHOD_UNSPECIFIED)
                    }
                    "RANDOM" => std::option::Option::Some(Self::RANDOM),
                    "CUSTOM" => std::option::Option::Some(Self::CUSTOM),
                    "KMEANS_PLUS_PLUS" => std::option::Option::Some(Self::KMEANS_PLUS_PLUS),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for KmeansInitializationMethod {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for KmeansInitializationMethod {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Enums for XGBoost model type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BoostedTreeOptionEnums {}

    impl BoostedTreeOptionEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BoostedTreeOptionEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.BoostedTreeOptionEnums"
        }
    }

    /// Defines additional types related to BoostedTreeOptionEnums
    pub mod boosted_tree_option_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Booster types supported. Refer to booster parameter in XGBoost.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct BoosterType(i32);

        impl BoosterType {
            /// Unspecified booster type.
            pub const BOOSTER_TYPE_UNSPECIFIED: BoosterType = BoosterType::new(0);

            /// Gbtree booster.
            pub const GBTREE: BoosterType = BoosterType::new(1);

            /// Dart booster.
            pub const DART: BoosterType = BoosterType::new(2);

            /// Creates a new BoosterType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("BOOSTER_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("GBTREE"),
                    2 => std::borrow::Cow::Borrowed("DART"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "BOOSTER_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::BOOSTER_TYPE_UNSPECIFIED)
                    }
                    "GBTREE" => std::option::Option::Some(Self::GBTREE),
                    "DART" => std::option::Option::Some(Self::DART),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for BoosterType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for BoosterType {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Type of normalization algorithm for boosted tree models using dart
        /// booster. Refer to normalize_type in XGBoost.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct DartNormalizeType(i32);

        impl DartNormalizeType {
            /// Unspecified dart normalize type.
            pub const DART_NORMALIZE_TYPE_UNSPECIFIED: DartNormalizeType =
                DartNormalizeType::new(0);

            /// New trees have the same weight of each of dropped trees.
            pub const TREE: DartNormalizeType = DartNormalizeType::new(1);

            /// New trees have the same weight of sum of dropped trees.
            pub const FOREST: DartNormalizeType = DartNormalizeType::new(2);

            /// Creates a new DartNormalizeType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("DART_NORMALIZE_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("TREE"),
                    2 => std::borrow::Cow::Borrowed("FOREST"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "DART_NORMALIZE_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::DART_NORMALIZE_TYPE_UNSPECIFIED)
                    }
                    "TREE" => std::option::Option::Some(Self::TREE),
                    "FOREST" => std::option::Option::Some(Self::FOREST),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for DartNormalizeType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for DartNormalizeType {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// Tree construction algorithm used in boosted tree models.
        /// Refer to tree_method in XGBoost.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct TreeMethod(i32);

        impl TreeMethod {
            /// Unspecified tree method.
            pub const TREE_METHOD_UNSPECIFIED: TreeMethod = TreeMethod::new(0);

            /// Use heuristic to choose the fastest method.
            pub const AUTO: TreeMethod = TreeMethod::new(1);

            /// Exact greedy algorithm.
            pub const EXACT: TreeMethod = TreeMethod::new(2);

            /// Approximate greedy algorithm using quantile sketch and gradient
            /// histogram.
            pub const APPROX: TreeMethod = TreeMethod::new(3);

            /// Fast histogram optimized approximate greedy algorithm.
            pub const HIST: TreeMethod = TreeMethod::new(4);

            /// Creates a new TreeMethod instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("TREE_METHOD_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("AUTO"),
                    2 => std::borrow::Cow::Borrowed("EXACT"),
                    3 => std::borrow::Cow::Borrowed("APPROX"),
                    4 => std::borrow::Cow::Borrowed("HIST"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "TREE_METHOD_UNSPECIFIED" => {
                        std::option::Option::Some(Self::TREE_METHOD_UNSPECIFIED)
                    }
                    "AUTO" => std::option::Option::Some(Self::AUTO),
                    "EXACT" => std::option::Option::Some(Self::EXACT),
                    "APPROX" => std::option::Option::Some(Self::APPROX),
                    "HIST" => std::option::Option::Some(Self::HIST),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for TreeMethod {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for TreeMethod {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Enums for hyperparameter tuning.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HparamTuningEnums {}

    impl HparamTuningEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for HparamTuningEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.HparamTuningEnums"
        }
    }

    /// Defines additional types related to HparamTuningEnums
    pub mod hparam_tuning_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Available evaluation metrics used as hyperparameter tuning objectives.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct HparamTuningObjective(i32);

        impl HparamTuningObjective {
            /// Unspecified evaluation metric.
            pub const HPARAM_TUNING_OBJECTIVE_UNSPECIFIED: HparamTuningObjective =
                HparamTuningObjective::new(0);

            /// Mean absolute error.
            /// mean_absolute_error = AVG(ABS(label - predicted))
            pub const MEAN_ABSOLUTE_ERROR: HparamTuningObjective = HparamTuningObjective::new(1);

            /// Mean squared error.
            /// mean_squared_error = AVG(POW(label - predicted, 2))
            pub const MEAN_SQUARED_ERROR: HparamTuningObjective = HparamTuningObjective::new(2);

            /// Mean squared log error.
            /// mean_squared_log_error = AVG(POW(LN(1 + label) - LN(1 + predicted), 2))
            pub const MEAN_SQUARED_LOG_ERROR: HparamTuningObjective = HparamTuningObjective::new(3);

            /// Mean absolute error.
            /// median_absolute_error = APPROX_QUANTILES(absolute_error, 2)[OFFSET(1)]
            pub const MEDIAN_ABSOLUTE_ERROR: HparamTuningObjective = HparamTuningObjective::new(4);

            /// R^2 score. This corresponds to r2_score in ML.EVALUATE.
            /// r_squared = 1 - SUM(squared_error)/(COUNT(label)*VAR_POP(label))
            pub const R_SQUARED: HparamTuningObjective = HparamTuningObjective::new(5);

            /// Explained variance.
            /// explained_variance = 1 - VAR_POP(label_error)/VAR_POP(label)
            pub const EXPLAINED_VARIANCE: HparamTuningObjective = HparamTuningObjective::new(6);

            /// Precision is the fraction of actual positive predictions that had
            /// positive actual labels. For multiclass this is a macro-averaged metric
            /// treating each class as a binary classifier.
            pub const PRECISION: HparamTuningObjective = HparamTuningObjective::new(7);

            /// Recall is the fraction of actual positive labels that were given a
            /// positive prediction. For multiclass this is a macro-averaged metric.
            pub const RECALL: HparamTuningObjective = HparamTuningObjective::new(8);

            /// Accuracy is the fraction of predictions given the correct label. For
            /// multiclass this is a globally micro-averaged metric.
            pub const ACCURACY: HparamTuningObjective = HparamTuningObjective::new(9);

            /// The F1 score is an average of recall and precision. For multiclass this
            /// is a macro-averaged metric.
            pub const F1_SCORE: HparamTuningObjective = HparamTuningObjective::new(10);

            /// Logarithmic Loss. For multiclass this is a macro-averaged metric.
            pub const LOG_LOSS: HparamTuningObjective = HparamTuningObjective::new(11);

            /// Area Under an ROC Curve. For multiclass this is a macro-averaged
            /// metric.
            pub const ROC_AUC: HparamTuningObjective = HparamTuningObjective::new(12);

            /// Davies-Bouldin Index.
            pub const DAVIES_BOULDIN_INDEX: HparamTuningObjective = HparamTuningObjective::new(13);

            /// Mean Average Precision.
            pub const MEAN_AVERAGE_PRECISION: HparamTuningObjective =
                HparamTuningObjective::new(14);

            /// Normalized Discounted Cumulative Gain.
            pub const NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN: HparamTuningObjective =
                HparamTuningObjective::new(15);

            /// Average Rank.
            pub const AVERAGE_RANK: HparamTuningObjective = HparamTuningObjective::new(16);

            /// Creates a new HparamTuningObjective instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("HPARAM_TUNING_OBJECTIVE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("MEAN_ABSOLUTE_ERROR"),
                    2 => std::borrow::Cow::Borrowed("MEAN_SQUARED_ERROR"),
                    3 => std::borrow::Cow::Borrowed("MEAN_SQUARED_LOG_ERROR"),
                    4 => std::borrow::Cow::Borrowed("MEDIAN_ABSOLUTE_ERROR"),
                    5 => std::borrow::Cow::Borrowed("R_SQUARED"),
                    6 => std::borrow::Cow::Borrowed("EXPLAINED_VARIANCE"),
                    7 => std::borrow::Cow::Borrowed("PRECISION"),
                    8 => std::borrow::Cow::Borrowed("RECALL"),
                    9 => std::borrow::Cow::Borrowed("ACCURACY"),
                    10 => std::borrow::Cow::Borrowed("F1_SCORE"),
                    11 => std::borrow::Cow::Borrowed("LOG_LOSS"),
                    12 => std::borrow::Cow::Borrowed("ROC_AUC"),
                    13 => std::borrow::Cow::Borrowed("DAVIES_BOULDIN_INDEX"),
                    14 => std::borrow::Cow::Borrowed("MEAN_AVERAGE_PRECISION"),
                    15 => std::borrow::Cow::Borrowed("NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN"),
                    16 => std::borrow::Cow::Borrowed("AVERAGE_RANK"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::HPARAM_TUNING_OBJECTIVE_UNSPECIFIED)
                    }
                    "MEAN_ABSOLUTE_ERROR" => std::option::Option::Some(Self::MEAN_ABSOLUTE_ERROR),
                    "MEAN_SQUARED_ERROR" => std::option::Option::Some(Self::MEAN_SQUARED_ERROR),
                    "MEAN_SQUARED_LOG_ERROR" => {
                        std::option::Option::Some(Self::MEAN_SQUARED_LOG_ERROR)
                    }
                    "MEDIAN_ABSOLUTE_ERROR" => {
                        std::option::Option::Some(Self::MEDIAN_ABSOLUTE_ERROR)
                    }
                    "R_SQUARED" => std::option::Option::Some(Self::R_SQUARED),
                    "EXPLAINED_VARIANCE" => std::option::Option::Some(Self::EXPLAINED_VARIANCE),
                    "PRECISION" => std::option::Option::Some(Self::PRECISION),
                    "RECALL" => std::option::Option::Some(Self::RECALL),
                    "ACCURACY" => std::option::Option::Some(Self::ACCURACY),
                    "F1_SCORE" => std::option::Option::Some(Self::F1_SCORE),
                    "LOG_LOSS" => std::option::Option::Some(Self::LOG_LOSS),
                    "ROC_AUC" => std::option::Option::Some(Self::ROC_AUC),
                    "DAVIES_BOULDIN_INDEX" => std::option::Option::Some(Self::DAVIES_BOULDIN_INDEX),
                    "MEAN_AVERAGE_PRECISION" => {
                        std::option::Option::Some(Self::MEAN_AVERAGE_PRECISION)
                    }
                    "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN" => {
                        std::option::Option::Some(Self::NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN)
                    }
                    "AVERAGE_RANK" => std::option::Option::Some(Self::AVERAGE_RANK),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for HparamTuningObjective {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for HparamTuningObjective {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Evaluation metrics for regression and explicit feedback type matrix
    /// factorization models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RegressionMetrics {
        /// Mean absolute error.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mean_absolute_error: std::option::Option<wkt::DoubleValue>,

        /// Mean squared error.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mean_squared_error: std::option::Option<wkt::DoubleValue>,

        /// Mean squared log error.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mean_squared_log_error: std::option::Option<wkt::DoubleValue>,

        /// Median absolute error.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub median_absolute_error: std::option::Option<wkt::DoubleValue>,

        /// R^2 score. This corresponds to r2_score in ML.EVALUATE.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub r_squared: std::option::Option<wkt::DoubleValue>,
    }

    impl RegressionMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mean_absolute_error][crate::model::model::RegressionMetrics::mean_absolute_error].
        pub fn set_mean_absolute_error<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mean_absolute_error = v.into();
            self
        }

        /// Sets the value of [mean_squared_error][crate::model::model::RegressionMetrics::mean_squared_error].
        pub fn set_mean_squared_error<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mean_squared_error = v.into();
            self
        }

        /// Sets the value of [mean_squared_log_error][crate::model::model::RegressionMetrics::mean_squared_log_error].
        pub fn set_mean_squared_log_error<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mean_squared_log_error = v.into();
            self
        }

        /// Sets the value of [median_absolute_error][crate::model::model::RegressionMetrics::median_absolute_error].
        pub fn set_median_absolute_error<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.median_absolute_error = v.into();
            self
        }

        /// Sets the value of [r_squared][crate::model::model::RegressionMetrics::r_squared].
        pub fn set_r_squared<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.r_squared = v.into();
            self
        }
    }

    impl wkt::message::Message for RegressionMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.RegressionMetrics"
        }
    }

    /// Aggregate metrics for classification/classifier models. For multi-class
    /// models, the metrics are either macro-averaged or micro-averaged. When
    /// macro-averaged, the metrics are calculated for each label and then an
    /// unweighted average is taken of those values. When micro-averaged, the
    /// metric is calculated globally by counting the total number of correctly
    /// predicted rows.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AggregateClassificationMetrics {
        /// Precision is the fraction of actual positive predictions that had
        /// positive actual labels. For multiclass this is a macro-averaged
        /// metric treating each class as a binary classifier.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub precision: std::option::Option<wkt::DoubleValue>,

        /// Recall is the fraction of actual positive labels that were given a
        /// positive prediction. For multiclass this is a macro-averaged metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub recall: std::option::Option<wkt::DoubleValue>,

        /// Accuracy is the fraction of predictions given the correct label. For
        /// multiclass this is a micro-averaged metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub accuracy: std::option::Option<wkt::DoubleValue>,

        /// Threshold at which the metrics are computed. For binary
        /// classification models this is the positive class threshold.
        /// For multi-class classification models this is the confidence
        /// threshold.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threshold: std::option::Option<wkt::DoubleValue>,

        /// The F1 score is an average of recall and precision. For multiclass
        /// this is a macro-averaged metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub f1_score: std::option::Option<wkt::DoubleValue>,

        /// Logarithmic Loss. For multiclass this is a macro-averaged metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub log_loss: std::option::Option<wkt::DoubleValue>,

        /// Area Under a ROC Curve. For multiclass this is a macro-averaged
        /// metric.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub roc_auc: std::option::Option<wkt::DoubleValue>,
    }

    impl AggregateClassificationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [precision][crate::model::model::AggregateClassificationMetrics::precision].
        pub fn set_precision<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.precision = v.into();
            self
        }

        /// Sets the value of [recall][crate::model::model::AggregateClassificationMetrics::recall].
        pub fn set_recall<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.recall = v.into();
            self
        }

        /// Sets the value of [accuracy][crate::model::model::AggregateClassificationMetrics::accuracy].
        pub fn set_accuracy<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.accuracy = v.into();
            self
        }

        /// Sets the value of [threshold][crate::model::model::AggregateClassificationMetrics::threshold].
        pub fn set_threshold<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.threshold = v.into();
            self
        }

        /// Sets the value of [f1_score][crate::model::model::AggregateClassificationMetrics::f1_score].
        pub fn set_f1_score<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.f1_score = v.into();
            self
        }

        /// Sets the value of [log_loss][crate::model::model::AggregateClassificationMetrics::log_loss].
        pub fn set_log_loss<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.log_loss = v.into();
            self
        }

        /// Sets the value of [roc_auc][crate::model::model::AggregateClassificationMetrics::roc_auc].
        pub fn set_roc_auc<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.roc_auc = v.into();
            self
        }
    }

    impl wkt::message::Message for AggregateClassificationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.AggregateClassificationMetrics"
        }
    }

    /// Evaluation metrics for binary classification/classifier models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BinaryClassificationMetrics {
        /// Aggregate classification metrics.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub aggregate_classification_metrics:
            std::option::Option<crate::model::model::AggregateClassificationMetrics>,

        /// Binary confusion matrix at multiple thresholds.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub binary_confusion_matrix_list: std::vec::Vec<
            crate::model::model::binary_classification_metrics::BinaryConfusionMatrix,
        >,

        /// Label representing the positive class.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub positive_label: std::string::String,

        /// Label representing the negative class.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub negative_label: std::string::String,
    }

    impl BinaryClassificationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [aggregate_classification_metrics][crate::model::model::BinaryClassificationMetrics::aggregate_classification_metrics].
        pub fn set_aggregate_classification_metrics<
            T: std::convert::Into<
                std::option::Option<crate::model::model::AggregateClassificationMetrics>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregate_classification_metrics = v.into();
            self
        }

        /// Sets the value of [positive_label][crate::model::model::BinaryClassificationMetrics::positive_label].
        pub fn set_positive_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.positive_label = v.into();
            self
        }

        /// Sets the value of [negative_label][crate::model::model::BinaryClassificationMetrics::negative_label].
        pub fn set_negative_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.negative_label = v.into();
            self
        }

        /// Sets the value of [binary_confusion_matrix_list][crate::model::model::BinaryClassificationMetrics::binary_confusion_matrix_list].
        pub fn set_binary_confusion_matrix_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::model::binary_classification_metrics::BinaryConfusionMatrix,
            >,
        {
            use std::iter::Iterator;
            self.binary_confusion_matrix_list = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BinaryClassificationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.BinaryClassificationMetrics"
        }
    }

    /// Defines additional types related to BinaryClassificationMetrics
    pub mod binary_classification_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Confusion matrix for binary classification models.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BinaryConfusionMatrix {
            /// Threshold value used when computing each of the following metric.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub positive_class_threshold: std::option::Option<wkt::DoubleValue>,

            /// Number of true samples predicted as true.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub true_positives: std::option::Option<wkt::Int64Value>,

            /// Number of false samples predicted as true.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub false_positives: std::option::Option<wkt::Int64Value>,

            /// Number of true samples predicted as false.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub true_negatives: std::option::Option<wkt::Int64Value>,

            /// Number of false samples predicted as false.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub false_negatives: std::option::Option<wkt::Int64Value>,

            /// The fraction of actual positive predictions that had positive actual
            /// labels.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub precision: std::option::Option<wkt::DoubleValue>,

            /// The fraction of actual positive labels that were given a positive
            /// prediction.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub recall: std::option::Option<wkt::DoubleValue>,

            /// The equally weighted average of recall and precision.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub f1_score: std::option::Option<wkt::DoubleValue>,

            /// The fraction of predictions given the correct label.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub accuracy: std::option::Option<wkt::DoubleValue>,
        }

        impl BinaryConfusionMatrix {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [positive_class_threshold][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::positive_class_threshold].
            pub fn set_positive_class_threshold<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.positive_class_threshold = v.into();
                self
            }

            /// Sets the value of [true_positives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::true_positives].
            pub fn set_true_positives<
                T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.true_positives = v.into();
                self
            }

            /// Sets the value of [false_positives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::false_positives].
            pub fn set_false_positives<
                T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.false_positives = v.into();
                self
            }

            /// Sets the value of [true_negatives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::true_negatives].
            pub fn set_true_negatives<
                T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.true_negatives = v.into();
                self
            }

            /// Sets the value of [false_negatives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::false_negatives].
            pub fn set_false_negatives<
                T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.false_negatives = v.into();
                self
            }

            /// Sets the value of [precision][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::precision].
            pub fn set_precision<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.precision = v.into();
                self
            }

            /// Sets the value of [recall][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::recall].
            pub fn set_recall<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.recall = v.into();
                self
            }

            /// Sets the value of [f1_score][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::f1_score].
            pub fn set_f1_score<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.f1_score = v.into();
                self
            }

            /// Sets the value of [accuracy][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::accuracy].
            pub fn set_accuracy<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.accuracy = v.into();
                self
            }
        }

        impl wkt::message::Message for BinaryConfusionMatrix {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.BinaryClassificationMetrics.BinaryConfusionMatrix"
            }
        }
    }

    /// Evaluation metrics for multi-class classification/classifier models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiClassClassificationMetrics {
        /// Aggregate classification metrics.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub aggregate_classification_metrics:
            std::option::Option<crate::model::model::AggregateClassificationMetrics>,

        /// Confusion matrix at different thresholds.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub confusion_matrix_list:
            std::vec::Vec<crate::model::model::multi_class_classification_metrics::ConfusionMatrix>,
    }

    impl MultiClassClassificationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [aggregate_classification_metrics][crate::model::model::MultiClassClassificationMetrics::aggregate_classification_metrics].
        pub fn set_aggregate_classification_metrics<
            T: std::convert::Into<
                std::option::Option<crate::model::model::AggregateClassificationMetrics>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregate_classification_metrics = v.into();
            self
        }

        /// Sets the value of [confusion_matrix_list][crate::model::model::MultiClassClassificationMetrics::confusion_matrix_list].
        pub fn set_confusion_matrix_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::model::multi_class_classification_metrics::ConfusionMatrix,
            >,
        {
            use std::iter::Iterator;
            self.confusion_matrix_list = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MultiClassClassificationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics"
        }
    }

    /// Defines additional types related to MultiClassClassificationMetrics
    pub mod multi_class_classification_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Confusion matrix for multi-class classification models.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ConfusionMatrix {
            /// Confidence threshold used when computing the entries of the
            /// confusion matrix.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub confidence_threshold: std::option::Option<wkt::DoubleValue>,

            /// One row per actual label.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub rows: std::vec::Vec<
                crate::model::model::multi_class_classification_metrics::confusion_matrix::Row,
            >,
        }

        impl ConfusionMatrix {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [confidence_threshold][crate::model::model::multi_class_classification_metrics::ConfusionMatrix::confidence_threshold].
            pub fn set_confidence_threshold<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.confidence_threshold = v.into();
                self
            }

            /// Sets the value of [rows][crate::model::model::multi_class_classification_metrics::ConfusionMatrix::rows].
            pub fn set_rows<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::model::multi_class_classification_metrics::confusion_matrix::Row,
                >,
            {
                use std::iter::Iterator;
                self.rows = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ConfusionMatrix {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics.ConfusionMatrix"
            }
        }

        /// Defines additional types related to ConfusionMatrix
        pub mod confusion_matrix {
            #[allow(unused_imports)]
            use super::*;

            /// A single entry in the confusion matrix.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Entry {
                /// The predicted label. For confidence_threshold > 0, we will
                /// also add an entry indicating the number of items under the
                /// confidence threshold.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub predicted_label: std::string::String,

                /// Number of items being predicted as this label.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
                pub item_count: std::option::Option<wkt::Int64Value>,
            }

            impl Entry {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [predicted_label][crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry::predicted_label].
                pub fn set_predicted_label<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.predicted_label = v.into();
                    self
                }

                /// Sets the value of [item_count][crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry::item_count].
                pub fn set_item_count<
                    T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.item_count = v.into();
                    self
                }
            }

            impl wkt::message::Message for Entry {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics.ConfusionMatrix.Entry"
                }
            }

            /// A single row in the confusion matrix.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Row {

                /// The original label of this row.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub actual_label: std::string::String,

                /// Info describing predicted label distribution.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub entries: std::vec::Vec<crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry>,
            }

            impl Row {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [actual_label][crate::model::model::multi_class_classification_metrics::confusion_matrix::Row::actual_label].
                pub fn set_actual_label<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actual_label = v.into();
                    self
                }

                /// Sets the value of [entries][crate::model::model::multi_class_classification_metrics::confusion_matrix::Row::entries].
                pub fn set_entries<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry>
                {
                    use std::iter::Iterator;
                    self.entries = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Row {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics.ConfusionMatrix.Row"
                }
            }
        }
    }

    /// Evaluation metrics for clustering models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClusteringMetrics {
        /// Davies-Bouldin index.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub davies_bouldin_index: std::option::Option<wkt::DoubleValue>,

        /// Mean of squared distances between each sample to its cluster centroid.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mean_squared_distance: std::option::Option<wkt::DoubleValue>,

        /// Information for all clusters.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub clusters: std::vec::Vec<crate::model::model::clustering_metrics::Cluster>,
    }

    impl ClusteringMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [davies_bouldin_index][crate::model::model::ClusteringMetrics::davies_bouldin_index].
        pub fn set_davies_bouldin_index<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.davies_bouldin_index = v.into();
            self
        }

        /// Sets the value of [mean_squared_distance][crate::model::model::ClusteringMetrics::mean_squared_distance].
        pub fn set_mean_squared_distance<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mean_squared_distance = v.into();
            self
        }

        /// Sets the value of [clusters][crate::model::model::ClusteringMetrics::clusters].
        pub fn set_clusters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::clustering_metrics::Cluster>,
        {
            use std::iter::Iterator;
            self.clusters = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ClusteringMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics"
        }
    }

    /// Defines additional types related to ClusteringMetrics
    pub mod clustering_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Message containing the information about one cluster.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Cluster {
            /// Centroid id.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub centroid_id: i64,

            /// Values of highly variant features for this cluster.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub feature_values:
                std::vec::Vec<crate::model::model::clustering_metrics::cluster::FeatureValue>,

            /// Count of training data rows that were assigned to this cluster.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub count: std::option::Option<wkt::Int64Value>,
        }

        impl Cluster {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [centroid_id][crate::model::model::clustering_metrics::Cluster::centroid_id].
            pub fn set_centroid_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.centroid_id = v.into();
                self
            }

            /// Sets the value of [count][crate::model::model::clustering_metrics::Cluster::count].
            pub fn set_count<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
                mut self,
                v: T,
            ) -> Self {
                self.count = v.into();
                self
            }

            /// Sets the value of [feature_values][crate::model::model::clustering_metrics::Cluster::feature_values].
            pub fn set_feature_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::model::clustering_metrics::cluster::FeatureValue,
                >,
            {
                use std::iter::Iterator;
                self.feature_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Cluster {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster"
            }
        }

        /// Defines additional types related to Cluster
        pub mod cluster {
            #[allow(unused_imports)]
            use super::*;

            /// Representative value of a single feature within the cluster.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct FeatureValue {
                /// The feature column name.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub feature_column: std::string::String,

                /// Value.
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub value: std::option::Option<
                    crate::model::model::clustering_metrics::cluster::feature_value::Value,
                >,
            }

            impl FeatureValue {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [feature_column][crate::model::model::clustering_metrics::cluster::FeatureValue::feature_column].
                pub fn set_feature_column<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.feature_column = v.into();
                    self
                }

                /// Sets the value of `value`.
                pub fn set_value<
                    T: std::convert::Into<
                        std::option::Option<
                            crate::model::model::clustering_metrics::cluster::feature_value::Value,
                        >,
                    >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.value = v.into();
                    self
                }

                /// The value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// if it holds a `NumericalValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_numerical_value(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<wkt::DoubleValue>> {
                    #[allow(unreachable_patterns)]
                    self.value.as_ref().and_then(|v| match v {
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::NumericalValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// The value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// if it holds a `CategoricalValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn get_categorical_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>>{
                    #[allow(unreachable_patterns)]
                    self.value.as_ref().and_then(|v| match v {
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::CategoricalValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// to hold a `NumericalValue`.
                ///
                /// Note that all the setters affecting `value` are
                /// mutually exclusive.
                pub fn set_numerical_value<
                    T: std::convert::Into<std::boxed::Box<wkt::DoubleValue>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.value = std::option::Option::Some(
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::NumericalValue(
                            v.into()
                        )
                    );
                    self
                }

                /// Sets the value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// to hold a `CategoricalValue`.
                ///
                /// Note that all the setters affecting `value` are
                /// mutually exclusive.
                pub fn set_categorical_value<T: std::convert::Into<std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>>>(mut self, v: T) -> Self{
                    self.value = std::option::Option::Some(
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::CategoricalValue(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for FeatureValue {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue"
                }
            }

            /// Defines additional types related to FeatureValue
            pub mod feature_value {
                #[allow(unused_imports)]
                use super::*;

                /// Representative value of a categorical feature.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct CategoricalValue {

                    /// Counts of all categories for the categorical feature. If there are
                    /// more than ten categories, we return top ten (by count) and return
                    /// one more CategoryCount with category "_OTHER_" and count as
                    /// aggregate counts of remaining categories.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub category_counts: std::vec::Vec<crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount>,
                }

                impl CategoricalValue {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [category_counts][crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue::category_counts].
                    pub fn set_category_counts<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount>
                    {
                        use std::iter::Iterator;
                        self.category_counts = v.into_iter().map(|i| i.into()).collect();
                        self
                    }
                }

                impl wkt::message::Message for CategoricalValue {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue"
                    }
                }

                /// Defines additional types related to CategoricalValue
                pub mod categorical_value {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Represents the count of a single category within the cluster.
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct CategoryCount {
                        /// The name of category.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub category: std::string::String,

                        /// The count of training samples matching the category within the
                        /// cluster.
                        #[serde(skip_serializing_if = "std::option::Option::is_none")]
                        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
                        pub count: std::option::Option<wkt::Int64Value>,
                    }

                    impl CategoryCount {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [category][crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount::category].
                        pub fn set_category<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.category = v.into();
                            self
                        }

                        /// Sets the value of [count][crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount::count].
                        pub fn set_count<
                            T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
                        >(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.count = v.into();
                            self
                        }
                    }

                    impl wkt::message::Message for CategoryCount {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue.CategoryCount"
                        }
                    }
                }

                /// Value.
                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Value {
                    /// The numerical feature value. This is the centroid value for this
                    /// feature.
                    NumericalValue(std::boxed::Box<wkt::DoubleValue>),
                    /// The categorical feature value.
                    CategoricalValue(std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>),
                }
            }
        }
    }

    /// Evaluation metrics used by weighted-ALS models specified by
    /// feedback_type=implicit.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RankingMetrics {
        /// Calculates a precision per user for all the items by ranking them and
        /// then averages all the precisions across all the users.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mean_average_precision: std::option::Option<wkt::DoubleValue>,

        /// Similar to the mean squared error computed in regression and explicit
        /// recommendation models except instead of computing the rating directly,
        /// the output from evaluate is computed against a preference which is 1 or 0
        /// depending on if the rating exists or not.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mean_squared_error: std::option::Option<wkt::DoubleValue>,

        /// A metric to determine the goodness of a ranking calculated from the
        /// predicted confidence by comparing it to an ideal rank measured by the
        /// original ratings.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub normalized_discounted_cumulative_gain: std::option::Option<wkt::DoubleValue>,

        /// Determines the goodness of a ranking by computing the percentile rank
        /// from the predicted confidence and dividing it by the original rank.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub average_rank: std::option::Option<wkt::DoubleValue>,
    }

    impl RankingMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mean_average_precision][crate::model::model::RankingMetrics::mean_average_precision].
        pub fn set_mean_average_precision<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mean_average_precision = v.into();
            self
        }

        /// Sets the value of [mean_squared_error][crate::model::model::RankingMetrics::mean_squared_error].
        pub fn set_mean_squared_error<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mean_squared_error = v.into();
            self
        }

        /// Sets the value of [normalized_discounted_cumulative_gain][crate::model::model::RankingMetrics::normalized_discounted_cumulative_gain].
        pub fn set_normalized_discounted_cumulative_gain<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.normalized_discounted_cumulative_gain = v.into();
            self
        }

        /// Sets the value of [average_rank][crate::model::model::RankingMetrics::average_rank].
        pub fn set_average_rank<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.average_rank = v.into();
            self
        }
    }

    impl wkt::message::Message for RankingMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.RankingMetrics"
        }
    }

    /// Model evaluation metrics for ARIMA forecasting models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArimaForecastingMetrics {
        /// Repeated as there can be many metric sets (one for each model) in
        /// auto-arima and the large-scale case.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub arima_single_model_forecasting_metrics: std::vec::Vec<
            crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics,
        >,
    }

    impl ArimaForecastingMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [arima_single_model_forecasting_metrics][crate::model::model::ArimaForecastingMetrics::arima_single_model_forecasting_metrics].
        pub fn set_arima_single_model_forecasting_metrics<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics,
            >,
        {
            use std::iter::Iterator;
            self.arima_single_model_forecasting_metrics = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ArimaForecastingMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaForecastingMetrics"
        }
    }

    /// Defines additional types related to ArimaForecastingMetrics
    pub mod arima_forecasting_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Model evaluation metrics for a single ARIMA forecasting model.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ArimaSingleModelForecastingMetrics {
            /// Non-seasonal order.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub non_seasonal_order: std::option::Option<crate::model::model::ArimaOrder>,

            /// Arima fitting metrics.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub arima_fitting_metrics:
                std::option::Option<crate::model::model::ArimaFittingMetrics>,

            /// Is arima model fitted with drift or not. It is always false when d
            /// is not 1.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub has_drift: std::option::Option<wkt::BoolValue>,

            /// The time_series_id value for this time series. It will be one of
            /// the unique values from the time_series_id_column specified during
            /// ARIMA model training. Only present when time_series_id_column
            /// training option was used.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub time_series_id: std::string::String,

            /// The tuple of time_series_ids identifying this time series. It will
            /// be one of the unique tuples of values present in the
            /// time_series_id_columns specified during ARIMA model training. Only
            /// present when time_series_id_columns training option was used and
            /// the order of values here are same as the order of
            /// time_series_id_columns.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub time_series_ids: std::vec::Vec<std::string::String>,

            /// Seasonal periods. Repeated because multiple periods are supported
            /// for one time series.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub seasonal_periods:
                std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>,

            /// If true, holiday_effect is a part of time series decomposition result.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub has_holiday_effect: std::option::Option<wkt::BoolValue>,

            /// If true, spikes_and_dips is a part of time series decomposition result.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub has_spikes_and_dips: std::option::Option<wkt::BoolValue>,

            /// If true, step_changes is a part of time series decomposition result.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub has_step_changes: std::option::Option<wkt::BoolValue>,
        }

        impl ArimaSingleModelForecastingMetrics {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [non_seasonal_order][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::non_seasonal_order].
            pub fn set_non_seasonal_order<
                T: std::convert::Into<std::option::Option<crate::model::model::ArimaOrder>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.non_seasonal_order = v.into();
                self
            }

            /// Sets the value of [arima_fitting_metrics][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::arima_fitting_metrics].
            pub fn set_arima_fitting_metrics<
                T: std::convert::Into<std::option::Option<crate::model::model::ArimaFittingMetrics>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.arima_fitting_metrics = v.into();
                self
            }

            /// Sets the value of [has_drift][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_drift].
            pub fn set_has_drift<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.has_drift = v.into();
                self
            }

            /// Sets the value of [time_series_id][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::time_series_id].
            pub fn set_time_series_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_id = v.into();
                self
            }

            /// Sets the value of [has_holiday_effect][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_holiday_effect].
            pub fn set_has_holiday_effect<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.has_holiday_effect = v.into();
                self
            }

            /// Sets the value of [has_spikes_and_dips][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_spikes_and_dips].
            pub fn set_has_spikes_and_dips<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.has_spikes_and_dips = v.into();
                self
            }

            /// Sets the value of [has_step_changes][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_step_changes].
            pub fn set_has_step_changes<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.has_step_changes = v.into();
                self
            }

            /// Sets the value of [time_series_ids][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::time_series_ids].
            pub fn set_time_series_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.time_series_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [seasonal_periods][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::seasonal_periods].
            pub fn set_seasonal_periods<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::model::seasonal_period::SeasonalPeriodType>,
            {
                use std::iter::Iterator;
                self.seasonal_periods = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ArimaSingleModelForecastingMetrics {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaForecastingMetrics.ArimaSingleModelForecastingMetrics"
            }
        }
    }

    /// Model evaluation metrics for dimensionality reduction models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DimensionalityReductionMetrics {
        /// Total percentage of variance explained by the selected principal
        /// components.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub total_explained_variance_ratio: std::option::Option<wkt::DoubleValue>,
    }

    impl DimensionalityReductionMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_explained_variance_ratio][crate::model::model::DimensionalityReductionMetrics::total_explained_variance_ratio].
        pub fn set_total_explained_variance_ratio<
            T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.total_explained_variance_ratio = v.into();
            self
        }
    }

    impl wkt::message::Message for DimensionalityReductionMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.DimensionalityReductionMetrics"
        }
    }

    /// Evaluation metrics of a model. These are either computed on all training
    /// data or just the eval data based on whether eval data was used during
    /// training. These are not present for imported models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EvaluationMetrics {
        /// Metrics.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub metrics: std::option::Option<crate::model::model::evaluation_metrics::Metrics>,
    }

    impl EvaluationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `metrics`.
        pub fn set_metrics<
            T: std::convert::Into<
                std::option::Option<crate::model::model::evaluation_metrics::Metrics>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = v.into();
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `RegressionMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_regression_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::RegressionMetrics>> {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::RegressionMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `BinaryClassificationMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_binary_classification_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::BinaryClassificationMetrics>>
        {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::BinaryClassificationMetrics(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `MultiClassClassificationMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_multi_class_classification_metrics(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>,
        > {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::MultiClassClassificationMetrics(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `ClusteringMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_clustering_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::ClusteringMetrics>> {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::ClusteringMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `RankingMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_ranking_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::RankingMetrics>> {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::RankingMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `ArimaForecastingMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_arima_forecasting_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::ArimaForecastingMetrics>>
        {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::ArimaForecastingMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `DimensionalityReductionMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_dimensionality_reduction_metrics(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>,
        > {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::DimensionalityReductionMetrics(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `RegressionMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_regression_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::RegressionMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::RegressionMetrics(v.into()),
            );
            self
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `BinaryClassificationMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_binary_classification_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::BinaryClassificationMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::BinaryClassificationMetrics(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `MultiClassClassificationMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_multi_class_classification_metrics<
            T: std::convert::Into<
                std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::MultiClassClassificationMetrics(
                    v.into(),
                ),
            );
            self
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `ClusteringMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_clustering_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::ClusteringMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::ClusteringMetrics(v.into()),
            );
            self
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `RankingMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_ranking_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::RankingMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::RankingMetrics(v.into()),
            );
            self
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `ArimaForecastingMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_arima_forecasting_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::ArimaForecastingMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::ArimaForecastingMetrics(v.into()),
            );
            self
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `DimensionalityReductionMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_dimensionality_reduction_metrics<
            T: std::convert::Into<
                std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::DimensionalityReductionMetrics(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for EvaluationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.EvaluationMetrics"
        }
    }

    /// Defines additional types related to EvaluationMetrics
    pub mod evaluation_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Metrics.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Metrics {
            /// Populated for regression models and explicit feedback type matrix
            /// factorization models.
            RegressionMetrics(std::boxed::Box<crate::model::model::RegressionMetrics>),
            /// Populated for binary classification/classifier models.
            BinaryClassificationMetrics(
                std::boxed::Box<crate::model::model::BinaryClassificationMetrics>,
            ),
            /// Populated for multi-class classification/classifier models.
            MultiClassClassificationMetrics(
                std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>,
            ),
            /// Populated for clustering models.
            ClusteringMetrics(std::boxed::Box<crate::model::model::ClusteringMetrics>),
            /// Populated for implicit feedback type matrix factorization models.
            RankingMetrics(std::boxed::Box<crate::model::model::RankingMetrics>),
            /// Populated for ARIMA models.
            ArimaForecastingMetrics(std::boxed::Box<crate::model::model::ArimaForecastingMetrics>),
            /// Evaluation metrics when the model is a dimensionality reduction model,
            /// which currently includes PCA.
            DimensionalityReductionMetrics(
                std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>,
            ),
        }
    }

    /// Data split result. This contains references to the training and evaluation
    /// data tables that were used to train the model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataSplitResult {
        /// Table reference of the training data after split.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub training_table: std::option::Option<crate::model::TableReference>,

        /// Table reference of the evaluation data after split.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub evaluation_table: std::option::Option<crate::model::TableReference>,

        /// Table reference of the test data after split.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub test_table: std::option::Option<crate::model::TableReference>,
    }

    impl DataSplitResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_table][crate::model::model::DataSplitResult::training_table].
        pub fn set_training_table<
            T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.training_table = v.into();
            self
        }

        /// Sets the value of [evaluation_table][crate::model::model::DataSplitResult::evaluation_table].
        pub fn set_evaluation_table<
            T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.evaluation_table = v.into();
            self
        }

        /// Sets the value of [test_table][crate::model::model::DataSplitResult::test_table].
        pub fn set_test_table<
            T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.test_table = v.into();
            self
        }
    }

    impl wkt::message::Message for DataSplitResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.DataSplitResult"
        }
    }

    /// Arima order, can be used for both non-seasonal and seasonal parts.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArimaOrder {
        /// Order of the autoregressive part.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub p: std::option::Option<wkt::Int64Value>,

        /// Order of the differencing part.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub d: std::option::Option<wkt::Int64Value>,

        /// Order of the moving-average part.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub q: std::option::Option<wkt::Int64Value>,
    }

    impl ArimaOrder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [p][crate::model::model::ArimaOrder::p].
        pub fn set_p<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.p = v.into();
            self
        }

        /// Sets the value of [d][crate::model::model::ArimaOrder::d].
        pub fn set_d<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.d = v.into();
            self
        }

        /// Sets the value of [q][crate::model::model::ArimaOrder::q].
        pub fn set_q<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.q = v.into();
            self
        }
    }

    impl wkt::message::Message for ArimaOrder {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaOrder"
        }
    }

    /// ARIMA model fitting metrics.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ArimaFittingMetrics {
        /// Log-likelihood.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub log_likelihood: std::option::Option<wkt::DoubleValue>,

        /// AIC.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub aic: std::option::Option<wkt::DoubleValue>,

        /// Variance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub variance: std::option::Option<wkt::DoubleValue>,
    }

    impl ArimaFittingMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [log_likelihood][crate::model::model::ArimaFittingMetrics::log_likelihood].
        pub fn set_log_likelihood<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.log_likelihood = v.into();
            self
        }

        /// Sets the value of [aic][crate::model::model::ArimaFittingMetrics::aic].
        pub fn set_aic<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.aic = v.into();
            self
        }

        /// Sets the value of [variance][crate::model::model::ArimaFittingMetrics::variance].
        pub fn set_variance<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.variance = v.into();
            self
        }
    }

    impl wkt::message::Message for ArimaFittingMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaFittingMetrics"
        }
    }

    /// Global explanations containing the top most important features
    /// after training.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GlobalExplanation {
        /// A list of the top global explanations. Sorted by absolute value of
        /// attribution in descending order.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub explanations: std::vec::Vec<crate::model::model::global_explanation::Explanation>,

        /// Class label for this set of global explanations. Will be empty/null for
        /// binary logistic and linear regression models. Sorted alphabetically in
        /// descending order.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub class_label: std::string::String,
    }

    impl GlobalExplanation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [class_label][crate::model::model::GlobalExplanation::class_label].
        pub fn set_class_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.class_label = v.into();
            self
        }

        /// Sets the value of [explanations][crate::model::model::GlobalExplanation::explanations].
        pub fn set_explanations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::global_explanation::Explanation>,
        {
            use std::iter::Iterator;
            self.explanations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GlobalExplanation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.GlobalExplanation"
        }
    }

    /// Defines additional types related to GlobalExplanation
    pub mod global_explanation {
        #[allow(unused_imports)]
        use super::*;

        /// Explanation for a single feature.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Explanation {
            /// The full feature name. For non-numerical features, will be formatted
            /// like `<column_name>.<encoded_feature_name>`. Overall size of feature
            /// name will always be truncated to first 120 characters.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub feature_name: std::string::String,

            /// Attribution of feature.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub attribution: std::option::Option<wkt::DoubleValue>,
        }

        impl Explanation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [feature_name][crate::model::model::global_explanation::Explanation::feature_name].
            pub fn set_feature_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.feature_name = v.into();
                self
            }

            /// Sets the value of [attribution][crate::model::model::global_explanation::Explanation::attribution].
            pub fn set_attribution<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.attribution = v.into();
                self
            }
        }

        impl wkt::message::Message for Explanation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.GlobalExplanation.Explanation"
            }
        }
    }

    /// Encoding methods for categorical features.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CategoryEncodingMethod {}

    impl CategoryEncodingMethod {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CategoryEncodingMethod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.CategoryEncodingMethod"
        }
    }

    /// Defines additional types related to CategoryEncodingMethod
    pub mod category_encoding_method {
        #[allow(unused_imports)]
        use super::*;

        /// Supported encoding methods for categorical features.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct EncodingMethod(i32);

        impl EncodingMethod {
            /// Unspecified encoding method.
            pub const ENCODING_METHOD_UNSPECIFIED: EncodingMethod = EncodingMethod::new(0);

            /// Applies one-hot encoding.
            pub const ONE_HOT_ENCODING: EncodingMethod = EncodingMethod::new(1);

            /// Applies label encoding.
            pub const LABEL_ENCODING: EncodingMethod = EncodingMethod::new(2);

            /// Applies dummy encoding.
            pub const DUMMY_ENCODING: EncodingMethod = EncodingMethod::new(3);

            /// Creates a new EncodingMethod instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("ENCODING_METHOD_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("ONE_HOT_ENCODING"),
                    2 => std::borrow::Cow::Borrowed("LABEL_ENCODING"),
                    3 => std::borrow::Cow::Borrowed("DUMMY_ENCODING"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "ENCODING_METHOD_UNSPECIFIED" => {
                        std::option::Option::Some(Self::ENCODING_METHOD_UNSPECIFIED)
                    }
                    "ONE_HOT_ENCODING" => std::option::Option::Some(Self::ONE_HOT_ENCODING),
                    "LABEL_ENCODING" => std::option::Option::Some(Self::LABEL_ENCODING),
                    "DUMMY_ENCODING" => std::option::Option::Some(Self::DUMMY_ENCODING),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for EncodingMethod {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for EncodingMethod {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// PCA solver options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PcaSolverOptionEnums {}

    impl PcaSolverOptionEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PcaSolverOptionEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.PcaSolverOptionEnums"
        }
    }

    /// Defines additional types related to PcaSolverOptionEnums
    pub mod pca_solver_option_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Enums for supported PCA solvers.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct PcaSolver(i32);

        impl PcaSolver {
            /// Default value.
            pub const UNSPECIFIED: PcaSolver = PcaSolver::new(0);

            /// Full eigen-decoposition.
            pub const FULL: PcaSolver = PcaSolver::new(1);

            /// Randomized SVD.
            pub const RANDOMIZED: PcaSolver = PcaSolver::new(2);

            /// Auto.
            pub const AUTO: PcaSolver = PcaSolver::new(3);

            /// Creates a new PcaSolver instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("FULL"),
                    2 => std::borrow::Cow::Borrowed("RANDOMIZED"),
                    3 => std::borrow::Cow::Borrowed("AUTO"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                    "FULL" => std::option::Option::Some(Self::FULL),
                    "RANDOMIZED" => std::option::Option::Some(Self::RANDOMIZED),
                    "AUTO" => std::option::Option::Some(Self::AUTO),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for PcaSolver {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for PcaSolver {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Model registry options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ModelRegistryOptionEnums {}

    impl ModelRegistryOptionEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ModelRegistryOptionEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ModelRegistryOptionEnums"
        }
    }

    /// Defines additional types related to ModelRegistryOptionEnums
    pub mod model_registry_option_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Enums for supported model registries.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ModelRegistry(i32);

        impl ModelRegistry {
            /// Default value.
            pub const MODEL_REGISTRY_UNSPECIFIED: ModelRegistry = ModelRegistry::new(0);

            /// Vertex AI.
            pub const VERTEX_AI: ModelRegistry = ModelRegistry::new(1);

            /// Creates a new ModelRegistry instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("MODEL_REGISTRY_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("VERTEX_AI"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "MODEL_REGISTRY_UNSPECIFIED" => {
                        std::option::Option::Some(Self::MODEL_REGISTRY_UNSPECIFIED)
                    }
                    "VERTEX_AI" => std::option::Option::Some(Self::VERTEX_AI),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for ModelRegistry {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for ModelRegistry {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Information about a single training query run for the model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrainingRun {
        /// Output only. Options that were used for this training run, includes
        /// user specified and default options that were used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub training_options:
            std::option::Option<crate::model::model::training_run::TrainingOptions>,

        /// Output only. The start time of this training run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Output only. Output of each iteration run, results.size() <=
        /// max_iterations.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub results: std::vec::Vec<crate::model::model::training_run::IterationResult>,

        /// Output only. The evaluation metrics over training/eval data that were
        /// computed at the end of training.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub evaluation_metrics: std::option::Option<crate::model::model::EvaluationMetrics>,

        /// Output only. Data split result of the training run. Only set when the
        /// input data is actually split.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub data_split_result: std::option::Option<crate::model::model::DataSplitResult>,

        /// Output only. Global explanation contains the explanation of top features
        /// on the model level. Applies to both regression and classification models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub model_level_global_explanation:
            std::option::Option<crate::model::model::GlobalExplanation>,

        /// Output only. Global explanation contains the explanation of top features
        /// on the class level. Applies to classification models only.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub class_level_global_explanations: std::vec::Vec<crate::model::model::GlobalExplanation>,

        /// The model id in the [Vertex AI Model
        /// Registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction)
        /// for this training run.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub vertex_ai_model_id: std::string::String,

        /// Output only. The model version in the [Vertex AI Model
        /// Registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction)
        /// for this training run.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub vertex_ai_model_version: std::string::String,
    }

    impl TrainingRun {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_options][crate::model::model::TrainingRun::training_options].
        pub fn set_training_options<
            T: std::convert::Into<
                std::option::Option<crate::model::model::training_run::TrainingOptions>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.training_options = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::model::TrainingRun::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [evaluation_metrics][crate::model::model::TrainingRun::evaluation_metrics].
        pub fn set_evaluation_metrics<
            T: std::convert::Into<std::option::Option<crate::model::model::EvaluationMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.evaluation_metrics = v.into();
            self
        }

        /// Sets the value of [data_split_result][crate::model::model::TrainingRun::data_split_result].
        pub fn set_data_split_result<
            T: std::convert::Into<std::option::Option<crate::model::model::DataSplitResult>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_split_result = v.into();
            self
        }

        /// Sets the value of [model_level_global_explanation][crate::model::model::TrainingRun::model_level_global_explanation].
        pub fn set_model_level_global_explanation<
            T: std::convert::Into<std::option::Option<crate::model::model::GlobalExplanation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_level_global_explanation = v.into();
            self
        }

        /// Sets the value of [vertex_ai_model_id][crate::model::model::TrainingRun::vertex_ai_model_id].
        pub fn set_vertex_ai_model_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vertex_ai_model_id = v.into();
            self
        }

        /// Sets the value of [vertex_ai_model_version][crate::model::model::TrainingRun::vertex_ai_model_version].
        pub fn set_vertex_ai_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vertex_ai_model_version = v.into();
            self
        }

        /// Sets the value of [results][crate::model::model::TrainingRun::results].
        pub fn set_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::training_run::IterationResult>,
        {
            use std::iter::Iterator;
            self.results = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [class_level_global_explanations][crate::model::model::TrainingRun::class_level_global_explanations].
        pub fn set_class_level_global_explanations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::GlobalExplanation>,
        {
            use std::iter::Iterator;
            self.class_level_global_explanations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TrainingRun {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun"
        }
    }

    /// Defines additional types related to TrainingRun
    pub mod training_run {
        #[allow(unused_imports)]
        use super::*;

        /// Options used in model training.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TrainingOptions {
            /// The maximum number of iterations in training. Used only for iterative
            /// training algorithms.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_iterations: i64,

            /// Type of loss function used during training run.
            pub loss_type: crate::model::model::LossType,

            /// Learning rate in training. Used only for iterative training algorithms.
            pub learn_rate: f64,

            /// L1 regularization coefficient.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub l1_regularization: std::option::Option<wkt::DoubleValue>,

            /// L2 regularization coefficient.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub l2_regularization: std::option::Option<wkt::DoubleValue>,

            /// When early_stop is true, stops training when accuracy improvement is
            /// less than 'min_relative_progress'. Used only for iterative training
            /// algorithms.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub min_relative_progress: std::option::Option<wkt::DoubleValue>,

            /// Whether to train a model from the last checkpoint.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub warm_start: std::option::Option<wkt::BoolValue>,

            /// Whether to stop early when the loss doesn't improve significantly
            /// any more (compared to min_relative_progress). Used only for iterative
            /// training algorithms.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub early_stop: std::option::Option<wkt::BoolValue>,

            /// Name of input label columns in training data.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub input_label_columns: std::vec::Vec<std::string::String>,

            /// The data split type for training and evaluation, e.g. RANDOM.
            pub data_split_method: crate::model::model::DataSplitMethod,

            /// The fraction of evaluation data over the whole input data. The rest
            /// of data will be used as training data. The format should be double.
            /// Accurate to two decimal places.
            /// Default value is 0.2.
            pub data_split_eval_fraction: f64,

            /// The column to split data with. This column won't be used as a
            /// feature.
            ///
            /// . When data_split_method is CUSTOM, the corresponding column should
            ///   be boolean. The rows with true value tag are eval data, and the false
            ///   are training data.
            /// . When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION
            ///   rows (from smallest to largest) in the corresponding column are used
            ///   as training data, and the rest are eval data. It respects the order
            ///   in Orderable data types:
            ///   <https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data_type_properties>
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub data_split_column: std::string::String,

            /// The strategy to determine learn rate for the current iteration.
            pub learn_rate_strategy: crate::model::model::LearnRateStrategy,

            /// Specifies the initial learning rate for the line search learn rate
            /// strategy.
            pub initial_learn_rate: f64,

            /// Weights associated with each label class, for rebalancing the
            /// training data. Only applicable for classification models.
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub label_class_weights: std::collections::HashMap<std::string::String, f64>,

            /// User column specified for matrix factorization models.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub user_column: std::string::String,

            /// Item column specified for matrix factorization models.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub item_column: std::string::String,

            /// Distance type for clustering models.
            pub distance_type: crate::model::model::DistanceType,

            /// Number of clusters for clustering models.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub num_clusters: i64,

            /// Google Cloud Storage URI from which the model was imported. Only
            /// applicable for imported models.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub model_uri: std::string::String,

            /// Optimization strategy for training linear regression models.
            pub optimization_strategy: crate::model::model::OptimizationStrategy,

            /// Hidden units for dnn models.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
            pub hidden_units: std::vec::Vec<i64>,

            /// Batch size for dnn models.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub batch_size: i64,

            /// Dropout probability for dnn models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub dropout: std::option::Option<wkt::DoubleValue>,

            /// Maximum depth of a tree for boosted tree models.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_tree_depth: i64,

            /// Subsample fraction of the training data to grow tree to prevent
            /// overfitting for boosted tree models.
            pub subsample: f64,

            /// Minimum split loss for boosted tree models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub min_split_loss: std::option::Option<wkt::DoubleValue>,

            /// Booster type for boosted tree models.
            pub booster_type: crate::model::model::boosted_tree_option_enums::BoosterType,

            /// Number of parallel trees constructed during each iteration for boosted
            /// tree models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub num_parallel_tree: std::option::Option<wkt::Int64Value>,

            /// Type of normalization algorithm for boosted tree models using
            /// dart booster.
            pub dart_normalize_type:
                crate::model::model::boosted_tree_option_enums::DartNormalizeType,

            /// Tree construction algorithm for boosted tree models.
            pub tree_method: crate::model::model::boosted_tree_option_enums::TreeMethod,

            /// Minimum sum of instance weight needed in a child for boosted tree
            /// models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub min_tree_child_weight: std::option::Option<wkt::Int64Value>,

            /// Subsample ratio of columns when constructing each tree for boosted tree
            /// models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub colsample_bytree: std::option::Option<wkt::DoubleValue>,

            /// Subsample ratio of columns for each level for boosted tree models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub colsample_bylevel: std::option::Option<wkt::DoubleValue>,

            /// Subsample ratio of columns for each node(split) for boosted tree
            /// models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub colsample_bynode: std::option::Option<wkt::DoubleValue>,

            /// Num factors specified for matrix factorization models.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub num_factors: i64,

            /// Feedback type that specifies which algorithm to run for matrix
            /// factorization.
            pub feedback_type: crate::model::model::FeedbackType,

            /// Hyperparameter for matrix factoration when implicit feedback type is
            /// specified.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub wals_alpha: std::option::Option<wkt::DoubleValue>,

            /// The method used to initialize the centroids for kmeans algorithm.
            pub kmeans_initialization_method:
                crate::model::model::kmeans_enums::KmeansInitializationMethod,

            /// The column used to provide the initial centroids for kmeans algorithm
            /// when kmeans_initialization_method is CUSTOM.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub kmeans_initialization_column: std::string::String,

            /// Column to be designated as time series timestamp for ARIMA model.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub time_series_timestamp_column: std::string::String,

            /// Column to be designated as time series data for ARIMA model.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub time_series_data_column: std::string::String,

            /// Whether to enable auto ARIMA or not.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub auto_arima: std::option::Option<wkt::BoolValue>,

            /// A specification of the non-seasonal part of the ARIMA model: the three
            /// components (p, d, q) are the AR order, the degree of differencing, and
            /// the MA order.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub non_seasonal_order: std::option::Option<crate::model::model::ArimaOrder>,

            /// The data frequency of a time series.
            pub data_frequency: crate::model::model::DataFrequency,

            /// Whether or not p-value test should be computed for this model. Only
            /// available for linear and logistic regression models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub calculate_p_values: std::option::Option<wkt::BoolValue>,

            /// Include drift when fitting an ARIMA model.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub include_drift: std::option::Option<wkt::BoolValue>,

            /// The geographical region based on which the holidays are considered in
            /// time series modeling. If a valid value is specified, then holiday
            /// effects modeling is enabled.
            pub holiday_region: crate::model::model::HolidayRegion,

            /// A list of geographical regions that are used for time series modeling.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub holiday_regions: std::vec::Vec<crate::model::model::HolidayRegion>,

            /// The time series id column that was used during ARIMA model training.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub time_series_id_column: std::string::String,

            /// The time series id columns that were used during ARIMA model training.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub time_series_id_columns: std::vec::Vec<std::string::String>,

            /// The forecast limit lower bound that was used during ARIMA model
            /// training with limits. To see more details of the algorithm:
            /// <https://otexts.com/fpp2/limits.html>
            pub forecast_limit_lower_bound: f64,

            /// The forecast limit upper bound that was used during ARIMA model
            /// training with limits.
            pub forecast_limit_upper_bound: f64,

            /// The number of periods ahead that need to be forecasted.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub horizon: i64,

            /// The max value of the sum of non-seasonal p and q.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub auto_arima_max_order: i64,

            /// The min value of the sum of non-seasonal p and q.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub auto_arima_min_order: i64,

            /// Number of trials to run this hyperparameter tuning job.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub num_trials: i64,

            /// Maximum number of trials to run in parallel.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_parallel_trials: i64,

            /// The target evaluation metrics to optimize the hyperparameters for.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub hparam_tuning_objectives:
                std::vec::Vec<crate::model::model::hparam_tuning_enums::HparamTuningObjective>,

            /// If true, perform decompose time series and save the results.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub decompose_time_series: std::option::Option<wkt::BoolValue>,

            /// If true, clean spikes and dips in the input time series.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub clean_spikes_and_dips: std::option::Option<wkt::BoolValue>,

            /// If true, detect step changes and make data adjustment in the input time
            /// series.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub adjust_step_changes: std::option::Option<wkt::BoolValue>,

            /// If true, enable global explanation during training.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub enable_global_explain: std::option::Option<wkt::BoolValue>,

            /// Number of paths for the sampled Shapley explain method.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub sampled_shapley_num_paths: i64,

            /// Number of integral steps for the integrated gradients explain method.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub integrated_gradients_num_steps: i64,

            /// Categorical feature encoding method.
            pub category_encoding_method:
                crate::model::model::category_encoding_method::EncodingMethod,

            /// Based on the selected TF version, the corresponding docker image is
            /// used to train external models.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub tf_version: std::string::String,

            /// Enums for color space, used for processing images in Object Table.
            /// See more details at
            /// <https://www.tensorflow.org/io/tutorials/colorspace>.
            pub color_space: crate::model::model::ColorSpace,

            /// Name of the instance weight column for training data.
            /// This column isn't be used as a feature.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub instance_weight_column: std::string::String,

            /// Smoothing window size for the trend component. When a positive value is
            /// specified, a center moving average smoothing is applied on the history
            /// trend. When the smoothing window is out of the boundary at the
            /// beginning or the end of the trend, the first element or the last
            /// element is padded to fill the smoothing window before the average is
            /// applied.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub trend_smoothing_window_size: i64,

            /// The fraction of the interpolated length of the time series that's used
            /// to model the time series trend component. All of the time points of the
            /// time series are used to model the non-trend component. This training
            /// option accelerates modeling training without sacrificing much
            /// forecasting accuracy. You can use this option with
            /// `minTimeSeriesLength` but not with `maxTimeSeriesLength`.
            pub time_series_length_fraction: f64,

            /// The minimum number of time points in a time series that are used in
            /// modeling the trend component of the time series. If you use this option
            /// you must also set the `timeSeriesLengthFraction` option. This training
            /// option ensures that enough time points are available when you use
            /// `timeSeriesLengthFraction` in trend modeling. This is particularly
            /// important when forecasting multiple time series in a single query using
            /// `timeSeriesIdColumn`. If the total number of time points is less than
            /// the `minTimeSeriesLength` value, then the query uses all available time
            /// points.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub min_time_series_length: i64,

            /// The maximum number of time points in a time series that can be used in
            /// modeling the trend component of the time series. Don't use this option
            /// with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub max_time_series_length: i64,

            /// User-selected XGBoost versions for training of XGBoost models.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub xgboost_version: std::string::String,

            /// Whether to use approximate feature contribution method in XGBoost model
            /// explanation for global explain.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub approx_global_feature_contrib: std::option::Option<wkt::BoolValue>,

            /// Whether the model should include intercept during model training.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub fit_intercept: std::option::Option<wkt::BoolValue>,

            /// Number of principal components to keep in the PCA model. Must be <= the
            /// number of features.
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub num_principal_components: i64,

            /// The minimum ratio of cumulative explained variance that needs to be
            /// given by the PCA model.
            pub pca_explained_variance_ratio: f64,

            /// If true, scale the feature values by dividing the feature standard
            /// deviation. Currently only apply to PCA.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub scale_features: std::option::Option<wkt::BoolValue>,

            /// The solver for PCA.
            pub pca_solver: crate::model::model::pca_solver_option_enums::PcaSolver,

            /// Whether to calculate class weights automatically based on the
            /// popularity of each label.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub auto_class_weights: std::option::Option<wkt::BoolValue>,

            /// Activation function of the neural nets.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub activation_fn: std::string::String,

            /// Optimizer used for training the neural nets.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub optimizer: std::string::String,

            /// Budget in hours for AutoML training.
            pub budget_hours: f64,

            /// Whether to standardize numerical features. Default to true.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub standardize_features: std::option::Option<wkt::BoolValue>,

            /// L1 regularization coefficient to activations.
            pub l1_reg_activation: f64,

            /// The model registry.
            pub model_registry: crate::model::model::model_registry_option_enums::ModelRegistry,

            /// The version aliases to apply in Vertex AI model registry. Always
            /// overwrite if the version aliases exists in a existing model.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub vertex_ai_model_version_aliases: std::vec::Vec<std::string::String>,

            /// Optional. Names of the columns to slice on. Applies to contribution
            /// analysis models.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub dimension_id_columns: std::vec::Vec<std::string::String>,

            /// The contribution metric. Applies to contribution analysis models.
            /// Allowed formats supported are for summable and summable ratio
            /// contribution metrics. These include expressions such as `SUM(x)` or
            /// `SUM(x)/SUM(y)`, where x and y are column names from the base table.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub contribution_metric: std::option::Option<std::string::String>,

            /// Name of the column used to determine the rows corresponding to control
            /// and test. Applies to contribution analysis models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub is_test_column: std::option::Option<std::string::String>,

            /// The apriori support minimum. Applies to contribution analysis models.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub min_apriori_support: std::option::Option<f64>,
        }

        impl TrainingOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [max_iterations][crate::model::model::training_run::TrainingOptions::max_iterations].
            pub fn set_max_iterations<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_iterations = v.into();
                self
            }

            /// Sets the value of [loss_type][crate::model::model::training_run::TrainingOptions::loss_type].
            pub fn set_loss_type<T: std::convert::Into<crate::model::model::LossType>>(
                mut self,
                v: T,
            ) -> Self {
                self.loss_type = v.into();
                self
            }

            /// Sets the value of [learn_rate][crate::model::model::training_run::TrainingOptions::learn_rate].
            pub fn set_learn_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.learn_rate = v.into();
                self
            }

            /// Sets the value of [l1_regularization][crate::model::model::training_run::TrainingOptions::l1_regularization].
            pub fn set_l1_regularization<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.l1_regularization = v.into();
                self
            }

            /// Sets the value of [l2_regularization][crate::model::model::training_run::TrainingOptions::l2_regularization].
            pub fn set_l2_regularization<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.l2_regularization = v.into();
                self
            }

            /// Sets the value of [min_relative_progress][crate::model::model::training_run::TrainingOptions::min_relative_progress].
            pub fn set_min_relative_progress<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.min_relative_progress = v.into();
                self
            }

            /// Sets the value of [warm_start][crate::model::model::training_run::TrainingOptions::warm_start].
            pub fn set_warm_start<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.warm_start = v.into();
                self
            }

            /// Sets the value of [early_stop][crate::model::model::training_run::TrainingOptions::early_stop].
            pub fn set_early_stop<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.early_stop = v.into();
                self
            }

            /// Sets the value of [data_split_method][crate::model::model::training_run::TrainingOptions::data_split_method].
            pub fn set_data_split_method<
                T: std::convert::Into<crate::model::model::DataSplitMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.data_split_method = v.into();
                self
            }

            /// Sets the value of [data_split_eval_fraction][crate::model::model::training_run::TrainingOptions::data_split_eval_fraction].
            pub fn set_data_split_eval_fraction<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.data_split_eval_fraction = v.into();
                self
            }

            /// Sets the value of [data_split_column][crate::model::model::training_run::TrainingOptions::data_split_column].
            pub fn set_data_split_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.data_split_column = v.into();
                self
            }

            /// Sets the value of [learn_rate_strategy][crate::model::model::training_run::TrainingOptions::learn_rate_strategy].
            pub fn set_learn_rate_strategy<
                T: std::convert::Into<crate::model::model::LearnRateStrategy>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.learn_rate_strategy = v.into();
                self
            }

            /// Sets the value of [initial_learn_rate][crate::model::model::training_run::TrainingOptions::initial_learn_rate].
            pub fn set_initial_learn_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.initial_learn_rate = v.into();
                self
            }

            /// Sets the value of [user_column][crate::model::model::training_run::TrainingOptions::user_column].
            pub fn set_user_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.user_column = v.into();
                self
            }

            /// Sets the value of [item_column][crate::model::model::training_run::TrainingOptions::item_column].
            pub fn set_item_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.item_column = v.into();
                self
            }

            /// Sets the value of [distance_type][crate::model::model::training_run::TrainingOptions::distance_type].
            pub fn set_distance_type<T: std::convert::Into<crate::model::model::DistanceType>>(
                mut self,
                v: T,
            ) -> Self {
                self.distance_type = v.into();
                self
            }

            /// Sets the value of [num_clusters][crate::model::model::training_run::TrainingOptions::num_clusters].
            pub fn set_num_clusters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.num_clusters = v.into();
                self
            }

            /// Sets the value of [model_uri][crate::model::model::training_run::TrainingOptions::model_uri].
            pub fn set_model_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.model_uri = v.into();
                self
            }

            /// Sets the value of [optimization_strategy][crate::model::model::training_run::TrainingOptions::optimization_strategy].
            pub fn set_optimization_strategy<
                T: std::convert::Into<crate::model::model::OptimizationStrategy>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.optimization_strategy = v.into();
                self
            }

            /// Sets the value of [batch_size][crate::model::model::training_run::TrainingOptions::batch_size].
            pub fn set_batch_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.batch_size = v.into();
                self
            }

            /// Sets the value of [dropout][crate::model::model::training_run::TrainingOptions::dropout].
            pub fn set_dropout<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.dropout = v.into();
                self
            }

            /// Sets the value of [max_tree_depth][crate::model::model::training_run::TrainingOptions::max_tree_depth].
            pub fn set_max_tree_depth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_tree_depth = v.into();
                self
            }

            /// Sets the value of [subsample][crate::model::model::training_run::TrainingOptions::subsample].
            pub fn set_subsample<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.subsample = v.into();
                self
            }

            /// Sets the value of [min_split_loss][crate::model::model::training_run::TrainingOptions::min_split_loss].
            pub fn set_min_split_loss<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.min_split_loss = v.into();
                self
            }

            /// Sets the value of [booster_type][crate::model::model::training_run::TrainingOptions::booster_type].
            pub fn set_booster_type<
                T: std::convert::Into<crate::model::model::boosted_tree_option_enums::BoosterType>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.booster_type = v.into();
                self
            }

            /// Sets the value of [num_parallel_tree][crate::model::model::training_run::TrainingOptions::num_parallel_tree].
            pub fn set_num_parallel_tree<
                T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.num_parallel_tree = v.into();
                self
            }

            /// Sets the value of [dart_normalize_type][crate::model::model::training_run::TrainingOptions::dart_normalize_type].
            pub fn set_dart_normalize_type<
                T: std::convert::Into<
                    crate::model::model::boosted_tree_option_enums::DartNormalizeType,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.dart_normalize_type = v.into();
                self
            }

            /// Sets the value of [tree_method][crate::model::model::training_run::TrainingOptions::tree_method].
            pub fn set_tree_method<
                T: std::convert::Into<crate::model::model::boosted_tree_option_enums::TreeMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.tree_method = v.into();
                self
            }

            /// Sets the value of [min_tree_child_weight][crate::model::model::training_run::TrainingOptions::min_tree_child_weight].
            pub fn set_min_tree_child_weight<
                T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.min_tree_child_weight = v.into();
                self
            }

            /// Sets the value of [colsample_bytree][crate::model::model::training_run::TrainingOptions::colsample_bytree].
            pub fn set_colsample_bytree<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.colsample_bytree = v.into();
                self
            }

            /// Sets the value of [colsample_bylevel][crate::model::model::training_run::TrainingOptions::colsample_bylevel].
            pub fn set_colsample_bylevel<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.colsample_bylevel = v.into();
                self
            }

            /// Sets the value of [colsample_bynode][crate::model::model::training_run::TrainingOptions::colsample_bynode].
            pub fn set_colsample_bynode<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.colsample_bynode = v.into();
                self
            }

            /// Sets the value of [num_factors][crate::model::model::training_run::TrainingOptions::num_factors].
            pub fn set_num_factors<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.num_factors = v.into();
                self
            }

            /// Sets the value of [feedback_type][crate::model::model::training_run::TrainingOptions::feedback_type].
            pub fn set_feedback_type<T: std::convert::Into<crate::model::model::FeedbackType>>(
                mut self,
                v: T,
            ) -> Self {
                self.feedback_type = v.into();
                self
            }

            /// Sets the value of [wals_alpha][crate::model::model::training_run::TrainingOptions::wals_alpha].
            pub fn set_wals_alpha<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.wals_alpha = v.into();
                self
            }

            /// Sets the value of [kmeans_initialization_method][crate::model::model::training_run::TrainingOptions::kmeans_initialization_method].
            pub fn set_kmeans_initialization_method<
                T: std::convert::Into<crate::model::model::kmeans_enums::KmeansInitializationMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.kmeans_initialization_method = v.into();
                self
            }

            /// Sets the value of [kmeans_initialization_column][crate::model::model::training_run::TrainingOptions::kmeans_initialization_column].
            pub fn set_kmeans_initialization_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kmeans_initialization_column = v.into();
                self
            }

            /// Sets the value of [time_series_timestamp_column][crate::model::model::training_run::TrainingOptions::time_series_timestamp_column].
            pub fn set_time_series_timestamp_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_timestamp_column = v.into();
                self
            }

            /// Sets the value of [time_series_data_column][crate::model::model::training_run::TrainingOptions::time_series_data_column].
            pub fn set_time_series_data_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_data_column = v.into();
                self
            }

            /// Sets the value of [auto_arima][crate::model::model::training_run::TrainingOptions::auto_arima].
            pub fn set_auto_arima<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.auto_arima = v.into();
                self
            }

            /// Sets the value of [non_seasonal_order][crate::model::model::training_run::TrainingOptions::non_seasonal_order].
            pub fn set_non_seasonal_order<
                T: std::convert::Into<std::option::Option<crate::model::model::ArimaOrder>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.non_seasonal_order = v.into();
                self
            }

            /// Sets the value of [data_frequency][crate::model::model::training_run::TrainingOptions::data_frequency].
            pub fn set_data_frequency<T: std::convert::Into<crate::model::model::DataFrequency>>(
                mut self,
                v: T,
            ) -> Self {
                self.data_frequency = v.into();
                self
            }

            /// Sets the value of [calculate_p_values][crate::model::model::training_run::TrainingOptions::calculate_p_values].
            pub fn set_calculate_p_values<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.calculate_p_values = v.into();
                self
            }

            /// Sets the value of [include_drift][crate::model::model::training_run::TrainingOptions::include_drift].
            pub fn set_include_drift<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.include_drift = v.into();
                self
            }

            /// Sets the value of [holiday_region][crate::model::model::training_run::TrainingOptions::holiday_region].
            pub fn set_holiday_region<T: std::convert::Into<crate::model::model::HolidayRegion>>(
                mut self,
                v: T,
            ) -> Self {
                self.holiday_region = v.into();
                self
            }

            /// Sets the value of [time_series_id_column][crate::model::model::training_run::TrainingOptions::time_series_id_column].
            pub fn set_time_series_id_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_id_column = v.into();
                self
            }

            /// Sets the value of [forecast_limit_lower_bound][crate::model::model::training_run::TrainingOptions::forecast_limit_lower_bound].
            pub fn set_forecast_limit_lower_bound<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.forecast_limit_lower_bound = v.into();
                self
            }

            /// Sets the value of [forecast_limit_upper_bound][crate::model::model::training_run::TrainingOptions::forecast_limit_upper_bound].
            pub fn set_forecast_limit_upper_bound<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.forecast_limit_upper_bound = v.into();
                self
            }

            /// Sets the value of [horizon][crate::model::model::training_run::TrainingOptions::horizon].
            pub fn set_horizon<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.horizon = v.into();
                self
            }

            /// Sets the value of [auto_arima_max_order][crate::model::model::training_run::TrainingOptions::auto_arima_max_order].
            pub fn set_auto_arima_max_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.auto_arima_max_order = v.into();
                self
            }

            /// Sets the value of [auto_arima_min_order][crate::model::model::training_run::TrainingOptions::auto_arima_min_order].
            pub fn set_auto_arima_min_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.auto_arima_min_order = v.into();
                self
            }

            /// Sets the value of [num_trials][crate::model::model::training_run::TrainingOptions::num_trials].
            pub fn set_num_trials<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.num_trials = v.into();
                self
            }

            /// Sets the value of [max_parallel_trials][crate::model::model::training_run::TrainingOptions::max_parallel_trials].
            pub fn set_max_parallel_trials<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_parallel_trials = v.into();
                self
            }

            /// Sets the value of [decompose_time_series][crate::model::model::training_run::TrainingOptions::decompose_time_series].
            pub fn set_decompose_time_series<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.decompose_time_series = v.into();
                self
            }

            /// Sets the value of [clean_spikes_and_dips][crate::model::model::training_run::TrainingOptions::clean_spikes_and_dips].
            pub fn set_clean_spikes_and_dips<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.clean_spikes_and_dips = v.into();
                self
            }

            /// Sets the value of [adjust_step_changes][crate::model::model::training_run::TrainingOptions::adjust_step_changes].
            pub fn set_adjust_step_changes<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.adjust_step_changes = v.into();
                self
            }

            /// Sets the value of [enable_global_explain][crate::model::model::training_run::TrainingOptions::enable_global_explain].
            pub fn set_enable_global_explain<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.enable_global_explain = v.into();
                self
            }

            /// Sets the value of [sampled_shapley_num_paths][crate::model::model::training_run::TrainingOptions::sampled_shapley_num_paths].
            pub fn set_sampled_shapley_num_paths<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sampled_shapley_num_paths = v.into();
                self
            }

            /// Sets the value of [integrated_gradients_num_steps][crate::model::model::training_run::TrainingOptions::integrated_gradients_num_steps].
            pub fn set_integrated_gradients_num_steps<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.integrated_gradients_num_steps = v.into();
                self
            }

            /// Sets the value of [category_encoding_method][crate::model::model::training_run::TrainingOptions::category_encoding_method].
            pub fn set_category_encoding_method<
                T: std::convert::Into<crate::model::model::category_encoding_method::EncodingMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.category_encoding_method = v.into();
                self
            }

            /// Sets the value of [tf_version][crate::model::model::training_run::TrainingOptions::tf_version].
            pub fn set_tf_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.tf_version = v.into();
                self
            }

            /// Sets the value of [color_space][crate::model::model::training_run::TrainingOptions::color_space].
            pub fn set_color_space<T: std::convert::Into<crate::model::model::ColorSpace>>(
                mut self,
                v: T,
            ) -> Self {
                self.color_space = v.into();
                self
            }

            /// Sets the value of [instance_weight_column][crate::model::model::training_run::TrainingOptions::instance_weight_column].
            pub fn set_instance_weight_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.instance_weight_column = v.into();
                self
            }

            /// Sets the value of [trend_smoothing_window_size][crate::model::model::training_run::TrainingOptions::trend_smoothing_window_size].
            pub fn set_trend_smoothing_window_size<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.trend_smoothing_window_size = v.into();
                self
            }

            /// Sets the value of [time_series_length_fraction][crate::model::model::training_run::TrainingOptions::time_series_length_fraction].
            pub fn set_time_series_length_fraction<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_length_fraction = v.into();
                self
            }

            /// Sets the value of [min_time_series_length][crate::model::model::training_run::TrainingOptions::min_time_series_length].
            pub fn set_min_time_series_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_time_series_length = v.into();
                self
            }

            /// Sets the value of [max_time_series_length][crate::model::model::training_run::TrainingOptions::max_time_series_length].
            pub fn set_max_time_series_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_time_series_length = v.into();
                self
            }

            /// Sets the value of [xgboost_version][crate::model::model::training_run::TrainingOptions::xgboost_version].
            pub fn set_xgboost_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.xgboost_version = v.into();
                self
            }

            /// Sets the value of [approx_global_feature_contrib][crate::model::model::training_run::TrainingOptions::approx_global_feature_contrib].
            pub fn set_approx_global_feature_contrib<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.approx_global_feature_contrib = v.into();
                self
            }

            /// Sets the value of [fit_intercept][crate::model::model::training_run::TrainingOptions::fit_intercept].
            pub fn set_fit_intercept<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.fit_intercept = v.into();
                self
            }

            /// Sets the value of [num_principal_components][crate::model::model::training_run::TrainingOptions::num_principal_components].
            pub fn set_num_principal_components<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.num_principal_components = v.into();
                self
            }

            /// Sets the value of [pca_explained_variance_ratio][crate::model::model::training_run::TrainingOptions::pca_explained_variance_ratio].
            pub fn set_pca_explained_variance_ratio<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.pca_explained_variance_ratio = v.into();
                self
            }

            /// Sets the value of [scale_features][crate::model::model::training_run::TrainingOptions::scale_features].
            pub fn set_scale_features<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.scale_features = v.into();
                self
            }

            /// Sets the value of [pca_solver][crate::model::model::training_run::TrainingOptions::pca_solver].
            pub fn set_pca_solver<
                T: std::convert::Into<crate::model::model::pca_solver_option_enums::PcaSolver>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.pca_solver = v.into();
                self
            }

            /// Sets the value of [auto_class_weights][crate::model::model::training_run::TrainingOptions::auto_class_weights].
            pub fn set_auto_class_weights<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.auto_class_weights = v.into();
                self
            }

            /// Sets the value of [activation_fn][crate::model::model::training_run::TrainingOptions::activation_fn].
            pub fn set_activation_fn<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.activation_fn = v.into();
                self
            }

            /// Sets the value of [optimizer][crate::model::model::training_run::TrainingOptions::optimizer].
            pub fn set_optimizer<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.optimizer = v.into();
                self
            }

            /// Sets the value of [budget_hours][crate::model::model::training_run::TrainingOptions::budget_hours].
            pub fn set_budget_hours<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.budget_hours = v.into();
                self
            }

            /// Sets the value of [standardize_features][crate::model::model::training_run::TrainingOptions::standardize_features].
            pub fn set_standardize_features<
                T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.standardize_features = v.into();
                self
            }

            /// Sets the value of [l1_reg_activation][crate::model::model::training_run::TrainingOptions::l1_reg_activation].
            pub fn set_l1_reg_activation<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.l1_reg_activation = v.into();
                self
            }

            /// Sets the value of [model_registry][crate::model::model::training_run::TrainingOptions::model_registry].
            pub fn set_model_registry<
                T: std::convert::Into<crate::model::model::model_registry_option_enums::ModelRegistry>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.model_registry = v.into();
                self
            }

            /// Sets the value of [contribution_metric][crate::model::model::training_run::TrainingOptions::contribution_metric].
            pub fn set_contribution_metric<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.contribution_metric = v.into();
                self
            }

            /// Sets the value of [is_test_column][crate::model::model::training_run::TrainingOptions::is_test_column].
            pub fn set_is_test_column<
                T: std::convert::Into<std::option::Option<std::string::String>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.is_test_column = v.into();
                self
            }

            /// Sets the value of [min_apriori_support][crate::model::model::training_run::TrainingOptions::min_apriori_support].
            pub fn set_min_apriori_support<T: std::convert::Into<std::option::Option<f64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.min_apriori_support = v.into();
                self
            }

            /// Sets the value of [input_label_columns][crate::model::model::training_run::TrainingOptions::input_label_columns].
            pub fn set_input_label_columns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.input_label_columns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [hidden_units][crate::model::model::training_run::TrainingOptions::hidden_units].
            pub fn set_hidden_units<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<i64>,
            {
                use std::iter::Iterator;
                self.hidden_units = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [holiday_regions][crate::model::model::training_run::TrainingOptions::holiday_regions].
            pub fn set_holiday_regions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::model::HolidayRegion>,
            {
                use std::iter::Iterator;
                self.holiday_regions = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [time_series_id_columns][crate::model::model::training_run::TrainingOptions::time_series_id_columns].
            pub fn set_time_series_id_columns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.time_series_id_columns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [hparam_tuning_objectives][crate::model::model::training_run::TrainingOptions::hparam_tuning_objectives].
            pub fn set_hparam_tuning_objectives<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::model::hparam_tuning_enums::HparamTuningObjective,
                >,
            {
                use std::iter::Iterator;
                self.hparam_tuning_objectives = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [vertex_ai_model_version_aliases][crate::model::model::training_run::TrainingOptions::vertex_ai_model_version_aliases].
            pub fn set_vertex_ai_model_version_aliases<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.vertex_ai_model_version_aliases = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [dimension_id_columns][crate::model::model::training_run::TrainingOptions::dimension_id_columns].
            pub fn set_dimension_id_columns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.dimension_id_columns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [label_class_weights][crate::model::model::training_run::TrainingOptions::label_class_weights].
            pub fn set_label_class_weights<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<f64>,
            {
                use std::iter::Iterator;
                self.label_class_weights =
                    v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for TrainingOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.TrainingOptions"
            }
        }

        /// Information about a single iteration of the training run.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IterationResult {
            /// Index of the iteration, 0 based.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub index: std::option::Option<wkt::Int32Value>,

            /// Time taken to run the iteration in milliseconds.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub duration_ms: std::option::Option<wkt::Int64Value>,

            /// Loss computed on the training data at the end of iteration.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub training_loss: std::option::Option<wkt::DoubleValue>,

            /// Loss computed on the eval data at the end of iteration.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub eval_loss: std::option::Option<wkt::DoubleValue>,

            /// Learn rate used for this iteration.
            pub learn_rate: f64,

            /// Information about top clusters for clustering models.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub cluster_infos:
                std::vec::Vec<crate::model::model::training_run::iteration_result::ClusterInfo>,

            /// Arima result.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub arima_result: std::option::Option<
                crate::model::model::training_run::iteration_result::ArimaResult,
            >,

            /// The information of the principal components.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub principal_component_infos: std::vec::Vec<
                crate::model::model::training_run::iteration_result::PrincipalComponentInfo,
            >,
        }

        impl IterationResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [index][crate::model::model::training_run::IterationResult::index].
            pub fn set_index<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
                mut self,
                v: T,
            ) -> Self {
                self.index = v.into();
                self
            }

            /// Sets the value of [duration_ms][crate::model::model::training_run::IterationResult::duration_ms].
            pub fn set_duration_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
                mut self,
                v: T,
            ) -> Self {
                self.duration_ms = v.into();
                self
            }

            /// Sets the value of [training_loss][crate::model::model::training_run::IterationResult::training_loss].
            pub fn set_training_loss<
                T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.training_loss = v.into();
                self
            }

            /// Sets the value of [eval_loss][crate::model::model::training_run::IterationResult::eval_loss].
            pub fn set_eval_loss<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.eval_loss = v.into();
                self
            }

            /// Sets the value of [learn_rate][crate::model::model::training_run::IterationResult::learn_rate].
            pub fn set_learn_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.learn_rate = v.into();
                self
            }

            /// Sets the value of [arima_result][crate::model::model::training_run::IterationResult::arima_result].
            pub fn set_arima_result<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::model::training_run::iteration_result::ArimaResult,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.arima_result = v.into();
                self
            }

            /// Sets the value of [cluster_infos][crate::model::model::training_run::IterationResult::cluster_infos].
            pub fn set_cluster_infos<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::model::training_run::iteration_result::ClusterInfo,
                >,
            {
                use std::iter::Iterator;
                self.cluster_infos = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [principal_component_infos][crate::model::model::training_run::IterationResult::principal_component_infos].
            pub fn set_principal_component_infos<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                    crate::model::model::training_run::iteration_result::PrincipalComponentInfo,
                >,
            {
                use std::iter::Iterator;
                self.principal_component_infos = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IterationResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult"
            }
        }

        /// Defines additional types related to IterationResult
        pub mod iteration_result {
            #[allow(unused_imports)]
            use super::*;

            /// Information about a single cluster for clustering model.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ClusterInfo {
                /// Centroid id.
                #[serde_as(as = "serde_with::DisplayFromStr")]
                pub centroid_id: i64,

                /// Cluster radius, the average distance from centroid
                /// to each point assigned to the cluster.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub cluster_radius: std::option::Option<wkt::DoubleValue>,

                /// Cluster size, the total number of points assigned to the cluster.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
                pub cluster_size: std::option::Option<wkt::Int64Value>,
            }

            impl ClusterInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [centroid_id][crate::model::model::training_run::iteration_result::ClusterInfo::centroid_id].
                pub fn set_centroid_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.centroid_id = v.into();
                    self
                }

                /// Sets the value of [cluster_radius][crate::model::model::training_run::iteration_result::ClusterInfo::cluster_radius].
                pub fn set_cluster_radius<
                    T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.cluster_radius = v.into();
                    self
                }

                /// Sets the value of [cluster_size][crate::model::model::training_run::iteration_result::ClusterInfo::cluster_size].
                pub fn set_cluster_size<
                    T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.cluster_size = v.into();
                    self
                }
            }

            impl wkt::message::Message for ClusterInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ClusterInfo"
                }
            }

            /// (Auto-)arima fitting result. Wrap everything in ArimaResult for easier
            /// refactoring if we want to use model-specific iteration results.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ArimaResult {

                /// This message is repeated because there are multiple arima models
                /// fitted in auto-arima. For non-auto-arima model, its size is one.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub arima_model_info: std::vec::Vec<crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo>,

                /// Seasonal periods. Repeated because multiple periods are supported for
                /// one time series.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub seasonal_periods: std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>,
            }

            impl ArimaResult {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [arima_model_info][crate::model::model::training_run::iteration_result::ArimaResult::arima_model_info].
                pub fn set_arima_model_info<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo>
                {
                    use std::iter::Iterator;
                    self.arima_model_info = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [seasonal_periods][crate::model::model::training_run::iteration_result::ArimaResult::seasonal_periods].
                pub fn set_seasonal_periods<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::model::seasonal_period::SeasonalPeriodType>,
                {
                    use std::iter::Iterator;
                    self.seasonal_periods = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for ArimaResult {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ArimaResult"
                }
            }

            /// Defines additional types related to ArimaResult
            pub mod arima_result {
                #[allow(unused_imports)]
                use super::*;

                /// Arima coefficients.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct ArimaCoefficients {
                    /// Auto-regressive coefficients, an array of double.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub auto_regressive_coefficients: std::vec::Vec<f64>,

                    /// Moving-average coefficients, an array of double.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub moving_average_coefficients: std::vec::Vec<f64>,

                    /// Intercept coefficient, just a double not an array.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub intercept_coefficient: std::option::Option<wkt::DoubleValue>,
                }

                impl ArimaCoefficients {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [intercept_coefficient][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::intercept_coefficient].
                    pub fn set_intercept_coefficient<
                        T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.intercept_coefficient = v.into();
                        self
                    }

                    /// Sets the value of [auto_regressive_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::auto_regressive_coefficients].
                    pub fn set_auto_regressive_coefficients<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<f64>,
                    {
                        use std::iter::Iterator;
                        self.auto_regressive_coefficients =
                            v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [moving_average_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::moving_average_coefficients].
                    pub fn set_moving_average_coefficients<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<f64>,
                    {
                        use std::iter::Iterator;
                        self.moving_average_coefficients =
                            v.into_iter().map(|i| i.into()).collect();
                        self
                    }
                }

                impl wkt::message::Message for ArimaCoefficients {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ArimaResult.ArimaCoefficients"
                    }
                }

                /// Arima model information.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct ArimaModelInfo {

                    /// Non-seasonal order.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub non_seasonal_order: std::option::Option<crate::model::model::ArimaOrder>,

                    /// Arima coefficients.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub arima_coefficients: std::option::Option<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>,

                    /// Arima fitting metrics.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub arima_fitting_metrics: std::option::Option<crate::model::model::ArimaFittingMetrics>,

                    /// Whether Arima model fitted with drift or not. It is always false
                    /// when d is not 1.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub has_drift: std::option::Option<wkt::BoolValue>,

                    /// The time_series_id value for this time series. It will be one of
                    /// the unique values from the time_series_id_column specified during
                    /// ARIMA model training. Only present when time_series_id_column
                    /// training option was used.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub time_series_id: std::string::String,

                    /// The tuple of time_series_ids identifying this time series. It will
                    /// be one of the unique tuples of values present in the
                    /// time_series_id_columns specified during ARIMA model training. Only
                    /// present when time_series_id_columns training option was used and
                    /// the order of values here are same as the order of
                    /// time_series_id_columns.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub time_series_ids: std::vec::Vec<std::string::String>,

                    /// Seasonal periods. Repeated because multiple periods are supported
                    /// for one time series.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub seasonal_periods: std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>,

                    /// If true, holiday_effect is a part of time series decomposition
                    /// result.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub has_holiday_effect: std::option::Option<wkt::BoolValue>,

                    /// If true, spikes_and_dips is a part of time series decomposition
                    /// result.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub has_spikes_and_dips: std::option::Option<wkt::BoolValue>,

                    /// If true, step_changes is a part of time series decomposition
                    /// result.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub has_step_changes: std::option::Option<wkt::BoolValue>,
                }

                impl ArimaModelInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [non_seasonal_order][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::non_seasonal_order].
                    pub fn set_non_seasonal_order<
                        T: std::convert::Into<std::option::Option<crate::model::model::ArimaOrder>>,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.non_seasonal_order = v.into();
                        self
                    }

                    /// Sets the value of [arima_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::arima_coefficients].
                    pub fn set_arima_coefficients<T: std::convert::Into<std::option::Option<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>>>(mut self, v: T) -> Self{
                        self.arima_coefficients = v.into();
                        self
                    }

                    /// Sets the value of [arima_fitting_metrics][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::arima_fitting_metrics].
                    pub fn set_arima_fitting_metrics<
                        T: std::convert::Into<
                            std::option::Option<crate::model::model::ArimaFittingMetrics>,
                        >,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.arima_fitting_metrics = v.into();
                        self
                    }

                    /// Sets the value of [has_drift][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_drift].
                    pub fn set_has_drift<
                        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.has_drift = v.into();
                        self
                    }

                    /// Sets the value of [time_series_id][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::time_series_id].
                    pub fn set_time_series_id<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.time_series_id = v.into();
                        self
                    }

                    /// Sets the value of [has_holiday_effect][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_holiday_effect].
                    pub fn set_has_holiday_effect<
                        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.has_holiday_effect = v.into();
                        self
                    }

                    /// Sets the value of [has_spikes_and_dips][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_spikes_and_dips].
                    pub fn set_has_spikes_and_dips<
                        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.has_spikes_and_dips = v.into();
                        self
                    }

                    /// Sets the value of [has_step_changes][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_step_changes].
                    pub fn set_has_step_changes<
                        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
                    >(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.has_step_changes = v.into();
                        self
                    }

                    /// Sets the value of [time_series_ids][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::time_series_ids].
                    pub fn set_time_series_ids<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<std::string::String>,
                    {
                        use std::iter::Iterator;
                        self.time_series_ids = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [seasonal_periods][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::seasonal_periods].
                    pub fn set_seasonal_periods<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<
                            crate::model::model::seasonal_period::SeasonalPeriodType,
                        >,
                    {
                        use std::iter::Iterator;
                        self.seasonal_periods = v.into_iter().map(|i| i.into()).collect();
                        self
                    }
                }

                impl wkt::message::Message for ArimaModelInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ArimaResult.ArimaModelInfo"
                    }
                }
            }

            /// Principal component infos, used only for eigen decomposition based
            /// models, e.g., PCA. Ordered by explained_variance in the descending
            /// order.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct PrincipalComponentInfo {
                /// Id of the principal component.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
                pub principal_component_id: std::option::Option<wkt::Int64Value>,

                /// Explained variance by this principal component, which is simply the
                /// eigenvalue.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub explained_variance: std::option::Option<wkt::DoubleValue>,

                /// Explained_variance over the total explained variance.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub explained_variance_ratio: std::option::Option<wkt::DoubleValue>,

                /// The explained_variance is pre-ordered in the descending order to
                /// compute the cumulative explained variance ratio.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub cumulative_explained_variance_ratio: std::option::Option<wkt::DoubleValue>,
            }

            impl PrincipalComponentInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [principal_component_id][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::principal_component_id].
                pub fn set_principal_component_id<
                    T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.principal_component_id = v.into();
                    self
                }

                /// Sets the value of [explained_variance][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::explained_variance].
                pub fn set_explained_variance<
                    T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.explained_variance = v.into();
                    self
                }

                /// Sets the value of [explained_variance_ratio][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::explained_variance_ratio].
                pub fn set_explained_variance_ratio<
                    T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.explained_variance_ratio = v.into();
                    self
                }

                /// Sets the value of [cumulative_explained_variance_ratio][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::cumulative_explained_variance_ratio].
                pub fn set_cumulative_explained_variance_ratio<
                    T: std::convert::Into<std::option::Option<wkt::DoubleValue>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.cumulative_explained_variance_ratio = v.into();
                    self
                }
            }

            impl wkt::message::Message for PrincipalComponentInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.PrincipalComponentInfo"
                }
            }
        }
    }

    /// Search space for a double hyperparameter.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DoubleHparamSearchSpace {
        /// Search space.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub search_space:
            std::option::Option<crate::model::model::double_hparam_search_space::SearchSpace>,
    }

    impl DoubleHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `search_space`.
        pub fn set_search_space<
            T: std::convert::Into<
                std::option::Option<crate::model::model::double_hparam_search_space::SearchSpace>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = v.into();
            self
        }

        /// The value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// if it holds a `Range`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_range(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::double_hparam_search_space::SearchSpace::Range(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// if it holds a `Candidates`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_candidates(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::double_hparam_search_space::SearchSpace::Candidates(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// to hold a `Range`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_range<
            T: std::convert::Into<
                std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::double_hparam_search_space::SearchSpace::Range(v.into()),
            );
            self
        }

        /// Sets the value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// to hold a `Candidates`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_candidates<
            T: std::convert::Into<
                std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::double_hparam_search_space::SearchSpace::Candidates(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DoubleHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace"
        }
    }

    /// Defines additional types related to DoubleHparamSearchSpace
    pub mod double_hparam_search_space {
        #[allow(unused_imports)]
        use super::*;

        /// Range of a double hyperparameter.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DoubleRange {
            /// Min value of the double parameter.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub min: std::option::Option<wkt::DoubleValue>,

            /// Max value of the double parameter.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub max: std::option::Option<wkt::DoubleValue>,
        }

        impl DoubleRange {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min][crate::model::model::double_hparam_search_space::DoubleRange::min].
            pub fn set_min<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.min = v.into();
                self
            }

            /// Sets the value of [max][crate::model::model::double_hparam_search_space::DoubleRange::max].
            pub fn set_max<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
                mut self,
                v: T,
            ) -> Self {
                self.max = v.into();
                self
            }
        }

        impl wkt::message::Message for DoubleRange {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.DoubleRange"
            }
        }

        /// Discrete candidates of a double hyperparameter.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DoubleCandidates {
            /// Candidates for the double parameter in increasing order.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub candidates: std::vec::Vec<wkt::DoubleValue>,
        }

        impl DoubleCandidates {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [candidates][crate::model::model::double_hparam_search_space::DoubleCandidates::candidates].
            pub fn set_candidates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<wkt::DoubleValue>,
            {
                use std::iter::Iterator;
                self.candidates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for DoubleCandidates {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.DoubleCandidates"
            }
        }

        /// Search space.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum SearchSpace {
            /// Range of the double hyperparameter.
            Range(std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>),
            /// Candidates of the double hyperparameter.
            Candidates(
                std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>,
            ),
        }
    }

    /// Search space for an int hyperparameter.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IntHparamSearchSpace {
        /// Search space.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub search_space:
            std::option::Option<crate::model::model::int_hparam_search_space::SearchSpace>,
    }

    impl IntHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `search_space`.
        pub fn set_search_space<
            T: std::convert::Into<
                std::option::Option<crate::model::model::int_hparam_search_space::SearchSpace>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = v.into();
            self
        }

        /// The value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// if it holds a `Range`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_range(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::int_hparam_search_space::SearchSpace::Range(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// if it holds a `Candidates`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_candidates(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::int_hparam_search_space::SearchSpace::Candidates(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// to hold a `Range`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_range<
            T: std::convert::Into<
                std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::int_hparam_search_space::SearchSpace::Range(v.into()),
            );
            self
        }

        /// Sets the value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// to hold a `Candidates`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_candidates<
            T: std::convert::Into<
                std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::int_hparam_search_space::SearchSpace::Candidates(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IntHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.IntHparamSearchSpace"
        }
    }

    /// Defines additional types related to IntHparamSearchSpace
    pub mod int_hparam_search_space {
        #[allow(unused_imports)]
        use super::*;

        /// Range of an int hyperparameter.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IntRange {
            /// Min value of the int parameter.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub min: std::option::Option<wkt::Int64Value>,

            /// Max value of the int parameter.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub max: std::option::Option<wkt::Int64Value>,
        }

        impl IntRange {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min][crate::model::model::int_hparam_search_space::IntRange::min].
            pub fn set_min<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
                mut self,
                v: T,
            ) -> Self {
                self.min = v.into();
                self
            }

            /// Sets the value of [max][crate::model::model::int_hparam_search_space::IntRange::max].
            pub fn set_max<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
                mut self,
                v: T,
            ) -> Self {
                self.max = v.into();
                self
            }
        }

        impl wkt::message::Message for IntRange {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.IntHparamSearchSpace.IntRange"
            }
        }

        /// Discrete candidates of an int hyperparameter.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IntCandidates {
            /// Candidates for the int parameter in increasing order.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
            pub candidates: std::vec::Vec<wkt::Int64Value>,
        }

        impl IntCandidates {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [candidates][crate::model::model::int_hparam_search_space::IntCandidates::candidates].
            pub fn set_candidates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<wkt::Int64Value>,
            {
                use std::iter::Iterator;
                self.candidates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IntCandidates {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.IntHparamSearchSpace.IntCandidates"
            }
        }

        /// Search space.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum SearchSpace {
            /// Range of the int hyperparameter.
            Range(std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>),
            /// Candidates of the int hyperparameter.
            Candidates(
                std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>,
            ),
        }
    }

    /// Search space for string and enum.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StringHparamSearchSpace {
        /// Canididates for the string or enum parameter in lower case.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub candidates: std::vec::Vec<std::string::String>,
    }

    impl StringHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [candidates][crate::model::model::StringHparamSearchSpace::candidates].
        pub fn set_candidates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.candidates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.StringHparamSearchSpace"
        }
    }

    /// Search space for int array.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IntArrayHparamSearchSpace {
        /// Candidates for the int array parameter.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub candidates: std::vec::Vec<crate::model::model::int_array_hparam_search_space::IntArray>,
    }

    impl IntArrayHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [candidates][crate::model::model::IntArrayHparamSearchSpace::candidates].
        pub fn set_candidates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::int_array_hparam_search_space::IntArray>,
        {
            use std::iter::Iterator;
            self.candidates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IntArrayHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.IntArrayHparamSearchSpace"
        }
    }

    /// Defines additional types related to IntArrayHparamSearchSpace
    pub mod int_array_hparam_search_space {
        #[allow(unused_imports)]
        use super::*;

        /// An array of int.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IntArray {
            /// Elements in the int array.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
            pub elements: std::vec::Vec<i64>,
        }

        impl IntArray {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [elements][crate::model::model::int_array_hparam_search_space::IntArray::elements].
            pub fn set_elements<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<i64>,
            {
                use std::iter::Iterator;
                self.elements = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IntArray {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.IntArrayHparamSearchSpace.IntArray"
            }
        }
    }

    /// Hyperparameter search spaces.
    /// These should be a subset of training_options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HparamSearchSpaces {
        /// Learning rate of training jobs.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub learn_rate: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// L1 regularization coefficient.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub l1_reg: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// L2 regularization coefficient.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub l2_reg: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Number of clusters for k-means.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub num_clusters: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Number of latent factors to train on.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub num_factors: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Hidden units for neural network models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hidden_units: std::option::Option<crate::model::model::IntArrayHparamSearchSpace>,

        /// Mini batch sample size.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub batch_size: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Dropout probability for dnn model training and boosted tree models
        /// using dart booster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub dropout: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Maximum depth of a tree for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_tree_depth: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Subsample the training data to grow tree to prevent overfitting for
        /// boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub subsample: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Minimum split loss for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_split_loss: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Hyperparameter for matrix factoration when implicit feedback type is
        /// specified.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub wals_alpha: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Booster type for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub booster_type: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Number of parallel trees for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub num_parallel_tree: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Dart normalization type for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub dart_normalize_type: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Tree construction algorithm for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub tree_method: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Minimum sum of instance weight needed in a child for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_tree_child_weight: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Subsample ratio of columns when constructing each tree for boosted tree
        /// models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub colsample_bytree: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Subsample ratio of columns for each level for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub colsample_bylevel: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Subsample ratio of columns for each node(split) for boosted tree models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub colsample_bynode: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Activation functions of neural network models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub activation_fn: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Optimizer of TF models.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub optimizer: std::option::Option<crate::model::model::StringHparamSearchSpace>,
    }

    impl HparamSearchSpaces {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [learn_rate][crate::model::model::HparamSearchSpaces::learn_rate].
        pub fn set_learn_rate<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.learn_rate = v.into();
            self
        }

        /// Sets the value of [l1_reg][crate::model::model::HparamSearchSpaces::l1_reg].
        pub fn set_l1_reg<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.l1_reg = v.into();
            self
        }

        /// Sets the value of [l2_reg][crate::model::model::HparamSearchSpaces::l2_reg].
        pub fn set_l2_reg<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.l2_reg = v.into();
            self
        }

        /// Sets the value of [num_clusters][crate::model::model::HparamSearchSpaces::num_clusters].
        pub fn set_num_clusters<
            T: std::convert::Into<std::option::Option<crate::model::model::IntHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.num_clusters = v.into();
            self
        }

        /// Sets the value of [num_factors][crate::model::model::HparamSearchSpaces::num_factors].
        pub fn set_num_factors<
            T: std::convert::Into<std::option::Option<crate::model::model::IntHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.num_factors = v.into();
            self
        }

        /// Sets the value of [hidden_units][crate::model::model::HparamSearchSpaces::hidden_units].
        pub fn set_hidden_units<
            T: std::convert::Into<std::option::Option<crate::model::model::IntArrayHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.hidden_units = v.into();
            self
        }

        /// Sets the value of [batch_size][crate::model::model::HparamSearchSpaces::batch_size].
        pub fn set_batch_size<
            T: std::convert::Into<std::option::Option<crate::model::model::IntHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.batch_size = v.into();
            self
        }

        /// Sets the value of [dropout][crate::model::model::HparamSearchSpaces::dropout].
        pub fn set_dropout<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.dropout = v.into();
            self
        }

        /// Sets the value of [max_tree_depth][crate::model::model::HparamSearchSpaces::max_tree_depth].
        pub fn set_max_tree_depth<
            T: std::convert::Into<std::option::Option<crate::model::model::IntHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_tree_depth = v.into();
            self
        }

        /// Sets the value of [subsample][crate::model::model::HparamSearchSpaces::subsample].
        pub fn set_subsample<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.subsample = v.into();
            self
        }

        /// Sets the value of [min_split_loss][crate::model::model::HparamSearchSpaces::min_split_loss].
        pub fn set_min_split_loss<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_split_loss = v.into();
            self
        }

        /// Sets the value of [wals_alpha][crate::model::model::HparamSearchSpaces::wals_alpha].
        pub fn set_wals_alpha<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.wals_alpha = v.into();
            self
        }

        /// Sets the value of [booster_type][crate::model::model::HparamSearchSpaces::booster_type].
        pub fn set_booster_type<
            T: std::convert::Into<std::option::Option<crate::model::model::StringHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.booster_type = v.into();
            self
        }

        /// Sets the value of [num_parallel_tree][crate::model::model::HparamSearchSpaces::num_parallel_tree].
        pub fn set_num_parallel_tree<
            T: std::convert::Into<std::option::Option<crate::model::model::IntHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.num_parallel_tree = v.into();
            self
        }

        /// Sets the value of [dart_normalize_type][crate::model::model::HparamSearchSpaces::dart_normalize_type].
        pub fn set_dart_normalize_type<
            T: std::convert::Into<std::option::Option<crate::model::model::StringHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.dart_normalize_type = v.into();
            self
        }

        /// Sets the value of [tree_method][crate::model::model::HparamSearchSpaces::tree_method].
        pub fn set_tree_method<
            T: std::convert::Into<std::option::Option<crate::model::model::StringHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.tree_method = v.into();
            self
        }

        /// Sets the value of [min_tree_child_weight][crate::model::model::HparamSearchSpaces::min_tree_child_weight].
        pub fn set_min_tree_child_weight<
            T: std::convert::Into<std::option::Option<crate::model::model::IntHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.min_tree_child_weight = v.into();
            self
        }

        /// Sets the value of [colsample_bytree][crate::model::model::HparamSearchSpaces::colsample_bytree].
        pub fn set_colsample_bytree<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.colsample_bytree = v.into();
            self
        }

        /// Sets the value of [colsample_bylevel][crate::model::model::HparamSearchSpaces::colsample_bylevel].
        pub fn set_colsample_bylevel<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.colsample_bylevel = v.into();
            self
        }

        /// Sets the value of [colsample_bynode][crate::model::model::HparamSearchSpaces::colsample_bynode].
        pub fn set_colsample_bynode<
            T: std::convert::Into<std::option::Option<crate::model::model::DoubleHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.colsample_bynode = v.into();
            self
        }

        /// Sets the value of [activation_fn][crate::model::model::HparamSearchSpaces::activation_fn].
        pub fn set_activation_fn<
            T: std::convert::Into<std::option::Option<crate::model::model::StringHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.activation_fn = v.into();
            self
        }

        /// Sets the value of [optimizer][crate::model::model::HparamSearchSpaces::optimizer].
        pub fn set_optimizer<
            T: std::convert::Into<std::option::Option<crate::model::model::StringHparamSearchSpace>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.optimizer = v.into();
            self
        }
    }

    impl wkt::message::Message for HparamSearchSpaces {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.HparamSearchSpaces"
        }
    }

    /// Training info of a trial in [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HparamTuningTrial {
        /// 1-based index of the trial.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub trial_id: i64,

        /// Starting time of the trial.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub start_time_ms: i64,

        /// Ending time of the trial.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub end_time_ms: i64,

        /// The hyperprameters selected for this trial.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hparams: std::option::Option<crate::model::model::training_run::TrainingOptions>,

        /// Evaluation metrics of this trial calculated on the test data.
        /// Empty in Job API.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub evaluation_metrics: std::option::Option<crate::model::model::EvaluationMetrics>,

        /// The status of the trial.
        pub status: crate::model::model::hparam_tuning_trial::TrialStatus,

        /// Error message for FAILED and INFEASIBLE trial.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        /// Loss computed on the training data at the end of trial.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub training_loss: std::option::Option<wkt::DoubleValue>,

        /// Loss computed on the eval data at the end of trial.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub eval_loss: std::option::Option<wkt::DoubleValue>,

        /// Hyperparameter tuning evaluation metrics of this trial calculated on the
        /// eval data. Unlike evaluation_metrics, only the fields corresponding to
        /// the hparam_tuning_objectives are set.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hparam_tuning_evaluation_metrics:
            std::option::Option<crate::model::model::EvaluationMetrics>,
    }

    impl HparamTuningTrial {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trial_id][crate::model::model::HparamTuningTrial::trial_id].
        pub fn set_trial_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.trial_id = v.into();
            self
        }

        /// Sets the value of [start_time_ms][crate::model::model::HparamTuningTrial::start_time_ms].
        pub fn set_start_time_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.start_time_ms = v.into();
            self
        }

        /// Sets the value of [end_time_ms][crate::model::model::HparamTuningTrial::end_time_ms].
        pub fn set_end_time_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.end_time_ms = v.into();
            self
        }

        /// Sets the value of [hparams][crate::model::model::HparamTuningTrial::hparams].
        pub fn set_hparams<
            T: std::convert::Into<
                std::option::Option<crate::model::model::training_run::TrainingOptions>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.hparams = v.into();
            self
        }

        /// Sets the value of [evaluation_metrics][crate::model::model::HparamTuningTrial::evaluation_metrics].
        pub fn set_evaluation_metrics<
            T: std::convert::Into<std::option::Option<crate::model::model::EvaluationMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.evaluation_metrics = v.into();
            self
        }

        /// Sets the value of [status][crate::model::model::HparamTuningTrial::status].
        pub fn set_status<
            T: std::convert::Into<crate::model::model::hparam_tuning_trial::TrialStatus>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::model::HparamTuningTrial::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [training_loss][crate::model::model::HparamTuningTrial::training_loss].
        pub fn set_training_loss<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.training_loss = v.into();
            self
        }

        /// Sets the value of [eval_loss][crate::model::model::HparamTuningTrial::eval_loss].
        pub fn set_eval_loss<T: std::convert::Into<std::option::Option<wkt::DoubleValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.eval_loss = v.into();
            self
        }

        /// Sets the value of [hparam_tuning_evaluation_metrics][crate::model::model::HparamTuningTrial::hparam_tuning_evaluation_metrics].
        pub fn set_hparam_tuning_evaluation_metrics<
            T: std::convert::Into<std::option::Option<crate::model::model::EvaluationMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.hparam_tuning_evaluation_metrics = v.into();
            self
        }
    }

    impl wkt::message::Message for HparamTuningTrial {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.HparamTuningTrial"
        }
    }

    /// Defines additional types related to HparamTuningTrial
    pub mod hparam_tuning_trial {
        #[allow(unused_imports)]
        use super::*;

        /// Current status of the trial.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct TrialStatus(i32);

        impl TrialStatus {
            /// Default value.
            pub const TRIAL_STATUS_UNSPECIFIED: TrialStatus = TrialStatus::new(0);

            /// Scheduled but not started.
            pub const NOT_STARTED: TrialStatus = TrialStatus::new(1);

            /// Running state.
            pub const RUNNING: TrialStatus = TrialStatus::new(2);

            /// The trial succeeded.
            pub const SUCCEEDED: TrialStatus = TrialStatus::new(3);

            /// The trial failed.
            pub const FAILED: TrialStatus = TrialStatus::new(4);

            /// The trial is infeasible due to the invalid params.
            pub const INFEASIBLE: TrialStatus = TrialStatus::new(5);

            /// Trial stopped early because it's not promising.
            pub const STOPPED_EARLY: TrialStatus = TrialStatus::new(6);

            /// Creates a new TrialStatus instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("TRIAL_STATUS_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("NOT_STARTED"),
                    2 => std::borrow::Cow::Borrowed("RUNNING"),
                    3 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                    4 => std::borrow::Cow::Borrowed("FAILED"),
                    5 => std::borrow::Cow::Borrowed("INFEASIBLE"),
                    6 => std::borrow::Cow::Borrowed("STOPPED_EARLY"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "TRIAL_STATUS_UNSPECIFIED" => {
                        std::option::Option::Some(Self::TRIAL_STATUS_UNSPECIFIED)
                    }
                    "NOT_STARTED" => std::option::Option::Some(Self::NOT_STARTED),
                    "RUNNING" => std::option::Option::Some(Self::RUNNING),
                    "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                    "FAILED" => std::option::Option::Some(Self::FAILED),
                    "INFEASIBLE" => std::option::Option::Some(Self::INFEASIBLE),
                    "STOPPED_EARLY" => std::option::Option::Some(Self::STOPPED_EARLY),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for TrialStatus {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for TrialStatus {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Indicates the type of the Model.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ModelType(i32);

    impl ModelType {
        /// Default value.
        pub const MODEL_TYPE_UNSPECIFIED: ModelType = ModelType::new(0);

        /// Linear regression model.
        pub const LINEAR_REGRESSION: ModelType = ModelType::new(1);

        /// Logistic regression based classification model.
        pub const LOGISTIC_REGRESSION: ModelType = ModelType::new(2);

        /// K-means clustering model.
        pub const KMEANS: ModelType = ModelType::new(3);

        /// Matrix factorization model.
        pub const MATRIX_FACTORIZATION: ModelType = ModelType::new(4);

        /// DNN classifier model.
        pub const DNN_CLASSIFIER: ModelType = ModelType::new(5);

        /// An imported TensorFlow model.
        pub const TENSORFLOW: ModelType = ModelType::new(6);

        /// DNN regressor model.
        pub const DNN_REGRESSOR: ModelType = ModelType::new(7);

        /// An imported XGBoost model.
        pub const XGBOOST: ModelType = ModelType::new(8);

        /// Boosted tree regressor model.
        pub const BOOSTED_TREE_REGRESSOR: ModelType = ModelType::new(9);

        /// Boosted tree classifier model.
        pub const BOOSTED_TREE_CLASSIFIER: ModelType = ModelType::new(10);

        /// ARIMA model.
        pub const ARIMA: ModelType = ModelType::new(11);

        /// AutoML Tables regression model.
        pub const AUTOML_REGRESSOR: ModelType = ModelType::new(12);

        /// AutoML Tables classification model.
        pub const AUTOML_CLASSIFIER: ModelType = ModelType::new(13);

        /// Prinpical Component Analysis model.
        pub const PCA: ModelType = ModelType::new(14);

        /// Wide-and-deep classifier model.
        pub const DNN_LINEAR_COMBINED_CLASSIFIER: ModelType = ModelType::new(16);

        /// Wide-and-deep regressor model.
        pub const DNN_LINEAR_COMBINED_REGRESSOR: ModelType = ModelType::new(17);

        /// Autoencoder model.
        pub const AUTOENCODER: ModelType = ModelType::new(18);

        /// New name for the ARIMA model.
        pub const ARIMA_PLUS: ModelType = ModelType::new(19);

        /// ARIMA with external regressors.
        pub const ARIMA_PLUS_XREG: ModelType = ModelType::new(23);

        /// Random forest regressor model.
        pub const RANDOM_FOREST_REGRESSOR: ModelType = ModelType::new(24);

        /// Random forest classifier model.
        pub const RANDOM_FOREST_CLASSIFIER: ModelType = ModelType::new(25);

        /// An imported TensorFlow Lite model.
        pub const TENSORFLOW_LITE: ModelType = ModelType::new(26);

        /// An imported ONNX model.
        pub const ONNX: ModelType = ModelType::new(28);

        /// Model to capture the columns and logic in the TRANSFORM clause along with
        /// statistics useful for ML analytic functions.
        pub const TRANSFORM_ONLY: ModelType = ModelType::new(29);

        /// The contribution analysis model.
        pub const CONTRIBUTION_ANALYSIS: ModelType = ModelType::new(37);

        /// Creates a new ModelType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MODEL_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LINEAR_REGRESSION"),
                2 => std::borrow::Cow::Borrowed("LOGISTIC_REGRESSION"),
                3 => std::borrow::Cow::Borrowed("KMEANS"),
                4 => std::borrow::Cow::Borrowed("MATRIX_FACTORIZATION"),
                5 => std::borrow::Cow::Borrowed("DNN_CLASSIFIER"),
                6 => std::borrow::Cow::Borrowed("TENSORFLOW"),
                7 => std::borrow::Cow::Borrowed("DNN_REGRESSOR"),
                8 => std::borrow::Cow::Borrowed("XGBOOST"),
                9 => std::borrow::Cow::Borrowed("BOOSTED_TREE_REGRESSOR"),
                10 => std::borrow::Cow::Borrowed("BOOSTED_TREE_CLASSIFIER"),
                11 => std::borrow::Cow::Borrowed("ARIMA"),
                12 => std::borrow::Cow::Borrowed("AUTOML_REGRESSOR"),
                13 => std::borrow::Cow::Borrowed("AUTOML_CLASSIFIER"),
                14 => std::borrow::Cow::Borrowed("PCA"),
                16 => std::borrow::Cow::Borrowed("DNN_LINEAR_COMBINED_CLASSIFIER"),
                17 => std::borrow::Cow::Borrowed("DNN_LINEAR_COMBINED_REGRESSOR"),
                18 => std::borrow::Cow::Borrowed("AUTOENCODER"),
                19 => std::borrow::Cow::Borrowed("ARIMA_PLUS"),
                23 => std::borrow::Cow::Borrowed("ARIMA_PLUS_XREG"),
                24 => std::borrow::Cow::Borrowed("RANDOM_FOREST_REGRESSOR"),
                25 => std::borrow::Cow::Borrowed("RANDOM_FOREST_CLASSIFIER"),
                26 => std::borrow::Cow::Borrowed("TENSORFLOW_LITE"),
                28 => std::borrow::Cow::Borrowed("ONNX"),
                29 => std::borrow::Cow::Borrowed("TRANSFORM_ONLY"),
                37 => std::borrow::Cow::Borrowed("CONTRIBUTION_ANALYSIS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MODEL_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::MODEL_TYPE_UNSPECIFIED),
                "LINEAR_REGRESSION" => std::option::Option::Some(Self::LINEAR_REGRESSION),
                "LOGISTIC_REGRESSION" => std::option::Option::Some(Self::LOGISTIC_REGRESSION),
                "KMEANS" => std::option::Option::Some(Self::KMEANS),
                "MATRIX_FACTORIZATION" => std::option::Option::Some(Self::MATRIX_FACTORIZATION),
                "DNN_CLASSIFIER" => std::option::Option::Some(Self::DNN_CLASSIFIER),
                "TENSORFLOW" => std::option::Option::Some(Self::TENSORFLOW),
                "DNN_REGRESSOR" => std::option::Option::Some(Self::DNN_REGRESSOR),
                "XGBOOST" => std::option::Option::Some(Self::XGBOOST),
                "BOOSTED_TREE_REGRESSOR" => std::option::Option::Some(Self::BOOSTED_TREE_REGRESSOR),
                "BOOSTED_TREE_CLASSIFIER" => {
                    std::option::Option::Some(Self::BOOSTED_TREE_CLASSIFIER)
                }
                "ARIMA" => std::option::Option::Some(Self::ARIMA),
                "AUTOML_REGRESSOR" => std::option::Option::Some(Self::AUTOML_REGRESSOR),
                "AUTOML_CLASSIFIER" => std::option::Option::Some(Self::AUTOML_CLASSIFIER),
                "PCA" => std::option::Option::Some(Self::PCA),
                "DNN_LINEAR_COMBINED_CLASSIFIER" => {
                    std::option::Option::Some(Self::DNN_LINEAR_COMBINED_CLASSIFIER)
                }
                "DNN_LINEAR_COMBINED_REGRESSOR" => {
                    std::option::Option::Some(Self::DNN_LINEAR_COMBINED_REGRESSOR)
                }
                "AUTOENCODER" => std::option::Option::Some(Self::AUTOENCODER),
                "ARIMA_PLUS" => std::option::Option::Some(Self::ARIMA_PLUS),
                "ARIMA_PLUS_XREG" => std::option::Option::Some(Self::ARIMA_PLUS_XREG),
                "RANDOM_FOREST_REGRESSOR" => {
                    std::option::Option::Some(Self::RANDOM_FOREST_REGRESSOR)
                }
                "RANDOM_FOREST_CLASSIFIER" => {
                    std::option::Option::Some(Self::RANDOM_FOREST_CLASSIFIER)
                }
                "TENSORFLOW_LITE" => std::option::Option::Some(Self::TENSORFLOW_LITE),
                "ONNX" => std::option::Option::Some(Self::ONNX),
                "TRANSFORM_ONLY" => std::option::Option::Some(Self::TRANSFORM_ONLY),
                "CONTRIBUTION_ANALYSIS" => std::option::Option::Some(Self::CONTRIBUTION_ANALYSIS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Loss metric to evaluate model training performance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LossType(i32);

    impl LossType {
        /// Default value.
        pub const LOSS_TYPE_UNSPECIFIED: LossType = LossType::new(0);

        /// Mean squared loss, used for linear regression.
        pub const MEAN_SQUARED_LOSS: LossType = LossType::new(1);

        /// Mean log loss, used for logistic regression.
        pub const MEAN_LOG_LOSS: LossType = LossType::new(2);

        /// Creates a new LossType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LOSS_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MEAN_SQUARED_LOSS"),
                2 => std::borrow::Cow::Borrowed("MEAN_LOG_LOSS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LOSS_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::LOSS_TYPE_UNSPECIFIED),
                "MEAN_SQUARED_LOSS" => std::option::Option::Some(Self::MEAN_SQUARED_LOSS),
                "MEAN_LOG_LOSS" => std::option::Option::Some(Self::MEAN_LOG_LOSS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LossType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LossType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Distance metric used to compute the distance between two points.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DistanceType(i32);

    impl DistanceType {
        /// Default value.
        pub const DISTANCE_TYPE_UNSPECIFIED: DistanceType = DistanceType::new(0);

        /// Eculidean distance.
        pub const EUCLIDEAN: DistanceType = DistanceType::new(1);

        /// Cosine distance.
        pub const COSINE: DistanceType = DistanceType::new(2);

        /// Creates a new DistanceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DISTANCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("EUCLIDEAN"),
                2 => std::borrow::Cow::Borrowed("COSINE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DISTANCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DISTANCE_TYPE_UNSPECIFIED)
                }
                "EUCLIDEAN" => std::option::Option::Some(Self::EUCLIDEAN),
                "COSINE" => std::option::Option::Some(Self::COSINE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DistanceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DistanceType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the method to split input data into multiple tables.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataSplitMethod(i32);

    impl DataSplitMethod {
        /// Default value.
        pub const DATA_SPLIT_METHOD_UNSPECIFIED: DataSplitMethod = DataSplitMethod::new(0);

        /// Splits data randomly.
        pub const RANDOM: DataSplitMethod = DataSplitMethod::new(1);

        /// Splits data with the user provided tags.
        pub const CUSTOM: DataSplitMethod = DataSplitMethod::new(2);

        /// Splits data sequentially.
        pub const SEQUENTIAL: DataSplitMethod = DataSplitMethod::new(3);

        /// Data split will be skipped.
        pub const NO_SPLIT: DataSplitMethod = DataSplitMethod::new(4);

        /// Splits data automatically: Uses NO_SPLIT if the data size is small.
        /// Otherwise uses RANDOM.
        pub const AUTO_SPLIT: DataSplitMethod = DataSplitMethod::new(5);

        /// Creates a new DataSplitMethod instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATA_SPLIT_METHOD_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RANDOM"),
                2 => std::borrow::Cow::Borrowed("CUSTOM"),
                3 => std::borrow::Cow::Borrowed("SEQUENTIAL"),
                4 => std::borrow::Cow::Borrowed("NO_SPLIT"),
                5 => std::borrow::Cow::Borrowed("AUTO_SPLIT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATA_SPLIT_METHOD_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATA_SPLIT_METHOD_UNSPECIFIED)
                }
                "RANDOM" => std::option::Option::Some(Self::RANDOM),
                "CUSTOM" => std::option::Option::Some(Self::CUSTOM),
                "SEQUENTIAL" => std::option::Option::Some(Self::SEQUENTIAL),
                "NO_SPLIT" => std::option::Option::Some(Self::NO_SPLIT),
                "AUTO_SPLIT" => std::option::Option::Some(Self::AUTO_SPLIT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DataSplitMethod {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DataSplitMethod {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of supported data frequency for time series forecasting models.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataFrequency(i32);

    impl DataFrequency {
        /// Default value.
        pub const DATA_FREQUENCY_UNSPECIFIED: DataFrequency = DataFrequency::new(0);

        /// Automatically inferred from timestamps.
        pub const AUTO_FREQUENCY: DataFrequency = DataFrequency::new(1);

        /// Yearly data.
        pub const YEARLY: DataFrequency = DataFrequency::new(2);

        /// Quarterly data.
        pub const QUARTERLY: DataFrequency = DataFrequency::new(3);

        /// Monthly data.
        pub const MONTHLY: DataFrequency = DataFrequency::new(4);

        /// Weekly data.
        pub const WEEKLY: DataFrequency = DataFrequency::new(5);

        /// Daily data.
        pub const DAILY: DataFrequency = DataFrequency::new(6);

        /// Hourly data.
        pub const HOURLY: DataFrequency = DataFrequency::new(7);

        /// Per-minute data.
        pub const PER_MINUTE: DataFrequency = DataFrequency::new(8);

        /// Creates a new DataFrequency instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATA_FREQUENCY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AUTO_FREQUENCY"),
                2 => std::borrow::Cow::Borrowed("YEARLY"),
                3 => std::borrow::Cow::Borrowed("QUARTERLY"),
                4 => std::borrow::Cow::Borrowed("MONTHLY"),
                5 => std::borrow::Cow::Borrowed("WEEKLY"),
                6 => std::borrow::Cow::Borrowed("DAILY"),
                7 => std::borrow::Cow::Borrowed("HOURLY"),
                8 => std::borrow::Cow::Borrowed("PER_MINUTE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATA_FREQUENCY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATA_FREQUENCY_UNSPECIFIED)
                }
                "AUTO_FREQUENCY" => std::option::Option::Some(Self::AUTO_FREQUENCY),
                "YEARLY" => std::option::Option::Some(Self::YEARLY),
                "QUARTERLY" => std::option::Option::Some(Self::QUARTERLY),
                "MONTHLY" => std::option::Option::Some(Self::MONTHLY),
                "WEEKLY" => std::option::Option::Some(Self::WEEKLY),
                "DAILY" => std::option::Option::Some(Self::DAILY),
                "HOURLY" => std::option::Option::Some(Self::HOURLY),
                "PER_MINUTE" => std::option::Option::Some(Self::PER_MINUTE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DataFrequency {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DataFrequency {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of supported holiday regions for time series forecasting models.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HolidayRegion(i32);

    impl HolidayRegion {
        /// Holiday region unspecified.
        pub const HOLIDAY_REGION_UNSPECIFIED: HolidayRegion = HolidayRegion::new(0);

        /// Global.
        pub const GLOBAL: HolidayRegion = HolidayRegion::new(1);

        /// North America.
        pub const NA: HolidayRegion = HolidayRegion::new(2);

        /// Japan and Asia Pacific: Korea, Greater China, India, Australia, and New
        /// Zealand.
        pub const JAPAC: HolidayRegion = HolidayRegion::new(3);

        /// Europe, the Middle East and Africa.
        pub const EMEA: HolidayRegion = HolidayRegion::new(4);

        /// Latin America and the Caribbean.
        pub const LAC: HolidayRegion = HolidayRegion::new(5);

        /// United Arab Emirates
        pub const AE: HolidayRegion = HolidayRegion::new(6);

        /// Argentina
        pub const AR: HolidayRegion = HolidayRegion::new(7);

        /// Austria
        pub const AT: HolidayRegion = HolidayRegion::new(8);

        /// Australia
        pub const AU: HolidayRegion = HolidayRegion::new(9);

        /// Belgium
        pub const BE: HolidayRegion = HolidayRegion::new(10);

        /// Brazil
        pub const BR: HolidayRegion = HolidayRegion::new(11);

        /// Canada
        pub const CA: HolidayRegion = HolidayRegion::new(12);

        /// Switzerland
        pub const CH: HolidayRegion = HolidayRegion::new(13);

        /// Chile
        pub const CL: HolidayRegion = HolidayRegion::new(14);

        /// China
        pub const CN: HolidayRegion = HolidayRegion::new(15);

        /// Colombia
        pub const CO: HolidayRegion = HolidayRegion::new(16);

        /// Czechoslovakia
        pub const CS: HolidayRegion = HolidayRegion::new(17);

        /// Czech Republic
        pub const CZ: HolidayRegion = HolidayRegion::new(18);

        /// Germany
        pub const DE: HolidayRegion = HolidayRegion::new(19);

        /// Denmark
        pub const DK: HolidayRegion = HolidayRegion::new(20);

        /// Algeria
        pub const DZ: HolidayRegion = HolidayRegion::new(21);

        /// Ecuador
        pub const EC: HolidayRegion = HolidayRegion::new(22);

        /// Estonia
        pub const EE: HolidayRegion = HolidayRegion::new(23);

        /// Egypt
        pub const EG: HolidayRegion = HolidayRegion::new(24);

        /// Spain
        pub const ES: HolidayRegion = HolidayRegion::new(25);

        /// Finland
        pub const FI: HolidayRegion = HolidayRegion::new(26);

        /// France
        pub const FR: HolidayRegion = HolidayRegion::new(27);

        /// Great Britain (United Kingdom)
        pub const GB: HolidayRegion = HolidayRegion::new(28);

        /// Greece
        pub const GR: HolidayRegion = HolidayRegion::new(29);

        /// Hong Kong
        pub const HK: HolidayRegion = HolidayRegion::new(30);

        /// Hungary
        pub const HU: HolidayRegion = HolidayRegion::new(31);

        /// Indonesia
        pub const ID: HolidayRegion = HolidayRegion::new(32);

        /// Ireland
        pub const IE: HolidayRegion = HolidayRegion::new(33);

        /// Israel
        pub const IL: HolidayRegion = HolidayRegion::new(34);

        /// India
        pub const IN: HolidayRegion = HolidayRegion::new(35);

        /// Iran
        pub const IR: HolidayRegion = HolidayRegion::new(36);

        /// Italy
        pub const IT: HolidayRegion = HolidayRegion::new(37);

        /// Japan
        pub const JP: HolidayRegion = HolidayRegion::new(38);

        /// Korea (South)
        pub const KR: HolidayRegion = HolidayRegion::new(39);

        /// Latvia
        pub const LV: HolidayRegion = HolidayRegion::new(40);

        /// Morocco
        pub const MA: HolidayRegion = HolidayRegion::new(41);

        /// Mexico
        pub const MX: HolidayRegion = HolidayRegion::new(42);

        /// Malaysia
        pub const MY: HolidayRegion = HolidayRegion::new(43);

        /// Nigeria
        pub const NG: HolidayRegion = HolidayRegion::new(44);

        /// Netherlands
        pub const NL: HolidayRegion = HolidayRegion::new(45);

        /// Norway
        pub const NO: HolidayRegion = HolidayRegion::new(46);

        /// New Zealand
        pub const NZ: HolidayRegion = HolidayRegion::new(47);

        /// Peru
        pub const PE: HolidayRegion = HolidayRegion::new(48);

        /// Philippines
        pub const PH: HolidayRegion = HolidayRegion::new(49);

        /// Pakistan
        pub const PK: HolidayRegion = HolidayRegion::new(50);

        /// Poland
        pub const PL: HolidayRegion = HolidayRegion::new(51);

        /// Portugal
        pub const PT: HolidayRegion = HolidayRegion::new(52);

        /// Romania
        pub const RO: HolidayRegion = HolidayRegion::new(53);

        /// Serbia
        pub const RS: HolidayRegion = HolidayRegion::new(54);

        /// Russian Federation
        pub const RU: HolidayRegion = HolidayRegion::new(55);

        /// Saudi Arabia
        pub const SA: HolidayRegion = HolidayRegion::new(56);

        /// Sweden
        pub const SE: HolidayRegion = HolidayRegion::new(57);

        /// Singapore
        pub const SG: HolidayRegion = HolidayRegion::new(58);

        /// Slovenia
        pub const SI: HolidayRegion = HolidayRegion::new(59);

        /// Slovakia
        pub const SK: HolidayRegion = HolidayRegion::new(60);

        /// Thailand
        pub const TH: HolidayRegion = HolidayRegion::new(61);

        /// Turkey
        pub const TR: HolidayRegion = HolidayRegion::new(62);

        /// Taiwan
        pub const TW: HolidayRegion = HolidayRegion::new(63);

        /// Ukraine
        pub const UA: HolidayRegion = HolidayRegion::new(64);

        /// United States
        pub const US: HolidayRegion = HolidayRegion::new(65);

        /// Venezuela
        pub const VE: HolidayRegion = HolidayRegion::new(66);

        /// Vietnam
        pub const VN: HolidayRegion = HolidayRegion::new(67);

        /// South Africa
        pub const ZA: HolidayRegion = HolidayRegion::new(68);

        /// Creates a new HolidayRegion instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("HOLIDAY_REGION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GLOBAL"),
                2 => std::borrow::Cow::Borrowed("NA"),
                3 => std::borrow::Cow::Borrowed("JAPAC"),
                4 => std::borrow::Cow::Borrowed("EMEA"),
                5 => std::borrow::Cow::Borrowed("LAC"),
                6 => std::borrow::Cow::Borrowed("AE"),
                7 => std::borrow::Cow::Borrowed("AR"),
                8 => std::borrow::Cow::Borrowed("AT"),
                9 => std::borrow::Cow::Borrowed("AU"),
                10 => std::borrow::Cow::Borrowed("BE"),
                11 => std::borrow::Cow::Borrowed("BR"),
                12 => std::borrow::Cow::Borrowed("CA"),
                13 => std::borrow::Cow::Borrowed("CH"),
                14 => std::borrow::Cow::Borrowed("CL"),
                15 => std::borrow::Cow::Borrowed("CN"),
                16 => std::borrow::Cow::Borrowed("CO"),
                17 => std::borrow::Cow::Borrowed("CS"),
                18 => std::borrow::Cow::Borrowed("CZ"),
                19 => std::borrow::Cow::Borrowed("DE"),
                20 => std::borrow::Cow::Borrowed("DK"),
                21 => std::borrow::Cow::Borrowed("DZ"),
                22 => std::borrow::Cow::Borrowed("EC"),
                23 => std::borrow::Cow::Borrowed("EE"),
                24 => std::borrow::Cow::Borrowed("EG"),
                25 => std::borrow::Cow::Borrowed("ES"),
                26 => std::borrow::Cow::Borrowed("FI"),
                27 => std::borrow::Cow::Borrowed("FR"),
                28 => std::borrow::Cow::Borrowed("GB"),
                29 => std::borrow::Cow::Borrowed("GR"),
                30 => std::borrow::Cow::Borrowed("HK"),
                31 => std::borrow::Cow::Borrowed("HU"),
                32 => std::borrow::Cow::Borrowed("ID"),
                33 => std::borrow::Cow::Borrowed("IE"),
                34 => std::borrow::Cow::Borrowed("IL"),
                35 => std::borrow::Cow::Borrowed("IN"),
                36 => std::borrow::Cow::Borrowed("IR"),
                37 => std::borrow::Cow::Borrowed("IT"),
                38 => std::borrow::Cow::Borrowed("JP"),
                39 => std::borrow::Cow::Borrowed("KR"),
                40 => std::borrow::Cow::Borrowed("LV"),
                41 => std::borrow::Cow::Borrowed("MA"),
                42 => std::borrow::Cow::Borrowed("MX"),
                43 => std::borrow::Cow::Borrowed("MY"),
                44 => std::borrow::Cow::Borrowed("NG"),
                45 => std::borrow::Cow::Borrowed("NL"),
                46 => std::borrow::Cow::Borrowed("NO"),
                47 => std::borrow::Cow::Borrowed("NZ"),
                48 => std::borrow::Cow::Borrowed("PE"),
                49 => std::borrow::Cow::Borrowed("PH"),
                50 => std::borrow::Cow::Borrowed("PK"),
                51 => std::borrow::Cow::Borrowed("PL"),
                52 => std::borrow::Cow::Borrowed("PT"),
                53 => std::borrow::Cow::Borrowed("RO"),
                54 => std::borrow::Cow::Borrowed("RS"),
                55 => std::borrow::Cow::Borrowed("RU"),
                56 => std::borrow::Cow::Borrowed("SA"),
                57 => std::borrow::Cow::Borrowed("SE"),
                58 => std::borrow::Cow::Borrowed("SG"),
                59 => std::borrow::Cow::Borrowed("SI"),
                60 => std::borrow::Cow::Borrowed("SK"),
                61 => std::borrow::Cow::Borrowed("TH"),
                62 => std::borrow::Cow::Borrowed("TR"),
                63 => std::borrow::Cow::Borrowed("TW"),
                64 => std::borrow::Cow::Borrowed("UA"),
                65 => std::borrow::Cow::Borrowed("US"),
                66 => std::borrow::Cow::Borrowed("VE"),
                67 => std::borrow::Cow::Borrowed("VN"),
                68 => std::borrow::Cow::Borrowed("ZA"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "HOLIDAY_REGION_UNSPECIFIED" => {
                    std::option::Option::Some(Self::HOLIDAY_REGION_UNSPECIFIED)
                }
                "GLOBAL" => std::option::Option::Some(Self::GLOBAL),
                "NA" => std::option::Option::Some(Self::NA),
                "JAPAC" => std::option::Option::Some(Self::JAPAC),
                "EMEA" => std::option::Option::Some(Self::EMEA),
                "LAC" => std::option::Option::Some(Self::LAC),
                "AE" => std::option::Option::Some(Self::AE),
                "AR" => std::option::Option::Some(Self::AR),
                "AT" => std::option::Option::Some(Self::AT),
                "AU" => std::option::Option::Some(Self::AU),
                "BE" => std::option::Option::Some(Self::BE),
                "BR" => std::option::Option::Some(Self::BR),
                "CA" => std::option::Option::Some(Self::CA),
                "CH" => std::option::Option::Some(Self::CH),
                "CL" => std::option::Option::Some(Self::CL),
                "CN" => std::option::Option::Some(Self::CN),
                "CO" => std::option::Option::Some(Self::CO),
                "CS" => std::option::Option::Some(Self::CS),
                "CZ" => std::option::Option::Some(Self::CZ),
                "DE" => std::option::Option::Some(Self::DE),
                "DK" => std::option::Option::Some(Self::DK),
                "DZ" => std::option::Option::Some(Self::DZ),
                "EC" => std::option::Option::Some(Self::EC),
                "EE" => std::option::Option::Some(Self::EE),
                "EG" => std::option::Option::Some(Self::EG),
                "ES" => std::option::Option::Some(Self::ES),
                "FI" => std::option::Option::Some(Self::FI),
                "FR" => std::option::Option::Some(Self::FR),
                "GB" => std::option::Option::Some(Self::GB),
                "GR" => std::option::Option::Some(Self::GR),
                "HK" => std::option::Option::Some(Self::HK),
                "HU" => std::option::Option::Some(Self::HU),
                "ID" => std::option::Option::Some(Self::ID),
                "IE" => std::option::Option::Some(Self::IE),
                "IL" => std::option::Option::Some(Self::IL),
                "IN" => std::option::Option::Some(Self::IN),
                "IR" => std::option::Option::Some(Self::IR),
                "IT" => std::option::Option::Some(Self::IT),
                "JP" => std::option::Option::Some(Self::JP),
                "KR" => std::option::Option::Some(Self::KR),
                "LV" => std::option::Option::Some(Self::LV),
                "MA" => std::option::Option::Some(Self::MA),
                "MX" => std::option::Option::Some(Self::MX),
                "MY" => std::option::Option::Some(Self::MY),
                "NG" => std::option::Option::Some(Self::NG),
                "NL" => std::option::Option::Some(Self::NL),
                "NO" => std::option::Option::Some(Self::NO),
                "NZ" => std::option::Option::Some(Self::NZ),
                "PE" => std::option::Option::Some(Self::PE),
                "PH" => std::option::Option::Some(Self::PH),
                "PK" => std::option::Option::Some(Self::PK),
                "PL" => std::option::Option::Some(Self::PL),
                "PT" => std::option::Option::Some(Self::PT),
                "RO" => std::option::Option::Some(Self::RO),
                "RS" => std::option::Option::Some(Self::RS),
                "RU" => std::option::Option::Some(Self::RU),
                "SA" => std::option::Option::Some(Self::SA),
                "SE" => std::option::Option::Some(Self::SE),
                "SG" => std::option::Option::Some(Self::SG),
                "SI" => std::option::Option::Some(Self::SI),
                "SK" => std::option::Option::Some(Self::SK),
                "TH" => std::option::Option::Some(Self::TH),
                "TR" => std::option::Option::Some(Self::TR),
                "TW" => std::option::Option::Some(Self::TW),
                "UA" => std::option::Option::Some(Self::UA),
                "US" => std::option::Option::Some(Self::US),
                "VE" => std::option::Option::Some(Self::VE),
                "VN" => std::option::Option::Some(Self::VN),
                "ZA" => std::option::Option::Some(Self::ZA),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for HolidayRegion {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for HolidayRegion {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Enums for color space, used for processing images in Object Table.
    /// See more details at
    /// <https://www.tensorflow.org/io/tutorials/colorspace>.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ColorSpace(i32);

    impl ColorSpace {
        /// Unspecified color space
        pub const COLOR_SPACE_UNSPECIFIED: ColorSpace = ColorSpace::new(0);

        /// RGB
        pub const RGB: ColorSpace = ColorSpace::new(1);

        /// HSV
        pub const HSV: ColorSpace = ColorSpace::new(2);

        /// YIQ
        pub const YIQ: ColorSpace = ColorSpace::new(3);

        /// YUV
        pub const YUV: ColorSpace = ColorSpace::new(4);

        /// GRAYSCALE
        pub const GRAYSCALE: ColorSpace = ColorSpace::new(5);

        /// Creates a new ColorSpace instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("COLOR_SPACE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RGB"),
                2 => std::borrow::Cow::Borrowed("HSV"),
                3 => std::borrow::Cow::Borrowed("YIQ"),
                4 => std::borrow::Cow::Borrowed("YUV"),
                5 => std::borrow::Cow::Borrowed("GRAYSCALE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "COLOR_SPACE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::COLOR_SPACE_UNSPECIFIED)
                }
                "RGB" => std::option::Option::Some(Self::RGB),
                "HSV" => std::option::Option::Some(Self::HSV),
                "YIQ" => std::option::Option::Some(Self::YIQ),
                "YUV" => std::option::Option::Some(Self::YUV),
                "GRAYSCALE" => std::option::Option::Some(Self::GRAYSCALE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ColorSpace {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ColorSpace {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the learning rate optimization strategy to use.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LearnRateStrategy(i32);

    impl LearnRateStrategy {
        /// Default value.
        pub const LEARN_RATE_STRATEGY_UNSPECIFIED: LearnRateStrategy = LearnRateStrategy::new(0);

        /// Use line search to determine learning rate.
        pub const LINE_SEARCH: LearnRateStrategy = LearnRateStrategy::new(1);

        /// Use a constant learning rate.
        pub const CONSTANT: LearnRateStrategy = LearnRateStrategy::new(2);

        /// Creates a new LearnRateStrategy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LEARN_RATE_STRATEGY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LINE_SEARCH"),
                2 => std::borrow::Cow::Borrowed("CONSTANT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LEARN_RATE_STRATEGY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::LEARN_RATE_STRATEGY_UNSPECIFIED)
                }
                "LINE_SEARCH" => std::option::Option::Some(Self::LINE_SEARCH),
                "CONSTANT" => std::option::Option::Some(Self::CONSTANT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LearnRateStrategy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LearnRateStrategy {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the optimization strategy used for training.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct OptimizationStrategy(i32);

    impl OptimizationStrategy {
        /// Default value.
        pub const OPTIMIZATION_STRATEGY_UNSPECIFIED: OptimizationStrategy =
            OptimizationStrategy::new(0);

        /// Uses an iterative batch gradient descent algorithm.
        pub const BATCH_GRADIENT_DESCENT: OptimizationStrategy = OptimizationStrategy::new(1);

        /// Uses a normal equation to solve linear regression problem.
        pub const NORMAL_EQUATION: OptimizationStrategy = OptimizationStrategy::new(2);

        /// Creates a new OptimizationStrategy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("OPTIMIZATION_STRATEGY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BATCH_GRADIENT_DESCENT"),
                2 => std::borrow::Cow::Borrowed("NORMAL_EQUATION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "OPTIMIZATION_STRATEGY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::OPTIMIZATION_STRATEGY_UNSPECIFIED)
                }
                "BATCH_GRADIENT_DESCENT" => std::option::Option::Some(Self::BATCH_GRADIENT_DESCENT),
                "NORMAL_EQUATION" => std::option::Option::Some(Self::NORMAL_EQUATION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for OptimizationStrategy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for OptimizationStrategy {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Indicates the training algorithm to use for matrix factorization models.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FeedbackType(i32);

    impl FeedbackType {
        /// Default value.
        pub const FEEDBACK_TYPE_UNSPECIFIED: FeedbackType = FeedbackType::new(0);

        /// Use weighted-als for implicit feedback problems.
        pub const IMPLICIT: FeedbackType = FeedbackType::new(1);

        /// Use nonweighted-als for explicit feedback problems.
        pub const EXPLICIT: FeedbackType = FeedbackType::new(2);

        /// Creates a new FeedbackType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FEEDBACK_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IMPLICIT"),
                2 => std::borrow::Cow::Borrowed("EXPLICIT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FEEDBACK_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::FEEDBACK_TYPE_UNSPECIFIED)
                }
                "IMPLICIT" => std::option::Option::Some(Self::IMPLICIT),
                "EXPLICIT" => std::option::Option::Some(Self::EXPLICIT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FeedbackType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FeedbackType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request format for getting information about a BigQuery ML model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. Project ID of the requested model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Model ID of the requested model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetModelRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetModelRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::GetModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetModelRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchModelRequest {
    /// Required. Project ID of the model to patch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the model to patch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Model ID of the model to patch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Required. Patched model.
    /// Follows RFC5789 patch semantics. Missing fields are not updated.
    /// To clear a field, explicitly set to default value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,
}

impl PatchModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PatchModelRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::PatchModelRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::PatchModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::PatchModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for PatchModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PatchModelRequest"
    }
}

/// Request format for deleting BigQuery ML models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. Project ID of the model to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the model to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Model ID of the model to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteModelRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteModelRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::DeleteModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteModelRequest"
    }
}

/// Request format for listing BigQuery ML models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. Project ID of the models to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the models to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call to request the next page of
    /// results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListModelsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListModelsRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListModelsRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<std::option::Option<wkt::UInt32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListModelsRequest"
    }
}

/// Response format for a single page when listing BigQuery ML models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// Models in the requested dataset. Only the following fields are populated:
    /// model_reference, model_type, creation_time, last_modified_time and
    /// labels.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to request the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListModelsResponse"
    }
}

/// Id path of a model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelReference {
    /// Required. The ID of the project containing this model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. The ID of the model. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 1,024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,
}

impl ModelReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ModelReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ModelReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::ModelReference::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }
}

impl wkt::message::Message for ModelReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ModelReference"
    }
}

/// The partitioning information, which includes managed table, external table
/// and metastore partitioned table partition information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartitioningDefinition {
    /// Optional. Details about each partitioning column. This field is output only
    /// for all partitioning types other than metastore partitioned tables.
    /// BigQuery native tables only support 1 partitioning column. Other table
    /// types may support 0, 1 or more partitioning columns.
    /// For metastore partitioned tables, the order must match the definition order
    /// in the Hive Metastore, where it must match the physical layout of the
    /// table. For example,
    ///
    /// CREATE TABLE a_table(id BIGINT, name STRING)
    /// PARTITIONED BY (city STRING, state STRING).
    ///
    /// In this case the values must be ['city', 'state'] in that order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partitioned_column: std::vec::Vec<crate::model::PartitionedColumn>,
}

impl PartitioningDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partitioned_column][crate::model::PartitioningDefinition::partitioned_column].
    pub fn set_partitioned_column<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PartitionedColumn>,
    {
        use std::iter::Iterator;
        self.partitioned_column = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartitioningDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PartitioningDefinition"
    }
}

/// The partitioning column information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartitionedColumn {
    /// Required. The name of the partition column.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<std::string::String>,
}

impl PartitionedColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::PartitionedColumn::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for PartitionedColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PartitionedColumn"
    }
}

/// Represents privacy policy associated with "aggregation threshold" method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AggregationThresholdPolicy {
    /// Optional. The threshold for the "aggregation threshold" policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub threshold: std::option::Option<i64>,

    /// Optional. The privacy unit column(s) associated with this policy.
    /// For now, only one column per data source object (table, view) is allowed as
    /// a privacy unit column.
    /// Representing as a repeated field in metadata for extensibility to
    /// multiple columns in future.
    /// Duplicates and Repeated struct fields are not allowed.
    /// For nested fields, use dot notation ("outer.inner")
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub privacy_unit_columns: std::vec::Vec<std::string::String>,
}

impl AggregationThresholdPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threshold][crate::model::AggregationThresholdPolicy::threshold].
    pub fn set_threshold<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.threshold = v.into();
        self
    }

    /// Sets the value of [privacy_unit_columns][crate::model::AggregationThresholdPolicy::privacy_unit_columns].
    pub fn set_privacy_unit_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.privacy_unit_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AggregationThresholdPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.AggregationThresholdPolicy"
    }
}

/// Represents privacy policy associated with "differential privacy" method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DifferentialPrivacyPolicy {
    /// Optional. The maximum epsilon value that a query can consume. If the
    /// subscriber specifies epsilon as a parameter in a SELECT query, it must be
    /// less than or equal to this value. The epsilon parameter controls the amount
    /// of noise that is added to the groups  a higher epsilon means less noise.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_epsilon_per_query: std::option::Option<f64>,

    /// Optional. The delta value that is used per query. Delta represents the
    /// probability that any row will fail to be epsilon differentially private.
    /// Indicates the risk associated with exposing aggregate rows in the result of
    /// a query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delta_per_query: std::option::Option<f64>,

    /// Optional. The maximum groups contributed value that is used per query.
    /// Represents the maximum number of groups to which each protected entity can
    /// contribute. Changing this value does not improve or worsen privacy. The
    /// best value for accuracy and utility depends on the query and data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_groups_contributed: std::option::Option<i64>,

    /// Optional. The privacy unit column associated with this policy. Differential
    /// privacy policies can only have one privacy unit column per data source
    /// object (table, view).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privacy_unit_column: std::option::Option<std::string::String>,

    /// Optional. The total epsilon budget for all queries against the
    /// privacy-protected view. Each subscriber query against this view charges the
    /// amount of epsilon they request in their query. If there is sufficient
    /// budget, then the subscriber query attempts to complete. It might still fail
    /// due to other reasons, in which case the charge is refunded. If there is
    /// insufficient budget the query is rejected. There might be multiple charge
    /// attempts if a single query references multiple views. In this case there
    /// must be sufficient budget for all charges or the query is rejected and
    /// charges are refunded in best effort. The budget does not have a refresh
    /// policy and can only be updated via ALTER VIEW or circumvented by creating a
    /// new view that can be queried with a fresh budget.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub epsilon_budget: std::option::Option<f64>,

    /// Optional. The total delta budget for all queries against the
    /// privacy-protected view. Each subscriber query against this view charges the
    /// amount of delta that is pre-defined by the contributor through the privacy
    /// policy delta_per_query field. If there is sufficient budget, then the
    /// subscriber query attempts to complete. It might still fail due to other
    /// reasons, in which case the charge is refunded. If there is insufficient
    /// budget the query is rejected. There might be multiple charge attempts if a
    /// single query references multiple views. In this case there must be
    /// sufficient budget for all charges or the query is rejected and charges are
    /// refunded in best effort. The budget does not have a refresh policy and can
    /// only be updated via ALTER VIEW or circumvented by creating a new view that
    /// can be queried with a fresh budget.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delta_budget: std::option::Option<f64>,

    /// Output only. The epsilon budget remaining. If budget is exhausted, no more
    /// queries are allowed. Note that the budget for queries that are in progress
    /// is deducted before the query executes. If the query fails or is cancelled
    /// then the budget is refunded. In this case the amount of budget remaining
    /// can increase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub epsilon_budget_remaining: std::option::Option<f64>,

    /// Output only. The delta budget remaining. If budget is exhausted, no more
    /// queries are allowed. Note that the budget for queries that are in progress
    /// is deducted before the query executes. If the query fails or is cancelled
    /// then the budget is refunded. In this case the amount of budget remaining
    /// can increase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delta_budget_remaining: std::option::Option<f64>,
}

impl DifferentialPrivacyPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_epsilon_per_query][crate::model::DifferentialPrivacyPolicy::max_epsilon_per_query].
    pub fn set_max_epsilon_per_query<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_epsilon_per_query = v.into();
        self
    }

    /// Sets the value of [delta_per_query][crate::model::DifferentialPrivacyPolicy::delta_per_query].
    pub fn set_delta_per_query<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delta_per_query = v.into();
        self
    }

    /// Sets the value of [max_groups_contributed][crate::model::DifferentialPrivacyPolicy::max_groups_contributed].
    pub fn set_max_groups_contributed<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_groups_contributed = v.into();
        self
    }

    /// Sets the value of [privacy_unit_column][crate::model::DifferentialPrivacyPolicy::privacy_unit_column].
    pub fn set_privacy_unit_column<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_unit_column = v.into();
        self
    }

    /// Sets the value of [epsilon_budget][crate::model::DifferentialPrivacyPolicy::epsilon_budget].
    pub fn set_epsilon_budget<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.epsilon_budget = v.into();
        self
    }

    /// Sets the value of [delta_budget][crate::model::DifferentialPrivacyPolicy::delta_budget].
    pub fn set_delta_budget<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delta_budget = v.into();
        self
    }

    /// Sets the value of [epsilon_budget_remaining][crate::model::DifferentialPrivacyPolicy::epsilon_budget_remaining].
    pub fn set_epsilon_budget_remaining<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.epsilon_budget_remaining = v.into();
        self
    }

    /// Sets the value of [delta_budget_remaining][crate::model::DifferentialPrivacyPolicy::delta_budget_remaining].
    pub fn set_delta_budget_remaining<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delta_budget_remaining = v.into();
        self
    }
}

impl wkt::message::Message for DifferentialPrivacyPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DifferentialPrivacyPolicy"
    }
}

/// Represents privacy policy associated with "join restrictions". Join
/// restriction gives data providers the ability to enforce joins on the
/// 'join_allowed_columns' when data is queried from a privacy protected view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JoinRestrictionPolicy {
    /// Optional. Specifies if a join is required or not on queries for the view.
    /// Default is JOIN_CONDITION_UNSPECIFIED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub join_condition: std::option::Option<crate::model::join_restriction_policy::JoinCondition>,

    /// Optional. The only columns that joins are allowed on.
    /// This field is must be specified for join_conditions JOIN_ANY and JOIN_ALL
    /// and it cannot be set for JOIN_BLOCKED.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub join_allowed_columns: std::vec::Vec<std::string::String>,
}

impl JoinRestrictionPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [join_condition][crate::model::JoinRestrictionPolicy::join_condition].
    pub fn set_join_condition<
        T: std::convert::Into<
            std::option::Option<crate::model::join_restriction_policy::JoinCondition>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.join_condition = v.into();
        self
    }

    /// Sets the value of [join_allowed_columns][crate::model::JoinRestrictionPolicy::join_allowed_columns].
    pub fn set_join_allowed_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.join_allowed_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JoinRestrictionPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JoinRestrictionPolicy"
    }
}

/// Defines additional types related to JoinRestrictionPolicy
pub mod join_restriction_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for Join Restrictions policy.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct JoinCondition(i32);

    impl JoinCondition {
        /// A join is neither required nor restricted on any column. Default value.
        pub const JOIN_CONDITION_UNSPECIFIED: JoinCondition = JoinCondition::new(0);

        /// A join is required on at least one of the specified columns.
        pub const JOIN_ANY: JoinCondition = JoinCondition::new(1);

        /// A join is required on all specified columns.
        pub const JOIN_ALL: JoinCondition = JoinCondition::new(2);

        /// A join is not required, but if present it is only permitted on
        /// 'join_allowed_columns'
        pub const JOIN_NOT_REQUIRED: JoinCondition = JoinCondition::new(3);

        /// Joins are blocked for all queries.
        pub const JOIN_BLOCKED: JoinCondition = JoinCondition::new(4);

        /// Creates a new JoinCondition instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("JOIN_CONDITION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("JOIN_ANY"),
                2 => std::borrow::Cow::Borrowed("JOIN_ALL"),
                3 => std::borrow::Cow::Borrowed("JOIN_NOT_REQUIRED"),
                4 => std::borrow::Cow::Borrowed("JOIN_BLOCKED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "JOIN_CONDITION_UNSPECIFIED" => {
                    std::option::Option::Some(Self::JOIN_CONDITION_UNSPECIFIED)
                }
                "JOIN_ANY" => std::option::Option::Some(Self::JOIN_ANY),
                "JOIN_ALL" => std::option::Option::Some(Self::JOIN_ALL),
                "JOIN_NOT_REQUIRED" => std::option::Option::Some(Self::JOIN_NOT_REQUIRED),
                "JOIN_BLOCKED" => std::option::Option::Some(Self::JOIN_BLOCKED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for JoinCondition {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for JoinCondition {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Represents privacy policy that contains the privacy requirements specified by
/// the data owner. Currently, this is only supported on views.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivacyPolicy {
    /// Optional. Join restriction policy is outside of the one of policies, since
    /// this policy can be set along with other policies. This policy gives data
    /// providers the ability to enforce joins on the 'join_allowed_columns' when
    /// data is queried from a privacy protected view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub join_restriction_policy: std::option::Option<crate::model::JoinRestrictionPolicy>,

    /// Privacy policy associated with this requirement specification. Only one of
    /// the privacy methods is allowed per data source object.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub privacy_policy: std::option::Option<crate::model::privacy_policy::PrivacyPolicy>,
}

impl PrivacyPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [join_restriction_policy][crate::model::PrivacyPolicy::join_restriction_policy].
    pub fn set_join_restriction_policy<
        T: std::convert::Into<std::option::Option<crate::model::JoinRestrictionPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.join_restriction_policy = v.into();
        self
    }

    /// Sets the value of `privacy_policy`.
    pub fn set_privacy_policy<
        T: std::convert::Into<std::option::Option<crate::model::privacy_policy::PrivacyPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = v.into();
        self
    }

    /// The value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// if it holds a `AggregationThresholdPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_aggregation_threshold_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AggregationThresholdPolicy>> {
        #[allow(unreachable_patterns)]
        self.privacy_policy.as_ref().and_then(|v| match v {
            crate::model::privacy_policy::PrivacyPolicy::AggregationThresholdPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// if it holds a `DifferentialPrivacyPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_differential_privacy_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DifferentialPrivacyPolicy>> {
        #[allow(unreachable_patterns)]
        self.privacy_policy.as_ref().and_then(|v| match v {
            crate::model::privacy_policy::PrivacyPolicy::DifferentialPrivacyPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// to hold a `AggregationThresholdPolicy`.
    ///
    /// Note that all the setters affecting `privacy_policy` are
    /// mutually exclusive.
    pub fn set_aggregation_threshold_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::AggregationThresholdPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = std::option::Option::Some(
            crate::model::privacy_policy::PrivacyPolicy::AggregationThresholdPolicy(v.into()),
        );
        self
    }

    /// Sets the value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// to hold a `DifferentialPrivacyPolicy`.
    ///
    /// Note that all the setters affecting `privacy_policy` are
    /// mutually exclusive.
    pub fn set_differential_privacy_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::DifferentialPrivacyPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = std::option::Option::Some(
            crate::model::privacy_policy::PrivacyPolicy::DifferentialPrivacyPolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivacyPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PrivacyPolicy"
    }
}

/// Defines additional types related to PrivacyPolicy
pub mod privacy_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Privacy policy associated with this requirement specification. Only one of
    /// the privacy methods is allowed per data source object.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PrivacyPolicy {
        /// Optional. Policy used for aggregation thresholds.
        AggregationThresholdPolicy(std::boxed::Box<crate::model::AggregationThresholdPolicy>),
        /// Optional. Policy used for differential privacy.
        DifferentialPrivacyPolicy(std::boxed::Box<crate::model::DifferentialPrivacyPolicy>),
    }
}

/// Request object of GetServiceAccount
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceAccountRequest {
    /// Required. ID of the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,
}

impl GetServiceAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetServiceAccountRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetServiceAccountRequest"
    }
}

/// Response object of GetServiceAccount
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceAccountResponse {
    /// The resource type of the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The service account email address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,
}

impl GetServiceAccountResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::GetServiceAccountResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [email][crate::model::GetServiceAccountResponse::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceAccountResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetServiceAccountResponse"
    }
}

/// The type of a struct parameter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryParameterStructType {
    /// Optional. The name of this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The type of this field.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>,

    /// Optional. Human-oriented description of the field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl QueryParameterStructType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryParameterStructType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::QueryParameterStructType::type].
    pub fn set_type<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::QueryParameterStructType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for QueryParameterStructType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameterStructType"
    }
}

/// The type of a query parameter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryParameterType {
    /// Required. The top level type of this field.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. The type of the array's elements, if this is an array.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub array_type: std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>,

    /// Optional. The types of the fields of this struct, in order, if this is a
    /// struct.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub struct_types: std::vec::Vec<crate::model::QueryParameterStructType>,

    /// Optional. The element type of the range, if this is a range.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_element_type: std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>,
}

impl QueryParameterType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::QueryParameterType::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [array_type][crate::model::QueryParameterType::array_type].
    pub fn set_array_type<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.array_type = v.into();
        self
    }

    /// Sets the value of [range_element_type][crate::model::QueryParameterType::range_element_type].
    pub fn set_range_element_type<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_element_type = v.into();
        self
    }

    /// Sets the value of [struct_types][crate::model::QueryParameterType::struct_types].
    pub fn set_struct_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryParameterStructType>,
    {
        use std::iter::Iterator;
        self.struct_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryParameterType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameterType"
    }
}

/// Represents the value of a range.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RangeValue {
    /// Optional. The start value of the range. A missing value represents an
    /// unbounded start.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start: std::option::Option<std::boxed::Box<crate::model::QueryParameterValue>>,

    /// Optional. The end value of the range. A missing value represents an
    /// unbounded end.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end: std::option::Option<std::boxed::Box<crate::model::QueryParameterValue>>,
}

impl RangeValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::RangeValue::start].
    pub fn set_start<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::QueryParameterValue>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::RangeValue::end].
    pub fn set_end<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::QueryParameterValue>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.end = v.into();
        self
    }
}

impl wkt::message::Message for RangeValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RangeValue"
    }
}

/// The value of a query parameter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryParameterValue {
    /// Optional. The value of this value, if a simple scalar type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<wkt::StringValue>,

    /// Optional. The array values, if this is an array type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub array_values: std::vec::Vec<crate::model::QueryParameterValue>,

    /// The struct field values.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub struct_values:
        std::collections::HashMap<std::string::String, crate::model::QueryParameterValue>,

    /// Optional. The range value, if this is a range type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_value: std::option::Option<std::boxed::Box<crate::model::RangeValue>>,

    /// This field should not be used.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alt_struct_values: std::vec::Vec<wkt::Value>,
}

impl QueryParameterValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::QueryParameterValue::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [range_value][crate::model::QueryParameterValue::range_value].
    pub fn set_range_value<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::RangeValue>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_value = v.into();
        self
    }

    /// Sets the value of [array_values][crate::model::QueryParameterValue::array_values].
    pub fn set_array_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryParameterValue>,
    {
        use std::iter::Iterator;
        self.array_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [alt_struct_values][crate::model::QueryParameterValue::alt_struct_values].
    pub fn set_alt_struct_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.alt_struct_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [struct_values][crate::model::QueryParameterValue::struct_values].
    pub fn set_struct_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::QueryParameterValue>,
    {
        use std::iter::Iterator;
        self.struct_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for QueryParameterValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameterValue"
    }
}

/// A parameter given to a query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryParameter {
    /// Optional. If unset, this is a positional parameter. Otherwise, should be
    /// unique within a query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The type of this parameter.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameter_type: std::option::Option<crate::model::QueryParameterType>,

    /// Required. The value of this parameter.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parameter_value: std::option::Option<crate::model::QueryParameterValue>,
}

impl QueryParameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryParameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parameter_type][crate::model::QueryParameter::parameter_type].
    pub fn set_parameter_type<
        T: std::convert::Into<std::option::Option<crate::model::QueryParameterType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameter_type = v.into();
        self
    }

    /// Sets the value of [parameter_value][crate::model::QueryParameter::parameter_value].
    pub fn set_parameter_value<
        T: std::convert::Into<std::option::Option<crate::model::QueryParameterValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parameter_value = v.into();
        self
    }
}

impl wkt::message::Message for QueryParameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameter"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RangePartitioning {
    /// Required. The name of the column to partition the table on. It must be a
    /// top-level, INT64 column whose mode is NULLABLE or REQUIRED.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field: std::string::String,

    /// Defines the ranges for range partitioning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range: std::option::Option<crate::model::range_partitioning::Range>,
}

impl RangePartitioning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::RangePartitioning::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [range][crate::model::RangePartitioning::range].
    pub fn set_range<
        T: std::convert::Into<std::option::Option<crate::model::range_partitioning::Range>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range = v.into();
        self
    }
}

impl wkt::message::Message for RangePartitioning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RangePartitioning"
    }
}

/// Defines additional types related to RangePartitioning
pub mod range_partitioning {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the ranges for range partitioning.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Range {
        /// Required. The start of range partitioning, inclusive. This field is an
        /// INT64 value represented as a string.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub start: std::string::String,

        /// Required. The end of range partitioning, exclusive. This field is an
        /// INT64 value represented as a string.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub end: std::string::String,

        /// Required. The width of each interval. This field is an INT64 value
        /// represented as a string.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub interval: std::string::String,
    }

    impl Range {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start][crate::model::range_partitioning::Range::start].
        pub fn set_start<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.start = v.into();
            self
        }

        /// Sets the value of [end][crate::model::range_partitioning::Range::end].
        pub fn set_end<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.end = v.into();
            self
        }

        /// Sets the value of [interval][crate::model::range_partitioning::Range::interval].
        pub fn set_interval<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.interval = v.into();
            self
        }
    }

    impl wkt::message::Message for Range {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.RangePartitioning.Range"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestrictionConfig {
    /// Output only. Specifies the type of dataset/table restriction.
    #[serde(rename = "type")]
    pub r#type: crate::model::restriction_config::RestrictionType,
}

impl RestrictionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::RestrictionConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::restriction_config::RestrictionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for RestrictionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RestrictionConfig"
    }
}

/// Defines additional types related to RestrictionConfig
pub mod restriction_config {
    #[allow(unused_imports)]
    use super::*;

    /// RestrictionType specifies the type of dataset/table restriction.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RestrictionType(i32);

    impl RestrictionType {
        /// Should never be used.
        pub const RESTRICTION_TYPE_UNSPECIFIED: RestrictionType = RestrictionType::new(0);

        /// Restrict data egress. See [Data
        /// egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
        /// for more details.
        pub const RESTRICTED_DATA_EGRESS: RestrictionType = RestrictionType::new(1);

        /// Creates a new RestrictionType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESTRICTION_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RESTRICTED_DATA_EGRESS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESTRICTION_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RESTRICTION_TYPE_UNSPECIFIED)
                }
                "RESTRICTED_DATA_EGRESS" => std::option::Option::Some(Self::RESTRICTED_DATA_EGRESS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RestrictionType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RestrictionType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A user-defined function or a stored procedure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Routine {
    /// Output only. A hash of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Required. Reference describing the ID of this routine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routine_reference: std::option::Option<crate::model::RoutineReference>,

    /// Required. The type of routine.
    pub routine_type: crate::model::routine::RoutineType,

    /// Output only. The time when this routine was created, in milliseconds since
    /// the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// Output only. The time when this routine was last modified, in milliseconds
    /// since the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub last_modified_time: i64,

    /// Optional. Defaults to "SQL" if remote_function_options field is absent, not
    /// set otherwise.
    pub language: crate::model::routine::Language,

    /// Optional.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub arguments: std::vec::Vec<crate::model::routine::Argument>,

    /// Optional if language = "SQL"; required otherwise.
    /// Cannot be set if routine_type = "TABLE_VALUED_FUNCTION".
    ///
    /// If absent, the return type is inferred from definition_body at query time
    /// in each query that references this routine. If present, then the evaluated
    /// result will be cast to the specified returned type at query time.
    ///
    /// For example, for the functions created with the following statements:
    ///
    /// * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
    ///
    /// * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
    ///
    /// * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
    ///
    ///
    /// The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and
    /// is absent for `Increment` (inferred as FLOAT64 at query time).
    ///
    /// Suppose the function `Add` is replaced by
    /// `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
    ///
    /// Then the inferred return type of `Increment` is automatically changed to
    /// INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub return_type: std::option::Option<crate::model::StandardSqlDataType>,

    /// Optional. Can be set only if routine_type = "TABLE_VALUED_FUNCTION".
    ///
    /// If absent, the return table type is inferred from definition_body at query
    /// time in each query that references this routine. If present, then the
    /// columns in the evaluated table result will be cast to match the column
    /// types specified in return table type, at query time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub return_table_type: std::option::Option<crate::model::StandardSqlTableType>,

    /// Optional. If language = "JAVASCRIPT", this field stores the path of the
    /// imported JAVASCRIPT libraries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub imported_libraries: std::vec::Vec<std::string::String>,

    /// Required. The body of the routine.
    ///
    /// For functions, this is the expression in the AS clause.
    ///
    /// If language=SQL, it is the substring inside (but excluding) the
    /// parentheses. For example, for the function created with the following
    /// statement:
    ///
    /// `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))`
    ///
    /// The definition_body is `concat(x, "\n", y)` (\n is not replaced with
    /// linebreak).
    ///
    /// If language=JAVASCRIPT, it is the evaluated string in the AS clause.
    /// For example, for the function created with the following statement:
    ///
    /// `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'`
    ///
    /// The definition_body is
    ///
    /// `return "\n";\n`
    ///
    /// Note that both \n are replaced with linebreaks.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub definition_body: std::string::String,

    /// Optional. The description of the routine, if defined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. The determinism level of the JavaScript UDF, if defined.
    pub determinism_level: crate::model::routine::DeterminismLevel,

    /// Optional. The security mode of the routine, if defined. If not defined, the
    /// security mode is automatically determined from the routine's configuration.
    pub security_mode: crate::model::routine::SecurityMode,

    /// Optional. Use this option to catch many common errors. Error checking is
    /// not exhaustive, and successfully creating a procedure doesn't guarantee
    /// that the procedure will successfully execute at runtime. If `strictMode` is
    /// set to `TRUE`, the procedure body is further checked for errors such as
    /// non-existent tables or columns. The `CREATE PROCEDURE` statement fails if
    /// the body fails any of these checks.
    ///
    /// If `strictMode` is set to `FALSE`, the procedure body is checked only for
    /// syntax. For procedures that invoke themselves recursively, specify
    /// `strictMode=FALSE` to avoid non-existent procedure errors during
    /// validation.
    ///
    /// Default value is `TRUE`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strict_mode: std::option::Option<wkt::BoolValue>,

    /// Optional. Remote function specific options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub remote_function_options: std::option::Option<crate::model::routine::RemoteFunctionOptions>,

    /// Optional. Spark specific options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_options: std::option::Option<crate::model::SparkOptions>,

    /// Optional. If set to `DATA_MASKING`, the function is validated and made
    /// available as a masking function. For more information, see [Create custom
    /// masking
    /// routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
    pub data_governance_type: crate::model::routine::DataGovernanceType,
}

impl Routine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::Routine::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [routine_reference][crate::model::Routine::routine_reference].
    pub fn set_routine_reference<
        T: std::convert::Into<std::option::Option<crate::model::RoutineReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routine_reference = v.into();
        self
    }

    /// Sets the value of [routine_type][crate::model::Routine::routine_type].
    pub fn set_routine_type<T: std::convert::Into<crate::model::routine::RoutineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine_type = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Routine::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Routine::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [language][crate::model::Routine::language].
    pub fn set_language<T: std::convert::Into<crate::model::routine::Language>>(
        mut self,
        v: T,
    ) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [return_type][crate::model::Routine::return_type].
    pub fn set_return_type<
        T: std::convert::Into<std::option::Option<crate::model::StandardSqlDataType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.return_type = v.into();
        self
    }

    /// Sets the value of [return_table_type][crate::model::Routine::return_table_type].
    pub fn set_return_table_type<
        T: std::convert::Into<std::option::Option<crate::model::StandardSqlTableType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.return_table_type = v.into();
        self
    }

    /// Sets the value of [definition_body][crate::model::Routine::definition_body].
    pub fn set_definition_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition_body = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Routine::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [determinism_level][crate::model::Routine::determinism_level].
    pub fn set_determinism_level<T: std::convert::Into<crate::model::routine::DeterminismLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.determinism_level = v.into();
        self
    }

    /// Sets the value of [security_mode][crate::model::Routine::security_mode].
    pub fn set_security_mode<T: std::convert::Into<crate::model::routine::SecurityMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_mode = v.into();
        self
    }

    /// Sets the value of [strict_mode][crate::model::Routine::strict_mode].
    pub fn set_strict_mode<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.strict_mode = v.into();
        self
    }

    /// Sets the value of [remote_function_options][crate::model::Routine::remote_function_options].
    pub fn set_remote_function_options<
        T: std::convert::Into<std::option::Option<crate::model::routine::RemoteFunctionOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_function_options = v.into();
        self
    }

    /// Sets the value of [spark_options][crate::model::Routine::spark_options].
    pub fn set_spark_options<
        T: std::convert::Into<std::option::Option<crate::model::SparkOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spark_options = v.into();
        self
    }

    /// Sets the value of [data_governance_type][crate::model::Routine::data_governance_type].
    pub fn set_data_governance_type<
        T: std::convert::Into<crate::model::routine::DataGovernanceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_governance_type = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Routine::arguments].
    pub fn set_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::routine::Argument>,
    {
        use std::iter::Iterator;
        self.arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [imported_libraries][crate::model::Routine::imported_libraries].
    pub fn set_imported_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.imported_libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Routine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Routine"
    }
}

/// Defines additional types related to Routine
pub mod routine {
    #[allow(unused_imports)]
    use super::*;

    /// Input/output argument of a function or a stored procedure.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Argument {
        /// Optional. The name of this argument. Can be absent for function return
        /// argument.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. Defaults to FIXED_TYPE.
        pub argument_kind: crate::model::routine::argument::ArgumentKind,

        /// Optional. Specifies whether the argument is input or output.
        /// Can be set for procedures only.
        pub mode: crate::model::routine::argument::Mode,

        /// Set if argument_kind == FIXED_TYPE.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub data_type: std::option::Option<crate::model::StandardSqlDataType>,

        /// Optional. Whether the argument is an aggregate function parameter.
        /// Must be Unset for routine types other than AGGREGATE_FUNCTION.
        /// For AGGREGATE_FUNCTION, if set to false, it is equivalent to adding "NOT
        /// AGGREGATE" clause in DDL; Otherwise, it is equivalent to omitting "NOT
        /// AGGREGATE" clause in DDL.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub is_aggregate: std::option::Option<wkt::BoolValue>,
    }

    impl Argument {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::routine::Argument::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [argument_kind][crate::model::routine::Argument::argument_kind].
        pub fn set_argument_kind<
            T: std::convert::Into<crate::model::routine::argument::ArgumentKind>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.argument_kind = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::routine::Argument::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::routine::argument::Mode>>(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::routine::Argument::data_type].
        pub fn set_data_type<
            T: std::convert::Into<std::option::Option<crate::model::StandardSqlDataType>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data_type = v.into();
            self
        }

        /// Sets the value of [is_aggregate][crate::model::routine::Argument::is_aggregate].
        pub fn set_is_aggregate<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
            mut self,
            v: T,
        ) -> Self {
            self.is_aggregate = v.into();
            self
        }
    }

    impl wkt::message::Message for Argument {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Routine.Argument"
        }
    }

    /// Defines additional types related to Argument
    pub mod argument {
        #[allow(unused_imports)]
        use super::*;

        /// Represents the kind of a given argument.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ArgumentKind(i32);

        impl ArgumentKind {
            /// Default value.
            pub const ARGUMENT_KIND_UNSPECIFIED: ArgumentKind = ArgumentKind::new(0);

            /// The argument is a variable with fully specified type, which can be a
            /// struct or an array, but not a table.
            pub const FIXED_TYPE: ArgumentKind = ArgumentKind::new(1);

            /// The argument is any type, including struct or array, but not a table.
            pub const ANY_TYPE: ArgumentKind = ArgumentKind::new(2);

            /// Creates a new ArgumentKind instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("ARGUMENT_KIND_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("FIXED_TYPE"),
                    2 => std::borrow::Cow::Borrowed("ANY_TYPE"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "ARGUMENT_KIND_UNSPECIFIED" => {
                        std::option::Option::Some(Self::ARGUMENT_KIND_UNSPECIFIED)
                    }
                    "FIXED_TYPE" => std::option::Option::Some(Self::FIXED_TYPE),
                    "ANY_TYPE" => std::option::Option::Some(Self::ANY_TYPE),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for ArgumentKind {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for ArgumentKind {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// The input/output mode of the argument.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Mode(i32);

        impl Mode {
            /// Default value.
            pub const MODE_UNSPECIFIED: Mode = Mode::new(0);

            /// The argument is input-only.
            pub const IN: Mode = Mode::new(1);

            /// The argument is output-only.
            pub const OUT: Mode = Mode::new(2);

            /// The argument is both an input and an output.
            pub const INOUT: Mode = Mode::new(3);

            /// Creates a new Mode instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("MODE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("IN"),
                    2 => std::borrow::Cow::Borrowed("OUT"),
                    3 => std::borrow::Cow::Borrowed("INOUT"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "MODE_UNSPECIFIED" => std::option::Option::Some(Self::MODE_UNSPECIFIED),
                    "IN" => std::option::Option::Some(Self::IN),
                    "OUT" => std::option::Option::Some(Self::OUT),
                    "INOUT" => std::option::Option::Some(Self::INOUT),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Options for a remote user-defined function.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RemoteFunctionOptions {
        /// Endpoint of the user-provided remote service, e.g.
        /// ```<https://us-east1-my_gcf_project.cloudfunctions.net/remote_add>```
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Fully qualified name of the user-provided connection object which holds
        /// the authentication information to send requests to the remote service.
        /// Format:
        /// ```"projects/{projectId}/locations/{locationId}/connections/{connectionId}"```
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection: std::string::String,

        /// User-defined context as a set of key/value pairs, which will be sent as
        /// function invocation context together with batched arguments in the
        /// requests to the remote service. The total number of bytes of keys and
        /// values must be less than 8KB.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub user_defined_context:
            std::collections::HashMap<std::string::String, std::string::String>,

        /// Max number of rows in each batch sent to the remote service.
        /// If absent or if 0, BigQuery dynamically decides the number of rows in a
        /// batch.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub max_batching_rows: i64,
    }

    impl RemoteFunctionOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::routine::RemoteFunctionOptions::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [connection][crate::model::routine::RemoteFunctionOptions::connection].
        pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.connection = v.into();
            self
        }

        /// Sets the value of [max_batching_rows][crate::model::routine::RemoteFunctionOptions::max_batching_rows].
        pub fn set_max_batching_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_batching_rows = v.into();
            self
        }

        /// Sets the value of [user_defined_context][crate::model::routine::RemoteFunctionOptions::user_defined_context].
        pub fn set_user_defined_context<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.user_defined_context = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for RemoteFunctionOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Routine.RemoteFunctionOptions"
        }
    }

    /// The fine-grained type of the routine.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RoutineType(i32);

    impl RoutineType {
        /// Default value.
        pub const ROUTINE_TYPE_UNSPECIFIED: RoutineType = RoutineType::new(0);

        /// Non-built-in persistent scalar function.
        pub const SCALAR_FUNCTION: RoutineType = RoutineType::new(1);

        /// Stored procedure.
        pub const PROCEDURE: RoutineType = RoutineType::new(2);

        /// Non-built-in persistent TVF.
        pub const TABLE_VALUED_FUNCTION: RoutineType = RoutineType::new(3);

        /// Non-built-in persistent aggregate function.
        pub const AGGREGATE_FUNCTION: RoutineType = RoutineType::new(4);

        /// Creates a new RoutineType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROUTINE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SCALAR_FUNCTION"),
                2 => std::borrow::Cow::Borrowed("PROCEDURE"),
                3 => std::borrow::Cow::Borrowed("TABLE_VALUED_FUNCTION"),
                4 => std::borrow::Cow::Borrowed("AGGREGATE_FUNCTION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROUTINE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ROUTINE_TYPE_UNSPECIFIED)
                }
                "SCALAR_FUNCTION" => std::option::Option::Some(Self::SCALAR_FUNCTION),
                "PROCEDURE" => std::option::Option::Some(Self::PROCEDURE),
                "TABLE_VALUED_FUNCTION" => std::option::Option::Some(Self::TABLE_VALUED_FUNCTION),
                "AGGREGATE_FUNCTION" => std::option::Option::Some(Self::AGGREGATE_FUNCTION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RoutineType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RoutineType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The language of the routine.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Language(i32);

    impl Language {
        /// Default value.
        pub const LANGUAGE_UNSPECIFIED: Language = Language::new(0);

        /// SQL language.
        pub const SQL: Language = Language::new(1);

        /// JavaScript language.
        pub const JAVASCRIPT: Language = Language::new(2);

        /// Python language.
        pub const PYTHON: Language = Language::new(3);

        /// Java language.
        pub const JAVA: Language = Language::new(4);

        /// Scala language.
        pub const SCALA: Language = Language::new(5);

        /// Creates a new Language instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LANGUAGE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SQL"),
                2 => std::borrow::Cow::Borrowed("JAVASCRIPT"),
                3 => std::borrow::Cow::Borrowed("PYTHON"),
                4 => std::borrow::Cow::Borrowed("JAVA"),
                5 => std::borrow::Cow::Borrowed("SCALA"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LANGUAGE_UNSPECIFIED" => std::option::Option::Some(Self::LANGUAGE_UNSPECIFIED),
                "SQL" => std::option::Option::Some(Self::SQL),
                "JAVASCRIPT" => std::option::Option::Some(Self::JAVASCRIPT),
                "PYTHON" => std::option::Option::Some(Self::PYTHON),
                "JAVA" => std::option::Option::Some(Self::JAVA),
                "SCALA" => std::option::Option::Some(Self::SCALA),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Language {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Language {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// JavaScript UDF determinism levels.
    ///
    /// If all JavaScript UDFs are DETERMINISTIC, the query result is
    /// potentially cacheable (see below). If any JavaScript UDF is
    /// NOT_DETERMINISTIC, the query result is not cacheable.
    ///
    /// Even if a JavaScript UDF is deterministic, many other factors can prevent
    /// usage of cached query results. Example factors include but not limited to:
    /// DDL/DML, non-deterministic SQL function calls, update of referenced
    /// tables/views/UDFs or imported JavaScript libraries.
    ///
    /// SQL UDFs cannot have determinism specified. Their determinism is
    /// automatically determined.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DeterminismLevel(i32);

    impl DeterminismLevel {
        /// The determinism of the UDF is unspecified.
        pub const DETERMINISM_LEVEL_UNSPECIFIED: DeterminismLevel = DeterminismLevel::new(0);

        /// The UDF is deterministic, meaning that 2 function calls with the same
        /// inputs always produce the same result, even across 2 query runs.
        pub const DETERMINISTIC: DeterminismLevel = DeterminismLevel::new(1);

        /// The UDF is not deterministic.
        pub const NOT_DETERMINISTIC: DeterminismLevel = DeterminismLevel::new(2);

        /// Creates a new DeterminismLevel instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DETERMINISM_LEVEL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DETERMINISTIC"),
                2 => std::borrow::Cow::Borrowed("NOT_DETERMINISTIC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DETERMINISM_LEVEL_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DETERMINISM_LEVEL_UNSPECIFIED)
                }
                "DETERMINISTIC" => std::option::Option::Some(Self::DETERMINISTIC),
                "NOT_DETERMINISTIC" => std::option::Option::Some(Self::NOT_DETERMINISTIC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DeterminismLevel {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DeterminismLevel {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Security mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SecurityMode(i32);

    impl SecurityMode {
        /// The security mode of the routine is unspecified.
        pub const SECURITY_MODE_UNSPECIFIED: SecurityMode = SecurityMode::new(0);

        /// The routine is to be executed with the privileges of the user who
        /// defines it.
        pub const DEFINER: SecurityMode = SecurityMode::new(1);

        /// The routine is to be executed with the privileges of the user who
        /// invokes it.
        pub const INVOKER: SecurityMode = SecurityMode::new(2);

        /// Creates a new SecurityMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SECURITY_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DEFINER"),
                2 => std::borrow::Cow::Borrowed("INVOKER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SECURITY_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SECURITY_MODE_UNSPECIFIED)
                }
                "DEFINER" => std::option::Option::Some(Self::DEFINER),
                "INVOKER" => std::option::Option::Some(Self::INVOKER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SecurityMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SecurityMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Data governance type values. Only supports `DATA_MASKING`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DataGovernanceType(i32);

    impl DataGovernanceType {
        /// The data governance type is unspecified.
        pub const DATA_GOVERNANCE_TYPE_UNSPECIFIED: DataGovernanceType = DataGovernanceType::new(0);

        /// The data governance type is data masking.
        pub const DATA_MASKING: DataGovernanceType = DataGovernanceType::new(1);

        /// Creates a new DataGovernanceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("DATA_GOVERNANCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DATA_MASKING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "DATA_GOVERNANCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::DATA_GOVERNANCE_TYPE_UNSPECIFIED)
                }
                "DATA_MASKING" => std::option::Option::Some(Self::DATA_MASKING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for DataGovernanceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for DataGovernanceType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Options for a user-defined Spark routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkOptions {
    /// Fully qualified name of the user-provided Spark connection object. Format:
    /// ```"projects/{project_id}/locations/{location_id}/connections/{connection_id}"```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection: std::string::String,

    /// Runtime version. If not specified, the default runtime version is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub runtime_version: std::string::String,

    /// Custom container image for the runtime environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_image: std::string::String,

    /// Configuration properties as a set of key/value pairs, which will be passed
    /// on to the Spark application. For more information, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html) and the
    /// [procedure option
    /// list](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#procedure_option_list).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// The main file/jar URI of the Spark application. Exactly one of the
    /// definition_body field and the main_file_uri field must be set for Python.
    /// Exactly one of main_class and main_file_uri field
    /// should be set for Java/Scala language type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub main_file_uri: std::string::String,

    /// Python files to be placed on the PYTHONPATH for PySpark application.
    /// Supported file types: `.py`, `.egg`, and `.zip`. For more information
    /// about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub py_file_uris: std::vec::Vec<std::string::String>,

    /// JARs to include on the driver and executor CLASSPATH.
    /// For more information about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_uris: std::vec::Vec<std::string::String>,

    /// Files to be placed in the working directory of each executor.
    /// For more information about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Archive files to be extracted into the working directory of each executor.
    /// For more information about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// The fully qualified name of a class in jar_uris, for example,
    /// com.example.wordcount. Exactly one of main_class and main_jar_uri field
    /// should be set for Java/Scala language type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub main_class: std::string::String,
}

impl SparkOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::SparkOptions::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [runtime_version][crate::model::SparkOptions::runtime_version].
    pub fn set_runtime_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_version = v.into();
        self
    }

    /// Sets the value of [container_image][crate::model::SparkOptions::container_image].
    pub fn set_container_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image = v.into();
        self
    }

    /// Sets the value of [main_file_uri][crate::model::SparkOptions::main_file_uri].
    pub fn set_main_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_file_uri = v.into();
        self
    }

    /// Sets the value of [main_class][crate::model::SparkOptions::main_class].
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_class = v.into();
        self
    }

    /// Sets the value of [py_file_uris][crate::model::SparkOptions::py_file_uris].
    pub fn set_py_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.py_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_uris][crate::model::SparkOptions::jar_uris].
    pub fn set_jar_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkOptions::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkOptions::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkOptions::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SparkOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SparkOptions"
    }
}

/// Describes the format for getting information about a routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRoutineRequest {
    /// Required. Project ID of the requested routine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested routine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the requested routine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub routine_id: std::string::String,
}

impl GetRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::GetRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }
}

impl wkt::message::Message for GetRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetRoutineRequest"
    }
}

/// Describes the format for inserting a routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsertRoutineRequest {
    /// Required. Project ID of the new routine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the new routine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. A routine resource to insert
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routine: std::option::Option<crate::model::Routine>,
}

impl InsertRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::InsertRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::InsertRoutineRequest::routine].
    pub fn set_routine<T: std::convert::Into<std::option::Option<crate::model::Routine>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine = v.into();
        self
    }
}

impl wkt::message::Message for InsertRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertRoutineRequest"
    }
}

/// Describes the format for updating a routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRoutineRequest {
    /// Required. Project ID of the routine to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routine to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the routine to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub routine_id: std::string::String,

    /// Required. A routine resource which will replace the specified routine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routine: std::option::Option<crate::model::Routine>,
}

impl UpdateRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::UpdateRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::UpdateRoutineRequest::routine].
    pub fn set_routine<T: std::convert::Into<std::option::Option<crate::model::Routine>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateRoutineRequest"
    }
}

/// Describes the format for the partial update (patch) of a routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchRoutineRequest {
    /// Required. Project ID of the routine to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routine to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the routine to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub routine_id: std::string::String,

    /// Required. A routine resource which will be used to partially
    /// update the specified routine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routine: std::option::Option<crate::model::Routine>,

    /// Only the Routine fields in the field mask are updated
    /// by the given routine. Repeated routine fields will be fully replaced
    /// if contained in the field mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field_mask: std::option::Option<wkt::FieldMask>,
}

impl PatchRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PatchRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::PatchRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::PatchRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::PatchRoutineRequest::routine].
    pub fn set_routine<T: std::convert::Into<std::option::Option<crate::model::Routine>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::PatchRoutineRequest::field_mask].
    pub fn set_field_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field_mask = v.into();
        self
    }
}

impl wkt::message::Message for PatchRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PatchRoutineRequest"
    }
}

/// Describes the format for deleting a routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRoutineRequest {
    /// Required. Project ID of the routine to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routine to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the routine to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub routine_id: std::string::String,
}

impl DeleteRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::DeleteRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteRoutineRequest"
    }
}

/// Describes the format for listing routines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRoutinesRequest {
    /// Required. Project ID of the routines to list
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routines to list
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If set, then only the Routines matching this filter are returned.
    /// The supported format is `routineType:{RoutineType}`, where `{RoutineType}`
    /// is a RoutineType enum. For example: `routineType:SCALAR_FUNCTION`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListRoutinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListRoutinesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListRoutinesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListRoutinesRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<std::option::Option<wkt::UInt32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRoutinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRoutinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRoutinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRoutinesRequest"
    }
}

/// Describes the format of a single result page when listing routines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRoutinesResponse {
    /// Routines in the requested dataset. Unless read_mask is set in the request,
    /// only the following fields are populated:
    /// etag, project_id, dataset_id, routine_id, routine_type, creation_time,
    /// last_modified_time, language, and remote_function_options.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub routines: std::vec::Vec<crate::model::Routine>,

    /// A token to request the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListRoutinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRoutinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [routines][crate::model::ListRoutinesResponse::routines].
    pub fn set_routines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Routine>,
    {
        use std::iter::Iterator;
        self.routines = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRoutinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRoutinesResponse"
    }
}

/// Id path of a routine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RoutineReference {
    /// Required. The ID of the project containing this routine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this routine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. The ID of the routine. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub routine_id: std::string::String,
}

impl RoutineReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RoutineReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::RoutineReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::RoutineReference::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }
}

impl wkt::message::Message for RoutineReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RoutineReference"
    }
}

/// Request message for the ListRowAccessPolicies method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRowAccessPoliciesRequest {
    /// Required. Project ID of the row access policies to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of row access policies to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to list row access policies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Page token, returned by a previous call, to request the next page of
    /// results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response page. Leverage
    /// the page tokens to iterate through the entire collection.
    pub page_size: i32,
}

impl ListRowAccessPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListRowAccessPoliciesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListRowAccessPoliciesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::ListRowAccessPoliciesRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRowAccessPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRowAccessPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListRowAccessPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRowAccessPoliciesRequest"
    }
}

/// Response message for the ListRowAccessPolicies method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRowAccessPoliciesResponse {
    /// Row access policies on the requested table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub row_access_policies: std::vec::Vec<crate::model::RowAccessPolicy>,

    /// A token to request the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListRowAccessPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRowAccessPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [row_access_policies][crate::model::ListRowAccessPoliciesResponse::row_access_policies].
    pub fn set_row_access_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RowAccessPolicy>,
    {
        use std::iter::Iterator;
        self.row_access_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRowAccessPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRowAccessPoliciesResponse"
    }
}

impl gax::paginator::PageableResponse for ListRowAccessPoliciesResponse {
    type PageItem = crate::model::RowAccessPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.row_access_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the GetRowAccessPolicy method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRowAccessPolicyRequest {
    /// Required. Project ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. Policy ID of the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_id: std::string::String,
}

impl GetRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::GetRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::GetRowAccessPolicyRequest::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }
}

impl wkt::message::Message for GetRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetRowAccessPolicyRequest"
    }
}

/// Request message for the CreateRowAccessPolicy method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRowAccessPolicyRequest {
    /// Required. Project ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. The row access policy to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub row_access_policy: std::option::Option<crate::model::RowAccessPolicy>,
}

impl CreateRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::CreateRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CreateRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [row_access_policy][crate::model::CreateRowAccessPolicyRequest::row_access_policy].
    pub fn set_row_access_policy<
        T: std::convert::Into<std::option::Option<crate::model::RowAccessPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.row_access_policy = v.into();
        self
    }
}

impl wkt::message::Message for CreateRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CreateRowAccessPolicyRequest"
    }
}

/// Request message for the UpdateRowAccessPolicy method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRowAccessPolicyRequest {
    /// Required. Project ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to get the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. Policy ID of the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_id: std::string::String,

    /// Required. The row access policy to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub row_access_policy: std::option::Option<crate::model::RowAccessPolicy>,
}

impl UpdateRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::UpdateRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::UpdateRowAccessPolicyRequest::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }

    /// Sets the value of [row_access_policy][crate::model::UpdateRowAccessPolicyRequest::row_access_policy].
    pub fn set_row_access_policy<
        T: std::convert::Into<std::option::Option<crate::model::RowAccessPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.row_access_policy = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateRowAccessPolicyRequest"
    }
}

/// Request message for the DeleteRowAccessPolicy method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRowAccessPolicyRequest {
    /// Required. Project ID of the table to delete the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to delete the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to delete the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. Policy ID of the row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_id: std::string::String,

    /// If set to true, it deletes the row access policy even if it's the last row
    /// access policy on the table and the deletion will widen the access rather
    /// narrowing it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub force: std::option::Option<bool>,
}

impl DeleteRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::DeleteRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::DeleteRowAccessPolicyRequest::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRowAccessPolicyRequest::force].
    pub fn set_force<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteRowAccessPolicyRequest"
    }
}

/// Request message for the BatchDeleteRowAccessPoliciesRequest method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDeleteRowAccessPoliciesRequest {
    /// Required. Project ID of the table to delete the row access policies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to delete the row access policies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to delete the row access policies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. Policy IDs of the row access policies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policy_ids: std::vec::Vec<std::string::String>,

    /// If set to true, it deletes the row access policy even if it's the last row
    /// access policy on the table and the deletion will widen the access rather
    /// narrowing it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub force: std::option::Option<bool>,
}

impl BatchDeleteRowAccessPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BatchDeleteRowAccessPoliciesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BatchDeleteRowAccessPoliciesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BatchDeleteRowAccessPoliciesRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::BatchDeleteRowAccessPoliciesRequest::force].
    pub fn set_force<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [policy_ids][crate::model::BatchDeleteRowAccessPoliciesRequest::policy_ids].
    pub fn set_policy_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policy_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteRowAccessPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BatchDeleteRowAccessPoliciesRequest"
    }
}

/// Represents access on a subset of rows on the specified table, defined by its
/// filter predicate. Access to the subset of rows is controlled by its IAM
/// policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RowAccessPolicy {
    /// Output only. A hash of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Required. Reference describing the ID of this row access policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub row_access_policy_reference: std::option::Option<crate::model::RowAccessPolicyReference>,

    /// Required. A SQL boolean expression that represents the rows defined by this
    /// row access policy, similar to the boolean expression in a WHERE clause of a
    /// SELECT query on a table.
    /// References to other tables, routines, and temporary functions are not
    /// supported.
    ///
    /// Examples: region="EU"
    /// date_field = CAST('2019-9-27' as DATE)
    /// nullable_field is not NULL
    /// numeric_field BETWEEN 1.0 AND 5.0
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter_predicate: std::string::String,

    /// Output only. The time when this row access policy was created, in
    /// milliseconds since the epoch.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creation_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when this row access policy was last modified, in
    /// milliseconds since the epoch.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Input only. The optional list of iam_member users or groups that
    /// specifies the initial members that the row-level access policy should be
    /// created with.
    ///
    /// grantees types:
    ///
    /// - "user:alice@example.com": An email address that represents a specific
    ///   Google account.
    /// - "serviceAccount:my-other-app@appspot.gserviceaccount.com": An email
    ///   address that represents a service account.
    /// - "group:admins@example.com": An email address that represents a Google
    ///   group.
    /// - "domain:example.com":The Google Workspace domain (primary) that
    ///   represents all the users of that domain.
    /// - "allAuthenticatedUsers": A special identifier that represents all service
    ///   accounts and all users on the internet who have authenticated with a Google
    ///   Account. This identifier includes accounts that aren't connected to a
    ///   Google Workspace or Cloud Identity domain, such as personal Gmail accounts.
    ///   Users who aren't authenticated, such as anonymous visitors, aren't
    ///   included.
    /// - "allUsers":A special identifier that represents anyone who is on
    ///   the internet, including authenticated and unauthenticated users. Because
    ///   BigQuery requires authentication before a user can access the service,
    ///   allUsers includes only authenticated users.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grantees: std::vec::Vec<std::string::String>,
}

impl RowAccessPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::RowAccessPolicy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [row_access_policy_reference][crate::model::RowAccessPolicy::row_access_policy_reference].
    pub fn set_row_access_policy_reference<
        T: std::convert::Into<std::option::Option<crate::model::RowAccessPolicyReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.row_access_policy_reference = v.into();
        self
    }

    /// Sets the value of [filter_predicate][crate::model::RowAccessPolicy::filter_predicate].
    pub fn set_filter_predicate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_predicate = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::RowAccessPolicy::creation_time].
    pub fn set_creation_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::RowAccessPolicy::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [grantees][crate::model::RowAccessPolicy::grantees].
    pub fn set_grantees<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grantees = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RowAccessPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RowAccessPolicy"
    }
}

/// Id path of a row access policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RowAccessPolicyReference {
    /// Required. The ID of the project containing this row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. The ID of the table containing this row access policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. The ID of the row access policy. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_id: std::string::String,
}

impl RowAccessPolicyReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RowAccessPolicyReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::RowAccessPolicyReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::RowAccessPolicyReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::RowAccessPolicyReference::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }
}

impl wkt::message::Message for RowAccessPolicyReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RowAccessPolicyReference"
    }
}

/// [Preview] Information related to sessions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SessionInfo {
    /// Output only. The id of the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session_id: std::string::String,
}

impl SessionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_id][crate::model::SessionInfo::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }
}

impl wkt::message::Message for SessionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SessionInfo"
    }
}

/// The data type of a variable such as a function argument.
/// Examples include:
///
/// * INT64: `{"typeKind": "INT64"}`
///
/// * ARRAY\<STRING\>:
///
/// * {
///   "typeKind": "ARRAY",
///   "arrayElementType": {"typeKind": "STRING"}
///   }
///
/// * STRUCT<x STRING, y ARRAY\<DATE\>>:
///
/// * {
///   "typeKind": "STRUCT",
///   "structType":
///   {
///   "fields":
///   [
///   {
///   "name": "x",
///   "type": {"typeKind": "STRING"}
///   },
///   {
///   "name": "y",
///   "type":
///   {
///   "typeKind": "ARRAY",
///   "arrayElementType": {"typeKind": "DATE"}
///   }
///   }
///   ]
///   }
///   }
///
/// * RANGE\<DATE\>:
///
/// * {
///   "typeKind": "RANGE",
///   "rangeElementType": {"typeKind": "DATE"}
///   }
///
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSqlDataType {
    /// Required. The top level type of this field.
    /// Can be any GoogleSQL data type (e.g., "INT64", "DATE", "ARRAY").
    pub type_kind: crate::model::standard_sql_data_type::TypeKind,

    /// For complex types, the sub type information.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sub_type: std::option::Option<crate::model::standard_sql_data_type::SubType>,
}

impl StandardSqlDataType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [type_kind][crate::model::StandardSqlDataType::type_kind].
    pub fn set_type_kind<T: std::convert::Into<crate::model::standard_sql_data_type::TypeKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_kind = v.into();
        self
    }

    /// Sets the value of `sub_type`.
    pub fn set_sub_type<
        T: std::convert::Into<std::option::Option<crate::model::standard_sql_data_type::SubType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = v.into();
        self
    }

    /// The value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// if it holds a `ArrayElementType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_array_element_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSqlDataType>> {
        #[allow(unreachable_patterns)]
        self.sub_type.as_ref().and_then(|v| match v {
            crate::model::standard_sql_data_type::SubType::ArrayElementType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// if it holds a `StructType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_struct_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSqlStructType>> {
        #[allow(unreachable_patterns)]
        self.sub_type.as_ref().and_then(|v| match v {
            crate::model::standard_sql_data_type::SubType::StructType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// if it holds a `RangeElementType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_range_element_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSqlDataType>> {
        #[allow(unreachable_patterns)]
        self.sub_type.as_ref().and_then(|v| match v {
            crate::model::standard_sql_data_type::SubType::RangeElementType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// to hold a `ArrayElementType`.
    ///
    /// Note that all the setters affecting `sub_type` are
    /// mutually exclusive.
    pub fn set_array_element_type<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSqlDataType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = std::option::Option::Some(
            crate::model::standard_sql_data_type::SubType::ArrayElementType(v.into()),
        );
        self
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// to hold a `StructType`.
    ///
    /// Note that all the setters affecting `sub_type` are
    /// mutually exclusive.
    pub fn set_struct_type<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSqlStructType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = std::option::Option::Some(
            crate::model::standard_sql_data_type::SubType::StructType(v.into()),
        );
        self
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// to hold a `RangeElementType`.
    ///
    /// Note that all the setters affecting `sub_type` are
    /// mutually exclusive.
    pub fn set_range_element_type<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSqlDataType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = std::option::Option::Some(
            crate::model::standard_sql_data_type::SubType::RangeElementType(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StandardSqlDataType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlDataType"
    }
}

/// Defines additional types related to StandardSqlDataType
pub mod standard_sql_data_type {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of the datatype.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TypeKind(i32);

    impl TypeKind {
        /// Invalid type.
        pub const TYPE_KIND_UNSPECIFIED: TypeKind = TypeKind::new(0);

        /// Encoded as a string in decimal format.
        pub const INT64: TypeKind = TypeKind::new(2);

        /// Encoded as a boolean "false" or "true".
        pub const BOOL: TypeKind = TypeKind::new(5);

        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        pub const FLOAT64: TypeKind = TypeKind::new(7);

        /// Encoded as a string value.
        pub const STRING: TypeKind = TypeKind::new(8);

        /// Encoded as a base64 string per RFC 4648, section 4.
        pub const BYTES: TypeKind = TypeKind::new(9);

        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
        /// 1985-04-12T23:20:50.52Z
        pub const TIMESTAMP: TypeKind = TypeKind::new(19);

        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        pub const DATE: TypeKind = TypeKind::new(10);

        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        pub const TIME: TypeKind = TypeKind::new(20);

        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        pub const DATETIME: TypeKind = TypeKind::new(21);

        /// Encoded as fully qualified 3 part: 0-5 15 2:30:45.6
        pub const INTERVAL: TypeKind = TypeKind::new(26);

        /// Encoded as WKT
        pub const GEOGRAPHY: TypeKind = TypeKind::new(22);

        /// Encoded as a decimal string.
        pub const NUMERIC: TypeKind = TypeKind::new(23);

        /// Encoded as a decimal string.
        pub const BIGNUMERIC: TypeKind = TypeKind::new(24);

        /// Encoded as a string.
        pub const JSON: TypeKind = TypeKind::new(25);

        /// Encoded as a list with types matching Type.array_type.
        pub const ARRAY: TypeKind = TypeKind::new(16);

        /// Encoded as a list with fields of type Type.struct_type[i]. List is used
        /// because a JSON object cannot have duplicate field names.
        pub const STRUCT: TypeKind = TypeKind::new(17);

        /// Encoded as a pair with types matching range_element_type. Pairs must
        /// begin with "[", end with ")", and be separated by ", ".
        pub const RANGE: TypeKind = TypeKind::new(29);

        /// Creates a new TypeKind instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_KIND_UNSPECIFIED"),
                2 => std::borrow::Cow::Borrowed("INT64"),
                5 => std::borrow::Cow::Borrowed("BOOL"),
                7 => std::borrow::Cow::Borrowed("FLOAT64"),
                8 => std::borrow::Cow::Borrowed("STRING"),
                9 => std::borrow::Cow::Borrowed("BYTES"),
                10 => std::borrow::Cow::Borrowed("DATE"),
                16 => std::borrow::Cow::Borrowed("ARRAY"),
                17 => std::borrow::Cow::Borrowed("STRUCT"),
                19 => std::borrow::Cow::Borrowed("TIMESTAMP"),
                20 => std::borrow::Cow::Borrowed("TIME"),
                21 => std::borrow::Cow::Borrowed("DATETIME"),
                22 => std::borrow::Cow::Borrowed("GEOGRAPHY"),
                23 => std::borrow::Cow::Borrowed("NUMERIC"),
                24 => std::borrow::Cow::Borrowed("BIGNUMERIC"),
                25 => std::borrow::Cow::Borrowed("JSON"),
                26 => std::borrow::Cow::Borrowed("INTERVAL"),
                29 => std::borrow::Cow::Borrowed("RANGE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_KIND_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_KIND_UNSPECIFIED),
                "INT64" => std::option::Option::Some(Self::INT64),
                "BOOL" => std::option::Option::Some(Self::BOOL),
                "FLOAT64" => std::option::Option::Some(Self::FLOAT64),
                "STRING" => std::option::Option::Some(Self::STRING),
                "BYTES" => std::option::Option::Some(Self::BYTES),
                "TIMESTAMP" => std::option::Option::Some(Self::TIMESTAMP),
                "DATE" => std::option::Option::Some(Self::DATE),
                "TIME" => std::option::Option::Some(Self::TIME),
                "DATETIME" => std::option::Option::Some(Self::DATETIME),
                "INTERVAL" => std::option::Option::Some(Self::INTERVAL),
                "GEOGRAPHY" => std::option::Option::Some(Self::GEOGRAPHY),
                "NUMERIC" => std::option::Option::Some(Self::NUMERIC),
                "BIGNUMERIC" => std::option::Option::Some(Self::BIGNUMERIC),
                "JSON" => std::option::Option::Some(Self::JSON),
                "ARRAY" => std::option::Option::Some(Self::ARRAY),
                "STRUCT" => std::option::Option::Some(Self::STRUCT),
                "RANGE" => std::option::Option::Some(Self::RANGE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TypeKind {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TypeKind {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// For complex types, the sub type information.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SubType {
        /// The type of the array's elements, if type_kind = "ARRAY".
        ArrayElementType(std::boxed::Box<crate::model::StandardSqlDataType>),
        /// The fields of this struct, in order, if type_kind = "STRUCT".
        StructType(std::boxed::Box<crate::model::StandardSqlStructType>),
        /// The type of the range's elements, if type_kind = "RANGE".
        RangeElementType(std::boxed::Box<crate::model::StandardSqlDataType>),
    }
}

/// A field or a column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSqlField {
    /// Optional. The name of this field. Can be absent for struct fields.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The type of this parameter. Absent if not explicitly
    /// specified (e.g., CREATE FUNCTION statement can omit the return type;
    /// in this case the output parameter does not have this "type" field).
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub r#type: std::option::Option<std::boxed::Box<crate::model::StandardSqlDataType>>,
}

impl StandardSqlField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StandardSqlField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::StandardSqlField::type].
    pub fn set_type<
        T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::StandardSqlDataType>>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for StandardSqlField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlField"
    }
}

/// The representation of a SQL STRUCT type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSqlStructType {
    /// Fields within the struct.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::StandardSqlField>,
}

impl StandardSqlStructType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::StandardSqlStructType::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StandardSqlStructType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlStructType"
    }
}

/// A table type
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardSqlTableType {
    /// The columns in this table type
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::StandardSqlField>,
}

impl StandardSqlTableType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::StandardSqlTableType::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StandardSqlTableType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlTableType"
    }
}

/// System variables given to a query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SystemVariables {
    /// Output only. Data type for each system variable.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub types: std::collections::HashMap<std::string::String, crate::model::StandardSqlDataType>,

    /// Output only. Value for each system variable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub values: std::option::Option<wkt::Struct>,
}

impl SystemVariables {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::SystemVariables::values].
    pub fn set_values<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.values = v.into();
        self
    }

    /// Sets the value of [types][crate::model::SystemVariables::types].
    pub fn set_types<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SystemVariables {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SystemVariables"
    }
}

/// Replication info of a table created using `AS REPLICA` DDL like:
/// `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableReplicationInfo {
    /// Required. Source table reference that is replicated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_table: std::option::Option<crate::model::TableReference>,

    /// Optional. Specifies the interval at which the source table is polled for
    /// updates.
    /// It's Optional. If not specified, default replication interval would be
    /// applied.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub replication_interval_ms: i64,

    /// Optional. Output only. If source is a materialized view, this field
    /// signifies the last refresh time of the source.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub replicated_source_last_refresh_time: i64,

    /// Optional. Output only. Replication status of configured replication.
    pub replication_status: crate::model::table_replication_info::ReplicationStatus,

    /// Optional. Output only. Replication error that will permanently stopped
    /// table replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_error: std::option::Option<crate::model::ErrorProto>,
}

impl TableReplicationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_table][crate::model::TableReplicationInfo::source_table].
    pub fn set_source_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [replication_interval_ms][crate::model::TableReplicationInfo::replication_interval_ms].
    pub fn set_replication_interval_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replication_interval_ms = v.into();
        self
    }

    /// Sets the value of [replicated_source_last_refresh_time][crate::model::TableReplicationInfo::replicated_source_last_refresh_time].
    pub fn set_replicated_source_last_refresh_time<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.replicated_source_last_refresh_time = v.into();
        self
    }

    /// Sets the value of [replication_status][crate::model::TableReplicationInfo::replication_status].
    pub fn set_replication_status<
        T: std::convert::Into<crate::model::table_replication_info::ReplicationStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_status = v.into();
        self
    }

    /// Sets the value of [replication_error][crate::model::TableReplicationInfo::replication_error].
    pub fn set_replication_error<
        T: std::convert::Into<std::option::Option<crate::model::ErrorProto>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_error = v.into();
        self
    }
}

impl wkt::message::Message for TableReplicationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableReplicationInfo"
    }
}

/// Defines additional types related to TableReplicationInfo
pub mod table_replication_info {
    #[allow(unused_imports)]
    use super::*;

    /// Replication status of the table created using `AS REPLICA` like:
    /// `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ReplicationStatus(i32);

    impl ReplicationStatus {
        /// Default value.
        pub const REPLICATION_STATUS_UNSPECIFIED: ReplicationStatus = ReplicationStatus::new(0);

        /// Replication is Active with no errors.
        pub const ACTIVE: ReplicationStatus = ReplicationStatus::new(1);

        /// Source object is deleted.
        pub const SOURCE_DELETED: ReplicationStatus = ReplicationStatus::new(2);

        /// Source revoked replication permissions.
        pub const PERMISSION_DENIED: ReplicationStatus = ReplicationStatus::new(3);

        /// Source configuration doesnt allow replication.
        pub const UNSUPPORTED_CONFIGURATION: ReplicationStatus = ReplicationStatus::new(4);

        /// Creates a new ReplicationStatus instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("REPLICATION_STATUS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ACTIVE"),
                2 => std::borrow::Cow::Borrowed("SOURCE_DELETED"),
                3 => std::borrow::Cow::Borrowed("PERMISSION_DENIED"),
                4 => std::borrow::Cow::Borrowed("UNSUPPORTED_CONFIGURATION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "REPLICATION_STATUS_UNSPECIFIED" => {
                    std::option::Option::Some(Self::REPLICATION_STATUS_UNSPECIFIED)
                }
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "SOURCE_DELETED" => std::option::Option::Some(Self::SOURCE_DELETED),
                "PERMISSION_DENIED" => std::option::Option::Some(Self::PERMISSION_DENIED),
                "UNSUPPORTED_CONFIGURATION" => {
                    std::option::Option::Some(Self::UNSUPPORTED_CONFIGURATION)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ReplicationStatus {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ReplicationStatus {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Describes the definition of a logical view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ViewDefinition {
    /// Required. A query that BigQuery executes when the view is referenced.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Describes user-defined function resources used in the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_defined_function_resources: std::vec::Vec<crate::model::UserDefinedFunctionResource>,

    /// Specifies whether to use BigQuery's legacy SQL for this view.
    /// The default value is true. If set to false, the view will use
    /// BigQuery's GoogleSQL:
    /// <https://cloud.google.com/bigquery/sql-reference/>
    ///
    /// Queries and views that reference this view must use the same flag value.
    /// A wrapper is used here because the default value is True.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_legacy_sql: std::option::Option<wkt::BoolValue>,

    /// True if the column names are explicitly specified. For example by using the
    /// 'CREATE VIEW v(c1, c2) AS ...' syntax.
    /// Can only be set for GoogleSQL views.
    pub use_explicit_column_names: bool,

    /// Optional. Specifies the privacy policy for the view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privacy_policy: std::option::Option<crate::model::PrivacyPolicy>,

    /// Optional. Foreign view representations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub foreign_definitions: std::vec::Vec<crate::model::ForeignViewDefinition>,
}

impl ViewDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::ViewDefinition::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [use_legacy_sql][crate::model::ViewDefinition::use_legacy_sql].
    pub fn set_use_legacy_sql<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.use_legacy_sql = v.into();
        self
    }

    /// Sets the value of [use_explicit_column_names][crate::model::ViewDefinition::use_explicit_column_names].
    pub fn set_use_explicit_column_names<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_explicit_column_names = v.into();
        self
    }

    /// Sets the value of [privacy_policy][crate::model::ViewDefinition::privacy_policy].
    pub fn set_privacy_policy<
        T: std::convert::Into<std::option::Option<crate::model::PrivacyPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = v.into();
        self
    }

    /// Sets the value of [user_defined_function_resources][crate::model::ViewDefinition::user_defined_function_resources].
    pub fn set_user_defined_function_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserDefinedFunctionResource>,
    {
        use std::iter::Iterator;
        self.user_defined_function_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [foreign_definitions][crate::model::ViewDefinition::foreign_definitions].
    pub fn set_foreign_definitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ForeignViewDefinition>,
    {
        use std::iter::Iterator;
        self.foreign_definitions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ViewDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ViewDefinition"
    }
}

/// A view can be represented in multiple ways. Each representation has its own
/// dialect. This message stores the metadata required for these representations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForeignViewDefinition {
    /// Required. The query that defines the view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. Represents the dialect of the query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dialect: std::string::String,
}

impl ForeignViewDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::ForeignViewDefinition::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [dialect][crate::model::ForeignViewDefinition::dialect].
    pub fn set_dialect<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dialect = v.into();
        self
    }
}

impl wkt::message::Message for ForeignViewDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ForeignViewDefinition"
    }
}

/// Definition and configuration of a materialized view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaterializedViewDefinition {
    /// Required. A query whose results are persisted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Output only. The time when this materialized view was last refreshed, in
    /// milliseconds since the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub last_refresh_time: i64,

    /// Optional. Enable automatic refresh of the materialized view when the base
    /// table is updated. The default value is "true".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_refresh: std::option::Option<wkt::BoolValue>,

    /// Optional. The maximum frequency at which this materialized view will be
    /// refreshed. The default value is "1800000" (30 minutes).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub refresh_interval_ms: std::option::Option<wkt::UInt64Value>,

    /// Optional. This option declares the intention to construct a materialized
    /// view that isn't refreshed incrementally. Non-incremental materialized views
    /// support an expanded range of SQL queries. The
    /// `allow_non_incremental_definition` option can't be changed after the
    /// materialized view is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_non_incremental_definition: std::option::Option<wkt::BoolValue>,
}

impl MaterializedViewDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::MaterializedViewDefinition::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [last_refresh_time][crate::model::MaterializedViewDefinition::last_refresh_time].
    pub fn set_last_refresh_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_refresh_time = v.into();
        self
    }

    /// Sets the value of [enable_refresh][crate::model::MaterializedViewDefinition::enable_refresh].
    pub fn set_enable_refresh<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_refresh = v.into();
        self
    }

    /// Sets the value of [refresh_interval_ms][crate::model::MaterializedViewDefinition::refresh_interval_ms].
    pub fn set_refresh_interval_ms<T: std::convert::Into<std::option::Option<wkt::UInt64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_interval_ms = v.into();
        self
    }

    /// Sets the value of [allow_non_incremental_definition][crate::model::MaterializedViewDefinition::allow_non_incremental_definition].
    pub fn set_allow_non_incremental_definition<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.allow_non_incremental_definition = v.into();
        self
    }
}

impl wkt::message::Message for MaterializedViewDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MaterializedViewDefinition"
    }
}

/// Status of a materialized view.
/// The last refresh timestamp status is omitted here, but is present in the
/// MaterializedViewDefinition message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaterializedViewStatus {
    /// Output only. Refresh watermark of materialized view. The base tables' data
    /// were collected into the materialized view cache until this time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub refresh_watermark: std::option::Option<wkt::Timestamp>,

    /// Output only. Error result of the last automatic refresh. If present,
    /// indicates that the last automatic refresh was unsuccessful.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_refresh_status: std::option::Option<crate::model::ErrorProto>,
}

impl MaterializedViewStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_watermark][crate::model::MaterializedViewStatus::refresh_watermark].
    pub fn set_refresh_watermark<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_watermark = v.into();
        self
    }

    /// Sets the value of [last_refresh_status][crate::model::MaterializedViewStatus::last_refresh_status].
    pub fn set_last_refresh_status<
        T: std::convert::Into<std::option::Option<crate::model::ErrorProto>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_refresh_status = v.into();
        self
    }
}

impl wkt::message::Message for MaterializedViewStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MaterializedViewStatus"
    }
}

/// Information about base table and snapshot time of the snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SnapshotDefinition {
    /// Required. Reference describing the ID of the table that was snapshot.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_table_reference: std::option::Option<crate::model::TableReference>,

    /// Required. The time at which the base table was snapshot. This value is
    /// reported in the JSON response using RFC3339 format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,
}

impl SnapshotDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_table_reference][crate::model::SnapshotDefinition::base_table_reference].
    pub fn set_base_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_table_reference = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::SnapshotDefinition::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }
}

impl wkt::message::Message for SnapshotDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SnapshotDefinition"
    }
}

/// Information about base table and clone time of a table clone.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloneDefinition {
    /// Required. Reference describing the ID of the table that was cloned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub base_table_reference: std::option::Option<crate::model::TableReference>,

    /// Required. The time at which the base table was cloned. This value is
    /// reported in the JSON response using RFC3339 format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clone_time: std::option::Option<wkt::Timestamp>,
}

impl CloneDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_table_reference][crate::model::CloneDefinition::base_table_reference].
    pub fn set_base_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.base_table_reference = v.into();
        self
    }

    /// Sets the value of [clone_time][crate::model::CloneDefinition::clone_time].
    pub fn set_clone_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.clone_time = v.into();
        self
    }
}

impl wkt::message::Message for CloneDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CloneDefinition"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Streamingbuffer {
    /// Output only. A lower-bound estimate of the number of bytes currently in
    /// the streaming buffer.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub estimated_bytes: u64,

    /// Output only. A lower-bound estimate of the number of rows currently in the
    /// streaming buffer.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub estimated_rows: u64,

    /// Output only. Contains the timestamp of the oldest entry in the streaming
    /// buffer, in milliseconds since the epoch, if the streaming buffer is
    /// available.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub oldest_entry_time: u64,
}

impl Streamingbuffer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_bytes][crate::model::Streamingbuffer::estimated_bytes].
    pub fn set_estimated_bytes<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.estimated_bytes = v.into();
        self
    }

    /// Sets the value of [estimated_rows][crate::model::Streamingbuffer::estimated_rows].
    pub fn set_estimated_rows<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.estimated_rows = v.into();
        self
    }

    /// Sets the value of [oldest_entry_time][crate::model::Streamingbuffer::oldest_entry_time].
    pub fn set_oldest_entry_time<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.oldest_entry_time = v.into();
        self
    }
}

impl wkt::message::Message for Streamingbuffer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Streamingbuffer"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Table {
    /// The type of resource ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Output only. A hash of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. An opaque ID uniquely identifying the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. A URL that can be used to access this resource again.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Required. Reference describing the ID of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::TableReference>,

    /// Optional. A descriptive name for this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// Optional. A user-friendly description of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<wkt::StringValue>,

    /// The labels associated with this table. You can use these to organize and
    /// group your tables. Label keys and values can be no longer than 63
    /// characters, can only contain lowercase letters, numeric characters,
    /// underscores and dashes. International characters are allowed. Label values
    /// are optional. Label keys must start with a letter and each label in the
    /// list must have a different key.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Describes the schema of this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// If specified, configures time-based partitioning for this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_partitioning: std::option::Option<crate::model::TimePartitioning>,

    /// If specified, configures range partitioning for this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_partitioning: std::option::Option<crate::model::RangePartitioning>,

    /// Clustering specification for the table. Must be specified with time-based
    /// partitioning, data in the table will be first partitioned and subsequently
    /// clustered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clustering: std::option::Option<crate::model::Clustering>,

    /// Optional. If set to true, queries over this table require
    /// a partition filter that can be used for partition elimination to be
    /// specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_partition_filter: std::option::Option<wkt::BoolValue>,

    /// Optional. The partition information for all table formats, including
    /// managed partitioned tables, hive partitioned tables, iceberg partitioned,
    /// and metastore partitioned tables. This field is only populated for
    /// metastore partitioned tables. For other table formats, this is an output
    /// only field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition_definition: std::option::Option<crate::model::PartitioningDefinition>,

    /// Output only. The size of this table in logical bytes, excluding any data in
    /// the streaming buffer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The physical size of this table in bytes. This includes
    /// storage used for time travel.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of logical bytes in the table that are considered
    /// "long-term storage".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_long_term_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of rows of data in this table, excluding any data
    /// in the streaming buffer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_rows: std::option::Option<wkt::UInt64Value>,

    /// Output only. The time when this table was created, in milliseconds since
    /// the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// Optional. The time when this table expires, in milliseconds since the
    /// epoch. If not present, the table will persist indefinitely. Expired tables
    /// will be deleted and their storage reclaimed.  The defaultTableExpirationMs
    /// property of the encapsulating dataset can be used to set a default
    /// expirationTime on newly created tables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub expiration_time: std::option::Option<wkt::Int64Value>,

    /// Output only. The time when this table was last modified, in milliseconds
    /// since the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub last_modified_time: u64,

    /// Output only. Describes the table type. The following values are supported:
    ///
    /// * `TABLE`: A normal BigQuery table.
    /// * `VIEW`: A virtual table defined by a SQL query.
    /// * `EXTERNAL`: A table that references data stored in an external storage
    ///   system, such as Google Cloud Storage.
    /// * `MATERIALIZED_VIEW`: A precomputed view defined by a SQL query.
    /// * `SNAPSHOT`: An immutable BigQuery table that preserves the contents of a
    ///   base table at a particular time. See additional information on
    ///   [table
    ///   snapshots](https://cloud.google.com/bigquery/docs/table-snapshots-intro).
    ///
    /// The default value is `TABLE`.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. The view definition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::ViewDefinition>,

    /// Optional. The materialized view definition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub materialized_view: std::option::Option<crate::model::MaterializedViewDefinition>,

    /// Output only. The materialized view status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub materialized_view_status: std::option::Option<crate::model::MaterializedViewStatus>,

    /// Optional. Describes the data format, location, and other properties of
    /// a table stored outside of BigQuery. By defining these properties, the data
    /// source can then be queried as if it were a standard BigQuery table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_data_configuration: std::option::Option<crate::model::ExternalDataConfiguration>,

    /// Optional. Specifies the configuration of a BigLake managed table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub biglake_configuration: std::option::Option<crate::model::BigLakeConfiguration>,

    /// Optional. If set, overrides the default managed table type configured in
    /// the dataset.
    pub managed_table_type: crate::model::ManagedTableType,

    /// Output only. The geographic location where the table resides. This value
    /// is inherited from the dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Output only. Contains information regarding this table's streaming buffer,
    /// if one is present. This field will be absent if the table is not being
    /// streamed to or if there is no data in the streaming buffer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub streaming_buffer: std::option::Option<crate::model::Streamingbuffer>,

    /// Custom encryption configuration (e.g., Cloud KMS keys).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Contains information about the snapshot. This value is set via
    /// snapshot creation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_definition: std::option::Option<crate::model::SnapshotDefinition>,

    /// Optional. Defines the default collation specification of new STRING fields
    /// in the table. During table creation or update, if a STRING field is added
    /// to this table without explicit collation specified, then the table inherits
    /// the table default collation. A change to this field affects only fields
    /// added afterwards, and does not alter the existing fields.
    /// The following values are supported:
    ///
    /// * 'und:ci': undetermined locale, case insensitive.
    /// * '': empty string. Default to case-sensitive behavior.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_collation: std::option::Option<wkt::StringValue>,

    /// Optional. Defines the default rounding mode specification of new decimal
    /// fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or
    /// update, if a decimal field is added to this table without an explicit
    /// rounding mode specified, then the field inherits the table default
    /// rounding mode. Changing this field doesn't affect existing fields.
    pub default_rounding_mode: crate::model::table_field_schema::RoundingMode,

    /// Output only. Contains information about the clone. This value is set via
    /// the clone operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clone_definition: std::option::Option<crate::model::CloneDefinition>,

    /// Output only. Number of physical bytes used by time travel storage (deleted
    /// or changed data). This data is not kept in real time, and might be delayed
    /// by a few seconds to a few minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_time_travel_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Total number of logical bytes in the table or materialized
    /// view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_total_logical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of logical bytes that are less than 90 days old.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_active_logical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of logical bytes that are more than 90 days old.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_long_term_logical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of physical bytes used by current live data storage.
    /// This data is not kept in real time, and might be delayed by a few seconds
    /// to a few minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_current_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The physical size of this table in bytes. This also includes
    /// storage used for time travel. This data is not kept in real time, and might
    /// be delayed by a few seconds to a few minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_total_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of physical bytes less than 90 days old. This data is
    /// not kept in real time, and might be delayed by a few seconds to a few
    /// minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_active_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of physical bytes more than 90 days old.
    /// This data is not kept in real time, and might be delayed by a few seconds
    /// to a few minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_long_term_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of partitions present in the table or materialized
    /// view. This data is not kept in real time, and might be delayed by a few
    /// seconds to a few minutes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub num_partitions: std::option::Option<wkt::Int64Value>,

    /// Optional. The maximum staleness of data that could be returned when the
    /// table (or stale MV) is queried. Staleness encoded as a string encoding
    /// of sql IntervalValue type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub max_staleness: std::string::String,

    /// Optional. Output only. Restriction config for table. If set, restrict
    /// certain accesses on the table based on the config. See [Data
    /// egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
    /// for more details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restrictions: std::option::Option<crate::model::RestrictionConfig>,

    /// Optional. Tables Primary Key and Foreign Key information
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_constraints: std::option::Option<crate::model::TableConstraints>,

    /// Optional. The [tags](https://cloud.google.com/bigquery/docs/tags) attached
    /// to this table. Tag keys are globally unique. Tag key is expected to be in
    /// the namespaced format, for example "123456789012/environment" where
    /// 123456789012 is the ID of the parent organization or project resource for
    /// this tag key. Tag value is expected to be the short name, for example
    /// "Production". See [Tag
    /// definitions](https://cloud.google.com/iam/docs/tags-access-control#definitions)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Table replication info for table created `AS REPLICA` DDL like:
    /// `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_replication_info: std::option::Option<crate::model::TableReplicationInfo>,

    /// Optional. Output only. Table references of all replicas currently active on
    /// the table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replicas: std::vec::Vec<crate::model::TableReference>,

    /// Optional. Options defining open source compatible table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_catalog_table_options:
        std::option::Option<crate::model::ExternalCatalogTableOptions>,
}

impl Table {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Table::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Table::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Table::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Table::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [table_reference][crate::model::Table::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::Table::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Table::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::Table::schema].
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::TableSchema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [time_partitioning][crate::model::Table::time_partitioning].
    pub fn set_time_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::TimePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_partitioning = v.into();
        self
    }

    /// Sets the value of [range_partitioning][crate::model::Table::range_partitioning].
    pub fn set_range_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::RangePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_partitioning = v.into();
        self
    }

    /// Sets the value of [clustering][crate::model::Table::clustering].
    pub fn set_clustering<T: std::convert::Into<std::option::Option<crate::model::Clustering>>>(
        mut self,
        v: T,
    ) -> Self {
        self.clustering = v.into();
        self
    }

    /// Sets the value of [require_partition_filter][crate::model::Table::require_partition_filter].
    pub fn set_require_partition_filter<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.require_partition_filter = v.into();
        self
    }

    /// Sets the value of [partition_definition][crate::model::Table::partition_definition].
    pub fn set_partition_definition<
        T: std::convert::Into<std::option::Option<crate::model::PartitioningDefinition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition_definition = v.into();
        self
    }

    /// Sets the value of [num_bytes][crate::model::Table::num_bytes].
    pub fn set_num_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.num_bytes = v.into();
        self
    }

    /// Sets the value of [num_physical_bytes][crate::model::Table::num_physical_bytes].
    pub fn set_num_physical_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.num_physical_bytes = v.into();
        self
    }

    /// Sets the value of [num_long_term_bytes][crate::model::Table::num_long_term_bytes].
    pub fn set_num_long_term_bytes<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.num_long_term_bytes = v.into();
        self
    }

    /// Sets the value of [num_rows][crate::model::Table::num_rows].
    pub fn set_num_rows<T: std::convert::Into<std::option::Option<wkt::UInt64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.num_rows = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Table::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Table::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Table::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Table::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [view][crate::model::Table::view].
    pub fn set_view<T: std::convert::Into<std::option::Option<crate::model::ViewDefinition>>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [materialized_view][crate::model::Table::materialized_view].
    pub fn set_materialized_view<
        T: std::convert::Into<std::option::Option<crate::model::MaterializedViewDefinition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.materialized_view = v.into();
        self
    }

    /// Sets the value of [materialized_view_status][crate::model::Table::materialized_view_status].
    pub fn set_materialized_view_status<
        T: std::convert::Into<std::option::Option<crate::model::MaterializedViewStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.materialized_view_status = v.into();
        self
    }

    /// Sets the value of [external_data_configuration][crate::model::Table::external_data_configuration].
    pub fn set_external_data_configuration<
        T: std::convert::Into<std::option::Option<crate::model::ExternalDataConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.external_data_configuration = v.into();
        self
    }

    /// Sets the value of [biglake_configuration][crate::model::Table::biglake_configuration].
    pub fn set_biglake_configuration<
        T: std::convert::Into<std::option::Option<crate::model::BigLakeConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.biglake_configuration = v.into();
        self
    }

    /// Sets the value of [managed_table_type][crate::model::Table::managed_table_type].
    pub fn set_managed_table_type<T: std::convert::Into<crate::model::ManagedTableType>>(
        mut self,
        v: T,
    ) -> Self {
        self.managed_table_type = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Table::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [streaming_buffer][crate::model::Table::streaming_buffer].
    pub fn set_streaming_buffer<
        T: std::convert::Into<std::option::Option<crate::model::Streamingbuffer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_buffer = v.into();
        self
    }

    /// Sets the value of [encryption_configuration][crate::model::Table::encryption_configuration].
    pub fn set_encryption_configuration<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfiguration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_configuration = v.into();
        self
    }

    /// Sets the value of [snapshot_definition][crate::model::Table::snapshot_definition].
    pub fn set_snapshot_definition<
        T: std::convert::Into<std::option::Option<crate::model::SnapshotDefinition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_definition = v.into();
        self
    }

    /// Sets the value of [default_collation][crate::model::Table::default_collation].
    pub fn set_default_collation<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_collation = v.into();
        self
    }

    /// Sets the value of [default_rounding_mode][crate::model::Table::default_rounding_mode].
    pub fn set_default_rounding_mode<
        T: std::convert::Into<crate::model::table_field_schema::RoundingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_rounding_mode = v.into();
        self
    }

    /// Sets the value of [clone_definition][crate::model::Table::clone_definition].
    pub fn set_clone_definition<
        T: std::convert::Into<std::option::Option<crate::model::CloneDefinition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.clone_definition = v.into();
        self
    }

    /// Sets the value of [num_time_travel_physical_bytes][crate::model::Table::num_time_travel_physical_bytes].
    pub fn set_num_time_travel_physical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_time_travel_physical_bytes = v.into();
        self
    }

    /// Sets the value of [num_total_logical_bytes][crate::model::Table::num_total_logical_bytes].
    pub fn set_num_total_logical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_total_logical_bytes = v.into();
        self
    }

    /// Sets the value of [num_active_logical_bytes][crate::model::Table::num_active_logical_bytes].
    pub fn set_num_active_logical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_active_logical_bytes = v.into();
        self
    }

    /// Sets the value of [num_long_term_logical_bytes][crate::model::Table::num_long_term_logical_bytes].
    pub fn set_num_long_term_logical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_long_term_logical_bytes = v.into();
        self
    }

    /// Sets the value of [num_current_physical_bytes][crate::model::Table::num_current_physical_bytes].
    pub fn set_num_current_physical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_current_physical_bytes = v.into();
        self
    }

    /// Sets the value of [num_total_physical_bytes][crate::model::Table::num_total_physical_bytes].
    pub fn set_num_total_physical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_total_physical_bytes = v.into();
        self
    }

    /// Sets the value of [num_active_physical_bytes][crate::model::Table::num_active_physical_bytes].
    pub fn set_num_active_physical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_active_physical_bytes = v.into();
        self
    }

    /// Sets the value of [num_long_term_physical_bytes][crate::model::Table::num_long_term_physical_bytes].
    pub fn set_num_long_term_physical_bytes<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.num_long_term_physical_bytes = v.into();
        self
    }

    /// Sets the value of [num_partitions][crate::model::Table::num_partitions].
    pub fn set_num_partitions<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.num_partitions = v.into();
        self
    }

    /// Sets the value of [max_staleness][crate::model::Table::max_staleness].
    pub fn set_max_staleness<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.max_staleness = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::Table::restrictions].
    pub fn set_restrictions<
        T: std::convert::Into<std::option::Option<crate::model::RestrictionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = v.into();
        self
    }

    /// Sets the value of [table_constraints][crate::model::Table::table_constraints].
    pub fn set_table_constraints<
        T: std::convert::Into<std::option::Option<crate::model::TableConstraints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_constraints = v.into();
        self
    }

    /// Sets the value of [table_replication_info][crate::model::Table::table_replication_info].
    pub fn set_table_replication_info<
        T: std::convert::Into<std::option::Option<crate::model::TableReplicationInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_replication_info = v.into();
        self
    }

    /// Sets the value of [external_catalog_table_options][crate::model::Table::external_catalog_table_options].
    pub fn set_external_catalog_table_options<
        T: std::convert::Into<std::option::Option<crate::model::ExternalCatalogTableOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.external_catalog_table_options = v.into();
        self
    }

    /// Sets the value of [replicas][crate::model::Table::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableReference>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Table::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_tags][crate::model::Table::resource_tags].
    pub fn set_resource_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Table"
    }
}

/// Request format for getting table metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTableRequest {
    /// Required. Project ID of the requested table
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested table
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the requested table
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// List of table schema fields to return (comma-separated).
    /// If unspecified, all fields are returned.
    /// A fieldMask cannot be used here because the fields will automatically be
    /// converted from camelCase to snake_case and the conversion will fail if
    /// there are underscores. Since these are fields in BigQuery table schemas,
    /// underscores are allowed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub selected_fields: std::string::String,

    /// Optional. Specifies the view that determines which table information is
    /// returned. By default, basic table information and storage statistics
    /// (STORAGE_STATS) are returned.
    pub view: crate::model::get_table_request::TableMetadataView,
}

impl GetTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::GetTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [selected_fields][crate::model::GetTableRequest::selected_fields].
    pub fn set_selected_fields<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.selected_fields = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetTableRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_table_request::TableMetadataView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetTableRequest"
    }
}

/// Defines additional types related to GetTableRequest
pub mod get_table_request {
    #[allow(unused_imports)]
    use super::*;

    /// TableMetadataView specifies which table information is returned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TableMetadataView(i32);

    impl TableMetadataView {
        /// The default value.
        /// Default to the STORAGE_STATS view.
        pub const TABLE_METADATA_VIEW_UNSPECIFIED: TableMetadataView = TableMetadataView::new(0);

        /// Includes basic table information including schema and
        /// partitioning specification. This view does not include storage statistics
        /// such as numRows or numBytes. This view is significantly more efficient
        /// and should be used to support high query rates.
        pub const BASIC: TableMetadataView = TableMetadataView::new(1);

        /// Includes all information in the BASIC view as well as storage statistics
        /// (numBytes, numLongTermBytes, numRows and lastModifiedTime).
        pub const STORAGE_STATS: TableMetadataView = TableMetadataView::new(2);

        /// Includes all table information, including storage statistics.
        /// It returns same information as STORAGE_STATS view, but may contain
        /// additional information in the future.
        pub const FULL: TableMetadataView = TableMetadataView::new(3);

        /// Creates a new TableMetadataView instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TABLE_METADATA_VIEW_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BASIC"),
                2 => std::borrow::Cow::Borrowed("STORAGE_STATS"),
                3 => std::borrow::Cow::Borrowed("FULL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TABLE_METADATA_VIEW_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TABLE_METADATA_VIEW_UNSPECIFIED)
                }
                "BASIC" => std::option::Option::Some(Self::BASIC),
                "STORAGE_STATS" => std::option::Option::Some(Self::STORAGE_STATS),
                "FULL" => std::option::Option::Some(Self::FULL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TableMetadataView {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TableMetadataView {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request format for inserting table metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsertTableRequest {
    /// Required. Project ID of the new table
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the new table
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. A tables resource to insert
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::Table>,
}

impl InsertTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::InsertTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table][crate::model::InsertTableRequest::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }
}

impl wkt::message::Message for InsertTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertTableRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateOrPatchTableRequest {
    /// Required. Project ID of the table to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to update
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. A tables resource which will replace or patch the specified table
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::Table>,

    /// Optional. When true will autodetect schema, else will keep original schema.
    pub autodetect_schema: bool,
}

impl UpdateOrPatchTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateOrPatchTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateOrPatchTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::UpdateOrPatchTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [table][crate::model::UpdateOrPatchTableRequest::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [autodetect_schema][crate::model::UpdateOrPatchTableRequest::autodetect_schema].
    pub fn set_autodetect_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.autodetect_schema = v.into();
        self
    }
}

impl wkt::message::Message for UpdateOrPatchTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateOrPatchTableRequest"
    }
}

/// Request format for deleting a table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTableRequest {
    /// Required. Project ID of the table to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,
}

impl DeleteTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::DeleteTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteTableRequest"
    }
}

/// Request format for enumerating tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTablesRequest {
    /// Required. Project ID of the tables to list
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. Dataset ID of the tables to list
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTablesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListTablesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListTablesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListTablesRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<std::option::Option<wkt::UInt32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTablesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTablesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListTablesRequest"
    }
}

/// Information about a logical view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFormatView {
    /// True if view is defined in legacy SQL dialect,
    /// false if in GoogleSQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub use_legacy_sql: std::option::Option<wkt::BoolValue>,

    /// Specifies the privacy policy for the view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privacy_policy: std::option::Option<crate::model::PrivacyPolicy>,
}

impl ListFormatView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_legacy_sql][crate::model::ListFormatView::use_legacy_sql].
    pub fn set_use_legacy_sql<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.use_legacy_sql = v.into();
        self
    }

    /// Sets the value of [privacy_policy][crate::model::ListFormatView::privacy_policy].
    pub fn set_privacy_policy<
        T: std::convert::Into<std::option::Option<crate::model::PrivacyPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = v.into();
        self
    }
}

impl wkt::message::Message for ListFormatView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatView"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFormatTable {
    /// The resource type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// An opaque ID of the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// A reference uniquely identifying table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table_reference: std::option::Option<crate::model::TableReference>,

    /// The user-friendly name for this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// The type of table.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// The time-based partitioning for this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_partitioning: std::option::Option<crate::model::TimePartitioning>,

    /// The range partitioning for this table.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_partitioning: std::option::Option<crate::model::RangePartitioning>,

    /// Clustering specification for this table, if configured.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clustering: std::option::Option<crate::model::Clustering>,

    /// The labels associated with this table. You can use these to organize
    /// and group your tables.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional details for a view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::ListFormatView>,

    /// Output only. The time when this table was created, in milliseconds since
    /// the epoch.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// The time when this table expires, in milliseconds since the
    /// epoch. If not present, the table will persist indefinitely. Expired tables
    /// will be deleted and their storage reclaimed.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub expiration_time: i64,

    /// Optional. If set to true, queries including this table must specify a
    /// partition filter. This filter is used for partition elimination.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_partition_filter: std::option::Option<wkt::BoolValue>,
}

impl ListFormatTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ListFormatTable::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ListFormatTable::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [table_reference][crate::model::ListFormatTable::table_reference].
    pub fn set_table_reference<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_reference = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::ListFormatTable::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ListFormatTable::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [time_partitioning][crate::model::ListFormatTable::time_partitioning].
    pub fn set_time_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::TimePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_partitioning = v.into();
        self
    }

    /// Sets the value of [range_partitioning][crate::model::ListFormatTable::range_partitioning].
    pub fn set_range_partitioning<
        T: std::convert::Into<std::option::Option<crate::model::RangePartitioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_partitioning = v.into();
        self
    }

    /// Sets the value of [clustering][crate::model::ListFormatTable::clustering].
    pub fn set_clustering<T: std::convert::Into<std::option::Option<crate::model::Clustering>>>(
        mut self,
        v: T,
    ) -> Self {
        self.clustering = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListFormatTable::view].
    pub fn set_view<T: std::convert::Into<std::option::Option<crate::model::ListFormatView>>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::ListFormatTable::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::ListFormatTable::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [require_partition_filter][crate::model::ListFormatTable::require_partition_filter].
    pub fn set_require_partition_filter<
        T: std::convert::Into<std::option::Option<wkt::BoolValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.require_partition_filter = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ListFormatTable::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ListFormatTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatTable"
    }
}

/// Partial projection of the metadata for a given table in a list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableList {
    /// The type of list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// A hash of this page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// A token to request the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Tables in the requested dataset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tables: std::vec::Vec<crate::model::ListFormatTable>,

    /// The total number of tables in the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_items: std::option::Option<wkt::Int32Value>,
}

impl TableList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TableList::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TableList::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::TableList::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_items][crate::model::TableList::total_items].
    pub fn set_total_items<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_items = v.into();
        self
    }

    /// Sets the value of [tables][crate::model::TableList::tables].
    pub fn set_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ListFormatTable>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableList"
    }
}

/// Represents the primary key constraint on a table's columns.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrimaryKey {
    /// Required. The columns that are composed of the primary key constraint.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<std::string::String>,
}

impl PrimaryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::PrimaryKey::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PrimaryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PrimaryKey"
    }
}

/// The pair of the foreign key column and primary key column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnReference {
    /// Required. The column that composes the foreign key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub referencing_column: std::string::String,

    /// Required. The column in the primary key that are referenced by the
    /// referencing_column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub referenced_column: std::string::String,
}

impl ColumnReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [referencing_column][crate::model::ColumnReference::referencing_column].
    pub fn set_referencing_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.referencing_column = v.into();
        self
    }

    /// Sets the value of [referenced_column][crate::model::ColumnReference::referenced_column].
    pub fn set_referenced_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.referenced_column = v.into();
        self
    }
}

impl wkt::message::Message for ColumnReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ColumnReference"
    }
}

/// Represents a foreign key constraint on a table's columns.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForeignKey {
    /// Optional. Set only if the foreign key constraint is named.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The table that holds the primary key and is referenced by this
    /// foreign key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub referenced_table: std::option::Option<crate::model::TableReference>,

    /// Required. The columns that compose the foreign key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub column_references: std::vec::Vec<crate::model::ColumnReference>,
}

impl ForeignKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ForeignKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [referenced_table][crate::model::ForeignKey::referenced_table].
    pub fn set_referenced_table<
        T: std::convert::Into<std::option::Option<crate::model::TableReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.referenced_table = v.into();
        self
    }

    /// Sets the value of [column_references][crate::model::ForeignKey::column_references].
    pub fn set_column_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnReference>,
    {
        use std::iter::Iterator;
        self.column_references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ForeignKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ForeignKey"
    }
}

/// The TableConstraints defines the primary key and foreign key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableConstraints {
    /// Optional. Represents a primary key constraint on a table's columns.
    /// Present only if the table has a primary key.
    /// The primary key is not enforced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_key: std::option::Option<crate::model::PrimaryKey>,

    /// Optional. Present only if the table has a foreign key.
    /// The foreign key is not enforced.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub foreign_keys: std::vec::Vec<crate::model::ForeignKey>,
}

impl TableConstraints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_key][crate::model::TableConstraints::primary_key].
    pub fn set_primary_key<T: std::convert::Into<std::option::Option<crate::model::PrimaryKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [foreign_keys][crate::model::TableConstraints::foreign_keys].
    pub fn set_foreign_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ForeignKey>,
    {
        use std::iter::Iterator;
        self.foreign_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableConstraints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableConstraints"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableReference {
    /// Required. The ID of the project containing this table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. The ID of the table. The ID can contain Unicode characters in
    /// category L (letter), M (mark), N (number), Pc (connector, including
    /// underscore), Pd (dash), and Zs (space). For more information, see [General
    /// Category](https://wikipedia.org/wiki/Unicode_character_property#General_Category).
    /// The maximum length is 1,024 characters.  Certain operations allow suffixing
    /// of the table ID with a partition decorator, such as
    /// `sample_table$20190123`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,
}

impl TableReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::TableReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::TableReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for TableReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableReference"
    }
}

/// Schema of a table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableSchema {
    /// Describes the fields in a table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::TableFieldSchema>,

    /// Optional. Specifies metadata of the foreign data type definition in field
    /// schema
    /// ([TableFieldSchema.foreign_type_definition][google.cloud.bigquery.v2.TableFieldSchema.foreign_type_definition]).
    ///
    /// [google.cloud.bigquery.v2.TableFieldSchema.foreign_type_definition]: crate::model::TableFieldSchema::foreign_type_definition
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub foreign_type_info: std::option::Option<crate::model::ForeignTypeInfo>,
}

impl TableSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [foreign_type_info][crate::model::TableSchema::foreign_type_info].
    pub fn set_foreign_type_info<
        T: std::convert::Into<std::option::Option<crate::model::ForeignTypeInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.foreign_type_info = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TableSchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableFieldSchema>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableSchema"
    }
}

/// Metadata about the foreign data type definition such as the system
/// in which the type is defined.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForeignTypeInfo {
    /// Required. Specifies the system which defines the foreign data type.
    pub type_system: crate::model::foreign_type_info::TypeSystem,
}

impl ForeignTypeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [type_system][crate::model::ForeignTypeInfo::type_system].
    pub fn set_type_system<T: std::convert::Into<crate::model::foreign_type_info::TypeSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_system = v.into();
        self
    }
}

impl wkt::message::Message for ForeignTypeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ForeignTypeInfo"
    }
}

/// Defines additional types related to ForeignTypeInfo
pub mod foreign_type_info {
    #[allow(unused_imports)]
    use super::*;

    /// External systems, such as query engines or table formats, that have their
    /// own data types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TypeSystem(i32);

    impl TypeSystem {
        /// TypeSystem not specified.
        pub const TYPE_SYSTEM_UNSPECIFIED: TypeSystem = TypeSystem::new(0);

        /// Represents Hive data types.
        pub const HIVE: TypeSystem = TypeSystem::new(1);

        /// Creates a new TypeSystem instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_SYSTEM_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("HIVE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_SYSTEM_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TYPE_SYSTEM_UNSPECIFIED)
                }
                "HIVE" => std::option::Option::Some(Self::HIVE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TypeSystem {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TypeSystem {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Data policy option proto, it currently supports name only, will support
/// precedence later.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataPolicyOption {
    /// Data policy resource name in the form of
    /// projects/project_id/locations/location_id/dataPolicies/data_policy_id.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,
}

impl DataPolicyOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataPolicyOption::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DataPolicyOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DataPolicyOption"
    }
}

/// A field in TableSchema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableFieldSchema {
    /// Required. The field name. The name must contain only letters (a-z, A-Z),
    /// numbers (0-9), or underscores (_), and must start with a letter or
    /// underscore. The maximum length is 300 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The field data type. Possible values include:
    ///
    /// * STRING
    /// * BYTES
    /// * INTEGER (or INT64)
    /// * FLOAT (or FLOAT64)
    /// * BOOLEAN (or BOOL)
    /// * TIMESTAMP
    /// * DATE
    /// * TIME
    /// * DATETIME
    /// * GEOGRAPHY
    /// * NUMERIC
    /// * BIGNUMERIC
    /// * JSON
    /// * RECORD (or STRUCT)
    /// * RANGE
    ///
    /// Use of RECORD/STRUCT indicates that the field contains a nested schema.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. The field mode. Possible values include NULLABLE, REQUIRED and
    /// REPEATED. The default value is NULLABLE.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mode: std::string::String,

    /// Optional. Describes the nested schema fields if the type property is set
    /// to RECORD.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::TableFieldSchema>,

    /// Optional. The field description. The maximum length is 1,024 characters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<wkt::StringValue>,

    /// Optional. The policy tags attached to this field, used for field-level
    /// access control. If not set, defaults to empty policy_tags.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy_tags: std::option::Option<crate::model::table_field_schema::PolicyTagList>,

    /// Optional. Data policy options, will replace the data_policies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_policies: std::vec::Vec<crate::model::DataPolicyOption>,

    /// Optional. Maximum length of values of this field for STRINGS or BYTES.
    ///
    /// If max_length is not specified, no maximum length constraint is imposed
    /// on this field.
    ///
    /// If type = "STRING", then max_length represents the maximum UTF-8
    /// length of strings in this field.
    ///
    /// If type = "BYTES", then max_length represents the maximum number of
    /// bytes in this field.
    ///
    /// It is invalid to set this field if type &ne; "STRING" and &ne; "BYTES".
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_length: i64,

    /// Optional. Precision (maximum number of total digits in base 10) and scale
    /// (maximum number of digits in the fractional part in base 10) constraints
    /// for values of this field for NUMERIC or BIGNUMERIC.
    ///
    /// It is invalid to set precision or scale if type &ne; "NUMERIC" and &ne;
    /// "BIGNUMERIC".
    ///
    /// If precision and scale are not specified, no value range constraint is
    /// imposed on this field insofar as values are permitted by the type.
    ///
    /// Values of this NUMERIC or BIGNUMERIC field must be in this range when:
    ///
    /// * Precision (\<var\>P\</var\>) and scale (\<var\>S\</var\>) are specified:
    ///   [-10\<sup\>\<var\>P\</var\>-\<var\>S\</var\>\</sup\> + 10\<sup\>-\<var\>S\</var\>\</sup\>,
    ///   10\<sup\>\<var\>P\</var\>-\<var\>S\</var\>\</sup\> - 10\<sup\>-\<var\>S\</var\>\</sup\>]
    /// * Precision (\<var\>P\</var\>) is specified but not scale (and thus scale is
    ///   interpreted to be equal to zero):
    ///   [-10\<sup\>\<var\>P\</var\>\</sup\> + 1, 10\<sup\>\<var\>P\</var\>\</sup\> - 1].
    ///
    /// Acceptable values for precision and scale if both are specified:
    ///
    /// * If type = "NUMERIC":
    ///   1 &le; precision - scale &le; 29 and 0 &le; scale &le; 9.
    /// * If type = "BIGNUMERIC":
    ///   1 &le; precision - scale &le; 38 and 0 &le; scale &le; 38.
    ///
    /// Acceptable values for precision if only precision is specified but not
    /// scale (and thus scale is interpreted to be equal to zero):
    ///
    /// * If type = "NUMERIC": 1 &le; precision &le; 29.
    /// * If type = "BIGNUMERIC": 1 &le; precision &le; 38.
    ///
    /// If scale is specified but not precision, then it is invalid.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub precision: i64,

    /// Optional. See documentation for precision.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub scale: i64,

    /// Optional. Specifies the rounding mode to be used when storing values of
    /// NUMERIC and BIGNUMERIC type.
    pub rounding_mode: crate::model::table_field_schema::RoundingMode,

    /// Optional. Field collation can be set only when the type of field is STRING.
    /// The following values are supported:
    ///
    /// * 'und:ci': undetermined locale, case insensitive.
    /// * '': empty string. Default to case-sensitive behavior.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub collation: std::option::Option<wkt::StringValue>,

    /// Optional. A SQL expression to specify the [default value]
    /// (<https://cloud.google.com/bigquery/docs/default-values>) for this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_value_expression: std::option::Option<wkt::StringValue>,

    /// Optional. The subtype of the RANGE, if the type of this field is RANGE. If
    /// the type is RANGE, this field is required. Values for the field element
    /// type can be the following:
    ///
    /// * DATE
    /// * DATETIME
    /// * TIMESTAMP
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub range_element_type: std::option::Option<crate::model::table_field_schema::FieldElementType>,

    /// Optional. Definition of the foreign data type.
    /// Only valid for top-level schema fields (not nested fields).
    /// If the type is FOREIGN, this field is required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub foreign_type_definition: std::string::String,
}

impl TableFieldSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TableFieldSchema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TableFieldSchema::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::TableFieldSchema::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TableFieldSchema::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy_tags][crate::model::TableFieldSchema::policy_tags].
    pub fn set_policy_tags<
        T: std::convert::Into<std::option::Option<crate::model::table_field_schema::PolicyTagList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy_tags = v.into();
        self
    }

    /// Sets the value of [max_length][crate::model::TableFieldSchema::max_length].
    pub fn set_max_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::TableFieldSchema::precision].
    pub fn set_precision<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::TableFieldSchema::scale].
    pub fn set_scale<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [rounding_mode][crate::model::TableFieldSchema::rounding_mode].
    pub fn set_rounding_mode<
        T: std::convert::Into<crate::model::table_field_schema::RoundingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rounding_mode = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::TableFieldSchema::collation].
    pub fn set_collation<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [default_value_expression][crate::model::TableFieldSchema::default_value_expression].
    pub fn set_default_value_expression<
        T: std::convert::Into<std::option::Option<wkt::StringValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_value_expression = v.into();
        self
    }

    /// Sets the value of [range_element_type][crate::model::TableFieldSchema::range_element_type].
    pub fn set_range_element_type<
        T: std::convert::Into<std::option::Option<crate::model::table_field_schema::FieldElementType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.range_element_type = v.into();
        self
    }

    /// Sets the value of [foreign_type_definition][crate::model::TableFieldSchema::foreign_type_definition].
    pub fn set_foreign_type_definition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.foreign_type_definition = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TableFieldSchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableFieldSchema>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_policies][crate::model::TableFieldSchema::data_policies].
    pub fn set_data_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataPolicyOption>,
    {
        use std::iter::Iterator;
        self.data_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableFieldSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableFieldSchema"
    }
}

/// Defines additional types related to TableFieldSchema
pub mod table_field_schema {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PolicyTagList {
        /// A list of policy tag resource names. For example,
        /// "projects/1/locations/eu/taxonomies/2/policyTags/3". At most 1 policy tag
        /// is currently allowed.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub names: std::vec::Vec<std::string::String>,
    }

    impl PolicyTagList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [names][crate::model::table_field_schema::PolicyTagList::names].
        pub fn set_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PolicyTagList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.TableFieldSchema.PolicyTagList"
        }
    }

    /// Represents the type of a field element.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FieldElementType {
        /// Required. The type of a field element. For more information, see
        /// [TableFieldSchema.type][google.cloud.bigquery.v2.TableFieldSchema.type].
        ///
        /// [google.cloud.bigquery.v2.TableFieldSchema.type]: crate::model::TableFieldSchema::type
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,
    }

    impl FieldElementType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::table_field_schema::FieldElementType::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for FieldElementType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.TableFieldSchema.FieldElementType"
        }
    }

    /// Rounding mode options that can be used when storing NUMERIC
    /// or BIGNUMERIC values.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RoundingMode(i32);

    impl RoundingMode {
        /// Unspecified will default to using ROUND_HALF_AWAY_FROM_ZERO.
        pub const ROUNDING_MODE_UNSPECIFIED: RoundingMode = RoundingMode::new(0);

        /// ROUND_HALF_AWAY_FROM_ZERO rounds half values away from zero
        /// when applying precision and scale upon writing of NUMERIC and BIGNUMERIC
        /// values.
        /// For Scale: 0
        /// 1.1, 1.2, 1.3, 1.4 => 1
        /// 1.5, 1.6, 1.7, 1.8, 1.9 => 2
        pub const ROUND_HALF_AWAY_FROM_ZERO: RoundingMode = RoundingMode::new(1);

        /// ROUND_HALF_EVEN rounds half values to the nearest even value
        /// when applying precision and scale upon writing of NUMERIC and BIGNUMERIC
        /// values.
        /// For Scale: 0
        /// 1.1, 1.2, 1.3, 1.4 => 1
        /// 1.5 => 2
        /// 1.6, 1.7, 1.8, 1.9 => 2
        /// 2.5 => 2
        pub const ROUND_HALF_EVEN: RoundingMode = RoundingMode::new(2);

        /// Creates a new RoundingMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ROUNDING_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ROUND_HALF_AWAY_FROM_ZERO"),
                2 => std::borrow::Cow::Borrowed("ROUND_HALF_EVEN"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ROUNDING_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ROUNDING_MODE_UNSPECIFIED)
                }
                "ROUND_HALF_AWAY_FROM_ZERO" => {
                    std::option::Option::Some(Self::ROUND_HALF_AWAY_FROM_ZERO)
                }
                "ROUND_HALF_EVEN" => std::option::Option::Some(Self::ROUND_HALF_EVEN),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RoundingMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RoundingMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimePartitioning {
    /// Required. The supported types are DAY, HOUR, MONTH, and YEAR, which will
    /// generate one partition per day, hour, month, and year, respectively.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Optional. Number of milliseconds for which to keep the storage for a
    /// partition.
    /// A wrapper is used here because 0 is an invalid value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub expiration_ms: std::option::Option<wkt::Int64Value>,

    /// Optional. If not set, the table is partitioned by pseudo
    /// column '_PARTITIONTIME'; if set, the table is partitioned by this field.
    /// The field must be a top-level TIMESTAMP or DATE field. Its mode must be
    /// NULLABLE or REQUIRED.
    /// A wrapper is used here because an empty string is an invalid value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub field: std::option::Option<wkt::StringValue>,
}

impl TimePartitioning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TimePartitioning::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [expiration_ms][crate::model::TimePartitioning::expiration_ms].
    pub fn set_expiration_ms<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration_ms = v.into();
        self
    }

    /// Sets the value of [field][crate::model::TimePartitioning::field].
    pub fn set_field<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.field = v.into();
        self
    }
}

impl wkt::message::Message for TimePartitioning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TimePartitioning"
    }
}

/// This is used for defining User Defined Function (UDF) resources only when
/// using legacy SQL.  Users of GoogleSQL should leverage either DDL (e.g.
/// CREATE [TEMPORARY] FUNCTION ... ) or the Routines API to define UDF
/// resources.
///
/// For additional information on migrating, see:
/// <https://cloud.google.com/bigquery/docs/reference/standard-sql/migrating-from-legacy-sql#differences_in_user-defined_javascript_functions>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserDefinedFunctionResource {
    /// [Pick one] A code resource to load from a Google Cloud Storage URI
    /// (gs://bucket/path).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_uri: std::option::Option<wkt::StringValue>,

    /// [Pick one] An inline resource that contains code for a user-defined
    /// function (UDF). Providing a inline code resource is equivalent to providing
    /// a URI for a file containing the same code.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub inline_code: std::option::Option<wkt::StringValue>,
}

impl UserDefinedFunctionResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_uri][crate::model::UserDefinedFunctionResource::resource_uri].
    pub fn set_resource_uri<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_uri = v.into();
        self
    }

    /// Sets the value of [inline_code][crate::model::UserDefinedFunctionResource::inline_code].
    pub fn set_inline_code<T: std::convert::Into<std::option::Option<wkt::StringValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.inline_code = v.into();
        self
    }
}

impl wkt::message::Message for UserDefinedFunctionResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UserDefinedFunctionResource"
    }
}

/// The data types that could be used as a target type when converting decimal
/// values.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DecimalTargetType(i32);

impl DecimalTargetType {
    /// Invalid type.
    pub const DECIMAL_TARGET_TYPE_UNSPECIFIED: DecimalTargetType = DecimalTargetType::new(0);

    /// Decimal values could be converted to NUMERIC
    /// type.
    pub const NUMERIC: DecimalTargetType = DecimalTargetType::new(1);

    /// Decimal values could be converted to BIGNUMERIC
    /// type.
    pub const BIGNUMERIC: DecimalTargetType = DecimalTargetType::new(2);

    /// Decimal values could be converted to STRING type.
    pub const STRING: DecimalTargetType = DecimalTargetType::new(3);

    /// Creates a new DecimalTargetType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("DECIMAL_TARGET_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("NUMERIC"),
            2 => std::borrow::Cow::Borrowed("BIGNUMERIC"),
            3 => std::borrow::Cow::Borrowed("STRING"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "DECIMAL_TARGET_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::DECIMAL_TARGET_TYPE_UNSPECIFIED)
            }
            "NUMERIC" => std::option::Option::Some(Self::NUMERIC),
            "BIGNUMERIC" => std::option::Option::Some(Self::BIGNUMERIC),
            "STRING" => std::option::Option::Some(Self::STRING),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DecimalTargetType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DecimalTargetType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// This enum defines how to interpret source URIs for load jobs and external
/// tables.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct FileSetSpecType(i32);

impl FileSetSpecType {
    /// This option expands source URIs by listing files from the object store. It
    /// is the default behavior if FileSetSpecType is not set.
    pub const FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH: FileSetSpecType = FileSetSpecType::new(0);

    /// This option indicates that the provided URIs are newline-delimited manifest
    /// files, with one URI per line. Wildcard URIs are not supported.
    pub const FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST: FileSetSpecType =
        FileSetSpecType::new(1);

    /// Creates a new FileSetSpecType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH"),
            1 => std::borrow::Cow::Borrowed("FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH" => {
                std::option::Option::Some(Self::FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH)
            }
            "FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST" => {
                std::option::Option::Some(Self::FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for FileSetSpecType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for FileSetSpecType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The type of editions.
/// Different features and behaviors are provided to different editions
/// Capacity commitments and reservations are linked to editions.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ReservationEdition(i32);

impl ReservationEdition {
    /// Default value, which will be treated as ENTERPRISE.
    pub const RESERVATION_EDITION_UNSPECIFIED: ReservationEdition = ReservationEdition::new(0);

    /// Standard edition.
    pub const STANDARD: ReservationEdition = ReservationEdition::new(1);

    /// Enterprise edition.
    pub const ENTERPRISE: ReservationEdition = ReservationEdition::new(2);

    /// Enterprise Plus edition.
    pub const ENTERPRISE_PLUS: ReservationEdition = ReservationEdition::new(3);

    /// Creates a new ReservationEdition instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("RESERVATION_EDITION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("STANDARD"),
            2 => std::borrow::Cow::Borrowed("ENTERPRISE"),
            3 => std::borrow::Cow::Borrowed("ENTERPRISE_PLUS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "RESERVATION_EDITION_UNSPECIFIED" => {
                std::option::Option::Some(Self::RESERVATION_EDITION_UNSPECIFIED)
            }
            "STANDARD" => std::option::Option::Some(Self::STANDARD),
            "ENTERPRISE" => std::option::Option::Some(Self::ENTERPRISE),
            "ENTERPRISE_PLUS" => std::option::Option::Some(Self::ENTERPRISE_PLUS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ReservationEdition {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ReservationEdition {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Used to indicate that a JSON variant, rather than normal JSON, is being used
/// as the source_format. This should only be used in combination with the
/// JSON source format.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct JsonExtension(i32);

impl JsonExtension {
    /// The default if provided value is not one included in the enum, or the value
    /// is not specified. The source format is parsed without any modification.
    pub const JSON_EXTENSION_UNSPECIFIED: JsonExtension = JsonExtension::new(0);

    /// Use GeoJSON variant of JSON. See <https://tools.ietf.org/html/rfc7946>.
    pub const GEOJSON: JsonExtension = JsonExtension::new(1);

    /// Creates a new JsonExtension instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("JSON_EXTENSION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("GEOJSON"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "JSON_EXTENSION_UNSPECIFIED" => {
                std::option::Option::Some(Self::JSON_EXTENSION_UNSPECIFIED)
            }
            "GEOJSON" => std::option::Option::Some(Self::GEOJSON),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for JsonExtension {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for JsonExtension {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The classification of managed table types that can be created.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ManagedTableType(i32);

impl ManagedTableType {
    /// No managed table type specified.
    pub const MANAGED_TABLE_TYPE_UNSPECIFIED: ManagedTableType = ManagedTableType::new(0);

    /// The managed table is a native BigQuery table.
    pub const NATIVE: ManagedTableType = ManagedTableType::new(1);

    /// The managed table is a BigQuery table for Apache Iceberg.
    pub const ICEBERG: ManagedTableType = ManagedTableType::new(2);

    /// Creates a new ManagedTableType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MANAGED_TABLE_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("NATIVE"),
            2 => std::borrow::Cow::Borrowed("ICEBERG"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MANAGED_TABLE_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::MANAGED_TABLE_TYPE_UNSPECIFIED)
            }
            "NATIVE" => std::option::Option::Some(Self::NATIVE),
            "ICEBERG" => std::option::Option::Some(Self::ICEBERG),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ManagedTableType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ManagedTableType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Indicates the map target type. Only applies to parquet maps.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MapTargetType(i32);

impl MapTargetType {
    /// In this mode, the map will have the following schema:
    /// struct map_field_name {  repeated struct key_value {  key  value  } }.
    pub const MAP_TARGET_TYPE_UNSPECIFIED: MapTargetType = MapTargetType::new(0);

    /// In this mode, the map will have the following schema:
    /// repeated struct map_field_name {  key  value }.
    pub const ARRAY_OF_STRUCT: MapTargetType = MapTargetType::new(1);

    /// Creates a new MapTargetType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("MAP_TARGET_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("ARRAY_OF_STRUCT"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "MAP_TARGET_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::MAP_TARGET_TYPE_UNSPECIFIED)
            }
            "ARRAY_OF_STRUCT" => std::option::Option::Some(Self::ARRAY_OF_STRUCT),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for MapTargetType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for MapTargetType {
    fn default() -> Self {
        Self::new(0)
    }
}
