// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

use crate::Result;
use std::sync::Arc;

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
/// DatasetService provides methods for managing BigQuery datasets.
///
/// # Configuration
///
/// `DatasetService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `DatasetService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `DatasetService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct DatasetService {
    inner: Arc<dyn super::stubs::dynamic::DatasetService>,
}

impl DatasetService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::DatasetService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::DatasetService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::DatasetService> {
        super::transport::DatasetService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::DatasetService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::DatasetService::new)
    }

    /// Returns the dataset specified by datasetID.
    pub fn get_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::GetDataset {
        super::builders::dataset_service::GetDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Creates a new empty dataset.
    pub fn insert_dataset(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::InsertDataset {
        super::builders::dataset_service::InsertDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
    }

    /// Updates information in an existing dataset. The update method replaces the
    /// entire dataset resource, whereas the patch method only replaces fields that
    /// are provided in the submitted dataset resource.
    /// This method supports RFC5789 patch semantics.
    pub fn patch_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::PatchDataset {
        super::builders::dataset_service::PatchDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Updates information in an existing dataset. The update method replaces the
    /// entire dataset resource, whereas the patch method only replaces fields that
    /// are provided in the submitted dataset resource.
    pub fn update_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::UpdateDataset {
        super::builders::dataset_service::UpdateDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Deletes the dataset specified by the datasetId value. Before you can delete
    /// a dataset, you must delete all its tables, either manually or by specifying
    /// deleteContents. Immediately after deletion, you can create another dataset
    /// with the same name.
    pub fn delete_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::DeleteDataset {
        super::builders::dataset_service::DeleteDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Lists all datasets in the specified project to which the user has been
    /// granted the READER dataset role.
    pub fn list_datasets(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::ListDatasets {
        super::builders::dataset_service::ListDatasets::new(self.inner.clone())
            .set_project_id(project_id.into())
    }

    /// Undeletes a dataset which is within time travel window based on datasetId.
    /// If a time is specified, the dataset version deleted at that time is
    /// undeleted, else the last live version is undeleted.
    pub fn undelete_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::dataset_service::UndeleteDataset {
        super::builders::dataset_service::UndeleteDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
///
/// # Configuration
///
/// `JobService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `JobService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `JobService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct JobService {
    inner: Arc<dyn super::stubs::dynamic::JobService>,
}

impl JobService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::JobService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::JobService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::JobService> {
        super::transport::JobService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::JobService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::JobService::new)
    }

    /// Requests that a job be cancelled. This call will return immediately, and
    /// the client will need to poll for the job status to see if the cancel
    /// completed successfully. Cancelled jobs may still incur costs.
    pub fn cancel_job(
        &self,
        project_id: impl Into<std::string::String>,
        job_id: impl Into<std::string::String>,
    ) -> super::builders::job_service::CancelJob {
        super::builders::job_service::CancelJob::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_job_id(job_id.into())
    }

    /// Returns information about a specific job. Job information is available for
    /// a six month period after creation. Requires that you're the person who ran
    /// the job, or have the Is Owner project role.
    pub fn get_job(
        &self,
        project_id: impl Into<std::string::String>,
        job_id: impl Into<std::string::String>,
    ) -> super::builders::job_service::GetJob {
        super::builders::job_service::GetJob::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_job_id(job_id.into())
    }

    /// Starts a new asynchronous job.
    ///
    /// This API has two different kinds of endpoint URIs, as this method supports
    /// a variety of use cases.
    ///
    /// * The *Metadata* URI is used for most interactions, as it accepts the job
    ///   configuration directly.
    /// * The *Upload* URI is ONLY for the case when you're sending both a load job
    ///   configuration and a data stream together.  In this case, the Upload URI
    ///   accepts the job configuration and the data as two distinct multipart MIME
    ///   parts.
    pub fn insert_job(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builders::job_service::InsertJob {
        super::builders::job_service::InsertJob::new(self.inner.clone())
            .set_project_id(project_id.into())
    }

    /// Requests the deletion of the metadata of a job. This call returns when the
    /// job's metadata is deleted.
    pub fn delete_job(
        &self,
        project_id: impl Into<std::string::String>,
        job_id: impl Into<std::string::String>,
    ) -> super::builders::job_service::DeleteJob {
        super::builders::job_service::DeleteJob::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_job_id(job_id.into())
    }

    /// Lists all jobs that you started in the specified project. Job information
    /// is available for a six month period after creation. The job list is sorted
    /// in reverse chronological order, by job creation time. Requires the Can View
    /// project role, or the Is Owner project role if you set the allUsers
    /// property.
    pub fn list_jobs(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builders::job_service::ListJobs {
        super::builders::job_service::ListJobs::new(self.inner.clone())
            .set_project_id(project_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
/// Model Service for BigQuery ML
///
/// # Configuration
///
/// `ModelService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ModelService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ModelService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ModelService {
    inner: Arc<dyn super::stubs::dynamic::ModelService>,
}

impl ModelService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::ModelService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::ModelService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::ModelService> {
        super::transport::ModelService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::ModelService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ModelService::new)
    }

    /// Gets the specified model resource by model ID.
    pub fn get_model(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        model_id: impl Into<std::string::String>,
    ) -> super::builders::model_service::GetModel {
        super::builders::model_service::GetModel::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_model_id(model_id.into())
    }

    /// Lists all models in the specified dataset. Requires the READER dataset
    /// role. After retrieving the list of models, you can get information about a
    /// particular model by calling the models.get method.
    pub fn list_models(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::model_service::ListModels {
        super::builders::model_service::ListModels::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Patch specific fields in the specified model.
    pub fn patch_model(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        model_id: impl Into<std::string::String>,
    ) -> super::builders::model_service::PatchModel {
        super::builders::model_service::PatchModel::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_model_id(model_id.into())
    }

    /// Deletes the model specified by modelId from the dataset.
    pub fn delete_model(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        model_id: impl Into<std::string::String>,
    ) -> super::builders::model_service::DeleteModel {
        super::builders::model_service::DeleteModel::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_model_id(model_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
/// This service provides access to BigQuery functionality related to projects.
///
/// # Configuration
///
/// `ProjectService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ProjectService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ProjectService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ProjectService {
    inner: Arc<dyn super::stubs::dynamic::ProjectService>,
}

impl ProjectService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::ProjectService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::ProjectService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::ProjectService> {
        super::transport::ProjectService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::ProjectService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ProjectService::new)
    }

    /// RPC to get the service account for a project used for interactions with
    /// Google Cloud KMS
    pub fn get_service_account(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builders::project_service::GetServiceAccount {
        super::builders::project_service::GetServiceAccount::new(self.inner.clone())
            .set_project_id(project_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
/// RoutineService provides management access to BigQuery routines.
///
/// # Configuration
///
/// `RoutineService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `RoutineService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RoutineService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct RoutineService {
    inner: Arc<dyn super::stubs::dynamic::RoutineService>,
}

impl RoutineService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::RoutineService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::RoutineService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::RoutineService> {
        super::transport::RoutineService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::RoutineService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RoutineService::new)
    }

    /// Gets the specified routine resource by routine ID.
    pub fn get_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        routine_id: impl Into<std::string::String>,
    ) -> super::builders::routine_service::GetRoutine {
        super::builders::routine_service::GetRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_routine_id(routine_id.into())
    }

    /// Creates a new routine in the dataset.
    pub fn insert_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::routine_service::InsertRoutine {
        super::builders::routine_service::InsertRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Updates information in an existing routine. The update method replaces the
    /// entire Routine resource.
    pub fn update_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        routine_id: impl Into<std::string::String>,
    ) -> super::builders::routine_service::UpdateRoutine {
        super::builders::routine_service::UpdateRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_routine_id(routine_id.into())
    }

    /// Deletes the routine specified by routineId from the dataset.
    pub fn delete_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        routine_id: impl Into<std::string::String>,
    ) -> super::builders::routine_service::DeleteRoutine {
        super::builders::routine_service::DeleteRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_routine_id(routine_id.into())
    }

    /// Lists all routines in the specified dataset. Requires the READER dataset
    /// role.
    pub fn list_routines(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::routine_service::ListRoutines {
        super::builders::routine_service::ListRoutines::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
/// Service for interacting with row access policies.
///
/// # Configuration
///
/// `RowAccessPolicyService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `RowAccessPolicyService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RowAccessPolicyService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct RowAccessPolicyService {
    inner: Arc<dyn super::stubs::dynamic::RowAccessPolicyService>,
}

impl RowAccessPolicyService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::RowAccessPolicyService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::RowAccessPolicyService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::RowAccessPolicyService> {
        super::transport::RowAccessPolicyService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::RowAccessPolicyService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RowAccessPolicyService::new)
    }

    /// Lists all row access policies on the specified table.
    pub fn list_row_access_policies(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::row_access_policy_service::ListRowAccessPolicies {
        super::builders::row_access_policy_service::ListRowAccessPolicies::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Gets the specified row access policy by policy ID.
    pub fn get_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
        policy_id: impl Into<std::string::String>,
    ) -> super::builders::row_access_policy_service::GetRowAccessPolicy {
        super::builders::row_access_policy_service::GetRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
            .set_policy_id(policy_id.into())
    }

    /// Creates a row access policy.
    pub fn create_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::row_access_policy_service::CreateRowAccessPolicy {
        super::builders::row_access_policy_service::CreateRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Updates a row access policy.
    pub fn update_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
        policy_id: impl Into<std::string::String>,
    ) -> super::builders::row_access_policy_service::UpdateRowAccessPolicy {
        super::builders::row_access_policy_service::UpdateRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
            .set_policy_id(policy_id.into())
    }

    /// Deletes a row access policy.
    pub fn delete_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
        policy_id: impl Into<std::string::String>,
    ) -> super::builders::row_access_policy_service::DeleteRowAccessPolicy {
        super::builders::row_access_policy_service::DeleteRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
            .set_policy_id(policy_id.into())
    }

    /// Deletes provided row access policies.
    pub fn batch_delete_row_access_policies(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::row_access_policy_service::BatchDeleteRowAccessPolicies {
        super::builders::row_access_policy_service::BatchDeleteRowAccessPolicies::new(
            self.inner.clone(),
        )
        .set_project_id(project_id.into())
        .set_dataset_id(dataset_id.into())
        .set_table_id(table_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Service Description
///
/// TableService provides methods for managing BigQuery tables and table-like
/// entities such as views and snapshots.
///
/// # Configuration
///
/// `TableService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `TableService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TableService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct TableService {
    inner: Arc<dyn super::stubs::dynamic::TableService>,
}

impl TableService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stubs::TableService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn super::stubs::dynamic::TableService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::TableService> {
        super::transport::TableService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl super::stubs::TableService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TableService::new)
    }

    /// Gets the specified table resource by table ID.
    /// This method does not return the data in the table, it only returns the
    /// table resource, which describes the structure of this table.
    pub fn get_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::table_service::GetTable {
        super::builders::table_service::GetTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Creates a new, empty table in the dataset.
    pub fn insert_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::table_service::InsertTable {
        super::builders::table_service::InsertTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Updates information in an existing table. The update method replaces the
    /// entire table resource, whereas the patch method only replaces fields that
    /// are provided in the submitted table resource.
    /// This method supports RFC5789 patch semantics.
    pub fn patch_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::table_service::PatchTable {
        super::builders::table_service::PatchTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Updates information in an existing table. The update method replaces the
    /// entire Table resource, whereas the patch method only replaces fields that
    /// are provided in the submitted Table resource.
    pub fn update_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::table_service::UpdateTable {
        super::builders::table_service::UpdateTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Deletes the table specified by tableId from the dataset.
    /// If the table contains data, all the data will be deleted.
    pub fn delete_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builders::table_service::DeleteTable {
        super::builders::table_service::DeleteTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Lists all tables in the specified dataset. Requires the READER dataset
    /// role.
    pub fn list_tables(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builders::table_service::ListTables {
        super::builders::table_service::ListTables::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }
}
