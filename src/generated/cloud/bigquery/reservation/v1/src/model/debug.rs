// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::Reservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Reservation");
        debug_struct.field("name", &self.name);
        debug_struct.field("slot_capacity", &self.slot_capacity);
        debug_struct.field("ignore_idle_slots", &self.ignore_idle_slots);
        debug_struct.field("autoscale", &self.autoscale);
        debug_struct.field("concurrency", &self.concurrency);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("multi_region_auxiliary", &self.multi_region_auxiliary);
        debug_struct.field("edition", &self.edition);
        debug_struct.field("primary_location", &self.primary_location);
        debug_struct.field("secondary_location", &self.secondary_location);
        debug_struct.field("original_primary_location", &self.original_primary_location);
        debug_struct.field("max_slots", &self.max_slots);
        debug_struct.field("scaling_mode", &self.scaling_mode);
        debug_struct.field("replication_status", &self.replication_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::reservation::Autoscale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Autoscale");
        debug_struct.field("current_slots", &self.current_slots);
        debug_struct.field("max_slots", &self.max_slots);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::reservation::ReplicationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationStatus");
        debug_struct.field("error", &self.error);
        debug_struct.field("last_error_time", &self.last_error_time);
        debug_struct.field("last_replication_time", &self.last_replication_time);
        debug_struct.field("soft_failover_start_time", &self.soft_failover_start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CapacityCommitment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CapacityCommitment");
        debug_struct.field("name", &self.name);
        debug_struct.field("slot_count", &self.slot_count);
        debug_struct.field("plan", &self.plan);
        debug_struct.field("state", &self.state);
        debug_struct.field("commitment_start_time", &self.commitment_start_time);
        debug_struct.field("commitment_end_time", &self.commitment_end_time);
        debug_struct.field("failure_status", &self.failure_status);
        debug_struct.field("renewal_plan", &self.renewal_plan);
        debug_struct.field("multi_region_auxiliary", &self.multi_region_auxiliary);
        debug_struct.field("edition", &self.edition);
        debug_struct.field("is_flat_rate", &self.is_flat_rate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReservationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("reservation_id", &self.reservation_id);
        debug_struct.field("reservation", &self.reservation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListReservationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReservationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListReservationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReservationsResponse");
        debug_struct.field("reservations", &self.reservations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateReservationRequest");
        debug_struct.field("reservation", &self.reservation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FailoverReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FailoverReservationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("failover_mode", &self.failover_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCapacityCommitmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("capacity_commitment", &self.capacity_commitment);
        debug_struct.field(
            "enforce_single_admin_project_per_org",
            &self.enforce_single_admin_project_per_org,
        );
        debug_struct.field("capacity_commitment_id", &self.capacity_commitment_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListCapacityCommitmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCapacityCommitmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListCapacityCommitmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCapacityCommitmentsResponse");
        debug_struct.field("capacity_commitments", &self.capacity_commitments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCapacityCommitmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCapacityCommitmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCapacityCommitmentRequest");
        debug_struct.field("capacity_commitment", &self.capacity_commitment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SplitCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SplitCapacityCommitmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("slot_count", &self.slot_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SplitCapacityCommitmentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SplitCapacityCommitmentResponse");
        debug_struct.field("first", &self.first);
        debug_struct.field("second", &self.second);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MergeCapacityCommitmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MergeCapacityCommitmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("capacity_commitment_ids", &self.capacity_commitment_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Assignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Assignment");
        debug_struct.field("name", &self.name);
        debug_struct.field("assignee", &self.assignee);
        debug_struct.field("job_type", &self.job_type);
        debug_struct.field("state", &self.state);
        debug_struct.field("enable_gemini_in_bigquery", &self.enable_gemini_in_bigquery);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAssignmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("assignment", &self.assignment);
        debug_struct.field("assignment_id", &self.assignment_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssignmentsResponse");
        debug_struct.field("assignments", &self.assignments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAssignmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("query", &self.query);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchAllAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("query", &self.query);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAssignmentsResponse");
        debug_struct.field("assignments", &self.assignments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchAllAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllAssignmentsResponse");
        debug_struct.field("assignments", &self.assignments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MoveAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveAssignmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("destination_id", &self.destination_id);
        debug_struct.field("assignment_id", &self.assignment_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAssignmentRequest");
        debug_struct.field("assignment", &self.assignment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BiReservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BiReservation");
        debug_struct.field("name", &self.name);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("size", &self.size);
        debug_struct.field("preferred_tables", &self.preferred_tables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBiReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBiReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBiReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBiReservationRequest");
        debug_struct.field("bi_reservation", &self.bi_reservation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
