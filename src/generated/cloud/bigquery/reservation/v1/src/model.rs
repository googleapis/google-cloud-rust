// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A reservation is a mechanism used to guarantee slots to users.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Reservation {
    /// The resource name of the reservation, e.g.,
    /// `projects/*/locations/*/reservations/team1-prod`.
    /// The reservation_id must only contain lower case alphanumeric characters or
    /// dashes. It must start with a letter and must not end with a dash. Its
    /// maximum length is 64 characters.
    pub name: std::string::String,

    /// Baseline slots available to this reservation. A slot is a unit of
    /// computational power in BigQuery, and serves as the unit of parallelism.
    ///
    /// Queries using this reservation might use more slots during runtime if
    /// ignore_idle_slots is set to false, or autoscaling is enabled.
    ///
    /// The total slot_capacity of the reservation and its siblings
    /// may exceed the total slot_count of capacity commitments. In that case, the
    /// exceeding slots will be charged with the autoscale SKU. You can increase
    /// the number of baseline slots in a reservation every few minutes. If you
    /// want to decrease your baseline slots, you are limited to once an hour if
    /// you have recently changed your baseline slot capacity and your baseline
    /// slots exceed your committed slots. Otherwise, you can decrease your
    /// baseline slots every few minutes.
    pub slot_capacity: i64,

    /// If false, any query or pipeline job using this reservation will use idle
    /// slots from other reservations within the same admin project. If true, a
    /// query or pipeline job using this reservation will execute with the slot
    /// capacity specified in the slot_capacity field at most.
    pub ignore_idle_slots: bool,

    /// The configuration parameters for the auto scaling feature.
    pub autoscale: std::option::Option<crate::model::reservation::Autoscale>,

    /// Job concurrency target which sets a soft upper bound on the number of jobs
    /// that can run concurrently in this reservation. This is a soft target due to
    /// asynchronous nature of the system and various optimizations for small
    /// queries.
    /// Default value is 0 which means that concurrency target will be
    /// automatically computed by the system.
    /// NOTE: this field is exposed as target job concurrency in the Information
    /// Schema, DDL and BigQuery CLI.
    pub concurrency: i64,

    /// Output only. Creation time of the reservation.
    pub creation_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Last update time of the reservation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Applicable only for reservations located within one of the BigQuery
    /// multi-regions (US or EU).
    ///
    /// If set to true, this reservation is placed in the organization's
    /// secondary region which is designated for disaster recovery purposes.
    /// If false, this reservation is placed in the organization's default region.
    ///
    /// NOTE: this is a preview feature. Project must be allow-listed in order to
    /// set this field.
    pub multi_region_auxiliary: bool,

    /// Edition of the reservation.
    pub edition: crate::model::Edition,

    /// Output only. The current location of the reservation's primary replica.
    /// This field is only set for reservations using the managed disaster recovery
    /// feature.
    pub primary_location: std::string::String,

    /// Optional. The current location of the reservation's secondary replica. This
    /// field is only set for reservations using the managed disaster recovery
    /// feature. Users can set this in create reservation calls
    /// to create a failover reservation or in update reservation calls to convert
    /// a non-failover reservation to a failover reservation(or vice versa).
    pub secondary_location: std::string::String,

    /// Output only. The location where the reservation was originally created.
    /// This is set only during the failover reservation's creation. All billing
    /// charges for the failover reservation will be applied to this location.
    pub original_primary_location: std::string::String,

    /// Optional. The overall max slots for the reservation, covering slot_capacity
    /// (baseline), idle slots (if ignore_idle_slots is false) and scaled slots.
    /// If present, the reservation won't use more than the specified number of
    /// slots, even if there is demand and supply (from idle slots).
    /// NOTE: capping a reservation's idle slot usage is best effort and its
    /// usage may exceed the max_slots value. However, in terms of
    /// autoscale.current_slots (which accounts for the additional added slots), it
    /// will never exceed the max_slots - baseline.
    ///
    /// This field must be set together with the scaling_mode enum value.
    ///
    /// If the max_slots and scaling_mode are set, the autoscale or
    /// autoscale.max_slots field must be unset. However, the
    /// autoscale field may still be in the output. The autopscale.max_slots will
    /// always show as 0 and the autoscaler.current_slots will represent the
    /// current slots from autoscaler excluding idle slots.
    /// For example, if the max_slots is 1000 and scaling_mode is AUTOSCALE_ONLY,
    /// then in the output, the autoscaler.max_slots will be 0 and the
    /// autoscaler.current_slots may be any value between 0 and 1000.
    ///
    /// If the max_slots is 1000, scaling_mode is ALL_SLOTS, the baseline is 100
    /// and idle slots usage is 200, then in the output, the autoscaler.max_slots
    /// will be 0 and the autoscaler.current_slots will not be higher than 700.
    ///
    /// If the max_slots is 1000, scaling_mode is IDLE_SLOTS_ONLY, then in the
    /// output, the autoscaler field will be null.
    ///
    /// If the max_slots and scaling_mode are set, then the ignore_idle_slots field
    /// must be aligned with the scaling_mode enum value.(See details in
    /// ScalingMode comments).
    ///
    /// Please note,  the max_slots is for user to manage the part of slots greater
    /// than the baseline. Therefore, we don't allow users to set max_slots smaller
    /// or equal to the baseline as it will not be meaningful. If the field is
    /// present and slot_capacity>=max_slots.
    ///
    /// Please note that if max_slots is set to 0, we will treat it as unset.
    /// Customers can set max_slots to 0 and set scaling_mode to
    /// SCALING_MODE_UNSPECIFIED to disable the max_slots feature.
    pub max_slots: std::option::Option<i64>,

    /// Optional. The scaling mode for the reservation.
    /// If the field is present but max_slots is not present.
    pub scaling_mode: crate::model::reservation::ScalingMode,

    /// Output only. The Disaster Recovery(DR) replication status of the
    /// reservation. This is only available for the primary replicas of DR/failover
    /// reservations and provides information about the both the staleness of the
    /// secondary and the last error encountered while trying to replicate changes
    /// from the primary to the secondary. If this field is blank, it means that
    /// the reservation is either not a DR reservation or the reservation is a DR
    /// secondary or that any replication operations on the reservation have
    /// succeeded.
    pub replication_status: std::option::Option<crate::model::reservation::ReplicationStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Reservation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Reservation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slot_capacity][crate::model::Reservation::slot_capacity].
    pub fn set_slot_capacity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.slot_capacity = v.into();
        self
    }

    /// Sets the value of [ignore_idle_slots][crate::model::Reservation::ignore_idle_slots].
    pub fn set_ignore_idle_slots<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_idle_slots = v.into();
        self
    }

    /// Sets the value of [autoscale][crate::model::Reservation::autoscale].
    pub fn set_autoscale<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::reservation::Autoscale>,
    {
        self.autoscale = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscale][crate::model::Reservation::autoscale].
    pub fn set_or_clear_autoscale<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::reservation::Autoscale>,
    {
        self.autoscale = v.map(|x| x.into());
        self
    }

    /// Sets the value of [concurrency][crate::model::Reservation::concurrency].
    pub fn set_concurrency<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.concurrency = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Reservation::creation_time].
    pub fn set_creation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_time][crate::model::Reservation::creation_time].
    pub fn set_or_clear_creation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Reservation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Reservation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [multi_region_auxiliary][crate::model::Reservation::multi_region_auxiliary].
    pub fn set_multi_region_auxiliary<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multi_region_auxiliary = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::Reservation::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::Edition>>(mut self, v: T) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [primary_location][crate::model::Reservation::primary_location].
    pub fn set_primary_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_location = v.into();
        self
    }

    /// Sets the value of [secondary_location][crate::model::Reservation::secondary_location].
    pub fn set_secondary_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_location = v.into();
        self
    }

    /// Sets the value of [original_primary_location][crate::model::Reservation::original_primary_location].
    pub fn set_original_primary_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.original_primary_location = v.into();
        self
    }

    /// Sets the value of [max_slots][crate::model::Reservation::max_slots].
    pub fn set_max_slots<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.max_slots = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_slots][crate::model::Reservation::max_slots].
    pub fn set_or_clear_max_slots<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.max_slots = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scaling_mode][crate::model::Reservation::scaling_mode].
    pub fn set_scaling_mode<T: std::convert::Into<crate::model::reservation::ScalingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling_mode = v.into();
        self
    }

    /// Sets the value of [replication_status][crate::model::Reservation::replication_status].
    pub fn set_replication_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::reservation::ReplicationStatus>,
    {
        self.replication_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_status][crate::model::Reservation::replication_status].
    pub fn set_or_clear_replication_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::reservation::ReplicationStatus>,
    {
        self.replication_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Reservation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.Reservation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Reservation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __slot_capacity,
            __ignore_idle_slots,
            __autoscale,
            __concurrency,
            __creation_time,
            __update_time,
            __multi_region_auxiliary,
            __edition,
            __primary_location,
            __secondary_location,
            __original_primary_location,
            __max_slots,
            __scaling_mode,
            __replication_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Reservation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "slotCapacity" => Ok(__FieldTag::__slot_capacity),
                            "slot_capacity" => Ok(__FieldTag::__slot_capacity),
                            "ignoreIdleSlots" => Ok(__FieldTag::__ignore_idle_slots),
                            "ignore_idle_slots" => Ok(__FieldTag::__ignore_idle_slots),
                            "autoscale" => Ok(__FieldTag::__autoscale),
                            "concurrency" => Ok(__FieldTag::__concurrency),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "multiRegionAuxiliary" => Ok(__FieldTag::__multi_region_auxiliary),
                            "multi_region_auxiliary" => Ok(__FieldTag::__multi_region_auxiliary),
                            "edition" => Ok(__FieldTag::__edition),
                            "primaryLocation" => Ok(__FieldTag::__primary_location),
                            "primary_location" => Ok(__FieldTag::__primary_location),
                            "secondaryLocation" => Ok(__FieldTag::__secondary_location),
                            "secondary_location" => Ok(__FieldTag::__secondary_location),
                            "originalPrimaryLocation" => {
                                Ok(__FieldTag::__original_primary_location)
                            }
                            "original_primary_location" => {
                                Ok(__FieldTag::__original_primary_location)
                            }
                            "maxSlots" => Ok(__FieldTag::__max_slots),
                            "max_slots" => Ok(__FieldTag::__max_slots),
                            "scalingMode" => Ok(__FieldTag::__scaling_mode),
                            "scaling_mode" => Ok(__FieldTag::__scaling_mode),
                            "replicationStatus" => Ok(__FieldTag::__replication_status),
                            "replication_status" => Ok(__FieldTag::__replication_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Reservation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Reservation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slot_capacity => {
                            if !fields.insert(__FieldTag::__slot_capacity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slot_capacity",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.slot_capacity =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ignore_idle_slots => {
                            if !fields.insert(__FieldTag::__ignore_idle_slots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_idle_slots",
                                ));
                            }
                            result.ignore_idle_slots = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscale => {
                            if !fields.insert(__FieldTag::__autoscale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscale",
                                ));
                            }
                            result.autoscale = map.next_value::<std::option::Option<crate::model::reservation::Autoscale>>()?
                                ;
                        }
                        __FieldTag::__concurrency => {
                            if !fields.insert(__FieldTag::__concurrency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for concurrency",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.concurrency = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__multi_region_auxiliary => {
                            if !fields.insert(__FieldTag::__multi_region_auxiliary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_region_auxiliary",
                                ));
                            }
                            result.multi_region_auxiliary = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__edition => {
                            if !fields.insert(__FieldTag::__edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edition",
                                ));
                            }
                            result.edition = map
                                .next_value::<std::option::Option<crate::model::Edition>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_location => {
                            if !fields.insert(__FieldTag::__primary_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_location",
                                ));
                            }
                            result.primary_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_location => {
                            if !fields.insert(__FieldTag::__secondary_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_location",
                                ));
                            }
                            result.secondary_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__original_primary_location => {
                            if !fields.insert(__FieldTag::__original_primary_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_primary_location",
                                ));
                            }
                            result.original_primary_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_slots => {
                            if !fields.insert(__FieldTag::__max_slots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_slots",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_slots = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__scaling_mode => {
                            if !fields.insert(__FieldTag::__scaling_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scaling_mode",
                                ));
                            }
                            result.scaling_mode = map.next_value::<std::option::Option<crate::model::reservation::ScalingMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__replication_status => {
                            if !fields.insert(__FieldTag::__replication_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_status",
                                ));
                            }
                            result.replication_status =
                                map.next_value::<std::option::Option<
                                    crate::model::reservation::ReplicationStatus,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Reservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.slot_capacity) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("slotCapacity", &__With(&self.slot_capacity))?;
        }
        if !wkt::internal::is_default(&self.ignore_idle_slots) {
            state.serialize_entry("ignoreIdleSlots", &self.ignore_idle_slots)?;
        }
        if self.autoscale.is_some() {
            state.serialize_entry("autoscale", &self.autoscale)?;
        }
        if !wkt::internal::is_default(&self.concurrency) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("concurrency", &__With(&self.concurrency))?;
        }
        if self.creation_time.is_some() {
            state.serialize_entry("creationTime", &self.creation_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.multi_region_auxiliary) {
            state.serialize_entry("multiRegionAuxiliary", &self.multi_region_auxiliary)?;
        }
        if !wkt::internal::is_default(&self.edition) {
            state.serialize_entry("edition", &self.edition)?;
        }
        if !self.primary_location.is_empty() {
            state.serialize_entry("primaryLocation", &self.primary_location)?;
        }
        if !self.secondary_location.is_empty() {
            state.serialize_entry("secondaryLocation", &self.secondary_location)?;
        }
        if !self.original_primary_location.is_empty() {
            state.serialize_entry("originalPrimaryLocation", &self.original_primary_location)?;
        }
        if self.max_slots.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxSlots", &__With(&self.max_slots))?;
        }
        if !wkt::internal::is_default(&self.scaling_mode) {
            state.serialize_entry("scalingMode", &self.scaling_mode)?;
        }
        if self.replication_status.is_some() {
            state.serialize_entry("replicationStatus", &self.replication_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Reservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Reservation");
        debug_struct.field("name", &self.name);
        debug_struct.field("slot_capacity", &self.slot_capacity);
        debug_struct.field("ignore_idle_slots", &self.ignore_idle_slots);
        debug_struct.field("autoscale", &self.autoscale);
        debug_struct.field("concurrency", &self.concurrency);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("multi_region_auxiliary", &self.multi_region_auxiliary);
        debug_struct.field("edition", &self.edition);
        debug_struct.field("primary_location", &self.primary_location);
        debug_struct.field("secondary_location", &self.secondary_location);
        debug_struct.field("original_primary_location", &self.original_primary_location);
        debug_struct.field("max_slots", &self.max_slots);
        debug_struct.field("scaling_mode", &self.scaling_mode);
        debug_struct.field("replication_status", &self.replication_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Reservation].
pub mod reservation {
    #[allow(unused_imports)]
    use super::*;

    /// Auto scaling settings.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Autoscale {
        /// Output only. The slot capacity added to this reservation when autoscale
        /// happens. Will be between [0, max_slots]. Note: after users reduce
        /// max_slots, it may take a while before it can be propagated, so
        /// current_slots may stay in the original value and could be larger than
        /// max_slots for that brief period (less than one minute)
        pub current_slots: i64,

        /// Number of slots to be scaled when needed.
        pub max_slots: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Autoscale {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [current_slots][crate::model::reservation::Autoscale::current_slots].
        pub fn set_current_slots<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.current_slots = v.into();
            self
        }

        /// Sets the value of [max_slots][crate::model::reservation::Autoscale::max_slots].
        pub fn set_max_slots<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_slots = v.into();
            self
        }
    }

    impl wkt::message::Message for Autoscale {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.reservation.v1.Reservation.Autoscale"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Autoscale {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __current_slots,
                __max_slots,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Autoscale")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "currentSlots" => Ok(__FieldTag::__current_slots),
                                "current_slots" => Ok(__FieldTag::__current_slots),
                                "maxSlots" => Ok(__FieldTag::__max_slots),
                                "max_slots" => Ok(__FieldTag::__max_slots),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Autoscale;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Autoscale")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__current_slots => {
                                if !fields.insert(__FieldTag::__current_slots) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for current_slots",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.current_slots =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_slots => {
                                if !fields.insert(__FieldTag::__max_slots) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_slots",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_slots =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Autoscale {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.current_slots) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("currentSlots", &__With(&self.current_slots))?;
            }
            if !wkt::internal::is_default(&self.max_slots) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxSlots", &__With(&self.max_slots))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Autoscale {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Autoscale");
            debug_struct.field("current_slots", &self.current_slots);
            debug_struct.field("max_slots", &self.max_slots);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Disaster Recovery(DR) replication status of the reservation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReplicationStatus {
        /// Output only. The last error encountered while trying to replicate changes
        /// from the primary to the secondary. This field is only available if the
        /// replication has not succeeded since.
        pub error: std::option::Option<rpc::model::Status>,

        /// Output only. The time at which the last error was encountered while
        /// trying to replicate changes from the primary to the secondary. This field
        /// is only available if the replication has not succeeded since.
        pub last_error_time: std::option::Option<wkt::Timestamp>,

        /// Output only. A timestamp corresponding to the last change on the primary
        /// that was successfully replicated to the secondary.
        pub last_replication_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReplicationStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error][crate::model::reservation::ReplicationStatus::error].
        pub fn set_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [error][crate::model::reservation::ReplicationStatus::error].
        pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.error = v.map(|x| x.into());
            self
        }

        /// Sets the value of [last_error_time][crate::model::reservation::ReplicationStatus::last_error_time].
        pub fn set_last_error_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_error_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_error_time][crate::model::reservation::ReplicationStatus::last_error_time].
        pub fn set_or_clear_last_error_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_error_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [last_replication_time][crate::model::reservation::ReplicationStatus::last_replication_time].
        pub fn set_last_replication_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_replication_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_replication_time][crate::model::reservation::ReplicationStatus::last_replication_time].
        pub fn set_or_clear_last_replication_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_replication_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ReplicationStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.reservation.v1.Reservation.ReplicationStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReplicationStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __error,
                __last_error_time,
                __last_replication_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReplicationStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "error" => Ok(__FieldTag::__error),
                                "lastErrorTime" => Ok(__FieldTag::__last_error_time),
                                "last_error_time" => Ok(__FieldTag::__last_error_time),
                                "lastReplicationTime" => Ok(__FieldTag::__last_replication_time),
                                "last_replication_time" => Ok(__FieldTag::__last_replication_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReplicationStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReplicationStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__last_error_time => {
                                if !fields.insert(__FieldTag::__last_error_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_error_time",
                                    ));
                                }
                                result.last_error_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__last_replication_time => {
                                if !fields.insert(__FieldTag::__last_replication_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_replication_time",
                                    ));
                                }
                                result.last_replication_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReplicationStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.error.is_some() {
                state.serialize_entry("error", &self.error)?;
            }
            if self.last_error_time.is_some() {
                state.serialize_entry("lastErrorTime", &self.last_error_time)?;
            }
            if self.last_replication_time.is_some() {
                state.serialize_entry("lastReplicationTime", &self.last_replication_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ReplicationStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ReplicationStatus");
            debug_struct.field("error", &self.error);
            debug_struct.field("last_error_time", &self.last_error_time);
            debug_struct.field("last_replication_time", &self.last_replication_time);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The scaling mode for the reservation. This enum determines how the
    /// reservation scales up and down.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScalingMode {
        /// Default value of ScalingMode.
        Unspecified,
        /// The reservation will scale up only using slots from autoscaling. It will
        /// not use any idle slots even if there may be some available. The upper
        /// limit that autoscaling can scale up to will be max_slots - baseline.
        /// For example, if max_slots is 1000, baseline is 200 and customer sets
        /// ScalingMode to AUTOSCALE_ONLY, then autoscalerg will scale up to 800
        /// slots and no idle slots will be used.
        ///
        /// Please note, in this mode, the ignore_idle_slots field must be set to
        /// true.
        AutoscaleOnly,
        /// The reservation will scale up using only idle slots contributed by
        /// other reservations or from unassigned commitments. If no idle slots are
        /// available it will not scale up further. If the idle slots which it is
        /// using are reclaimed by the contributing reservation(s) it may be forced
        /// to scale down. The max idle slots the reservation can be max_slots -
        /// baseline capacity. For example, if max_slots is 1000, baseline is 200 and
        /// customer sets ScalingMode to IDLE_SLOTS_ONLY,
        ///
        /// 1. if there are 1000 idle slots available in other reservations, the
        ///    reservation will scale up to 1000 slots with 200 baseline and 800 idle
        ///    slots.
        /// 1. if there are 500 idle slots available in other reservations, the
        ///    reservation will scale up to 700 slots with 200 baseline and 300 idle
        ///    slots.
        ///    Please note, in this mode, the reservation might not be able to scale up
        ///    to max_slots.
        ///
        /// Please note, in this mode, the ignore_idle_slots field must be set to
        /// false.
        IdleSlotsOnly,
        /// The reservation will scale up using all slots available to it. It will
        /// use idle slots contributed by other reservations or from unassigned
        /// commitments first. If no idle slots are available it will scale up using
        /// autoscaling. For example, if max_slots is 1000, baseline is 200 and
        /// customer sets ScalingMode to ALL_SLOTS,
        ///
        /// 1. if there are 800 idle slots available in other reservations, the
        ///    reservation will scale up to 1000 slots with 200 baseline and 800 idle
        ///    slots.
        /// 1. if there are 500 idle slots available in other reservations, the
        ///    reservation will scale up to 1000 slots with 200 baseline, 500 idle
        ///    slots and 300 autoscaling slots.
        /// 1. if there are no idle slots available in other reservations, it will
        ///    scale up to 1000 slots with 200 baseline and 800 autoscaling slots.
        ///
        /// Please note, in this mode, the ignore_idle_slots field must be set to
        /// false.
        AllSlots,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScalingMode::value] or
        /// [ScalingMode::name].
        UnknownValue(scaling_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scaling_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScalingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AutoscaleOnly => std::option::Option::Some(1),
                Self::IdleSlotsOnly => std::option::Option::Some(2),
                Self::AllSlots => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCALING_MODE_UNSPECIFIED"),
                Self::AutoscaleOnly => std::option::Option::Some("AUTOSCALE_ONLY"),
                Self::IdleSlotsOnly => std::option::Option::Some("IDLE_SLOTS_ONLY"),
                Self::AllSlots => std::option::Option::Some("ALL_SLOTS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScalingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScalingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScalingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AutoscaleOnly,
                2 => Self::IdleSlotsOnly,
                3 => Self::AllSlots,
                _ => Self::UnknownValue(scaling_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScalingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCALING_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOSCALE_ONLY" => Self::AutoscaleOnly,
                "IDLE_SLOTS_ONLY" => Self::IdleSlotsOnly,
                "ALL_SLOTS" => Self::AllSlots,
                _ => Self::UnknownValue(scaling_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScalingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AutoscaleOnly => serializer.serialize_i32(1),
                Self::IdleSlotsOnly => serializer.serialize_i32(2),
                Self::AllSlots => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScalingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScalingMode>::new(
                ".google.cloud.bigquery.reservation.v1.Reservation.ScalingMode",
            ))
        }
    }
}

/// Capacity commitment is a way to purchase compute capacity for BigQuery jobs
/// (in the form of slots) with some committed period of usage. Annual
/// commitments renew by default. Commitments can be removed after their
/// commitment end time passes.
///
/// In order to remove annual commitment, its plan needs to be changed
/// to monthly or flex first.
///
/// A capacity commitment resource exists as a child resource of the admin
/// project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CapacityCommitment {
    /// Output only. The resource name of the capacity commitment, e.g.,
    /// `projects/myproject/locations/US/capacityCommitments/123`
    /// The commitment_id must only contain lower case alphanumeric characters or
    /// dashes. It must start with a letter and must not end
    /// with a dash. Its maximum length is 64 characters.
    pub name: std::string::String,

    /// Number of slots in this commitment.
    pub slot_count: i64,

    /// Capacity commitment commitment plan.
    pub plan: crate::model::capacity_commitment::CommitmentPlan,

    /// Output only. State of the commitment.
    pub state: crate::model::capacity_commitment::State,

    /// Output only. The start of the current commitment period. It is applicable
    /// only for ACTIVE capacity commitments. Note after the commitment is renewed,
    /// commitment_start_time won't be changed. It refers to the start time of the
    /// original commitment.
    pub commitment_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end of the current commitment period. It is applicable
    /// only for ACTIVE capacity commitments. Note after renewal,
    /// commitment_end_time is the time the renewed commitment expires. So it would
    /// be at a time after commitment_start_time + committed period, because we
    /// don't change commitment_start_time ,
    pub commitment_end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For FAILED commitment plan, provides the reason of failure.
    pub failure_status: std::option::Option<rpc::model::Status>,

    /// The plan this capacity commitment is converted to after commitment_end_time
    /// passes. Once the plan is changed, committed period is extended according to
    /// commitment plan. Only applicable for ANNUAL and TRIAL commitments.
    pub renewal_plan: crate::model::capacity_commitment::CommitmentPlan,

    /// Applicable only for commitments located within one of the BigQuery
    /// multi-regions (US or EU).
    ///
    /// If set to true, this commitment is placed in the organization's
    /// secondary region which is designated for disaster recovery purposes.
    /// If false, this commitment is placed in the organization's default region.
    ///
    /// NOTE: this is a preview feature. Project must be allow-listed in order to
    /// set this field.
    pub multi_region_auxiliary: bool,

    /// Edition of the capacity commitment.
    pub edition: crate::model::Edition,

    /// Output only. If true, the commitment is a flat-rate commitment, otherwise,
    /// it's an edition commitment.
    pub is_flat_rate: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CapacityCommitment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CapacityCommitment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slot_count][crate::model::CapacityCommitment::slot_count].
    pub fn set_slot_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.slot_count = v.into();
        self
    }

    /// Sets the value of [plan][crate::model::CapacityCommitment::plan].
    pub fn set_plan<T: std::convert::Into<crate::model::capacity_commitment::CommitmentPlan>>(
        mut self,
        v: T,
    ) -> Self {
        self.plan = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CapacityCommitment::state].
    pub fn set_state<T: std::convert::Into<crate::model::capacity_commitment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [commitment_start_time][crate::model::CapacityCommitment::commitment_start_time].
    pub fn set_commitment_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.commitment_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [commitment_start_time][crate::model::CapacityCommitment::commitment_start_time].
    pub fn set_or_clear_commitment_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.commitment_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [commitment_end_time][crate::model::CapacityCommitment::commitment_end_time].
    pub fn set_commitment_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.commitment_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [commitment_end_time][crate::model::CapacityCommitment::commitment_end_time].
    pub fn set_or_clear_commitment_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.commitment_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failure_status][crate::model::CapacityCommitment::failure_status].
    pub fn set_failure_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.failure_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failure_status][crate::model::CapacityCommitment::failure_status].
    pub fn set_or_clear_failure_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.failure_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [renewal_plan][crate::model::CapacityCommitment::renewal_plan].
    pub fn set_renewal_plan<
        T: std::convert::Into<crate::model::capacity_commitment::CommitmentPlan>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.renewal_plan = v.into();
        self
    }

    /// Sets the value of [multi_region_auxiliary][crate::model::CapacityCommitment::multi_region_auxiliary].
    pub fn set_multi_region_auxiliary<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multi_region_auxiliary = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::CapacityCommitment::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::Edition>>(mut self, v: T) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [is_flat_rate][crate::model::CapacityCommitment::is_flat_rate].
    pub fn set_is_flat_rate<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_flat_rate = v.into();
        self
    }
}

impl wkt::message::Message for CapacityCommitment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.CapacityCommitment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CapacityCommitment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __slot_count,
            __plan,
            __state,
            __commitment_start_time,
            __commitment_end_time,
            __failure_status,
            __renewal_plan,
            __multi_region_auxiliary,
            __edition,
            __is_flat_rate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CapacityCommitment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "slotCount" => Ok(__FieldTag::__slot_count),
                            "slot_count" => Ok(__FieldTag::__slot_count),
                            "plan" => Ok(__FieldTag::__plan),
                            "state" => Ok(__FieldTag::__state),
                            "commitmentStartTime" => Ok(__FieldTag::__commitment_start_time),
                            "commitment_start_time" => Ok(__FieldTag::__commitment_start_time),
                            "commitmentEndTime" => Ok(__FieldTag::__commitment_end_time),
                            "commitment_end_time" => Ok(__FieldTag::__commitment_end_time),
                            "failureStatus" => Ok(__FieldTag::__failure_status),
                            "failure_status" => Ok(__FieldTag::__failure_status),
                            "renewalPlan" => Ok(__FieldTag::__renewal_plan),
                            "renewal_plan" => Ok(__FieldTag::__renewal_plan),
                            "multiRegionAuxiliary" => Ok(__FieldTag::__multi_region_auxiliary),
                            "multi_region_auxiliary" => Ok(__FieldTag::__multi_region_auxiliary),
                            "edition" => Ok(__FieldTag::__edition),
                            "isFlatRate" => Ok(__FieldTag::__is_flat_rate),
                            "is_flat_rate" => Ok(__FieldTag::__is_flat_rate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CapacityCommitment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CapacityCommitment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slot_count => {
                            if !fields.insert(__FieldTag::__slot_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slot_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.slot_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__plan => {
                            if !fields.insert(__FieldTag::__plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plan",
                                ));
                            }
                            result.plan = map
                                .next_value::<std::option::Option<
                                    crate::model::capacity_commitment::CommitmentPlan,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::capacity_commitment::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__commitment_start_time => {
                            if !fields.insert(__FieldTag::__commitment_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commitment_start_time",
                                ));
                            }
                            result.commitment_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__commitment_end_time => {
                            if !fields.insert(__FieldTag::__commitment_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commitment_end_time",
                                ));
                            }
                            result.commitment_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__failure_status => {
                            if !fields.insert(__FieldTag::__failure_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_status",
                                ));
                            }
                            result.failure_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__renewal_plan => {
                            if !fields.insert(__FieldTag::__renewal_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for renewal_plan",
                                ));
                            }
                            result.renewal_plan = map
                                .next_value::<std::option::Option<
                                    crate::model::capacity_commitment::CommitmentPlan,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_region_auxiliary => {
                            if !fields.insert(__FieldTag::__multi_region_auxiliary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_region_auxiliary",
                                ));
                            }
                            result.multi_region_auxiliary = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__edition => {
                            if !fields.insert(__FieldTag::__edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edition",
                                ));
                            }
                            result.edition = map
                                .next_value::<std::option::Option<crate::model::Edition>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_flat_rate => {
                            if !fields.insert(__FieldTag::__is_flat_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_flat_rate",
                                ));
                            }
                            result.is_flat_rate = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CapacityCommitment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.slot_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("slotCount", &__With(&self.slot_count))?;
        }
        if !wkt::internal::is_default(&self.plan) {
            state.serialize_entry("plan", &self.plan)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.commitment_start_time.is_some() {
            state.serialize_entry("commitmentStartTime", &self.commitment_start_time)?;
        }
        if self.commitment_end_time.is_some() {
            state.serialize_entry("commitmentEndTime", &self.commitment_end_time)?;
        }
        if self.failure_status.is_some() {
            state.serialize_entry("failureStatus", &self.failure_status)?;
        }
        if !wkt::internal::is_default(&self.renewal_plan) {
            state.serialize_entry("renewalPlan", &self.renewal_plan)?;
        }
        if !wkt::internal::is_default(&self.multi_region_auxiliary) {
            state.serialize_entry("multiRegionAuxiliary", &self.multi_region_auxiliary)?;
        }
        if !wkt::internal::is_default(&self.edition) {
            state.serialize_entry("edition", &self.edition)?;
        }
        if !wkt::internal::is_default(&self.is_flat_rate) {
            state.serialize_entry("isFlatRate", &self.is_flat_rate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CapacityCommitment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CapacityCommitment");
        debug_struct.field("name", &self.name);
        debug_struct.field("slot_count", &self.slot_count);
        debug_struct.field("plan", &self.plan);
        debug_struct.field("state", &self.state);
        debug_struct.field("commitment_start_time", &self.commitment_start_time);
        debug_struct.field("commitment_end_time", &self.commitment_end_time);
        debug_struct.field("failure_status", &self.failure_status);
        debug_struct.field("renewal_plan", &self.renewal_plan);
        debug_struct.field("multi_region_auxiliary", &self.multi_region_auxiliary);
        debug_struct.field("edition", &self.edition);
        debug_struct.field("is_flat_rate", &self.is_flat_rate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CapacityCommitment].
pub mod capacity_commitment {
    #[allow(unused_imports)]
    use super::*;

    /// Commitment plan defines the current committed period. Capacity commitment
    /// cannot be deleted during it's committed period.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommitmentPlan {
        /// Invalid plan value. Requests with this value will be rejected with
        /// error code `google.rpc.Code.INVALID_ARGUMENT`.
        Unspecified,
        /// Flex commitments have committed period of 1 minute after becoming ACTIVE.
        /// After that, they are not in a committed period anymore and can be removed
        /// any time.
        Flex,
        /// Same as FLEX, should only be used if flat-rate commitments are still
        /// available.
        #[deprecated]
        FlexFlatRate,
        /// Trial commitments have a committed period of 182 days after becoming
        /// ACTIVE. After that, they are converted to a new commitment based on the
        /// `renewal_plan`. Default `renewal_plan` for Trial commitment is Flex so
        /// that it can be deleted right after committed period ends.
        #[deprecated]
        Trial,
        /// Monthly commitments have a committed period of 30 days after becoming
        /// ACTIVE. After that, they are not in a committed period anymore and can be
        /// removed any time.
        Monthly,
        /// Same as MONTHLY, should only be used if flat-rate commitments are still
        /// available.
        #[deprecated]
        MonthlyFlatRate,
        /// Annual commitments have a committed period of 365 days after becoming
        /// ACTIVE. After that they are converted to a new commitment based on the
        /// renewal_plan.
        Annual,
        /// Same as ANNUAL, should only be used if flat-rate commitments are still
        /// available.
        #[deprecated]
        AnnualFlatRate,
        /// 3-year commitments have a committed period of 1095(3 * 365) days after
        /// becoming ACTIVE. After that they are converted to a new commitment based
        /// on the renewal_plan.
        ThreeYear,
        /// Should only be used for `renewal_plan` and is only meaningful if
        /// edition is specified to values other than EDITION_UNSPECIFIED. Otherwise
        /// CreateCapacityCommitmentRequest or UpdateCapacityCommitmentRequest will
        /// be rejected with error code `google.rpc.Code.INVALID_ARGUMENT`. If the
        /// renewal_plan is NONE, capacity commitment will be removed at the end of
        /// its commitment period.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommitmentPlan::value] or
        /// [CommitmentPlan::name].
        UnknownValue(commitment_plan::UnknownValue),
    }

    #[doc(hidden)]
    pub mod commitment_plan {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommitmentPlan {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Flex => std::option::Option::Some(3),
                Self::FlexFlatRate => std::option::Option::Some(7),
                Self::Trial => std::option::Option::Some(5),
                Self::Monthly => std::option::Option::Some(2),
                Self::MonthlyFlatRate => std::option::Option::Some(8),
                Self::Annual => std::option::Option::Some(4),
                Self::AnnualFlatRate => std::option::Option::Some(9),
                Self::ThreeYear => std::option::Option::Some(10),
                Self::None => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMMITMENT_PLAN_UNSPECIFIED"),
                Self::Flex => std::option::Option::Some("FLEX"),
                Self::FlexFlatRate => std::option::Option::Some("FLEX_FLAT_RATE"),
                Self::Trial => std::option::Option::Some("TRIAL"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::MonthlyFlatRate => std::option::Option::Some("MONTHLY_FLAT_RATE"),
                Self::Annual => std::option::Option::Some("ANNUAL"),
                Self::AnnualFlatRate => std::option::Option::Some("ANNUAL_FLAT_RATE"),
                Self::ThreeYear => std::option::Option::Some("THREE_YEAR"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommitmentPlan {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommitmentPlan {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommitmentPlan {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Monthly,
                3 => Self::Flex,
                4 => Self::Annual,
                5 => Self::Trial,
                6 => Self::None,
                7 => Self::FlexFlatRate,
                8 => Self::MonthlyFlatRate,
                9 => Self::AnnualFlatRate,
                10 => Self::ThreeYear,
                _ => Self::UnknownValue(commitment_plan::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommitmentPlan {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMITMENT_PLAN_UNSPECIFIED" => Self::Unspecified,
                "FLEX" => Self::Flex,
                "FLEX_FLAT_RATE" => Self::FlexFlatRate,
                "TRIAL" => Self::Trial,
                "MONTHLY" => Self::Monthly,
                "MONTHLY_FLAT_RATE" => Self::MonthlyFlatRate,
                "ANNUAL" => Self::Annual,
                "ANNUAL_FLAT_RATE" => Self::AnnualFlatRate,
                "THREE_YEAR" => Self::ThreeYear,
                "NONE" => Self::None,
                _ => Self::UnknownValue(commitment_plan::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommitmentPlan {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Flex => serializer.serialize_i32(3),
                Self::FlexFlatRate => serializer.serialize_i32(7),
                Self::Trial => serializer.serialize_i32(5),
                Self::Monthly => serializer.serialize_i32(2),
                Self::MonthlyFlatRate => serializer.serialize_i32(8),
                Self::Annual => serializer.serialize_i32(4),
                Self::AnnualFlatRate => serializer.serialize_i32(9),
                Self::ThreeYear => serializer.serialize_i32(10),
                Self::None => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommitmentPlan {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommitmentPlan>::new(
                ".google.cloud.bigquery.reservation.v1.CapacityCommitment.CommitmentPlan",
            ))
        }
    }

    /// Capacity commitment can either become ACTIVE right away or transition
    /// from PENDING to ACTIVE or FAILED.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid state value.
        Unspecified,
        /// Capacity commitment is pending provisioning. Pending capacity commitment
        /// does not contribute to the project's slot_capacity.
        Pending,
        /// Once slots are provisioned, capacity commitment becomes active.
        /// slot_count is added to the project's slot_capacity.
        Active,
        /// Capacity commitment is failed to be activated by the backend.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.reservation.v1.CapacityCommitment.State",
            ))
        }
    }
}

/// The request for
/// [ReservationService.CreateReservation][google.cloud.bigquery.reservation.v1.ReservationService.CreateReservation].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.CreateReservation]: crate::client::ReservationService::create_reservation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReservationRequest {
    /// Required. Project, location. E.g.,
    /// `projects/myproject/locations/US`
    pub parent: std::string::String,

    /// The reservation ID. It must only contain lower case alphanumeric
    /// characters or dashes. It must start with a letter and must not end
    /// with a dash. Its maximum length is 64 characters.
    pub reservation_id: std::string::String,

    /// Definition of the new reservation to create.
    pub reservation: std::option::Option<crate::model::Reservation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReservationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reservation_id][crate::model::CreateReservationRequest::reservation_id].
    pub fn set_reservation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reservation_id = v.into();
        self
    }

    /// Sets the value of [reservation][crate::model::CreateReservationRequest::reservation].
    pub fn set_reservation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Reservation>,
    {
        self.reservation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation][crate::model::CreateReservationRequest::reservation].
    pub fn set_or_clear_reservation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Reservation>,
    {
        self.reservation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.CreateReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __reservation_id,
            __reservation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "reservationId" => Ok(__FieldTag::__reservation_id),
                            "reservation_id" => Ok(__FieldTag::__reservation_id),
                            "reservation" => Ok(__FieldTag::__reservation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation_id => {
                            if !fields.insert(__FieldTag::__reservation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation_id",
                                ));
                            }
                            result.reservation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation => {
                            if !fields.insert(__FieldTag::__reservation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation",
                                ));
                            }
                            result.reservation =
                                map.next_value::<std::option::Option<crate::model::Reservation>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.reservation_id.is_empty() {
            state.serialize_entry("reservationId", &self.reservation_id)?;
        }
        if self.reservation.is_some() {
            state.serialize_entry("reservation", &self.reservation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReservationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("reservation_id", &self.reservation_id);
        debug_struct.field("reservation", &self.reservation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.ListReservations][google.cloud.bigquery.reservation.v1.ReservationService.ListReservations].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.ListReservations]: crate::client::ReservationService::list_reservations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReservationsRequest {
    /// Required. The parent resource name containing project and location, e.g.:
    /// `projects/myproject/locations/US`
    pub parent: std::string::String,

    /// The maximum number of items to return per page.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReservationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReservationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReservationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReservationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReservationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.ListReservationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReservationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReservationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReservationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReservationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReservationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReservationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReservationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ReservationService.ListReservations][google.cloud.bigquery.reservation.v1.ReservationService.ListReservations].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.ListReservations]: crate::client::ReservationService::list_reservations
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReservationsResponse {
    /// List of reservations visible to the user.
    pub reservations: std::vec::Vec<crate::model::Reservation>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReservationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reservations][crate::model::ListReservationsResponse::reservations].
    pub fn set_reservations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Reservation>,
    {
        use std::iter::Iterator;
        self.reservations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReservationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReservationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.ListReservationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReservationsResponse {
    type PageItem = crate::model::Reservation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reservations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReservationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reservations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReservationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reservations" => Ok(__FieldTag::__reservations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReservationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReservationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reservations => {
                            if !fields.insert(__FieldTag::__reservations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservations",
                                ));
                            }
                            result.reservations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Reservation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReservationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reservations.is_empty() {
            state.serialize_entry("reservations", &self.reservations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReservationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReservationsResponse");
        debug_struct.field("reservations", &self.reservations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.GetReservation][google.cloud.bigquery.reservation.v1.ReservationService.GetReservation].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.GetReservation]: crate::client::ReservationService::get_reservation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReservationRequest {
    /// Required. Resource name of the reservation to retrieve. E.g.,
    /// `projects/myproject/locations/US/reservations/team1-prod`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReservationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.GetReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.DeleteReservation][google.cloud.bigquery.reservation.v1.ReservationService.DeleteReservation].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.DeleteReservation]: crate::client::ReservationService::delete_reservation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReservationRequest {
    /// Required. Resource name of the reservation to retrieve. E.g.,
    /// `projects/myproject/locations/US/reservations/team1-prod`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReservationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.DeleteReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.UpdateReservation][google.cloud.bigquery.reservation.v1.ReservationService.UpdateReservation].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.UpdateReservation]: crate::client::ReservationService::update_reservation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateReservationRequest {
    /// Content of the reservation to update.
    pub reservation: std::option::Option<crate::model::Reservation>,

    /// Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reservation][crate::model::UpdateReservationRequest::reservation].
    pub fn set_reservation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Reservation>,
    {
        self.reservation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation][crate::model::UpdateReservationRequest::reservation].
    pub fn set_or_clear_reservation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Reservation>,
    {
        self.reservation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateReservationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateReservationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.UpdateReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reservation,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reservation" => Ok(__FieldTag::__reservation),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reservation => {
                            if !fields.insert(__FieldTag::__reservation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation",
                                ));
                            }
                            result.reservation =
                                map.next_value::<std::option::Option<crate::model::Reservation>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reservation.is_some() {
            state.serialize_entry("reservation", &self.reservation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateReservationRequest");
        debug_struct.field("reservation", &self.reservation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for ReservationService.FailoverReservation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FailoverReservationRequest {
    /// Required. Resource name of the reservation to failover. E.g.,
    /// `projects/myproject/locations/US/reservations/team1-prod`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailoverReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FailoverReservationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FailoverReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.FailoverReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FailoverReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailoverReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FailoverReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailoverReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FailoverReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FailoverReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FailoverReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.CreateCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.CreateCapacityCommitment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.CreateCapacityCommitment]: crate::client::ReservationService::create_capacity_commitment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCapacityCommitmentRequest {
    /// Required. Resource name of the parent reservation. E.g.,
    /// `projects/myproject/locations/US`
    pub parent: std::string::String,

    /// Content of the capacity commitment to create.
    pub capacity_commitment: std::option::Option<crate::model::CapacityCommitment>,

    /// If true, fail the request if another project in the organization has a
    /// capacity commitment.
    pub enforce_single_admin_project_per_org: bool,

    /// The optional capacity commitment ID. Capacity commitment name will be
    /// generated automatically if this field is empty.
    /// This field must only contain lower case alphanumeric characters or dashes.
    /// The first and last character cannot be a dash. Max length is 64 characters.
    /// NOTE: this ID won't be kept if the capacity commitment is split or merged.
    pub capacity_commitment_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCapacityCommitmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCapacityCommitmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [capacity_commitment][crate::model::CreateCapacityCommitmentRequest::capacity_commitment].
    pub fn set_capacity_commitment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.capacity_commitment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [capacity_commitment][crate::model::CreateCapacityCommitmentRequest::capacity_commitment].
    pub fn set_or_clear_capacity_commitment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.capacity_commitment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enforce_single_admin_project_per_org][crate::model::CreateCapacityCommitmentRequest::enforce_single_admin_project_per_org].
    pub fn set_enforce_single_admin_project_per_org<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enforce_single_admin_project_per_org = v.into();
        self
    }

    /// Sets the value of [capacity_commitment_id][crate::model::CreateCapacityCommitmentRequest::capacity_commitment_id].
    pub fn set_capacity_commitment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.capacity_commitment_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCapacityCommitmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.CreateCapacityCommitmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCapacityCommitmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __capacity_commitment,
            __enforce_single_admin_project_per_org,
            __capacity_commitment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCapacityCommitmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "capacityCommitment" => Ok(__FieldTag::__capacity_commitment),
                            "capacity_commitment" => Ok(__FieldTag::__capacity_commitment),
                            "enforceSingleAdminProjectPerOrg" => {
                                Ok(__FieldTag::__enforce_single_admin_project_per_org)
                            }
                            "enforce_single_admin_project_per_org" => {
                                Ok(__FieldTag::__enforce_single_admin_project_per_org)
                            }
                            "capacityCommitmentId" => Ok(__FieldTag::__capacity_commitment_id),
                            "capacity_commitment_id" => Ok(__FieldTag::__capacity_commitment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCapacityCommitmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCapacityCommitmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__capacity_commitment => {
                            if !fields.insert(__FieldTag::__capacity_commitment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_commitment",
                                ));
                            }
                            result.capacity_commitment = map.next_value::<std::option::Option<crate::model::CapacityCommitment>>()?
                                ;
                        }
                        __FieldTag::__enforce_single_admin_project_per_org => {
                            if !fields.insert(__FieldTag::__enforce_single_admin_project_per_org) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enforce_single_admin_project_per_org",
                                ));
                            }
                            result.enforce_single_admin_project_per_org = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__capacity_commitment_id => {
                            if !fields.insert(__FieldTag::__capacity_commitment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_commitment_id",
                                ));
                            }
                            result.capacity_commitment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCapacityCommitmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.capacity_commitment.is_some() {
            state.serialize_entry("capacityCommitment", &self.capacity_commitment)?;
        }
        if !wkt::internal::is_default(&self.enforce_single_admin_project_per_org) {
            state.serialize_entry(
                "enforceSingleAdminProjectPerOrg",
                &self.enforce_single_admin_project_per_org,
            )?;
        }
        if !self.capacity_commitment_id.is_empty() {
            state.serialize_entry("capacityCommitmentId", &self.capacity_commitment_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCapacityCommitmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("capacity_commitment", &self.capacity_commitment);
        debug_struct.field(
            "enforce_single_admin_project_per_org",
            &self.enforce_single_admin_project_per_org,
        );
        debug_struct.field("capacity_commitment_id", &self.capacity_commitment_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.ListCapacityCommitments][google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments]: crate::client::ReservationService::list_capacity_commitments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCapacityCommitmentsRequest {
    /// Required. Resource name of the parent reservation. E.g.,
    /// `projects/myproject/locations/US`
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCapacityCommitmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCapacityCommitmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCapacityCommitmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCapacityCommitmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCapacityCommitmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.ListCapacityCommitmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCapacityCommitmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCapacityCommitmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCapacityCommitmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCapacityCommitmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCapacityCommitmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCapacityCommitmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCapacityCommitmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ReservationService.ListCapacityCommitments][google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments]: crate::client::ReservationService::list_capacity_commitments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCapacityCommitmentsResponse {
    /// List of capacity commitments visible to the user.
    pub capacity_commitments: std::vec::Vec<crate::model::CapacityCommitment>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCapacityCommitmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [capacity_commitments][crate::model::ListCapacityCommitmentsResponse::capacity_commitments].
    pub fn set_capacity_commitments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CapacityCommitment>,
    {
        use std::iter::Iterator;
        self.capacity_commitments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCapacityCommitmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCapacityCommitmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.ListCapacityCommitmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCapacityCommitmentsResponse {
    type PageItem = crate::model::CapacityCommitment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.capacity_commitments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCapacityCommitmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __capacity_commitments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCapacityCommitmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "capacityCommitments" => Ok(__FieldTag::__capacity_commitments),
                            "capacity_commitments" => Ok(__FieldTag::__capacity_commitments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCapacityCommitmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCapacityCommitmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__capacity_commitments => {
                            if !fields.insert(__FieldTag::__capacity_commitments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_commitments",
                                ));
                            }
                            result.capacity_commitments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityCommitment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCapacityCommitmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.capacity_commitments.is_empty() {
            state.serialize_entry("capacityCommitments", &self.capacity_commitments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCapacityCommitmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCapacityCommitmentsResponse");
        debug_struct.field("capacity_commitments", &self.capacity_commitments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.GetCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.GetCapacityCommitment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.GetCapacityCommitment]: crate::client::ReservationService::get_capacity_commitment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCapacityCommitmentRequest {
    /// Required. Resource name of the capacity commitment to retrieve. E.g.,
    /// `projects/myproject/locations/US/capacityCommitments/123`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCapacityCommitmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCapacityCommitmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCapacityCommitmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.GetCapacityCommitmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCapacityCommitmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCapacityCommitmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCapacityCommitmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCapacityCommitmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCapacityCommitmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCapacityCommitmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.DeleteCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.DeleteCapacityCommitment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.DeleteCapacityCommitment]: crate::client::ReservationService::delete_capacity_commitment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCapacityCommitmentRequest {
    /// Required. Resource name of the capacity commitment to delete. E.g.,
    /// `projects/myproject/locations/US/capacityCommitments/123`
    pub name: std::string::String,

    /// Can be used to force delete commitments even if assignments exist. Deleting
    /// commitments with assignments may cause queries to fail if they no longer
    /// have access to slots.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCapacityCommitmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCapacityCommitmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteCapacityCommitmentRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCapacityCommitmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.DeleteCapacityCommitmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCapacityCommitmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCapacityCommitmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCapacityCommitmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCapacityCommitmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCapacityCommitmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCapacityCommitmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.UpdateCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.UpdateCapacityCommitment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.UpdateCapacityCommitment]: crate::client::ReservationService::update_capacity_commitment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCapacityCommitmentRequest {
    /// Content of the capacity commitment to update.
    pub capacity_commitment: std::option::Option<crate::model::CapacityCommitment>,

    /// Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCapacityCommitmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [capacity_commitment][crate::model::UpdateCapacityCommitmentRequest::capacity_commitment].
    pub fn set_capacity_commitment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.capacity_commitment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [capacity_commitment][crate::model::UpdateCapacityCommitmentRequest::capacity_commitment].
    pub fn set_or_clear_capacity_commitment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.capacity_commitment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCapacityCommitmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCapacityCommitmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCapacityCommitmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.UpdateCapacityCommitmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCapacityCommitmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __capacity_commitment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCapacityCommitmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "capacityCommitment" => Ok(__FieldTag::__capacity_commitment),
                            "capacity_commitment" => Ok(__FieldTag::__capacity_commitment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCapacityCommitmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCapacityCommitmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__capacity_commitment => {
                            if !fields.insert(__FieldTag::__capacity_commitment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_commitment",
                                ));
                            }
                            result.capacity_commitment = map.next_value::<std::option::Option<crate::model::CapacityCommitment>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCapacityCommitmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.capacity_commitment.is_some() {
            state.serialize_entry("capacityCommitment", &self.capacity_commitment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCapacityCommitmentRequest");
        debug_struct.field("capacity_commitment", &self.capacity_commitment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.SplitCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment]: crate::client::ReservationService::split_capacity_commitment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SplitCapacityCommitmentRequest {
    /// Required. The resource name e.g.,:
    /// `projects/myproject/locations/US/capacityCommitments/123`
    pub name: std::string::String,

    /// Number of slots in the capacity commitment after the split.
    pub slot_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SplitCapacityCommitmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SplitCapacityCommitmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [slot_count][crate::model::SplitCapacityCommitmentRequest::slot_count].
    pub fn set_slot_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.slot_count = v.into();
        self
    }
}

impl wkt::message::Message for SplitCapacityCommitmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.SplitCapacityCommitmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SplitCapacityCommitmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __slot_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SplitCapacityCommitmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "slotCount" => Ok(__FieldTag::__slot_count),
                            "slot_count" => Ok(__FieldTag::__slot_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SplitCapacityCommitmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SplitCapacityCommitmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slot_count => {
                            if !fields.insert(__FieldTag::__slot_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slot_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.slot_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SplitCapacityCommitmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.slot_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("slotCount", &__With(&self.slot_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SplitCapacityCommitmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SplitCapacityCommitmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("slot_count", &self.slot_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ReservationService.SplitCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment]: crate::client::ReservationService::split_capacity_commitment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SplitCapacityCommitmentResponse {
    /// First capacity commitment, result of a split.
    pub first: std::option::Option<crate::model::CapacityCommitment>,

    /// Second capacity commitment, result of a split.
    pub second: std::option::Option<crate::model::CapacityCommitment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SplitCapacityCommitmentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [first][crate::model::SplitCapacityCommitmentResponse::first].
    pub fn set_first<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.first = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [first][crate::model::SplitCapacityCommitmentResponse::first].
    pub fn set_or_clear_first<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.first = v.map(|x| x.into());
        self
    }

    /// Sets the value of [second][crate::model::SplitCapacityCommitmentResponse::second].
    pub fn set_second<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.second = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [second][crate::model::SplitCapacityCommitmentResponse::second].
    pub fn set_or_clear_second<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CapacityCommitment>,
    {
        self.second = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SplitCapacityCommitmentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.SplitCapacityCommitmentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SplitCapacityCommitmentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __first,
            __second,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SplitCapacityCommitmentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "first" => Ok(__FieldTag::__first),
                            "second" => Ok(__FieldTag::__second),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SplitCapacityCommitmentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SplitCapacityCommitmentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__first => {
                            if !fields.insert(__FieldTag::__first) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first",
                                ));
                            }
                            result.first = map.next_value::<std::option::Option<crate::model::CapacityCommitment>>()?
                                ;
                        }
                        __FieldTag::__second => {
                            if !fields.insert(__FieldTag::__second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for second",
                                ));
                            }
                            result.second = map.next_value::<std::option::Option<crate::model::CapacityCommitment>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SplitCapacityCommitmentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.first.is_some() {
            state.serialize_entry("first", &self.first)?;
        }
        if self.second.is_some() {
            state.serialize_entry("second", &self.second)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SplitCapacityCommitmentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SplitCapacityCommitmentResponse");
        debug_struct.field("first", &self.first);
        debug_struct.field("second", &self.second);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.MergeCapacityCommitments][google.cloud.bigquery.reservation.v1.ReservationService.MergeCapacityCommitments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.MergeCapacityCommitments]: crate::client::ReservationService::merge_capacity_commitments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MergeCapacityCommitmentsRequest {
    /// Parent resource that identifies admin project and location e.g.,
    /// `projects/myproject/locations/us`
    pub parent: std::string::String,

    /// Ids of capacity commitments to merge.
    /// These capacity commitments must exist under admin project and location
    /// specified in the parent.
    /// ID is the last portion of capacity commitment name e.g., 'abc' for
    /// projects/myproject/locations/US/capacityCommitments/abc
    pub capacity_commitment_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MergeCapacityCommitmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::MergeCapacityCommitmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [capacity_commitment_ids][crate::model::MergeCapacityCommitmentsRequest::capacity_commitment_ids].
    pub fn set_capacity_commitment_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.capacity_commitment_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MergeCapacityCommitmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.MergeCapacityCommitmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MergeCapacityCommitmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __capacity_commitment_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MergeCapacityCommitmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "capacityCommitmentIds" => Ok(__FieldTag::__capacity_commitment_ids),
                            "capacity_commitment_ids" => Ok(__FieldTag::__capacity_commitment_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MergeCapacityCommitmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MergeCapacityCommitmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__capacity_commitment_ids => {
                            if !fields.insert(__FieldTag::__capacity_commitment_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_commitment_ids",
                                ));
                            }
                            result.capacity_commitment_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MergeCapacityCommitmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.capacity_commitment_ids.is_empty() {
            state.serialize_entry("capacityCommitmentIds", &self.capacity_commitment_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MergeCapacityCommitmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MergeCapacityCommitmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("capacity_commitment_ids", &self.capacity_commitment_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An assignment allows a project to submit jobs
/// of a certain type using slots from the specified reservation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Assignment {
    /// Output only. Name of the resource. E.g.:
    /// `projects/myproject/locations/US/reservations/team1-prod/assignments/123`.
    /// The assignment_id must only contain lower case alphanumeric characters or
    /// dashes and the max length is 64 characters.
    pub name: std::string::String,

    /// The resource which will use the reservation. E.g.
    /// `projects/myproject`, `folders/123`, or `organizations/456`.
    pub assignee: std::string::String,

    /// Which type of jobs will use the reservation.
    pub job_type: crate::model::assignment::JobType,

    /// Output only. State of the assignment.
    pub state: crate::model::assignment::State,

    /// Optional. This field controls if "Gemini in BigQuery"
    /// (<https://cloud.google.com/gemini/docs/bigquery/overview>) features should be
    /// enabled for this reservation assignment, which is not on by default.
    /// "Gemini in BigQuery" has a distinct compliance posture from BigQuery.  If
    /// this field is set to true, the assignment job type is QUERY, and
    /// the parent reservation edition is ENTERPRISE_PLUS, then the assignment will
    /// give the grantee project/organization access to "Gemini in BigQuery"
    /// features.
    pub enable_gemini_in_bigquery: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Assignment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Assignment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [assignee][crate::model::Assignment::assignee].
    pub fn set_assignee<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.assignee = v.into();
        self
    }

    /// Sets the value of [job_type][crate::model::Assignment::job_type].
    pub fn set_job_type<T: std::convert::Into<crate::model::assignment::JobType>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Assignment::state].
    pub fn set_state<T: std::convert::Into<crate::model::assignment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [enable_gemini_in_bigquery][crate::model::Assignment::enable_gemini_in_bigquery].
    pub fn set_enable_gemini_in_bigquery<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_gemini_in_bigquery = v.into();
        self
    }
}

impl wkt::message::Message for Assignment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.Assignment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Assignment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __assignee,
            __job_type,
            __state,
            __enable_gemini_in_bigquery,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Assignment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "assignee" => Ok(__FieldTag::__assignee),
                            "jobType" => Ok(__FieldTag::__job_type),
                            "job_type" => Ok(__FieldTag::__job_type),
                            "state" => Ok(__FieldTag::__state),
                            "enableGeminiInBigquery" => Ok(__FieldTag::__enable_gemini_in_bigquery),
                            "enable_gemini_in_bigquery" => {
                                Ok(__FieldTag::__enable_gemini_in_bigquery)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Assignment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Assignment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assignee => {
                            if !fields.insert(__FieldTag::__assignee) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignee",
                                ));
                            }
                            result.assignee = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_type => {
                            if !fields.insert(__FieldTag::__job_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_type",
                                ));
                            }
                            result.job_type = map.next_value::<std::option::Option<crate::model::assignment::JobType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::assignment::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_gemini_in_bigquery => {
                            if !fields.insert(__FieldTag::__enable_gemini_in_bigquery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_gemini_in_bigquery",
                                ));
                            }
                            result.enable_gemini_in_bigquery = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Assignment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.assignee.is_empty() {
            state.serialize_entry("assignee", &self.assignee)?;
        }
        if !wkt::internal::is_default(&self.job_type) {
            state.serialize_entry("jobType", &self.job_type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.enable_gemini_in_bigquery) {
            state.serialize_entry("enableGeminiInBigquery", &self.enable_gemini_in_bigquery)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Assignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Assignment");
        debug_struct.field("name", &self.name);
        debug_struct.field("assignee", &self.assignee);
        debug_struct.field("job_type", &self.job_type);
        debug_struct.field("state", &self.state);
        debug_struct.field("enable_gemini_in_bigquery", &self.enable_gemini_in_bigquery);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Assignment].
pub mod assignment {
    #[allow(unused_imports)]
    use super::*;

    /// Types of job, which could be specified when using the reservation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobType {
        /// Invalid type. Requests with this value will be rejected with
        /// error code `google.rpc.Code.INVALID_ARGUMENT`.
        Unspecified,
        /// Pipeline (load/export) jobs from the project will use the reservation.
        Pipeline,
        /// Query jobs from the project will use the reservation.
        Query,
        /// BigQuery ML jobs that use services external to BigQuery for model
        /// training. These jobs will not utilize idle slots from other reservations.
        MlExternal,
        /// Background jobs that BigQuery runs for the customers in the background.
        Background,
        /// Continuous SQL jobs will use this reservation. Reservations with
        /// continuous assignments cannot be mixed with non-continuous assignments.
        Continuous,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobType::value] or
        /// [JobType::name].
        UnknownValue(job_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pipeline => std::option::Option::Some(1),
                Self::Query => std::option::Option::Some(2),
                Self::MlExternal => std::option::Option::Some(3),
                Self::Background => std::option::Option::Some(4),
                Self::Continuous => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOB_TYPE_UNSPECIFIED"),
                Self::Pipeline => std::option::Option::Some("PIPELINE"),
                Self::Query => std::option::Option::Some("QUERY"),
                Self::MlExternal => std::option::Option::Some("ML_EXTERNAL"),
                Self::Background => std::option::Option::Some("BACKGROUND"),
                Self::Continuous => std::option::Option::Some("CONTINUOUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pipeline,
                2 => Self::Query,
                3 => Self::MlExternal,
                4 => Self::Background,
                6 => Self::Continuous,
                _ => Self::UnknownValue(job_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOB_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PIPELINE" => Self::Pipeline,
                "QUERY" => Self::Query,
                "ML_EXTERNAL" => Self::MlExternal,
                "BACKGROUND" => Self::Background,
                "CONTINUOUS" => Self::Continuous,
                _ => Self::UnknownValue(job_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pipeline => serializer.serialize_i32(1),
                Self::Query => serializer.serialize_i32(2),
                Self::MlExternal => serializer.serialize_i32(3),
                Self::Background => serializer.serialize_i32(4),
                Self::Continuous => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobType>::new(
                ".google.cloud.bigquery.reservation.v1.Assignment.JobType",
            ))
        }
    }

    /// Assignment will remain in PENDING state if no active capacity commitment is
    /// present. It will become ACTIVE when some capacity commitment becomes
    /// active.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid state value.
        Unspecified,
        /// Queries from assignee will be executed as on-demand, if related
        /// assignment is pending.
        Pending,
        /// Assignment is ready.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.reservation.v1.Assignment.State",
            ))
        }
    }
}

/// The request for
/// [ReservationService.CreateAssignment][google.cloud.bigquery.reservation.v1.ReservationService.CreateAssignment].
/// Note: "bigquery.reservationAssignments.create" permission is required on the
/// related assignee.
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.CreateAssignment]: crate::client::ReservationService::create_assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAssignmentRequest {
    /// Required. The parent resource name of the assignment
    /// E.g. `projects/myproject/locations/US/reservations/team1-prod`
    pub parent: std::string::String,

    /// Assignment resource to create.
    pub assignment: std::option::Option<crate::model::Assignment>,

    /// The optional assignment ID. Assignment name will be generated automatically
    /// if this field is empty.
    /// This field must only contain lower case alphanumeric characters or dashes.
    /// Max length is 64 characters.
    pub assignment_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssignmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [assignment][crate::model::CreateAssignmentRequest::assignment].
    pub fn set_assignment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Assignment>,
    {
        self.assignment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assignment][crate::model::CreateAssignmentRequest::assignment].
    pub fn set_or_clear_assignment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Assignment>,
    {
        self.assignment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assignment_id][crate::model::CreateAssignmentRequest::assignment_id].
    pub fn set_assignment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.assignment_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.CreateAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __assignment,
            __assignment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "assignment" => Ok(__FieldTag::__assignment),
                            "assignmentId" => Ok(__FieldTag::__assignment_id),
                            "assignment_id" => Ok(__FieldTag::__assignment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assignment => {
                            if !fields.insert(__FieldTag::__assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignment",
                                ));
                            }
                            result.assignment =
                                map.next_value::<std::option::Option<crate::model::Assignment>>()?;
                        }
                        __FieldTag::__assignment_id => {
                            if !fields.insert(__FieldTag::__assignment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignment_id",
                                ));
                            }
                            result.assignment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.assignment.is_some() {
            state.serialize_entry("assignment", &self.assignment)?;
        }
        if !self.assignment_id.is_empty() {
            state.serialize_entry("assignmentId", &self.assignment_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAssignmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("assignment", &self.assignment);
        debug_struct.field("assignment_id", &self.assignment_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.ListAssignments][google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments]: crate::client::ReservationService::list_assignments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssignmentsRequest {
    /// Required. The parent resource name e.g.:
    ///
    /// `projects/myproject/locations/US/reservations/team1-prod`
    ///
    /// Or:
    ///
    /// `projects/myproject/locations/US/reservations/-`
    pub parent: std::string::String,

    /// The maximum number of items to return per page.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssignmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssignmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssignmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssignmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssignmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.ListAssignmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssignmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssignmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssignmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssignmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssignmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ReservationService.ListAssignments][google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments]: crate::client::ReservationService::list_assignments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssignmentsResponse {
    /// List of assignments visible to the user.
    pub assignments: std::vec::Vec<crate::model::Assignment>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssignmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assignments][crate::model::ListAssignmentsResponse::assignments].
    pub fn set_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Assignment>,
    {
        use std::iter::Iterator;
        self.assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAssignmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssignmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.ListAssignmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAssignmentsResponse {
    type PageItem = crate::model::Assignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssignmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssignmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assignments" => Ok(__FieldTag::__assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssignmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssignmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assignments => {
                            if !fields.insert(__FieldTag::__assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignments",
                                ));
                            }
                            result.assignments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Assignment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssignmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assignments.is_empty() {
            state.serialize_entry("assignments", &self.assignments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAssignmentsResponse");
        debug_struct.field("assignments", &self.assignments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.DeleteAssignment][google.cloud.bigquery.reservation.v1.ReservationService.DeleteAssignment].
/// Note: "bigquery.reservationAssignments.delete" permission is required on the
/// related assignee.
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.DeleteAssignment]: crate::client::ReservationService::delete_assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAssignmentRequest {
    /// Required. Name of the resource, e.g.
    /// `projects/myproject/locations/US/reservations/team1-prod/assignments/123`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAssignmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.DeleteAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAssignmentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.SearchAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments].
/// Note: "bigquery.reservationAssignments.search" permission is required on the
/// related assignee.
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments]: crate::client::ReservationService::search_assignments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAssignmentsRequest {
    /// Required. The resource name of the admin project(containing project and
    /// location), e.g.:
    /// `projects/myproject/locations/US`.
    pub parent: std::string::String,

    /// Please specify resource name as assignee in the query.
    ///
    /// Examples:
    ///
    /// * `assignee=projects/myproject`
    /// * `assignee=folders/123`
    /// * `assignee=organizations/456`
    pub query: std::string::String,

    /// The maximum number of items to return per page.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAssignmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchAssignmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchAssignmentsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchAssignmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchAssignmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchAssignmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.SearchAssignmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAssignmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __query,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAssignmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "query" => Ok(__FieldTag::__query),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAssignmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAssignmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAssignmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("query", &self.query);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.SearchAllAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments].
/// Note: "bigquery.reservationAssignments.search" permission is required on the
/// related assignee.
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments]: crate::client::ReservationService::search_all_assignments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAllAssignmentsRequest {
    /// Required. The resource name with location (project name could be the
    /// wildcard '-'), e.g.:
    /// `projects/-/locations/US`.
    pub parent: std::string::String,

    /// Please specify resource name as assignee in the query.
    ///
    /// Examples:
    ///
    /// * `assignee=projects/myproject`
    /// * `assignee=folders/123`
    /// * `assignee=organizations/456`
    pub query: std::string::String,

    /// The maximum number of items to return per page.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAllAssignmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchAllAssignmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchAllAssignmentsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchAllAssignmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchAllAssignmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchAllAssignmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.SearchAllAssignmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAllAssignmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __query,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAllAssignmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "query" => Ok(__FieldTag::__query),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAllAssignmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAllAssignmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAllAssignmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAllAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("query", &self.query);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ReservationService.SearchAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments]: crate::client::ReservationService::search_assignments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAssignmentsResponse {
    /// List of assignments visible to the user.
    pub assignments: std::vec::Vec<crate::model::Assignment>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAssignmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assignments][crate::model::SearchAssignmentsResponse::assignments].
    pub fn set_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Assignment>,
    {
        use std::iter::Iterator;
        self.assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchAssignmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchAssignmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.SearchAssignmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchAssignmentsResponse {
    type PageItem = crate::model::Assignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAssignmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAssignmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assignments" => Ok(__FieldTag::__assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAssignmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAssignmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assignments => {
                            if !fields.insert(__FieldTag::__assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignments",
                                ));
                            }
                            result.assignments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Assignment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAssignmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assignments.is_empty() {
            state.serialize_entry("assignments", &self.assignments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAssignmentsResponse");
        debug_struct.field("assignments", &self.assignments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ReservationService.SearchAllAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments]: crate::client::ReservationService::search_all_assignments
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAllAssignmentsResponse {
    /// List of assignments visible to the user.
    pub assignments: std::vec::Vec<crate::model::Assignment>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchAllAssignmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assignments][crate::model::SearchAllAssignmentsResponse::assignments].
    pub fn set_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Assignment>,
    {
        use std::iter::Iterator;
        self.assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchAllAssignmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchAllAssignmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.SearchAllAssignmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchAllAssignmentsResponse {
    type PageItem = crate::model::Assignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAllAssignmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAllAssignmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assignments" => Ok(__FieldTag::__assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAllAssignmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAllAssignmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assignments => {
                            if !fields.insert(__FieldTag::__assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignments",
                                ));
                            }
                            result.assignments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Assignment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchAllAssignmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assignments.is_empty() {
            state.serialize_entry("assignments", &self.assignments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchAllAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchAllAssignmentsResponse");
        debug_struct.field("assignments", &self.assignments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.MoveAssignment][google.cloud.bigquery.reservation.v1.ReservationService.MoveAssignment].
///
/// **Note**: "bigquery.reservationAssignments.create" permission is required on
/// the destination_id.
///
/// **Note**: "bigquery.reservationAssignments.create" and
/// "bigquery.reservationAssignments.delete" permission are required on the
/// related assignee.
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.MoveAssignment]: crate::client::ReservationService::move_assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveAssignmentRequest {
    /// Required. The resource name of the assignment,
    /// e.g.
    /// `projects/myproject/locations/US/reservations/team1-prod/assignments/123`
    pub name: std::string::String,

    /// The new reservation ID, e.g.:
    /// `projects/myotherproject/locations/US/reservations/team2-prod`
    pub destination_id: std::string::String,

    /// The optional assignment ID. A new assignment name is generated if this
    /// field is empty.
    ///
    /// This field can contain only lowercase alphanumeric characters or dashes.
    /// Max length is 64 characters.
    pub assignment_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MoveAssignmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination_id][crate::model::MoveAssignmentRequest::destination_id].
    pub fn set_destination_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_id = v.into();
        self
    }

    /// Sets the value of [assignment_id][crate::model::MoveAssignmentRequest::assignment_id].
    pub fn set_assignment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.assignment_id = v.into();
        self
    }
}

impl wkt::message::Message for MoveAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.MoveAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __destination_id,
            __assignment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "destinationId" => Ok(__FieldTag::__destination_id),
                            "destination_id" => Ok(__FieldTag::__destination_id),
                            "assignmentId" => Ok(__FieldTag::__assignment_id),
                            "assignment_id" => Ok(__FieldTag::__assignment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_id => {
                            if !fields.insert(__FieldTag::__destination_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_id",
                                ));
                            }
                            result.destination_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assignment_id => {
                            if !fields.insert(__FieldTag::__assignment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignment_id",
                                ));
                            }
                            result.assignment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.destination_id.is_empty() {
            state.serialize_entry("destinationId", &self.destination_id)?;
        }
        if !self.assignment_id.is_empty() {
            state.serialize_entry("assignmentId", &self.assignment_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MoveAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveAssignmentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("destination_id", &self.destination_id);
        debug_struct.field("assignment_id", &self.assignment_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ReservationService.UpdateAssignment][google.cloud.bigquery.reservation.v1.ReservationService.UpdateAssignment].
///
/// [google.cloud.bigquery.reservation.v1.ReservationService.UpdateAssignment]: crate::client::ReservationService::update_assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAssignmentRequest {
    /// Content of the assignment to update.
    pub assignment: std::option::Option<crate::model::Assignment>,

    /// Standard field mask for the set of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assignment][crate::model::UpdateAssignmentRequest::assignment].
    pub fn set_assignment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Assignment>,
    {
        self.assignment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assignment][crate::model::UpdateAssignmentRequest::assignment].
    pub fn set_or_clear_assignment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Assignment>,
    {
        self.assignment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAssignmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAssignmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.UpdateAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assignment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assignment" => Ok(__FieldTag::__assignment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assignment => {
                            if !fields.insert(__FieldTag::__assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignment",
                                ));
                            }
                            result.assignment =
                                map.next_value::<std::option::Option<crate::model::Assignment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.assignment.is_some() {
            state.serialize_entry("assignment", &self.assignment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAssignmentRequest");
        debug_struct.field("assignment", &self.assignment);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Fully qualified reference to BigQuery table.
/// Internally stored as google.cloud.bi.v1.BqTableReference.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TableReference {
    /// The assigned project ID of the project.
    pub project_id: std::string::String,

    /// The ID of the dataset in the above project.
    pub dataset_id: std::string::String,

    /// The ID of the table in the above dataset.
    pub table_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::TableReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::TableReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for TableReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.TableReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TableReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a BI Reservation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BiReservation {
    /// The resource name of the singleton BI reservation.
    /// Reservation names have the form
    /// `projects/{project_id}/locations/{location_id}/biReservation`.
    pub name: std::string::String,

    /// Output only. The last update timestamp of a reservation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Size of a reservation, in bytes.
    pub size: i64,

    /// Preferred tables to use BI capacity for.
    pub preferred_tables: std::vec::Vec<crate::model::TableReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BiReservation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BiReservation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BiReservation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BiReservation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [size][crate::model::BiReservation::size].
    pub fn set_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [preferred_tables][crate::model::BiReservation::preferred_tables].
    pub fn set_preferred_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableReference>,
    {
        use std::iter::Iterator;
        self.preferred_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BiReservation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.BiReservation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BiReservation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __update_time,
            __size,
            __preferred_tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BiReservation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "size" => Ok(__FieldTag::__size),
                            "preferredTables" => Ok(__FieldTag::__preferred_tables),
                            "preferred_tables" => Ok(__FieldTag::__preferred_tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BiReservation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BiReservation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__size => {
                            if !fields.insert(__FieldTag::__size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__preferred_tables => {
                            if !fields.insert(__FieldTag::__preferred_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preferred_tables",
                                ));
                            }
                            result.preferred_tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BiReservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if !self.preferred_tables.is_empty() {
            state.serialize_entry("preferredTables", &self.preferred_tables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BiReservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BiReservation");
        debug_struct.field("name", &self.name);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("size", &self.size);
        debug_struct.field("preferred_tables", &self.preferred_tables);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to get a singleton BI reservation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBiReservationRequest {
    /// Required. Name of the requested reservation, for example:
    /// `projects/{project_id}/locations/{location_id}/biReservation`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBiReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBiReservationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBiReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.GetBiReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBiReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBiReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBiReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBiReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBiReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBiReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBiReservationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to update a BI reservation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBiReservationRequest {
    /// A reservation to update.
    pub bi_reservation: std::option::Option<crate::model::BiReservation>,

    /// A list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBiReservationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bi_reservation][crate::model::UpdateBiReservationRequest::bi_reservation].
    pub fn set_bi_reservation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BiReservation>,
    {
        self.bi_reservation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bi_reservation][crate::model::UpdateBiReservationRequest::bi_reservation].
    pub fn set_or_clear_bi_reservation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BiReservation>,
    {
        self.bi_reservation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBiReservationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBiReservationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBiReservationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.reservation.v1.UpdateBiReservationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBiReservationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bi_reservation,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBiReservationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "biReservation" => Ok(__FieldTag::__bi_reservation),
                            "bi_reservation" => Ok(__FieldTag::__bi_reservation),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBiReservationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBiReservationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bi_reservation => {
                            if !fields.insert(__FieldTag::__bi_reservation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bi_reservation",
                                ));
                            }
                            result.bi_reservation = map
                                .next_value::<std::option::Option<crate::model::BiReservation>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBiReservationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bi_reservation.is_some() {
            state.serialize_entry("biReservation", &self.bi_reservation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateBiReservationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBiReservationRequest");
        debug_struct.field("bi_reservation", &self.bi_reservation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The type of editions.
/// Different features and behaviors are provided to different editions
/// Capacity commitments and reservations are linked to editions.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Edition {
    /// Default value, which will be treated as ENTERPRISE.
    Unspecified,
    /// Standard edition.
    Standard,
    /// Enterprise edition.
    Enterprise,
    /// Enterprise Plus edition.
    EnterprisePlus,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Edition::value] or
    /// [Edition::name].
    UnknownValue(edition::UnknownValue),
}

#[doc(hidden)]
pub mod edition {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Edition {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Enterprise => std::option::Option::Some(2),
            Self::EnterprisePlus => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("STANDARD"),
            Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
            Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Edition {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Edition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Edition {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Enterprise,
            3 => Self::EnterprisePlus,
            _ => Self::UnknownValue(edition::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Edition {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EDITION_UNSPECIFIED" => Self::Unspecified,
            "STANDARD" => Self::Standard,
            "ENTERPRISE" => Self::Enterprise,
            "ENTERPRISE_PLUS" => Self::EnterprisePlus,
            _ => Self::UnknownValue(edition::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Edition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Enterprise => serializer.serialize_i32(2),
            Self::EnterprisePlus => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Edition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
            ".google.cloud.bigquery.reservation.v1.Edition",
        ))
    }
}
