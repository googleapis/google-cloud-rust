// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [DatasetService](super::stub::DatasetService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DatasetService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DatasetService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DatasetService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DatasetService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::DatasetService for DatasetService {
    async fn get_dataset(
        &self,
        req: crate::model::GetDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("datasetView", &req.dataset_view)]);
            let builder = builder.query(&[("accessPolicyVersion", &req.access_policy_version)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert_dataset(
        &self,
        req: crate::model::InsertDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("accessPolicyVersion", &req.access_policy_version)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.dataset, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn patch_dataset(
        &self,
        req: crate::model::UpdateOrPatchDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = builder.query(&[("updateMode", &req.update_mode)]);
            let builder = builder.query(&[("accessPolicyVersion", &req.access_policy_version)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.dataset, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_dataset(
        &self,
        req: crate::model::UpdateOrPatchDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = builder.query(&[("updateMode", &req.update_mode)]);
            let builder = builder.query(&[("accessPolicyVersion", &req.access_policy_version)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.dataset, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_dataset(
        &self,
        req: crate::model::DeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("deleteContents", &req.delete_contents)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn list_datasets(
        &self,
        req: crate::model::ListDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.max_results.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxResults") });
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = builder.query(&[("all", &req.all)]);
                let builder = builder.query(&[("filter", &req.filter)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn undelete_dataset(
        &self,
        req: crate::model::UndeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}:undelete",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [JobService](super::stub::JobService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct JobService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for JobService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("JobService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl JobService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::JobService for JobService {
    async fn cancel_job(
        &self,
        req: crate::model::CancelJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::JobCancelResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/jobs/{}/cancel",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.job_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("location", &req.location)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.job_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "job_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_job(
        &self,
        req: crate::model::GetJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/jobs/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.job_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("location", &req.location)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.job_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "job_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert_job(
        &self,
        req: crate::model::InsertJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/jobs",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.job, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_job(
        &self,
        req: crate::model::DeleteJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/jobs/{}/delete",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.job_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("location", &req.location)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.job_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "job_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn list_jobs(
        &self,
        req: crate::model::ListJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::JobList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/jobs",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = builder.query(&[("allUsers", &req.all_users)]);
                let builder = req.max_results.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxResults") });
                let builder = builder.query(&[("minCreationTime", &req.min_creation_time)]);
                let builder = req.max_creation_time.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxCreationTime") });
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = builder.query(&[("projection", &req.projection)]);
                let builder = req.state_filter.iter().fold(builder, |builder, p| builder.query(&[("stateFilter", p)]));
                let builder = builder.query(&[("parentJobId", &req.parent_job_id)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_query_results(
        &self,
        req: crate::model::GetQueryResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetQueryResultsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/queries/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.job_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.start_index.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "startIndex") });
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = req.max_results.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxResults") });
                let builder = req.timeout_ms.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "timeoutMs") });
                let builder = builder.query(&[("location", &req.location)]);
                let builder = req.format_options.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "formatOptions") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.job_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "job_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn query(
        &self,
        req: crate::model::PostQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/queries",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.query_request, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [ModelService](super::stub::ModelService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ModelService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ModelService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ModelService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ModelService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ModelService for ModelService {
    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/models/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.model_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.model_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "model_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/models",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.max_results.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxResults") });
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn patch_model(
        &self,
        req: crate::model::PatchModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/models/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.model_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.model_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "model_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.model, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/models/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.model_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.model_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "model_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

}

/// Implements [ProjectService](super::stub::ProjectService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ProjectService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ProjectService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ProjectService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ProjectService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ProjectService for ProjectService {
    async fn get_service_account(
        &self,
        req: crate::model::GetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetServiceAccountResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/serviceAccount",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [RoutineService](super::stub::RoutineService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct RoutineService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for RoutineService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RoutineService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl RoutineService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::RoutineService for RoutineService {
    async fn get_routine(
        &self,
        req: crate::model::GetRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/routines/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.routine_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.routine_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "routine_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert_routine(
        &self,
        req: crate::model::InsertRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/routines",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.routine, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_routine(
        &self,
        req: crate::model::UpdateRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/routines/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.routine_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.routine_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "routine_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.routine, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_routine(
        &self,
        req: crate::model::DeleteRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/routines/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.routine_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.routine_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "routine_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn list_routines(
        &self,
        req: crate::model::ListRoutinesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRoutinesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/routines",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.max_results.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxResults") });
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = builder.query(&[("filter", &req.filter)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [RowAccessPolicyService](super::stub::RowAccessPolicyService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct RowAccessPolicyService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for RowAccessPolicyService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RowAccessPolicyService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl RowAccessPolicyService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::RowAccessPolicyService for RowAccessPolicyService {
    async fn list_row_access_policies(
        &self,
        req: crate::model::ListRowAccessPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRowAccessPoliciesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}/rowAccessPolicies",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = builder.query(&[("pageSize", &req.page_size)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_row_access_policy(
        &self,
        req: crate::model::GetRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}/rowAccessPolicies/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.policy_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.policy_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "policy_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_row_access_policy(
        &self,
        req: crate::model::CreateRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}/rowAccessPolicies",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.row_access_policy, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_row_access_policy(
        &self,
        req: crate::model::UpdateRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}/rowAccessPolicies/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.policy_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.policy_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "policy_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.row_access_policy, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_row_access_policy(
        &self,
        req: crate::model::DeleteRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}/rowAccessPolicies/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.policy_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = req.force.iter().fold(builder, |builder, p| builder.query(&[("force", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.policy_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "policy_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn batch_delete_row_access_policies(
        &self,
        req: crate::model::BatchDeleteRowAccessPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}/rowAccessPolicies:batchDelete",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

}

/// Implements [TableService](super::stub::TableService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct TableService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for TableService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TableService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl TableService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::TableService for TableService {
    async fn get_table(
        &self,
        req: crate::model::GetTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("selectedFields", &req.selected_fields)]);
            let builder = builder.query(&[("view", &req.view)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert_table(
        &self,
        req: crate::model::InsertTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.table, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn patch_table(
        &self,
        req: crate::model::UpdateOrPatchTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = builder.query(&[("autodetectSchema", &req.autodetect_schema)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.table, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update_table(
        &self,
        req: crate::model::UpdateOrPatchTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = builder.query(&[("autodetectSchema", &req.autodetect_schema)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.table, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete_table(
        &self,
        req: crate::model::DeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.table_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.table_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "table_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

    async fn list_tables(
        &self,
        req: crate::model::ListTablesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TableList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/bigquery/v2/projects/{}/datasets/{}/tables",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.max_results.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "maxResults") });
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.dataset_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "dataset_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

