// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

//! Traits to mock the clients in this library.
//!
//! Application developers may need to mock the clients in this library to test
//! how their application works with different (and sometimes hard to trigger)
//! client and service behavior. Such test can define mocks implementing the
//! trait(s) defined in this module, initialize the client with an instance of
//! this mock in their tests, and verify their application responds as expected.

#![allow(rustdoc::broken_intra_doc_links)]

use gax::error::Error;

pub(crate) mod dynamic;

/// Defines the trait used to implement [super::client::DatasetService].
///
/// Application developers may need to implement this trait to mock
/// `client::DatasetService`.  In other use-cases, application developers only
/// use `client::DatasetService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait DatasetService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::DatasetService::get_dataset].
    fn get_dataset(
        &self,
        _req: crate::model::GetDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Dataset>> + Send {
        std::future::ready::<crate::Result<crate::model::Dataset>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::DatasetService::insert_dataset].
    fn insert_dataset(
        &self,
        _req: crate::model::InsertDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Dataset>> + Send {
        std::future::ready::<crate::Result<crate::model::Dataset>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::DatasetService::patch_dataset].
    fn patch_dataset(
        &self,
        _req: crate::model::UpdateOrPatchDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Dataset>> + Send {
        std::future::ready::<crate::Result<crate::model::Dataset>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::DatasetService::update_dataset].
    fn update_dataset(
        &self,
        _req: crate::model::UpdateOrPatchDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Dataset>> + Send {
        std::future::ready::<crate::Result<crate::model::Dataset>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::DatasetService::delete_dataset].
    fn delete_dataset(
        &self,
        _req: crate::model::DeleteDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::DatasetService::list_datasets].
    fn list_datasets(
        &self,
        _req: crate::model::ListDatasetsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::DatasetList>> + Send {
        std::future::ready::<crate::Result<crate::model::DatasetList>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::DatasetService::undelete_dataset].
    fn undelete_dataset(
        &self,
        _req: crate::model::UndeleteDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Dataset>> + Send {
        std::future::ready::<crate::Result<crate::model::Dataset>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::ModelService].
///
/// Application developers may need to implement this trait to mock
/// `client::ModelService`.  In other use-cases, application developers only
/// use `client::ModelService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait ModelService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::ModelService::get_model].
    fn get_model(
        &self,
        _req: crate::model::GetModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Model>> + Send {
        std::future::ready::<crate::Result<crate::model::Model>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ModelService::list_models].
    fn list_models(
        &self,
        _req: crate::model::ListModelsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListModelsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListModelsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::ModelService::patch_model].
    fn patch_model(
        &self,
        _req: crate::model::PatchModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Model>> + Send {
        std::future::ready::<crate::Result<crate::model::Model>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ModelService::delete_model].
    fn delete_model(
        &self,
        _req: crate::model::DeleteModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [super::client::ProjectService].
///
/// Application developers may need to implement this trait to mock
/// `client::ProjectService`.  In other use-cases, application developers only
/// use `client::ProjectService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait ProjectService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::ProjectService::get_service_account].
    fn get_service_account(
        &self,
        _req: crate::model::GetServiceAccountRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::GetServiceAccountResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::GetServiceAccountResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }
}

/// Defines the trait used to implement [super::client::RoutineService].
///
/// Application developers may need to implement this trait to mock
/// `client::RoutineService`.  In other use-cases, application developers only
/// use `client::RoutineService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait RoutineService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::RoutineService::get_routine].
    fn get_routine(
        &self,
        _req: crate::model::GetRoutineRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Routine>> + Send {
        std::future::ready::<crate::Result<crate::model::Routine>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::RoutineService::insert_routine].
    fn insert_routine(
        &self,
        _req: crate::model::InsertRoutineRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Routine>> + Send {
        std::future::ready::<crate::Result<crate::model::Routine>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::RoutineService::update_routine].
    fn update_routine(
        &self,
        _req: crate::model::UpdateRoutineRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Routine>> + Send {
        std::future::ready::<crate::Result<crate::model::Routine>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::RoutineService::delete_routine].
    fn delete_routine(
        &self,
        _req: crate::model::DeleteRoutineRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::RoutineService::list_routines].
    fn list_routines(
        &self,
        _req: crate::model::ListRoutinesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListRoutinesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListRoutinesResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::RowAccessPolicyService].
///
/// Application developers may need to implement this trait to mock
/// `client::RowAccessPolicyService`.  In other use-cases, application developers only
/// use `client::RowAccessPolicyService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait RowAccessPolicyService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::RowAccessPolicyService::list_row_access_policies].
    fn list_row_access_policies(
        &self,
        _req: crate::model::ListRowAccessPoliciesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ListRowAccessPoliciesResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ListRowAccessPoliciesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::RowAccessPolicyService::get_row_access_policy].
    fn get_row_access_policy(
        &self,
        _req: crate::model::GetRowAccessPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::RowAccessPolicy>> + Send
    {
        std::future::ready::<crate::Result<crate::model::RowAccessPolicy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::RowAccessPolicyService::create_row_access_policy].
    fn create_row_access_policy(
        &self,
        _req: crate::model::CreateRowAccessPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::RowAccessPolicy>> + Send
    {
        std::future::ready::<crate::Result<crate::model::RowAccessPolicy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::RowAccessPolicyService::update_row_access_policy].
    fn update_row_access_policy(
        &self,
        _req: crate::model::UpdateRowAccessPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::RowAccessPolicy>> + Send
    {
        std::future::ready::<crate::Result<crate::model::RowAccessPolicy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::RowAccessPolicyService::delete_row_access_policy].
    fn delete_row_access_policy(
        &self,
        _req: crate::model::DeleteRowAccessPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::RowAccessPolicyService::batch_delete_row_access_policies].
    fn batch_delete_row_access_policies(
        &self,
        _req: crate::model::BatchDeleteRowAccessPoliciesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }
}

/// Defines the trait used to implement [super::client::TableService].
///
/// Application developers may need to implement this trait to mock
/// `client::TableService`.  In other use-cases, application developers only
/// use `client::TableService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait TableService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::TableService::get_table].
    fn get_table(
        &self,
        _req: crate::model::GetTableRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Table>> + Send {
        std::future::ready::<crate::Result<crate::model::Table>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::TableService::insert_table].
    fn insert_table(
        &self,
        _req: crate::model::InsertTableRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Table>> + Send {
        std::future::ready::<crate::Result<crate::model::Table>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::TableService::patch_table].
    fn patch_table(
        &self,
        _req: crate::model::UpdateOrPatchTableRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Table>> + Send {
        std::future::ready::<crate::Result<crate::model::Table>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::TableService::update_table].
    fn update_table(
        &self,
        _req: crate::model::UpdateOrPatchTableRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::Table>> + Send {
        std::future::ready::<crate::Result<crate::model::Table>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::TableService::delete_table].
    fn delete_table(
        &self,
        _req: crate::model::DeleteTableRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<wkt::Empty>> + Send {
        std::future::ready::<crate::Result<wkt::Empty>>(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::TableService::list_tables].
    fn list_tables(
        &self,
        _req: crate::model::ListTablesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::TableList>> + Send {
        std::future::ready::<crate::Result<crate::model::TableList>>(Err(Error::other(
            "unimplemented",
        )))
    }
}
